[
    {
        "link": "https://realpython.com/python-split-string",
        "document": "Python’s method lets you divide a string into a list of substrings based on a specified delimiter. By default, separates at whitespace, including spaces, tabs, and newlines. You can customize to work with specific delimiters using the parameter, and control the amount of splits with .\n\nBy the end of this tutorial, you’ll understand that:\n• You split a string by spaces in Python using without arguments.\n• Python’s method can split on custom delimiters when you pass a character or string as an argument.\n• You limit splits using to control the number of substrings Python extracts.\n• splits multiline strings into individual lines, excluding or including line breaks with the parameter.\n• uses regular expressions for splitting strings based on complex patterns.\n\nExploring these methods will level up your text-processing capabilities and enable you to confidently tackle real-world data parsing challenges.\n\nHow to Split a String in Python Using The method in Python is a versatile tool that allows you to divide a string into a list of substrings based on a specified delimiter. By default, separates a string at each occurrence of whitespace, which includes spaces, tabs, and newlines. This makes it particularly handy when dealing with plain text where words are separated by spaces: As you can see, divides the sentence into individual words, removing the spaces in the process. It’s important to note that also strips newlines by default, which might not be immediately obvious: ['Line', 'one', 'Line', 'two', 'Line', 'three'] The method treats the newline characters as whitespace, and splits the text into individual words rather than lines. This is a crucial point to remember when working with multiline strings. The simplicity of makes it a powerful tool for string manipulation. Whether you’re processing text files or parsing user input, using can streamline your workflow. When you’re faced with the task of cleaning up messy text, you may want to pair with . You can learn more about using by expanding the collapsible section below: You may encounter code that uses in combination with another string method, : In this example, you’re dealing with text that contains whitespace characters at the beginning and end of . You may see results like this when working with data that you received through web scraping, copy-paste artifacts from PDFs, or even regular user input. Combining and is a common and straightforward way to break potentially messy text into manageable tokens. The idea is that you first remove superfluous whitespace characters from the beginning and end of the string using . This operation returns a new string object without that whitespace. You then chain to this cleaned output, allowing it to break the text into elements—in this case, individual words. If you’re only dealing with messy whitespace, however, then you don’t need to use to get to a clean result: Because splits on any whitespace and ignores extra leading and trailing whitespace, the result is the same as when you first explicitly remove leading and trailing whitespace with . Nevertheless, there may be advantages to adding into the mix:\n• Explicitness: You clearly communicate to other developers that you intend to apply data cleaning—and readability counts!\n• Future-proofing: You may later need to update your code to split on a different delimiter, in which case won’t remove extra whitespace automatically. A well-designed additional step of explicitly removing whitespace with can prevent surprises. If you’re only splitting on whitespace, then you likely won’t need to use . However, due to developer habits and a preference for explicitness, you may still come across this combination of string methods in the wild. When you use , it returns a list of substrings. This means that you can iterate over the result, access individual elements using indexing, or unpack the iterable into separate variables. For example, when you’re dealing with user input, you might want to extract specific pieces of information: In this code snippet, you take a string containing a name, surname, and age, and split it into a list of three separate strings. Then, you unpack the list into three descriptive variables. Finally, you use an f-string to format the output. Note: Extracting data pieces like this is useful when you’re dealing with structured data where you know the position of each element beforehand, and you can rely on consistent use of whitespace. In this section, you’ve learned how to use Python’s method to divide strings into smaller parts based on whitespace. This method is invaluable when working with plain text data, allowing you to extract and manipulate information. By understanding the default behavior of , including its treatment of newlines, you’ll be well-equipped to handle a variety of string manipulation tasks in your Python projects. In the next section, you’ll explore how to customize the behavior of by specifying different delimiters, enabling you to tackle more complex string splitting scenarios.\n\nSplit With Different Delimiters Using By default, uses any whitespace as a delimiter to separate a string into a list of substrings. However, many real-world scenarios require splitting strings using other delimiters. This is where the parameter comes into play. Imagine that you’re parsing data from a CSV (comma-separated values) file. CSV files are a popular format for storing tabular data, where each line represents a row and each value within a line is separated by a comma. Note: In a real-world scenario, it’s best to use Python’s library when you’re working with CSV files. Trying to parse CSV files manually can be surprisingly tricky, as you might have to handle various edge cases, cross-platform newlines, and character encoding schemes. To parse such data, you can specify a comma as the first argument to . This will successfully split a string of comma-separated names: Here, the string contains several names separated by commas. By passing a comma ( ) as the argument to , you instruct Python to use commas as the delimiter for splitting. As a result, separates the string into a list of individual names. Note that doesn’t include the delimiter in the output. To consider another example, imagine that you have a line from a CSV file that contains product information: In this example, contains information about a product, such as its name, color, price, and availability. You split the string again on commas. Note: In this second example, you pass as a positional argument instead of as a keyword argument through . In practice, you’ll see the separator string more often passed as a positional argument, but both ways lead to the same result. By splitting the string on commas, you extract each piece of information into a list, which you can then access individually: The parameter is not limited to commas. You can use any character—or even a sequence of characters—as a delimiter. Consider a scenario where your kids assembled a shopping list for you and used a semicolon followed by a closing parenthesis as item delimiters: In this case, each fruit name is separated by an emoticon of a winking face. Looks like someone had a fun time doing data entry for this shopping list! By specifying as the argument, the method will break the string into individual fruit names. Passing a specific argument to can also help if you need to split a string only on a specific whitespace character. Remember that by default, splits on any whitespace character. Say that in your day job, you’re working with TSV (tab-separated values) files that contain product information from a store’s database, such as a product ID, an item description, and a price: You want to split the data into separate pieces of information. For , this works well by just relying on the default behavior of . However, if the product name includes a whitespace character, then you’ll run into trouble: Because the default behavior of is to separate your string at any whitespace character, it also breaks into two separate items. This could mess up your whole pipeline, because different lines may produce a different amount of data and you can’t rely on list indices anymore. To avoid this issue, you can explicitly pass the whitespace character that you want to operate on—in this case, the tab character ( ): By specifying the type of whitespace Python should split on, you can mitigate this issue and make sure that only separates the TSV string when it encounters a tab character. Note: Remember that if you’re working with a TSV or CSV file in a real-world scenario, it’s best to use Python’s library instead of fiddling with . Sometimes, you might encounter data that’s separated by a variety of inconsistently used delimiters. While doesn’t support this directly, you can tackle this task with the method from Python’s module that you’ll learn about in the section on advanced splitting. If you need to handle a diverse set of delimiters and don’t want to work with regular expressions, then you could unify the delimiters before applying a split: In this example, you chain two calls to before your call. Using this method allows you to replace all alternative delimiters with only one unified delimiter ( ), which you then instruct to use as the separator to split on. Using the parameter allows you to handle a variety of string splitting scenarios with the method. It’s particularly useful when you’re working with data separated by unusual but consistent delimiters, as it provides the flexibility needed to extract meaningful information.\n\nLimit the Amount of Splits With Sometimes, you may need to limit the number of splits when working with strings in Python. This is especially useful when you need to extract a specific number of elements while preserving the remainder of the string as a single unit. Python’s method provides an optional parameter that allows you to specify the maximum number of splits to perform. Once Python reaches the specified number of splits, it returns the remaining part of the string as the final element in the list. Consider a scenario where you’re parsing a log file. Each log entry contains a timestamp, log level, and a message. You want to extract the date, time, and log level, while keeping the entire rest of the message as a single string. You can achieve this using : You pass the value as an argument to the parameter, which means that the method performs three splits on whitespace characters. This results in four elements: the date, time, log level, and the remainder of the message. This approach allows you to neatly separate the structured components from the unstructured message. Note: Like in earlier examples, it’s important to consider the consistency of your data. Using like shown above requires that the delimiters and the number of expected splits are consistent across your dataset. If the structure of your data varies, then you might need to handle exceptions or preprocess the data to ensure compatibility with your splitting logic. If you want to pass an argument to without specifying a separator, then you need to use as a keyword argument. Otherwise, Python will throw a : File , line , in : must be str or None, not int If you pass arguments positionally, then Python assigns the first value to , and that value needs to be a string for the method to work. You can also pass an argument to positionally, if you specify both possible arguments: However, even when specifying a separator, it’s more common to pass as a keyword argument. This is because is used less frequently, and adding the parameter’s name into the method call improves readability: Passing the value for as a keyword argument helps to make your code more straightforward to read and understand, because it adds self-documenting information to the method call. Once you’re familiar with how works, you can also use it in combination with a related string method, .\n\nGo Backwards Through Your String Using Python’s string method allows you to split a string like does, but instead of starting from the left, it starts splitting from the right. Without specifying , and produce identical results: However, in combination with , this method comes in handy for string splitting tasks. For example, if you want to extract a filename from the end of a file path: Here, you use instead of and pass as the argument to . This allows you to extract the filename while keeping the rest of the string as one element, which you assign to . What happens if you use instead of for this example, and why is it less robust? Think about what you expect the output to be, then click the Show/Hide toggle below to reveal the answer: If you use instead of in the example above, you’ll end up with an empty string and another string that has the original value of , but without the leading forward slash ( ): In this case, you split on forward slashes starting from the left. Because starts with a forward slash, cuts the string right away and creates an empty string as the first element. There was nothing before the first occurrence of the separator after all. Because you also specified , Python stops splitting the string after this and adds the rest of the string as the second list element. Of course, you could also fiddle with the code to create the same result as before when using . For example, you could not specify , then fetch the last list element from the result and assign it to . However, to get the same result, you’d still have to join the other list elements to re-create and add the root forward slash that cut off. All in all, isn’t a good match for extracting substrings from the end of a string. If you need to do this, then it’s better to use instead. After slicing your file path with your precise split using , you now know exactly where you stored this year’s tax documents. Just in time to submit your taxes and make your contribution to keep everything rolling smoothly. Note: If you’re working with file paths in a real-world scenario, then you should use Python’s module instead of fiddling with or . The module handles paths in an object-oriented and cross-platform manner. This spares you from worrying about which directory separators to split on or how to reconstruct paths. Overall, it’ll keep your code cleaner and more robust by offering convenient attributes and methods for working with file systems in a portable, reliable way. The parameter in Python’s and methods helps you to control string splitting operations. It provides a flexible way to manage the number of splits while preserving the integrity of the remaining string. When you use in , you can more quickly tackle string-splitting tasks when you’re primarily interested in the final parts of a string.\n\nWhen processing text, you might often need to handle multiline text and split it into individual lines—for example, when you’re reading data from a file, processing user input, or dealing with text generated by an application. It’s possible to split text into multiple lines using and specifying the line break character: ['Hello, World!', 'How are you doing?', ''] In this example, you use the newline character ( ) as a custom delimiter so that only operates on line breaks, not on other whitespace characters. While it works, you may have noticed that adds an empty string when the text ends with a final newline. This may not always be what you want. Additionally, splittling text into lines is a very common text processing task. Therefore, Python provides a dedicated string method called for it, which also avoids the awkward empty string in the final index. The method splits a string at line boundaries, such as the newline characters ( ), carriage returns ( ), and some combinations like . It returns a list of lines that you can iterate over or manipulate further: ['Hello, world!', 'How are you doing?'] In this example, the string contains again two lines with text, and a final newline. When you call , it returns a list with each line as a separate element. The final line break doesn’t result in an extra empty string element. By default, doesn’t include line end characters in the resulting list elements. However, you can change this behavior by using the parameter. Setting to will retain the line end characters in the resulting lines. This may be useful if you need to preserve the exact formatting of the original text: ['Hello, world!\n\n', 'How are you doing?\n\n'] With , the output will include any existing newline characters at the end of each line. Splitting strings by lines has numerous practical applications. Here are a few scenarios where can be particularly handy:\n• Reading small files: When you read a file’s content into a string, you often want to process it line by line. Using allows you to quickly convert the entire content into a list of lines, helping you to iterate and analyze the data.\n• Processing logs: Logs typically contain multiple lines of text, each representing a separate event or message. By splitting the log data into individual lines, you can efficiently parse and filter the information that you need.\n• Handling multiline user input: If your application accepts multiline input from users, can help you break down and process each line separately, enabling more granular input validation and processing. To examine a practical situation, you’ll take a closer look at using to parse a multiline log file: In this example, contains several log entries, each on a new line. By splitting the string into lines, you can iterate over each entry. You then use Python’s membership operator to search for a specific keyword, which allows you to filter messages based on severity and display only error messages. The method is a convenient tool for working with multiline strings in Python. Whether you need to handle text files, logs, or user input, it provides a straightforward way to split strings by line boundaries and manipulate the resulting data. By leveraging the parameter, you can further control the output to suit your specific needs. Note: If you need to iterate over lines in a file, it’s best to use only for small files. The method reads the entire file into memory, which will impact performance when you’re working with larger files. In such cases, it’s best to directly iterate over the file object to access each line. Python evaluates this operation lazily because the file object itself is a lazy iterator that yields the data on demand. As you continue to work with text data in Python, keep in your toolkit for situations where you need to split text into separate lines.\n\nWhen you need to divide strings based on more complex splitting criteria, you’ll need a more powerful tool. This is where the function from Python’s module shines. It allows you to use regular expressions for splitting strings, enabling you to handle patterns that can’t easily address. The function takes a regular expression pattern as its first argument and the target string as its second argument. You can use this function to split strings based on complex criteria, such as multiple, inconsistently used delimiters: In this example, the regular expression specifies that Python should split the string at any occurrence of a colon, vertical bar, or minus sign. As you can see, the function provides a concise way to handle cases that involve multiple delimiters. But that’s not all! With you have access to the full power of regular expressions. So, consider a more complex scenario where your shopping list user input got completely out of hand, but you still need to extract the relevant information from it. You’re now dealing with a shopping list that uses a varying number of delimiters, along with the possibility of different types of delimiters. There may even be whitespace around the delimiters—but maybe not! Finally, the list even contains one delimter made up of several different characters ( ). You’re starting to wonder whether you should have introduced more input validation when building your shopping list app! To add some more data for you to split on, this messy shopping list also hides information about how many of the items you need. Amazingly, you can handle all of this with an elegant pattern that you pass to : The pattern that you pass to handles a complex string splitting scenario where you’d be hopelessly lost and in the weeds when using the string method . Here’s a list of the regex constructs that you used to make this split happen:\n• : Matches zero or more occurrences of the preceding.\n• : Creates an alternation group, for example , that matches any of the patterns or in their entirety. In your specific example, this allows you to treat as a single delimiter to split on.\n• : Creates a character set that matches any one of the characters inside the square brackets.\n• : Matches one or more occurrences of the preceding. When you arrange these different regex constructs into the concise pattern shown above, you can split your messy shopping list into useful substrings. Thanks to you’ll have your morning smoothie for the rest of the week! The power of lies in its ability to utilize the full range of regular expression capabilities, such as character sets, groups, and metacharacters. You can define intricate patterns to split strings in ways that go beyond simple character delimiters. When you’re dealing with complex string-splitting requirements, especially with multi-delimiter scenarios, using is the right tool to handle the job effectively. If you frequently need to split strings following complex patterns, then you may want to continue learning about regular expressions in Python to understand their full capabilities. This will provide you with the knowledge to leverage regular expressions for a wide range of text processing tasks."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-split-join-string",
        "document": "In Python, we can use the function split() to split a string and join() to join a string. These functions allow us to easily break a string into smaller parts and then reassemble those parts into a new string. This article will explore ways to split and join a string.\n\nSplit the string into a list of strings\n\nSplitting a string can be quite useful sometimes, especially when we need only certain parts of strings. We can do this by using below mentioned methods.\n\nsplit() method splits a string into a list of substrings based on a specified delimiter (by default, it splits by whitespace).\n\nThe splitlines() method splits the string at line breaks and returns a list of lines. This is useful while using multiple strings.\n\nJoin the list of strings into a string\n\nAfter splitting a string into smaller parts, we might want to join those parts back together. This is commonly done with a delimiter between the parts.\n\nThe most common and efficient way to join a list of strings with a delimiter is using the join() method. This method is available for strings and allows we to specify the delimiter we want to use between elements.\n\nUsing for loop [Less Efficient]\n\nAlthough less efficient, we can manually join the strings in a list using a for loop. This method allows we to apply more complex transformations during the joining process."
    },
    {
        "link": "https://runestone.academy/ns/books/published/fopp/Sequences/SplitandJoin.html",
        "document": "Making great stuff takes time and $$. If you appreciate the book you are reading now and want to keep quality materials free for other students please consider a donation to Runestone Academy. We ask that you consider a $10 donation, but if you can give more thats great, if $10 is too much for your budget we would be happy with whatever you can afford as a show of support.\n\nRunestone Academy can only continue if we get support from individuals like you. As a student you are well aware of the high cost of textbooks. Our mission is to provide great books to you for free, but we ask that you consider a $10 donation, more if you can or less if $10 is a burden.\n\nTwo of the most useful methods on strings involve lists of strings. The method breaks a string into a list of words. By default, any number of whitespace characters is considered a word boundary.\n\nAn optional argument called a delimiter can be used to specify which characters to use as word boundaries.\n\nThe following example uses the string as the delimiter:\n\nNotice that the delimiter doesn’t appear in the result.\n\nThe inverse of the method is . You choose a desired separator string, (often called the glue) and join the list with the glue between each of the elements.\n\nThe list that you glue together ( in this example) is not modified. Also, you can use empty glue or multi-character strings as glue."
    },
    {
        "link": "https://codesignal.com/learn/courses/string-manipulation-for-python-coders/lessons/mastering-text-analysis-with-python-splitting-and-joining-strings-like-a-pro?courseSlug=string-manipulation-for-python-coders&unitSlug=unmasking-nested-loops-navigating-advanced-looping-structures-in-python&urlSlug=python-programming-for-beginners",
        "document": "Splitting breaks a string into substrings. Python simplifies this task using the method. For example, let's split a sentence into words: The method divides the string at spaces. However, we can specify a different delimiter. Here's an instance of splitting a list of comma-separated words: On top of that, you can provide a second parameter to that will configure the number of splits to do. Here is how it works: # doing 1 split from the left, i.e., there will be 2 parts\n\nAnother useful feature when using on your string is dereference. Imagine you need to split a string containing the first and the last name joined by a comma ( ), and you know there will always be at least two parts after the split. In such case you can retrieve the first and the last name by dereferencing the list: However, in case there will be not enough elements in the list after splitting the string, an error will be thrown: # Just the first name, no last name # Raises \"ValueError: not enough values to unpack (expected 2, got 1)\"\n\nIn addition to , Python provides other methods like and for specialized splitting. On the other hand, does the opposite of . It splits the string from the right:\n\nJust as we can split strings, we can also merge or join them using the method. Here's how to join words into a sentence: As shown, concatenates strings using a specified delimiter. The method is quite handy for merging strings. For example, consider joining a list of strings with a comma as the delimiter: A common pitfall when using is invoking it with a non-string delimiter. To avoid this, always ensure the delimiter is a string, for example: # This won't work, as the delimiter is not a string\n\nWith string splitting and joining, tasks like decoding a secret message or parsing a log file become simple. Let's consider an example. Suppose you're given a list of books and authors in a peculiar format: each line contains a book title followed by a dash, then the author's name. You're tasked with converting this into a neat catalog: # Turn the text into a list of lines lines = text.splitlines() # For each line, split the line into title and author catalog = [] catalog.append((title, author)) The Interpretation of Cultures, by Clifford Geertz The Structure of Scientific Revolutions, by Thomas Kuhn The Two Cultures, by C.P. Snow This code takes the original text, breaks it down using the function, and puts it back together using the function to create a beautifully formatted catalog."
    },
    {
        "link": "https://freecodecamp.org/news/python-string-split-and-join-methods-explained-with-examples",
        "document": "When working with strings in Python, you may have to split a string into substrings. Or you might need to join together smaller chunks to form a string. Python's and string methods help you do these tasks easily.\n\nIn this tutorial, you'll learn about the and string methods with plenty of example code.\n\nAs strings in Python are immutable, you can call methods on them without modifying the original strings. Let's get started.\n\nWhen you need to split a string into substrings, you can use the method.\n\nThe method acts on a string and returns a list of substrings. The syntax is:\n\nIn the above syntax:\n• is the separator that you'd like to split on. It should be specified as a string.\n• is an optional argument. By default, this method splits strings on whitespaces.\n• is an optional argument indicating the number of times you'd like to split .\n• has a default value of , which splits the string on all occurrences of .\n\nAnd setting will leave you with two chunks – one with the section of before the first comma, and another with the section of after the first comma.\n\nWhen you split a string once, you'll get 2 chunks. When you split a string twice, you'll get 3 chunks. When you split a string times, you'll get chunks.\n\n▶ Let's take a few examples to see the method in action.\n\nNow, call the method on , without the arguments and .\n\nYou can see that has been split on all whitespaces and the list of substrings is returned, as shown above.\n\n▶ Let's now consider the following example. Here, has names of fruits, separated by commas.\n\nLet's now split on commas – set or only specify in the method call.\n\nAs expected, the method returns a list of fruits, where each fruit in is now a list item.\n\n▶ Let's now use the optional argument as well by setting it equal to 2.\n\nLet's try to parse the returned list.\n\nRecall that is , and we decided to split on commas ( ).\n• The first comma is after , and after the first split you'll have 2 items, and .\n• The second comma is after . And you'll have 3 items, , , and after the second split.\n• At this point, you've reached the count of 2, and no further splits can be made.\n• This is why the portion of the string after the second comma is lumped together as a single item in the returned list.\n\nI hope you understand how the method and the arguments and work.\n\nNow that you know how to split a string into substrings, it's time to learn how to use the method to form a string from substrings.\n\nThe syntax of Python's method is:\n• is any Python iterable containing the substrings, say, a list or a tuple, and\n• is the separator that you'd like to join the substrings on.\n\n▶ And it's time for examples.\n\nIn the previous section on the method, you split into a list on the occurrences of commas. Let's call the list .\n\nNow, you'll form a string using the method to put together items in the returned list. The items in are all names of fruits.\n\n📑 Note that the separator to join on should be specified as a string. You'll run into syntax errors if you don't do so, as shown below.\n\n▶ To join the items in using a comma as the separator, use not . This is shown in the code snippet below.\n\nThe above line of code joins items in using a comma followed by a space as the separator.\n\nYou can specify any separator of your choice. This time, you'll use 3 underscores ( ) to join items in .\n\nThe items in have now been joined into a single string, and have all been separated from each other by a .\n\nAnd you now know how you can form a Python string by putting together substrings using the method.\n\nIn this tutorial, you've learned the following:\n• splits on the occurrence of , number of times,\n• joins substrings in using as the separator."
    },
    {
        "link": "https://stackoverflow.com/questions/62532105/adding-values-to-list-elements-based-on-condition-python",
        "document": "Say I got a list like this:\n\nNow everytime the subsequent element in the list is less than the preceding element, i.e. I want to add multiples of say 10 in ascending order to all the elements from this point until the next point where the condition is met. The resulting list for the example above should look like this:\n\nSo first 10 is added, then 20... I'll mention that the length of each intervall is abritrarily long.\n\nHow could i achieve that elegantly? I did what I wanted by using the list as a temporary list and appending to a new list through a for and if loop but that seems rather ugly. I thought of doing it with list comprehension but I cannot figure out how this would work."
    },
    {
        "link": "https://stackoverflow.com/questions/52921800/appending-a-list-through-if-condition-in-python",
        "document": "This could be a very basic question, but I realized I am not understanding something.\n\nWhen appending new things in for loop, how can I raise conditions and still append the item?\n\nHow do I get\n\nEssentially, I want to tell python to not go through when .\n\nWould this be the only solution? append n==5 separately in a list and then sum new and the separate list?"
    },
    {
        "link": "https://geeksforgeeks.org/python-list-comprehension-using-if-else",
        "document": "List comprehension with in Python is a concise way to apply conditional logic while creating a new list. It allows users to add elements based on specific conditions and even modify them before adding.\n\nThis is the simplest and most efficient way to apply conditional logic directly. This applies the condition directly in the list comprehension. Each number is checked for divisibility by 2, and either \"Even\" or \"Odd\" is added to the list.\n\nLet's explore some other methods on how to use list comprehension using if-else\n\nUsing Condition Only (Without )\n\nThis method is used when elements are added only if the condition is met. Here, the condition filters out numbers that do not meet the condition. Only even numbers are added to the new list.\n\nHandle multiple conditions with nested logic. Using Nested if-else in List allows chaining of conditions. It categorizes each number based on whether it is divisible by 2, 3, or neither."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://geeksforgeeks.org/python-conditional-string-append",
        "document": "Sometimes, while working with data, we have a problem in which we need to perform an append operation in a string on a particular condition. This kind of problem is common in web development and day-day programming. Let’s discuss certain ways in which this task can be performed.\n\nMethod #1: Using loop This is a brute-force way to perform this task. In this, we run a loop and check for the condition, and according to that append the string to the original string.\n\nMethod #2: Using list comprehension List comprehension is shorthand for the longer method of loops. This solved problem in similar way but in shorter constructs.\n\nMethod #3: Using map function Map function is used to create a new list by updating the existing list. We solve this problem by defining the condition append function for the map function which will apply to all the elements of the list.\n\nThis Approach uses regular expressions to match strings ending with “Singh” and appends “Boy” to those strings. For other strings, it appends “Girl”. The filtered strings are stored in a new list called “filtered_strings”.\n\n1. Import the re module for regular expressions\n\n2. Define a regular expression pattern to match strings ending with ‘Singh’\n\n3. Create an empty list ‘filtered_strings’\n\n4. Iterate over each string in the original list:\n\na. Use the re.sub() function to replace the matched pattern with ‘Boy’ and append it to ‘filtered_strings’\n\nb. If the pattern does not match, append the string with ‘Girl’ and add it to ‘filtered_strings’\n\n5. Return the ‘filtered_strings’ list\n\nTime complexity: O(n), where n is the length of the original list. We iterate over each string in the list once.\n\nAuxiliary Space: O(n), where n is the length of the original list. We create a new list ‘filtered_strings’ which stores n strings. We also create a regular expression pattern object, which takes up some memory."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-handle-edge-cases-in-a-python-function-398003",
        "document": "In the realm of software development, edge cases refer to the unique or exceptional situations that can occur during the execution of a program. These are the scenarios that fall outside the normal or expected range of input or behavior, but still need to be accounted for to ensure the robustness and reliability of the application.\n\nEdge cases can arise due to a variety of reasons, such as:\n\nWhen a function or program is designed to handle a specific range of input values, edge cases can occur when the input falls outside of that range. For example, a function that calculates the area of a rectangle might encounter an edge case if the input values for length or width are negative or zero.\n\nEdge cases can also occur at the boundaries of a function's input or output range. For instance, a function that calculates the factorial of a number might encounter an edge case when the input is 0 or a very large number.\n\nEdge cases can also arise from exceptional situations that are not part of the normal program flow, such as errors, system failures, or unexpected user actions. These can include scenarios like division by zero, file not found, or network connectivity issues.\n\nEdge cases can also be related to performance-related issues, such as handling large or complex data sets, or dealing with high-volume or high-concurrency scenarios.\n\nIdentifying and handling edge cases is a crucial aspect of software development, as it helps ensure that the application can gracefully handle unexpected or exceptional situations, and provides a better user experience by anticipating and addressing potential problems."
    },
    {
        "link": "https://stackoverflow.com/questions/66094765/edge-cases-and-text-formatting-in-python",
        "document": "As part of a larger group project I am working on as a personal challenge, I'm trying to make a function to format a chunk of text into two sentence blocks. The current form of the function is as follows:\n\nThis works pretty well. However, there are some obvious cases in common colloquial text where it fails, as well as cases where it's result is less than ideal. Here are two examples produced using an small excerpt from a BBC article (https://www.bbc.co.uk/news/business-55916254):\n\nBut he didn't get where he is by being nice. \"If you're not prepared for a meeting with him... and especially if you try to mask that lack of preparedness with smooth talking, he'll know and he will make it clear,\" Scott Chancellor, a former AWS director told the news portal. \"People who don't do their best in those meetings won't get a second shot, at least not for a long time.\"\n\nThe two notable ways that this will be processed incorrectly are:\n• The ellipsis at the start of the text will become:\n\nIdeally this should be ignored, or considered it's own separate symbol to a fullstop.\n• The final speech mark falls at the end of two sentences, as a result it ends up separated from the text is actually associated with:\n\nIdeally I'd like to keep the function small and fast, but this problem has sort of stumped me. I can't think of a method which doesn't involve iterating through every character in the input string and checking the nearby characters for any edge cases every time it finds a fullstop.\n\nMost related questions I've found seem to be either a mix of 'How do I split a string at all the punctuation marks' or on how to use regex to clean a string of unwanted text. While I admit a almost complete lack of knowledge about using regex, I'm not aware of a way I could use it to ignore punctuation like ellipses, or include a stray speech mark at the end of the string. I've also seen the nltk library mentioned in this question, \"https://stackoverflow.com/questions/34006169/regex-to-remove-words-from-a-list-that-are-not-a-z-a-z-exceptions/34006378#34006378\", however I'm not sure how I could utilise it for my purpose.\n\nPresumably there's a more elegant solution to this problem which utilises the standard functions provided by python to avoid the runtime slowness caused by the python interpreter. If you have an idea that could help, or a suggestion of where I could look to find one, it would be greatly appreciated!\n\nI'm in the UK and after a few hours of research I'm pretty exhausted given it's 1am. So sorry if I miss any replies!"
    },
    {
        "link": "https://thenewstack.io/handling-edge-cases-and-exceptions-in-python",
        "document": "Developing applications is all fun and games until the error messages start coming fast and furiously. Welcome to your exceptions and edge cases. It might seem intimidating at first but there is a way to handle exceptions and edge cases without the headache — because they’re going to happen, especially when the application has user input fields. The best way to troubleshoot these issues before they occur in a production-level application is to properly handle exceptions and edge cases.\n\nWhat Are Exceptions and Edge Cases?\n\nAn exception is an error that occurs when an application encounters an unexpected situation. This interrupts the normal execution flow. Exceptions are situations that the program wasn’t designed to handle. Examples of common exceptions are , which occurs when the program tries to access a file that doesn’t exist, and , which arises when an operation is applied to an object of an inappropriate type.\n\nAn edge case represents an atypical boundary condition that, though rare, could cause the program to behave unexpectedly. An edge case could turn into an exception, but that’s not always the case. Examples of edge cases include empty inputs or lists in a function that processes data, processing the maximum integer value allowed by the system, and dealing with the first or last element in a loop sequence. If not handled correctly, edge cases can result in an error.\n\nWhat Happens If We Don’t Handle Exceptions In the Development Phase?\n\nWhen an error arises during code execution, the program stops running while Python passes the error to the section in the code designed to handle errors, the exception handler. If there is no exception handler in the code block, Python’s native exception-handling mechanism will take over. Python will check for error handling up the call stack. If it gets to the program’s top level without locating any exception handling, Python’s default handler will stop program execution and return a traceback — a detailed message printed to the console. It includes information about the exception type and where in the code it occurred.\n\nCrashing an application isn’t the worst thing that could happen if you fail to handle exceptions and edge cases during the development phase, though it is one outcome. Skipping exception handling is a security risk once the application reaches the production level. Certain errors might expose sensitive information or system vulnerabilities. Tracebacks can reveal internal logic or paths in the application that bad actors can exploit. Additionally, neglecting exception handling makes debugging more challenging, as exception handling provides more insight into where errors occur than the tracebacks.\n\nIt’s a good idea to handle edge cases first. This allows you to define the expected boundaries and special conditions of your input data and processing logic. Start by defining the expected input range, limits, and unusual conditions. Once you have those parameters defined, you can implement validation and boundary checks and the logic to handle these cases appropriately.\n\nThe function below was designed to take in an integer parameter and return information about whether this person is a child, adult or senior. Without handling the edge cases, the function looks like this:\n\nWithout handling edge cases, the function might produce incorrect or inappropriate results, such as allowing negative ages or unrealistically high ages (e.g., 150 years old). To handle these edge cases, we can define realistic boundaries:\n• Let’s favor on the side of optimism and cap the maximum value at 120, just in case\n\nHere’s the updated code which accounts for the edge cases:\n\nThe code should handle the edge cases first. If the execution thread reaches the functional logic, it will return the same results with the edge handling as it would without it.\n\nPython uses the block to catch and handle exceptions. The basic syntax is:\n\nThe function below converts inputs into integers. This means anything that isn’t a string of numbers will error out and needs to be handled.\n\nThe console for this will display:\n\n Conversion successful: 123\n\n Error: Input could not be converted to an integer.\n\nYou can build multiple clauses under a single block. The example below divides two numbers, handling several potential issues:\n• catches errors where is zero.\n• is a generic exception handler that catches any other unexpected errors.\n\nIf a built-in exception handler doesn’t exist, you can create a custom one. The basic syntax is:\n\nMost of the syntax here follows basic child class syntax but there are some elements to point out. The custom class inherits properties from the built-in class. The method returns a string representation of the exception. It’s often overridden to return the error message, making it easier to print or log the exception.\n\nLet’s pretend we’re building an application that can’t accept the number 2. We can build the following exception:\n\nIn a function body, it looks like this:\n\nProperly handling exceptions and edge cases is crucial in developing robust and secure applications. Neglecting these aspects can lead to crashes, security vulnerabilities, and challenging debugging scenarios. By implementing thorough exception and edge case handling, developers can ensure their applications run smoothly and securely, providing a better user experience and maintaining system integrity. Whether you’re dealing with built-in exceptions, edge cases, or creating custom exceptions, the goal is the same: to anticipate and manage potential issues proactively."
    },
    {
        "link": "https://stackoverflow.com/questions/2643209/python-list-comprehension-to-return-edge-values-of-a-list",
        "document": "If I have a list in python such as:\n\nwith length n (in this case 9) and I am interested in creating lists of length n/2 (in this case 4). I want all possible sets of n/2 values in the original list, for example:\n\nis there some list comprehension code I could use to iterate through the list and retrieve all of those sublists? I don't care about the order of the values within the lists, I am just trying to find a clever method of generating the lists."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    }
]