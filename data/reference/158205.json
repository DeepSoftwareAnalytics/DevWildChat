[
    {
        "link": "https://github.com/bytedeco/javacv/blob/master/src/main/java/org/bytedeco/javacv/FFmpegFrameRecorder.java",
        "document": ""
    },
    {
        "link": "https://bytedeco.org/javacv/apidocs/org/bytedeco/javacv/FFmpegFrameRecorder.html",
        "document": "Returns best guess for timestamp in microseconds...\n\nSets the rotation in degrees to the side data of the video stream."
    },
    {
        "link": "https://github.com/bytedeco/javacv/issues/1163",
        "document": "I'd like to know if there's anything I can do to make these run faster. With 4K videos, I don't even get real-time performance which would allow to play back the video normally (I get about 26 FPS for a 30 FPS video), when I throw in encoding, I get something between 6 FPS and 12 FPS, depending on params used.\n\nThis is the code I use for testing:\n\nIs there anything I can do to make things faster? Docs for this are next to non-existent, that's why I'm asking this here."
    },
    {
        "link": "https://javadoc.io/static/org.bytedeco/javacv/1.1/org/bytedeco/javacv/FFmpegFrameRecorder.html",
        "document": "JavaScript is disabled on your browser."
    },
    {
        "link": "https://ffmpeg.org/ffmpeg.html",
        "document": "is a universal media converter. It can read a wide variety of inputs - including live grabbing/recording devices - filter, and transcode them into a plethora of output formats.\n\nreads from an arbitrary number of inputs (which can be regular files, pipes, network streams, grabbing devices, etc.), specified by the option, and writes to an arbitrary number of outputs, which are specified by a plain output url. Anything found on the command line which cannot be interpreted as an option is considered to be an output url.\n\nEach input or output can, in principle, contain any number of elementary streams of different types (video/audio/subtitle/attachment/data), though the allowed stream counts and/or types may be limited by the container format. Selecting which streams from which inputs will go into which output is either done automatically or with the option (see the Stream selection chapter).\n\nTo refer to inputs/outputs in options, you must use their indices (0-based). E.g. the first input is , the second is , etc. Similarly, streams within an input/output are referred to by their indices. E.g. refers to the fourth stream in the third input or output. Also see the Stream specifiers chapter.\n\nAs a general rule, options are applied to the next specified file. Therefore, order is important, and you can have the same option on the command line multiple times. Each occurrence is then applied to the next input or output file. Exceptions from this rule are the global options (e.g. verbosity level), which should be specified first.\n\nDo not mix input and output files – first specify all input files, then all output files. Also do not mix options which belong to different files. All options apply ONLY to the next input or output file and are reset between files.\n• Convert an input media file to a different format, by re-encoding media streams:\n• Set the video bitrate of the output file to 64 kbit/s:\n• Force the frame rate of the output file to 24 fps:\n• Force the frame rate of the input file (valid for raw formats only) to 1 fps and the frame rate of the output file to 24 fps:\n\nThe format option may be needed for raw input files.\n\nbuilds a transcoding pipeline out of the components listed below. The program’s operation then consists of input data chunks flowing from the sources down the pipes towards the sinks, while being transformed by the components they encounter along the way.\n\nThe following kinds of components are available:\n• Demuxers (short for \"demultiplexers\") read an input source in order to extract\n• global properties such as metadata or chapters;\n• list of input elementary streams and their properties One demuxer instance is created for each option, and sends encoded packets to decoders or muxers. In other literature, demuxers are sometimes called splitters, because their main function is splitting a file into elementary streams (though some files only contain one elementary stream). A schematic representation of a demuxer looks like this: ┌──────────┬───────────────────────┐ │ demuxer │ │ packets for stream 0 ╞══════════╡ elementary stream 0 ├──────────────────────► │ │ │ │ global ├───────────────────────┤ │properties│ │ packets for stream 1 │ and │ elementary stream 1 ├──────────────────────► │ metadata │ │ │ ├───────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├───────────────────────┤ │ │ │ packets for stream N │ │ elementary stream N ├──────────────────────► │ │ │ └──────────┴───────────────────────┘ ▲ │ │ read from file, network stream, │ grabbing device, etc. │\n• Decoders receive encoded (compressed) packets for an audio, video, or subtitle elementary stream, and decode them into raw frames (arrays of pixels for video, PCM for audio). A decoder is typically associated with (and receives its input from) an elementary stream in a demuxer, but sometimes may also exist on its own (see Loopback decoders). A schematic representation of a decoder looks like this:\n• Filtergraphs process and transform raw audio or video frames. A filtergraph consists of one or more individual filters linked into a graph. Filtergraphs come in two flavors - simple and complex, configured with the and options, respectively. A simple filtergraph is associated with an output elementary stream; it receives the input to be filtered from a decoder and sends filtered output to that output stream’s encoder. A simple video filtergraph that performs deinterlacing (using the deinterlacer) followed by resizing (using the filter) can look like this: ┌────────────────────────┐ │ simple filtergraph │ frames from ╞════════════════════════╡ frames for a decoder │ ┌───────┐ ┌───────┐ │ an encoder ────────────►├─►│ yadif ├─►│ scale ├─►│────────────► │ └───────┘ └───────┘ │ └────────────────────────┘ A complex filtergraph is standalone and not associated with any specific stream. It may have multiple (or zero) inputs, potentially of different types (audio or video), each of which receiving data either from a decoder or another complex filtergraph’s output. It also has one or more outputs that feed either an encoder or another complex filtergraph’s input. The following example diagram represents a complex filtergraph with 3 inputs and 2 outputs (all video): Frames from second input are overlaid over those from the first. Frames from the third input are rescaled, then the duplicated into two identical streams. One of them is overlaid over the combined first two inputs, with the result exposed as the filtergraph’s first output. The other duplicate ends up being the filtergraph’s second output.\n• Encoders receive raw audio, video, or subtitle frames and encode them into encoded packets. The encoding (compression) process is typically lossy - it degrades stream quality to make the output smaller; some encoders are lossless, but at the cost of much higher output size. A video or audio encoder receives its input from some filtergraph’s output, subtitle encoders receive input from a decoder (since subtitle filtering is not supported yet). Every encoder is associated with some muxer’s output elementary stream and sends its output to that muxer. A schematic representation of an encoder looks like this:\n• Muxers (short for \"multiplexers\") receive encoded packets for their elementary streams from encoders (the transcoding path) or directly from demuxers (the streamcopy path), interleave them (when there is more than one elementary stream), and write the resulting bytes into the output file (or pipe, network stream, etc.). A schematic representation of a muxer looks like this: ┌──────────────────────┬───────────┐ packets for stream 0 │ │ muxer │ ──────────────────────►│ elementary stream 0 ╞═══════════╡ │ │ │ ├──────────────────────┤ global │ packets for stream 1 │ │properties │ ──────────────────────►│ elementary stream 1 │ and │ │ │ metadata │ ├──────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├──────────────────────┤ │ packets for stream N │ │ │ ──────────────────────►│ elementary stream N │ │ │ │ │ └──────────────────────┴─────┬─────┘ │ write to file, network stream, │ grabbing device, etc. │ │ ▼\n\nThe simplest pipeline in is single-stream streamcopy, that is copying one input elementary stream’s packets without decoding, filtering, or encoding them. As an example, consider an input file called with 3 elementary streams, from which we take the second and write it to file . A schematic representation of such a pipeline looks like this:\n\nThe above pipeline can be constructed with the following commandline:\n• there are no input options for this input;\n• there are two output options for this output:\n• selects the input stream to be used - from input with index 0 (i.e. the first one) the stream with index 1 (i.e. the second one);\n• selects the encoder, i.e. streamcopy with no decoding or encoding.\n\nStreamcopy is useful for changing the elementary stream count, container format, or modifying container-level metadata. Since there is no decoding or encoding, it is very fast and there is no quality loss. However, it might not work in some cases because of a variety of factors (e.g. certain information required by the target container is not available in the source). Applying filters is obviously also impossible, since filters work on decoded frames.\n\nMore complex streamcopy scenarios can be constructed - e.g. combining streams from two input files into a single output:\n\nthat can be built by the commandline\n\nThe output option is used twice here, creating two streams in the output file - one fed by the first input and one by the second. The single instance of the option selects streamcopy for both of those streams. You could also use multiple instances of this option together with Stream specifiers to apply different values to each stream, as will be demonstrated in following sections.\n\nA converse scenario is splitting multiple streams from a single input into multiple outputs:\n\nNote how a separate instance of the option is needed for every output file even though their values are the same. This is because non-global options (which is most of them) only apply in the context of the file before which they are placed.\n\nThese examples can of course be further generalized into arbitrary remappings of any number of inputs into any number of outputs.\n\nTranscoding is the process of decoding a stream and then encoding it again. Since encoding tends to be computationally expensive and in most cases degrades the stream quality (i.e. it is lossy), you should only transcode when you need to and perform streamcopy otherwise. Typical reasons to transcode are:\n• you want to feed the stream to something that cannot decode the original codec.\n\nNote that will transcode all audio, video, and subtitle streams unless you specify for them.\n\nConsider an example pipeline that reads an input file with one audio and one video stream, transcodes the video and copies the audio into a single output file. This can be schematically represented as follows\n\nand implemented with the following commandline:\n\nNote how it uses stream specifiers and to select input streams and apply different values of the option to them; see the Stream specifiers section for more details.\n\nWhen transcoding, audio and video streams can be filtered before encoding, with either a simple or complex filtergraph.\n\nSimple filtergraphs are those that have exactly one input and output, both of the same type (audio or video). They are configured with the per-stream option (with and aliases for (video) and (audio) respectively). Note that simple filtergraphs are tied to their output stream, so e.g. if you have multiple audio streams, will create a separate filtergraph for each one.\n\nTaking the trancoding example from above, adding filtering (and omitting audio, for clarity) makes it look like this:\n\nComplex filtergraphs are those which cannot be described as simply a linear processing chain applied to one stream. This is the case, for example, when the graph has more than one input and/or output, or when output stream type is different from input. Complex filtergraphs are configured with the option. Note that this option is global, since a complex filtergraph, by its nature, cannot be unambiguously associated with a single stream or file. Each instance of creates a new complex filtergraph, and there can be any number of them.\n\nA trivial example of a complex filtergraph is the filter, which has two video inputs and one video output, containing one video overlaid on top of the other. Its audio counterpart is the filter.\n\nWhile decoders are normally associated with demuxer streams, it is also possible to create \"loopback\" decoders that decode the output from some encoder and allow it to be fed back to complex filtergraphs. This is done with the directive, which takes as a parameter the index of the output stream that should be decoded. Every such directive creates a new loopback decoder, indexed with successive integers starting at zero. These indices should then be used to refer to loopback decoders in complex filtergraph link labels, as described in the documentation for .\n\nDecoding AVOptions can be passed to loopback decoders by placing them before , analogously to input/output options.\n\nE.g. the following example:\n• (line 2) encodes it with at low quality;\n• (line 4) places decoded video side by side with the original input video;\n• (line 5) combined video is then losslessly encoded and written into .\n\nSuch a transcoding pipeline can be represented with the following diagram:\n\nprovides the option for manual control of stream selection in each output file. Users can skip and let ffmpeg perform automatic stream selection as described below. The options can be used to skip inclusion of video, audio, subtitle and data streams respectively, whether manually mapped or automatically selected, except for those streams which are outputs of complex filtergraphs.\n\nThe sub-sections that follow describe the various rules that are involved in stream selection. The examples that follow next show how these rules are applied in practice.\n\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous development and the code may have changed since the time of this writing.\n\nIn the absence of any map options for a particular output file, ffmpeg inspects the output format to check which type of streams can be included in it, viz. video, audio and/or subtitles. For each acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.\n\nIt will select that stream based upon the following criteria:\n• for video, it is the stream with the highest resolution,\n• for audio, it is the stream with the most channels,\n• for subtitles, it is the first subtitle stream found but there’s a caveat. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.\n\nIn the case where several streams of the same type rate equally, the stream with the lowest index is chosen.\n\nData or attachment streams are not automatically selected and can only be included using .\n\nWhen is used, only user-mapped streams are included in that output file, with one possible exception for filtergraph outputs described below.\n\nIf there are any complex filtergraph output streams with unlabeled pads, they will be added to the first output file. This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.\n\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n\nStream handling is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the option addressed to streams within a specific output file. In particular, codec options are applied by ffmpeg after the stream selection process and thus do not influence the latter. If no option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.\n\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.\n\nThe following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream selection methods.\n\nThey assume the following three input files.\n\nThere are three output files specified, and for the first two, no options are set, so ffmpeg will select streams for these two files automatically.\n\nis a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try to select one of each type.\n\n For video, it will select from , which has the highest resolution among all the input video streams.\n\n For audio, it will select from , since it has the greatest number of channels.\n\n For subtitles, it will select from , which is the first subtitle stream from among and .\n\naccepts only audio streams, so only from is selected.\n\nFor , since a option is set, no automatic stream selection will occur. The option will select all audio streams from the second input . No other streams will be included in this output file.\n\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will be the default ones registered by each output format, which may not match the codec of the selected input streams.\n\nFor the third output, codec option for audio streams has been set to , so no decoding-filtering-encoding operations will occur, or can occur. Packets of selected streams shall be conveyed from the input file and muxed within the output file.\n\nAlthough is a Matroska container file which accepts subtitle streams, only a video and audio stream shall be selected. The subtitle stream of is image-based and the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation for the subtitles is expected to fail and hence the stream isn’t selected. However, in , a subtitle encoder is specified in the command and so, the subtitle stream is selected, in addition to the video stream. The presence of disables audio stream selection for .\n\nA filtergraph is setup here using the option and consists of a single video filter. The filter requires exactly two video inputs, but none are specified, so the first two available video streams are used, those of and . The output pad of the filter has no label and so is sent to the first output file . Due to this, automatic selection of the video stream is skipped, which would have selected the stream in . The audio stream with most channels viz. in , is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\n\nThe 2nd output file, , only accepts text-based subtitle streams. So, even though the first subtitle stream available belongs to , it is image-based and hence skipped. The selected stream, in , is the first text-based subtitle stream.\n\nThe above command will fail, as the output pad labelled has been mapped twice. None of the output files shall be processed.\n\nThis command above will also fail as the hue filter output has a label, , and hasn’t been mapped anywhere.\n\nThe command should be modified as follows,\n\nThe video stream from is sent to the hue filter, whose output is cloned once using the split filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.\n\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those are the streams from and . The overlay output isn’t labelled, so it is sent to the first output file , regardless of the presence of the option.\n\nThe aresample filter is sent the first unused audio stream, that of . Since this filter output is also unlabelled, it too is mapped to the first output file. The presence of only suppresses automatic or manual stream selection of audio streams, not outputs sent from filtergraphs. Both these mapped streams shall be ordered before the mapped stream in .\n\nThe video, audio and subtitle streams mapped to are entirely determined by automatic stream selection.\n\nconsists of the cloned video output from the hue filter and the first audio stream from . \n\n\n\nAll the numerical options, if not specified otherwise, accept a string representing a number as input, which may be followed by one of the SI unit prefixes, for example: ’K’, ’M’, or ’G’.\n\nIf ’i’ is appended to the SI unit prefix, the complete prefix will be interpreted as a unit prefix for binary multiples, which are based on powers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit prefix multiplies the value by 8. This allows using, for example: ’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.\n\nOptions which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing the option name with \"no\". For example using \"-nofoo\" will set the boolean option with name \"foo\" to false.\n\nOptions that take arguments support a special syntax where the argument given on the command line is interpreted as a path to the file from which the actual argument value is loaded. To use this feature, add a forward slash ’/’ immediately before the option name (after the leading dash). E.g.\n\nwill load a filtergraph description from the file named .\n\nSome options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) a given option belongs to.\n\nA stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. contains the stream specifier, which matches the second audio stream. Therefore, it would select the ac3 codec for the second audio stream.\n\nA stream specifier can match several streams, so that the option is applied to all of them. E.g. the stream specifier in matches all audio streams.\n\nAn empty stream specifier matches all streams. For example, or would copy all the streams without reencoding.\n\nPossible forms of stream specifiers are:\n\nThese options are shared amongst the ff* tools.\n\nThese options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the option. They are separated into two categories:\n\nFor example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the private option of the MP3 muxer:\n\nAll codec AVOptions are per-stream, and thus a stream specifier should be attached to them:\n\nIn the above example, a multichannel audio stream is mapped twice for output. The first instance is encoded with codec ac3 and bitrate 640k. The second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.\n\nNote: the syntax cannot be used for boolean AVOptions, use / .\n\nNote: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.\n\nForce input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. Do not overwrite output files, and exit immediately if a specified output file already exists. Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. Allow forcing a decoder of a different media type than the one detected or designated by the demuxer. Useful for decoding media data muxed as data streams. Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. is the name of a decoder/encoder or a special value (output only) to indicate that the stream is not to be re-encoded. encodes all video streams with libx264 and copies all audio streams. For each stream, the last matching option is applied, so will copy all the streams except the second video, which will be encoded with libx264, and the 138th audio, which will be encoded with libvorbis. When used as an input option (before ), limit the of data read from the input file. When used as an output option (before an output url), stop writing the output after its duration reaches . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Stop writing the output or reading the input at . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Set the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is exceeded. The size of the output file is slightly more than the requested file size. When used as an input option (before ), seeks in this input file to . Note that in most formats it is not possible to seek exactly, so will seek to the closest seek point before . When transcoding and is enabled (the default), this extra segment between the seek point and will be decoded and discarded. When doing stream copy or when is used, it will be preserved. When used as an output option (before an output url), decodes but discards input until the timestamps reach . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. Like the option but relative to the \"end of file\". That is negative values are earlier in the file, 0 is at EOF. This will take the difference between the start times of the target and reference inputs and offset the timestamps of the target file by that difference. The source timestamps of the two inputs should derive from the same clock source for expected results. If is set then must also be set. If either of the inputs has no starting timestamp then no sync adjustment is made. Acceptable values are those that refer to a valid ffmpeg input index. If the sync reference is the target index itself or , then no adjustment is made to target timestamps. A sync reference may not itself be synced to any other input. must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. The offset is added to the timestamps of the input files. Specifying a positive offset means that the corresponding streams are delayed by the time duration specified in . Set the recording timestamp in the container. must be a date specification, see (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual. An optional may be given to set metadata on streams, chapters or programs. See documentation for details. This option overrides metadata set with . It is also possible to delete metadata by using an empty value. For example, for setting the title in the output file: To set the language of the first audio stream: Default value: by default, all disposition flags are copied from the input stream, unless the output stream this option applies to is fed by a complex filtergraph - in that case no disposition flags are set by default. is a sequence of disposition flags separated by ’+’ or ’-’. A ’+’ prefix adds the given disposition, ’-’ removes it. If the first flag is also prefixed with ’+’ or ’-’, the resulting disposition is the default value updated by . If the first flag is not prefixed, the resulting disposition is . It is also possible to clear the disposition by setting it to 0. If no options were specified for an output file, ffmpeg will automatically set the ’default’ disposition flag on the first stream of each type, when there are multiple streams of this type in the output file and no stream of that type is already marked as default. The option lists the known disposition flags. For example, to make the second audio stream the default stream: To make the second subtitle stream the default stream and remove the default disposition from the first subtitle stream: To add the ’original’ and remove the ’comment’ disposition flag from the first audio stream without removing its other disposition flags: To remove the ’original’ and add the ’comment’ disposition flag to the first audio stream without removing its other disposition flags: To set only the ’original’ and ’comment’ disposition flags on the first audio stream (and remove its other disposition flags): To remove all disposition flags from the first audio stream: Not all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG or PNG. Creates a program with the specified , and adds the specified (s) to it. Creates a stream group of the specified and , or by ping an input group, adding the specified (s) and/or previously defined (s) to it. can be one of the following: Groups s that belong to the same IAMF Audio Element For this group , the following options are available The Audio Element type. The following values are supported: Demixing information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to Recon gain information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to A layer defining a Channel Layout in the Audio Element. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options The following flags are available: Wether to signal if recon_gain is present as metadata in parameter blocks within frames Which channels output_gain applies to. The following flags are available: The ambisonics mode. This has no effect if audio_element_type is set to channel. The following values are supported: Each ambisonics channel is coded as an individual mono stream in the group Groups s that belong to all IAMF Audio Element the same IAMF Mix Presentation references For this group , the following options are available A sub-mix within the Mix Presentation. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options An identifier parameters blocks in frames may refer to, for post-processing the mixed audio signal to generate the audio signal for playback The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame References an Audio Element used in this Mix Presentation to generate the final output audio signal for playback. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The for an Audio Element which this sub-mix refers to An identifier parameters blocks in frames may refer to, for applying any processing to the referenced and rendered Audio Element before being summed with other processed Audio Elements The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame A key=value string describing the sub-mix element where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the one in the mix’s Indicates whether the input channel-based Audio Element is rendered to stereo loudspeakers or spatialized with a binaural renderer when played back on headphones. This has no effect if the referenced Audio Element’s is set to channel. The following values are supported: Specifies the layouts for this sub-mix on which the loudness information was measured. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The layout follows the loudspeaker sound system convention of ITU-2051-3. Channel layout matching one of Sound Systems A to J of ITU-2051-3, plus 7.1.2 and 3.1.2 This has no effect if is set to binaural. The program integrated loudness information, as defined in ITU-1770-4. The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4. The true peak of the audio signal, as defined in ITU-1770-4. The Dialogue loudness information, as defined in ITU-1770-4. The Album loudness information, as defined in ITU-1770-4. A key=value string string describing the mix where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the ones in all sub-mix element’s s E.g. to create an scalable 5.1 IAMF file from several WAV input files To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with four streams into an mp4 output Specify target file type ( , , , , ). may be prefixed with , or to use the corresponding standard. All the format options (bitrate, codecs, buffer sizes) are then set automatically. You can just type: Nevertheless you can specify additional options as long as you know they do not conflict with the standard, as in: The parameters set for each target are as follows. The target is identical to the target except that the pixel format set is for all three standards. Any user-set value for a parameter above will override the target preset value. In that case, the output may not comply with the target standard. As an input option, blocks all data streams of a file from being filtered or being automatically selected or mapped for any output. See option to disable streams individually. As an output option, disables data recording i.e. automatic selection or mapping of any data stream. For full manual control see the option. Set the number of data frames to output. This is an obsolete alias for , which you should use instead. Stop writing to the stream after frames. Use fixed quality scale (VBR). The meaning of / is codec-dependent. If is used without a then it applies only to the video stream, this is to maintain compatibility with previous behavior and as specifying the same codec specific value to 2 different codecs that is audio and video generally is not what is intended when no stream_specifier is used. Create the filtergraph specified by and use it to filter the stream. is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label , and the output to the label . See the ffmpeg-filters manual for more information about the filtergraph syntax. See the -filter_complex option if you want to create filtergraphs with multiple inputs and/or outputs. This boolean option determines if the filtergraph(s) to which this stream is fed gets reinitialized when input frame parameters change mid-stream. This option is enabled by default as most video and all audio filters cannot handle deviation in input frame properties. Upon reinitialization, existing filter state is lost, like e.g. the frame count reference available in some filters. Any frames buffered at time of reinitialization are lost. The properties where a change triggers reinitialization are, for video, frame resolution or pixel format; for audio, sample format, sample rate, channel count or channel layout. Defines how many threads are used to process a filter pipeline. Each pipeline will produce a thread pool with this many threads available for parallel processing. The default is the number of available CPUs. Specify the preset for matching stream(s). Log encoding progress/statistics as \"info\"-level log (see ). It is on by default, to explicitly disable it you need to specify . Set period at which encoding progress/statistics are updated. Default is 0.5 seconds. Progress information is written periodically and at the end of the encoding process. It is made of \" = \" lines. consists of only alphanumeric characters. The last key of a sequence of progress information is always \"progress\" with the value \"continue\" or \"end\". The update period is set using . For example, log progress information to stdout: Enable interaction on standard input. On by default unless standard input is used as an input. To explicitly disable interaction you need to specify . Disabling interaction on standard input is useful, for example, if ffmpeg is in the background process group. Roughly the same result can be achieved with but it requires a shell. Print timestamp/latency information. It is off by default. This option is mostly useful for testing and debugging purposes, and the output format may change from one version to another, so it should not be employed by portable scripts. See also the option . Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option will add a new stream to the file. It is then possible to use per-stream options on this stream in the usual way. Attachment streams created with this option will be created after all the other streams (i.e. those created with or automatic mappings). Note that for Matroska you also have to set the mimetype metadata tag: (assuming that the attachment stream will be third in the output file). Extract the matching attachment stream into a file named . If is empty, then the value of the metadata tag will be used. E.g. to extract the first attachment to a file named ’out.ttf’: To extract all attachments to files determined by the tag: Technical note – attachments are implemented as codec extradata, so this option can actually be used to extract extradata from any stream, not just attachments.\n\nSet pixel format. Use to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If is prefixed by a , ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If is a single , ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled. Set default flags for the libswscale library. These flags are used by automatically inserted filters and those within simple filtergraphs, if not overridden within the filtergraph definition. See the (ffmpeg-scaler)ffmpeg-scaler manual for a list of scaler options. Rate control override for specific intervals, formatted as \"int,int,int\" list separated with slashes. Two first values are the beginning and end frame numbers, last one is quantizer to use if positive, or quality factor if negative. Dump video coding statistics to . See the vstats file format section for the format description. Dump video coding statistics to . See the vstats file format section for the format description. Specify which version of the vstats format to use. Default is . See the vstats file format section for the format description. Force video tag/fourcc. This is an alias for . can take arguments of the following form: If the argument consists of timestamps, ffmpeg will round the specified times to the nearest output timestamp as per the encoder time base and force a keyframe at the first frame having timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too coarse, then the keyframes may be forced on frames with timestamps lower than the specified time. The default encoder time base is the inverse of the output framerate but may be set otherwise via . If one of the times is \" [ ]\", it is expanded into the time of the beginning of all chapters in the file, shifted by , expressed as a time in seconds. This option can be useful to ensure that a seek point is present at a chapter mark or any other designated place in the output file. For example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning of every chapter: If the argument is prefixed with , the string is interpreted like an expression and is evaluated for each frame. A key frame is forced in case the evaluation is non-zero. The expression in can contain the following constants: the number of current processed frame, starting from 0 the number of the previous forced frame, it is when no keyframe was forced yet the time of the previous forced frame, it is when no keyframe was forced yet the time of the current processed frame For example to force a key frame every 5 seconds, you can specify: To force a key frame 5 seconds after the time of the last forced one, starting from second 13: If the argument is , ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source. In cases where this particular source frame has to be dropped, enforce the next available frame to become a key frame instead. Note that forcing too many keyframes is very harmful for the lookahead algorithms of certain encoders: using fixed-GOP options or similar would be more efficient. Automatically crop the video after decoding according to file metadata. Default is all. Apply both codec and container level croppping. This is the default mode. When doing stream copy, copy also non-key frames found at the beginning. Initialise a new hardware device of type called , using the given device parameters. If no name is specified it will receive a default name of the form \" %d\". The meaning of and the following arguments depends on the device type: is the number of the CUDA device. The following options are recognized: If set to 1, uses the primary device context instead of creating a new one. Choose the second device on the system. Choose the first device and use the primary device context. is the number of the Direct3D 9 display adapter. is the number of the Direct3D 11 display adapter. If not specified, it will attempt to use the default Direct3D 11 display adapter or the first Direct3D 11 display adapter whose hardware VendorId is specified by ‘ ’. Create a d3d11va device on the Direct3D 11 display adapter specified by index 1. Create a d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is 0x8086. is either an X11 display name, a DRM render node or a DirectX adapter index. If not specified, it will attempt to open the default X11 display ($DISPLAY) and then the first DRM render node (/dev/dri/renderD128), or the default DirectX adapter on Windows. The following options are recognized: When is not specified, use this option to specify the name of the kernel driver associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled. When and are not specified, use this option to specify the vendor id associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled and kernel_driver is not specified. Create a vaapi device on a device associated with kernel driver ‘ ’. Create a vaapi device on a device associated with vendor id ‘ ’. is an X11 display name. If not specified, it will attempt to open the default X11 display ($DISPLAY). selects a value in ‘ ’. Allowed values are: If not specified, ‘ ’ is used. (Note that it may be easier to achieve the desired result for QSV by creating the platform-appropriate subdevice (‘ ’ or ‘ ’ or ‘ ’) and then deriving a QSV device from that.) The following options are recognized: Specify a DRM render node on Linux or DirectX adapter on Windows. Choose platform-appropriate subdevice type. On Windows ‘ ’ is used as default subdevice type when is specified at configuration time, ‘ ’ is used as default subdevice type when is specified at configuration time. On Linux user can use ‘ ’ only as subdevice type. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Create a QSV device with ‘ ’ on DirectX adapter 1 with subdevice type ‘ ’. Create a VAAPI device called ‘ ’ on , then derive a QSV device called ‘ ’ from device ‘ ’. selects the platform and device as platform_index.device_index. The set of devices can also be filtered using the key-value pairs to find only devices matching particular platform or device strings. The strings usable as filters are: The indices and filters must together uniquely select a device. Choose the second device on the first platform. Choose the device with a name containing the string Foo9000. Choose the GPU device on the second platform supporting the cl_khr_fp16 extension. If is an integer, it selects the device by its index in a system-dependent list of devices. If is any other string, it selects the first device with a name containing that string as a substring. The following options are recognized: If set to 1, enables the validation layer, if installed. If set to 1, images allocated by the hwcontext will be linear and locally mappable. A plus separated list of additional instance extensions to enable. A plus separated list of additional device extensions to enable. Choose the second device on the system. Choose the first device with a name containing the string RADV. Choose the first device and enable the Wayland and XCB instance extensions. Initialise a new hardware device of type called , deriving it from the existing device with the name . List all hardware device types supported in this build of ffmpeg. Pass the hardware device called to all filters in any filter graph. This can be used to set the device to upload to with the filter, or the device to map to with the filter. Other filters may also make use of this parameter when they require a hardware device. Note that this is typically only required when the input is not already in hardware frames - when it is, filters will derive the device they require from the context of the frames they receive as input. This is a global setting, so all filters will receive the same device. Use hardware acceleration to decode the matching stream(s). The allowed values of are: Do not use any hardware acceleration (the default). Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration. Use the Intel QuickSync Video acceleration for video transcoding. Unlike most other values, this option does not enable accelerated decoding (that is used automatically whenever a qsv decoder is selected), but accelerated transcoding, without copying the frames into the system memory. For it to work, both the decoder and the encoder must support QSV acceleration and no filters must be used. This option has no effect if the selected hwaccel is not available or not supported by the chosen decoder. Note that most acceleration methods are intended for playback and will not be faster than software decoding on modern CPUs. Additionally, will usually need to copy the decoded frames from the GPU memory into the system memory, resulting in further performance loss. This option is thus mainly useful for testing. Select a device to use for hardware acceleration. This option only makes sense when the option is also specified. It can either refer to an existing device created with by name, or it can create a new device as if ‘ ’ : were called immediately before. List all hardware acceleration components enabled in this build of ffmpeg. Actual runtime availability depends on the hardware and its suitable driver being installed. Set a specific output video stream as the heartbeat stream according to which to split and push through currently in-progress subtitle upon receipt of a random access packet. This lowers the latency of subtitles for which the end packet or the following subtitle has not yet been received. As a drawback, this will most likely lead to duplication of subtitle events in order to cover the full duration, so when dealing with use cases where latency of when the subtitle event is passed on to output is not relevant this option should not be utilized. Requires to be set for the relevant input subtitle stream for this to have any effect, as well as for the input subtitle stream having to be directly mapped to the same output in which the heartbeat stream resides.\n\nCreate one or more streams in the output file. This option has two forms for specifying the data source(s): the first selects one or more streams from some input file (specified with ), the second takes an output from some complex filtergraph (specified with ). In the first form, an output stream is created for every stream from the input file with the index . If is given, only those streams that match the specifier are used (see the Stream specifiers section for the syntax). A character before the stream identifier creates a \"negative\" mapping. It disables matching streams from already created mappings. An optional may be given after the stream specifier, which for multiview video specifies the view to be used. The view specifier may have one of the following formats: select a view by its ID; may be set to ’all’ to use all the views interleaved into one stream; select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc. select a view by its display position; may be or The default for transcoding is to only use the base view, i.e. the equivalent of . For streamcopy, view specifiers are not supported and all views are always copied. A trailing after the stream index will allow the map to be optional: if the map matches no streams the map will be ignored instead of failing. Note the map will still fail if an invalid input file index is used; such as if the map refers to a non-existent input. An alternative form will map outputs from complex filter graphs (see the option) to the output file. must correspond to a defined output link label in the graph. This option may be specified multiple times, each adding more streams to the output file. Any given input stream may also be mapped any number of times as a source for different output streams, e.g. in order to use different encoding options and/or filters. The streams are created in the output in the same order in which the options are given on the commandline. Using this option disables the default mappings for this output file. To map ALL streams from the first input file to output If you have two audio streams in the first input file, these streams are identified by and . You can use to select which streams to place in an output file. For example: will map the second input stream in to the (single) output stream in . To select the stream with index 2 from input file (specified by the identifier ), and stream with index 6 from input (specified by the identifier ), and copy them to the output file : To select all video and the third audio stream from an input file: To map all the streams except the second audio, use negative mappings To map the video and audio streams from the first input, and using the trailing , ignore the audio mapping if no audio streams exist in the first input: Ignore input streams with unknown type instead of failing if copying such streams is attempted. Allow input streams with unknown type to be copied instead of failing if copying such streams is attempted. Set metadata information of the next output file from . Note that those are file indices (zero-based), not filenames. Optional parameters specify, which metadata to copy. A metadata specifier can have the following forms: global metadata, i.e. metadata that applies to the whole file per-stream metadata. is a stream specifier as described in the Stream specifiers chapter. In an input metadata specifier, the first matching stream is copied from. In an output metadata specifier, all matching streams are copied to. If metadata specifier is omitted, it defaults to global. By default, global metadata is copied from the first input file, per-stream and per-chapter metadata is copied along with streams/chapters. These default mappings are disabled by creating any mapping of the relevant type. A negative file index can be used to create a dummy mapping that just disables automatic copying. For example to copy metadata from the first stream of the input file to global metadata of the output file: To do the reverse, i.e. copy global metadata to all audio streams: Note that simple would work as well in this example, since global metadata is assumed by default. Copy chapters from input file with index to the next output file. If no chapter mapping is specified, then chapters are copied from the first input file with at least one chapter. Use a negative file index to disable any chapter copying. Show benchmarking information at the end of an encode. Shows real, system and user time used and maximum memory consumption. Maximum memory consumption is not supported on all systems, it will usually display as 0 if not supported. Show benchmarking information during the encode. Shows real, system and user time used in various steps (audio/video encode/decode). Exit after ffmpeg has been running for seconds in CPU user time. When dumping packets, also dump the payload. Its value is a floating-point positive number which represents the maximum duration of media, in seconds, that should be ingested in one second of wallclock time. Default value is zero and represents no imposed limitation on speed of ingestion. Value represents real-time speed and is equivalent to . Mainly used to simulate a capture device or live input stream (e.g. when reading from a file). Should not be used with a low value when input is an actual capture device or live stream as it may cause packet loss. It is useful for when flow speed of output packets is important, such as live streaming. Read input at native frame rate. This is equivalent to setting . Set an initial read burst time, in seconds, after which will be enforced. If either the input or output is blocked leading to actual read speed falling behind the specified readrate, then this rate takes effect till the input catches up with the specified readrate. Must not be lower than the primary readrate. Set video sync method / framerate mode. vsync is applied to all output video streams but can be overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future. For compatibility reasons some of the values for vsync can be specified as numbers (shown in parentheses in the following table). Each frame is passed with its timestamp from the demuxer to the muxer. Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. Chooses between cfr and vfr depending on muxer capabilities. This is the default method. Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option is enabled. With -map you can select from which stream the timestamps should be taken. You can leave either video or audio unchanged and sync the remaining stream(s) to the unchanged one. Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In frame rate units, so 1.0 is one frame. The default is -1.1. One possible usecase is to avoid framedrops in case of noisy timestamps or to increase frame drop precision in case of exact timestamps. Pad the output audio stream(s). This is the same as applying . Argument is a string of filter parameters composed the same as with the filter. must be set for this output for the option to take effect. Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value. Note that, depending on the option or on specific muxer processing (e.g. in case the format option is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected. When used with , shift input timestamps so they start at zero. This means that using e.g. will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at. Specify how to set the encoder timebase when stream copying. is an integer numeric value, and can assume one of the following values: The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate. The time base is copied to the output encoder from the corresponding input decoder. Try to make the choice automatically, in order to generate a sane output. Set the encoder timebase. can assume one of the following values: Assign a default value according to the media type. For video - use 1/framerate, for audio - use 1/samplerate. Use the timebase from the demuxer. Use the timebase from the filtergraph. Use the provided number as the timebase. This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number (e.g. 0.04166, 2.0833e-5) Note that this option may require buffering frames, which introduces extra latency. The maximum amount of this latency may be controlled with the option. The option may require buffering potentially large amounts of data when at least one of the streams is \"sparse\" (i.e. has large gaps between frames – this is typically the case for subtitles). This option controls the maximum duration of buffered frames in seconds. Larger values may allow the option to produce more accurate results, but increase memory use and latency. The default value is 10 seconds. The timestamp discontinuity correction enabled by this option is only applied to input formats accepting timestamp discontinuity (for which the flag is enabled), e.g. MPEG-TS and HLS, and is automatically disabled when employing the option (unless wrapping is detected). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will remove the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta value. The timestamp correction enabled by this option is only applied to input formats not accepting timestamp discontinuity (for which the flag is not enabled). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will drop the PTS/DTS timestamp value. The default value is (30 hours), which is arbitrarily picked and quite conservative. Assign a new stream-id value to an output stream. This option should be specified prior to the output filename to which it applies. For the situation where multiple output files exist, a streamid may be reassigned to a different value. For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file: Apply bitstream filters to matching streams. The filters are applied to each packet as it is received from the demuxer (when used as an input option) or before it is sent to the muxer (when used as an output option). is a comma-separated list of bitstream filter specifications, each of the form Any of the ’,=:’ characters that are to be a part of an option value need to be escaped with a backslash. Use the option to get the list of bitstream filters. applies the bitstream filter (which converts MP4-encapsulated H.264 stream to Annex B) to the input video stream. applies the bitstream filter (which extracts text from MOV subtitles) to the output subtitle stream. Note, however, that since both examples use , it matters little whether the filters are applied on input or output - that would change if transcoding was happening. Specify Timecode for writing. is ’:’ for non drop timecode and ’;’ (or ’.’) for drop. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. For simple graphs – those with one input and one output of the same type – see the options. is a description of the filtergraph, as described in the “Filtergraph syntax” section of the ffmpeg-filters manual. This option may be specified multiple times - each use creates a new complex filtergraph. Inputs to a complex filtergraph may come from different source types, distinguished by the format of the corresponding link label:\n• To connect an input stream, use (i.e. the same syntax as ). If matches multiple streams, the first one will be used. For multiview video, the stream specifier may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect a loopback decoder use [dec: ], where is the index of the loopback decoder to be connected to given input. For multiview video, the decoder index may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect an output from another complex filtergraph, use its link label. E.g the following example:\n• (line 2) uses a complex filtergraph with one input and two outputs to scale the video to 1920x1080 and duplicate the result to both outputs;\n• (line 3) encodes one scaled output with and writes the result to ;\n• (line 5) places the output of the loopback decoder (i.e. the -encoded video) side by side with the scaled original input;\n• (line 6) combined video is then losslessly encoded and written into . Note that the two filtergraphs cannot be combined into one, because then there would be a cycle in the transcoding pipeline (filtergraph output goes to encoding, from there to decoding, then back to the same graph), and such cycles are not allowed. An unlabeled input will be connected to the first unused input stream of the matching type. Output link labels are referred to with . Unlabeled outputs are added to the first output file. Note that with this option it is possible to use only lavfi sources without normal input files. For example, to overlay an image over video Here refers to the first video stream in the first input file, which is linked to the first (main) input of the overlay filter. Similarly the first video stream in the second input is linked to the second (overlay) input of overlay. Assuming there is only one video stream in each input file, we can omit input labels, so the above is equivalent to Furthermore we can omit the output label and the single output from the filter graph will be added to the output file automatically, so we can simply write As a special exception, you can use a bitmap subtitle stream as input: it will be converted into a video with the same size as the largest video in the file, or 720x576 if no video is present. Note that this is an experimental and temporary solution. It will be removed once libavfilter has proper support for subtitles. For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the subtitles by 1 second: To generate 5 seconds of pure red video using lavfi source: Defines how many threads are used to process a filter_complex graph. Similar to filter_threads but used for graphs only. The default is the number of available CPUs. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent to . This option enables or disables accurate seeking in input files with the option. It is enabled by default, so seeking is accurate when transcoding. Use to disable it, which may be useful e.g. when copying some streams and transcoding the others. This option enables or disables seeking by timestamp in input files with the option. It is disabled by default. If enabled, the argument to the option is considered an actual timestamp, and is not offset by the start time of the file. This matters only for files which do not start from timestamp 0, such as transport streams. For input, this option sets the maximum number of queued packets when reading from the file or device. With low latency / high rate live streams, packets may be discarded if they are not read in a timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as soon as they arrive. By default ffmpeg only does this if multiple inputs are specified. For output, this option specified the maximum number of packets that may be queued to each muxing thread. Print sdp information for an output stream to . This allows dumping sdp information when at least one output isn’t an rtp stream. (Requires at least one of the output formats to be rtp). Allows discarding specific streams or frames from streams. Any input stream can be fully discarded, using value whereas selective discarding of frames from a stream occurs at the demuxer and is not supported by all demuxers. Stop and abort on various conditions. The following flags are available: No packets were passed to the muxer, the output is empty. No packets were passed to the muxer in some of the output streams. Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return exit code 69. Crossing this threshold does not terminate processing. Range is a floating-point number between 0 to 1. Default is 2/3. When transcoding audio and/or video streams, ffmpeg will not begin writing into the output until it has one packet for each such stream. While waiting for that to happen, packets for other streams are buffered. This option sets the size of this buffer, in packets, for the matching output stream. The default value of this option should be high enough for most uses, so only touch this option if you are sure that you need it. This is a minimum threshold until which the muxing queue size is not taken into account. Defaults to 50 megabytes per stream, and is based on the overall size of packets passed to the muxer. Enable automatically inserting format conversion filters in all filter graphs, including those defined by , , and . If filter format negotiation requires a conversion, the initialization of the filters will fail. Conversions can still be performed by inserting the relevant conversion filter (scale, aresample) in the graph. On by default, to explicitly disable it you need to specify . Declare the number of bits per raw sample in the given output stream to be . Note that this option sets the information provided to the encoder/muxer, it does not change the stream to conform to this value. Setting values that do not match the stream properties may result in encoding failures or invalid output files. Write per-frame encoding information about the matching streams into the file given by . writes information about raw video or audio frames right before they are sent for encoding, while writes information about encoded packets as they are received from the encoder. writes information about packets just as they are about to be sent to the muxer. Every frame or packet produces one line in the specified file. The format of this line is controlled by / / . When stats for multiple streams are written into a single file, the lines corresponding to different streams will be interleaved. The precise order of this interleaving is not specified and not guaranteed to remain stable between different invocations of the program, even with the same options. Specify the format for the lines written with / / . is a string that may contain directives of the form . is backslash-escaped — use \\{, \\}, and \\\\ to write a literal {, }, or \\, respectively, into the output. The directives given with may be one of the following: Index of the output stream in the file. Frame number. Pre-encoding: number of frames sent to the encoder so far. Post-encoding: number of packets received from the encoder so far. Muxing: number of packets submitted to the muxer for this stream so far. Input frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this output frame or packet. -1 if unavailable. Timebase in which this frame/packet’s timestamps are expressed, as a rational number . Note that encoder and muxer may use different timebases. Timebase for , as a rational number . Available when is available, otherwise. Presentation timestamp of the frame or packet, as an integer. Should be multiplied by the timebase to compute presentation time. Presentation timestamp of the input frame (see ), as an integer. Should be multiplied by to compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available. Presentation time of the frame or packet, as a decimal number. Equal to multiplied by . Presentation time of the input frame (see ), as a decimal number. Equal to multiplied by . Printed as inf when not available. Decoding timestamp of the packet, as an integer. Should be multiplied by the timebase to compute presentation time. Decoding time of the frame or packet, as a decimal number. Equal to multiplied by . Number of audio samples sent to the encoder so far. Number of audio samples in the frame. Size of the encoded packet in bytes. Current bitrate in bits per second. Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at this point. Character ’K’ if the packet contains a keyframe, character ’N’ otherwise. Directives tagged with packet may only be used with and . Directives tagged with frame may only be used with . Directives tagged with audio may only be used with audio streams. In the future, new items may be added to the end of the default formatting strings. Users who depend on the format staying exactly the same, should prescribe it manually. Note that stats for different streams written into the same file may have different formats.\n\nA preset file contains a sequence of = pairs, one for each line, specifying a sequence of options which would be awkward to specify on the command line. Lines starting with the hash (’#’) character are ignored and are used to provide comments. Check the directory in the FFmpeg source tree for examples.\n\nThere are two types of preset files: ffpreset and avpreset files.\n\nffpreset files are specified with the , , , and options. The option takes the filename of the preset instead of a preset name as input and can be used for any kind of codec. For the , , and options, the options specified in a preset file are applied to the currently selected codec of the same type as the preset option.\n\nThe argument passed to the , , and preset options identifies the preset file to use according to the following rules:\n\nFirst ffmpeg searches for a file named .ffpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ) or in a folder along the executable on win32, in that order. For example, if the argument is , it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named - .ffpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\navpreset files are specified with the option. They work similar to ffpreset files, but they only allow encoder- specific options. Therefore, an = pair specifying an encoder cannot be used.\n\nWhen the option is specified, ffmpeg will look for files with the suffix .avpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ), in that order.\n\nFirst ffmpeg searches for a file named - .avpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named .avpreset in the same directories.\n\nThe and options enable generation of a file containing statistics about the generated video outputs.\n\nThe option controls the format version of the generated file.\n\nWith version the format is:\n\nWith version the format is:\n\nThe value corresponding to each key is described below:\n\nSee also the -stats_enc options for an alternative way to show encoding statistics.\n\nIf you specify the input format and device then ffmpeg can grab video and audio directly.\n\nOr with an ALSA audio source (mono input, card id 1) instead of OSS:\n\nNote that you must activate the right video source and channel before launching ffmpeg with any TV viewer such as xawtv by Gerd Knorr. You also have to set the audio recording levels correctly with a standard mixer.\n\nGrab the X11 display with ffmpeg via\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable. 10 is the x-offset and 20 the y-offset for the grabbing.\n\nAny supported file format and protocol can serve as input to ffmpeg:\n• You can use YUV files as input: It will use the files: The Y files use twice the resolution of the U and V files. They are raw files, without header. They can be generated by all decent video decoders. You must specify the size of the image with the option if ffmpeg cannot guess it.\n• You can input from a raw YUV420P file: test.yuv is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by the U and V planes at half vertical and horizontal resolution.\n• You can output to a raw YUV420P file:\n• You can set several input files and output files: Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.\n• You can also do audio and video conversions at the same time:\n• You can encode to several formats at the same time and define a mapping from input stream to output streams: Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map file:index’ specifies which input stream is used for each output stream, in the order of the definition of output streams.\n• You can transcode decrypted VOBs: This is a typical DVD ripping example; the input is a VOB file, the output an AVI file with MPEG-4 video and MP3 audio. Note that in this command we use B-frames so the MPEG-4 stream is DivX5 compatible, and GOP size is 300 which means one intra frame every 10 seconds for 29.97fps input video. Furthermore, the audio stream is MP3-encoded so you need to enable LAME support by passing to configure. The mapping is particularly useful for DVD transcoding to get the desired audio language. NOTE: To see the supported input formats, use .\n• You can extract images from a video, or create a video from many images: This will extract one video frame per second from the video and will output them in files named , , etc. Images will be rescaled to fit the new WxH values. If you want to extract just a limited number of frames, you can use the above command in combination with the or option, or in combination with -ss to start extracting from a certain point in time. For creating a video from many images: The syntax specifies to use a decimal number composed of three digits padded with zeroes to express the sequence number. It is the same syntax supported by the C printf function, but only formats accepting a normal integer are suitable. When importing an image sequence, -i also supports expanding shell-like wildcard patterns (globbing) internally, by selecting the image2-specific option. For example, for creating a video from filenames matching the glob pattern :\n• You can put many streams of the same type in the output: The resulting output file will contain the first four streams from the input files in reverse order.\n• The four options lmin, lmax, mblmin and mblmax use ’lambda’ units, but you may use the QP2LAMBDA constant to easily convert from ’q’ units:\n\nFor details about the authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg), e.g. by typing the command in the FFmpeg source directory, or browsing the online repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file in the source code tree.\n\nThis document was generated on March 22, 2025 using makeinfo."
    },
    {
        "link": "https://docs.opencv.org/4.x/javadoc/org/opencv/imgcodecs/Imgcodecs.html",
        "document": "\n• function loads an image from the specified file and returns OpenCV matrix. If the image cannot be read (because of a missing file, improper permissions, or unsupported/invalid format), the function returns an empty matrix. Currently, the following file formats are supported:\n• Raster and Vector geospatial data supported by GDAL (see the *Note* section) Note:\n• The function determines the type of an image by its content, not by the file extension.\n• In the case of color images, the decoded images will have the channels stored in B G R order.\n• When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ from the output of cvtColor().\n• On Microsoft Windows\\* and Mac OS\\*, the codecs shipped with OpenCV (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On Mac OS, there is also an option to use native Mac OS image readers. However, beware that currently these native image loaders give images with different pixel values because of the color management embedded into Mac OS.\n• On Linux\\*, BSD flavors, and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with the OS. Ensure the relevant packages are installed (including development files, such as \"libjpeg-dev\" in Debian\\* and Ubuntu\\*) to get codec support, or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n• If the *WITH_GDAL* flag is set to true in CMake and REF: IMREAD_LOAD_GDAL is used to load the image, the [GDAL](http://www.gdal.org) driver will be used to decode the image, supporting [Raster](http://www.gdal.org/formats_list.html) and [Vector](http://www.gdal.org/ogr_formats.html) formats.\n• If EXIF information is embedded in the image file, the EXIF orientation will be taken into account, and thus the image will be rotated accordingly unless the flags REF: IMREAD_IGNORE_ORIENTATION or REF: IMREAD_UNCHANGED are passed.\n• Use the IMREAD_UNCHANGED flag to preserve the floating-point values from PFM images.\n• By default, the number of pixels must be less than 2^30. This limit can be changed by setting the environment variable . See REF: tutorial_env_reference. Loads an image from a file. imread Thefunction loads an image from the specified file and returns OpenCV matrix. If the image cannot be read (because of a missing file, improper permissions, or unsupported/invalid format), the function returns an empty matrix. Currently, the following file formats are supported: - Name of the file to be loaded. - Flag that can take values of .\n• function loads an image from the specified file and returns OpenCV matrix. If the image cannot be read (because of a missing file, improper permissions, or unsupported/invalid format), the function returns an empty matrix. Currently, the following file formats are supported:\n• Raster and Vector geospatial data supported by GDAL (see the *Note* section) Note:\n• The function determines the type of an image by its content, not by the file extension.\n• In the case of color images, the decoded images will have the channels stored in B G R order.\n• When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ from the output of cvtColor().\n• On Microsoft Windows\\* and Mac OS\\*, the codecs shipped with OpenCV (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On Mac OS, there is also an option to use native Mac OS image readers. However, beware that currently these native image loaders give images with different pixel values because of the color management embedded into Mac OS.\n• On Linux\\*, BSD flavors, and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with the OS. Ensure the relevant packages are installed (including development files, such as \"libjpeg-dev\" in Debian\\* and Ubuntu\\*) to get codec support, or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n• If the *WITH_GDAL* flag is set to true in CMake and REF: IMREAD_LOAD_GDAL is used to load the image, the [GDAL](http://www.gdal.org) driver will be used to decode the image, supporting [Raster](http://www.gdal.org/formats_list.html) and [Vector](http://www.gdal.org/ogr_formats.html) formats.\n• If EXIF information is embedded in the image file, the EXIF orientation will be taken into account, and thus the image will be rotated accordingly unless the flags REF: IMREAD_IGNORE_ORIENTATION or REF: IMREAD_UNCHANGED are passed.\n• Use the IMREAD_UNCHANGED flag to preserve the floating-point values from PFM images.\n• By default, the number of pixels must be less than 2^30. This limit can be changed by setting the environment variable . See REF: tutorial_env_reference. Loads an image from a file. imread Thefunction loads an image from the specified file and returns OpenCV matrix. If the image cannot be read (because of a missing file, improper permissions, or unsupported/invalid format), the function returns an empty matrix. Currently, the following file formats are supported: - Name of the file to be loaded.\n• Loads an image from a file. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts and the return value. - Name of file to be loaded. - object in which the image will be loaded. - Flag that can take values of cv::ImreadModes Note: The image passing through the img parameter can be pre-allocated. The memory is reused if the shape and the type match with the load image.\n• Loads an image from a file. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts and the return value. - Name of file to be loaded. - object in which the image will be loaded. Note: The image passing through the img parameter can be pre-allocated. The memory is reused if the shape and the type match with the load image.\n• Loads a multi-page image from a file. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. SEE: cv::imread\n• Loads a multi-page image from a file. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - A vector of Mat objects holding each page. SEE: cv::imread\n• Loads images of a multi-page image from a file. The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - Start index of the image to load - Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. SEE: cv::imread\n• Loads images of a multi-page image from a file. The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - Start index of the image to load - Count number of images to load SEE: cv::imread\n• Loads frames from an animated image file into an Animation structure. The function imreadanimation loads frames from an animated image file (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A string containing the path to the file. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. - The index of the first frame to load. This is optional and defaults to 0. - The number of frames to load. This is optional and defaults to 32767. Returns true if the file was successfully loaded and frames were extracted; returns false otherwise.\n• Loads frames from an animated image file into an Animation structure. The function imreadanimation loads frames from an animated image file (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A string containing the path to the file. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. - The index of the first frame to load. This is optional and defaults to 0. Returns true if the file was successfully loaded and frames were extracted; returns false otherwise.\n• Loads frames from an animated image file into an Animation structure. The function imreadanimation loads frames from an animated image file (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A string containing the path to the file. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. Returns true if the file was successfully loaded and frames were extracted; returns false otherwise.\n• Loads frames from an animated image buffer into an Animation structure. The function imdecodeanimation loads frames from an animated image buffer (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A reference to an InputArray containing the image buffer. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. - The index of the first frame to load. This is optional and defaults to 0. - The number of frames to load. This is optional and defaults to 32767. Returns true if the buffer was successfully loaded and frames were extracted; returns false otherwise.\n• Loads frames from an animated image buffer into an Animation structure. The function imdecodeanimation loads frames from an animated image buffer (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A reference to an InputArray containing the image buffer. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. - The index of the first frame to load. This is optional and defaults to 0. Returns true if the buffer was successfully loaded and frames were extracted; returns false otherwise.\n• Loads frames from an animated image buffer into an Animation structure. The function imdecodeanimation loads frames from an animated image buffer (e.g., GIF, AVIF, APNG, WEBP) into the provided Animation struct. - A reference to an InputArray containing the image buffer. - A reference to an Animation structure where the loaded frames will be stored. It should be initialized before the function is called. Returns true if the buffer was successfully loaded and frames were extracted; returns false otherwise.\n• Saves an Animation to a specified file. The function imwriteanimation saves the provided Animation data to the specified file in an animated format. Supported formats depend on the implementation and may include formats like GIF, AVIF, APNG, or WEBP. - The name of the file where the animation will be saved. The file extension determines the format. - A constant reference to an Animation struct containing the frames and metadata to be saved. - Optional format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...). These parameters are used to specify additional options for the encoding process. Refer to for details on possible parameters. Returns true if the animation was successfully saved; returns false otherwise.\n• Saves an Animation to a specified file. The function imwriteanimation saves the provided Animation data to the specified file in an animated format. Supported formats depend on the implementation and may include formats like GIF, AVIF, APNG, or WEBP. - The name of the file where the animation will be saved. The file extension determines the format. - A constant reference to an Animation struct containing the frames and metadata to be saved. These parameters are used to specify additional options for the encoding process. Refer to for details on possible parameters. Returns true if the animation was successfully saved; returns false otherwise.\n• Encodes an Animation to a memory buffer. The function imencodeanimation encodes the provided Animation data into a memory buffer in an animated format. Supported formats depend on the implementation and may include formats like GIF, AVIF, APNG, or WEBP. - The file extension that determines the format of the encoded data. - A constant reference to an Animation struct containing the frames and metadata to be encoded. - A reference to a vector of unsigned chars where the encoded data will be stored. - Optional format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ...). These parameters are used to specify additional options for the encoding process. Refer to for details on possible parameters. Returns true if the animation was successfully encoded; returns false otherwise.\n• Encodes an Animation to a memory buffer. The function imencodeanimation encodes the provided Animation data into a memory buffer in an animated format. Supported formats depend on the implementation and may include formats like GIF, AVIF, APNG, or WEBP. - The file extension that determines the format of the encoded data. - A constant reference to an Animation struct containing the frames and metadata to be encoded. - A reference to a vector of unsigned chars where the encoded data will be stored. paramValue_1, paramId_2, paramValue_2, ...). These parameters are used to specify additional options for the encoding process. Refer to for details on possible parameters. Returns true if the animation was successfully encoded; returns false otherwise.\n• Returns the number of images inside the given file The function imcount returns the number of pages in a multi-page image (e.g. TIFF), the number of frames in an animation (e.g. AVIF), and 1 otherwise. If the image cannot be decoded, 0 is returned. - Name of file to be loaded. - Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. TODO: when cv::IMREAD_LOAD_GDAL flag used the return value will be 0 or 1 because OpenCV's GDAL decoder doesn't support multi-page reading yet.\n• Returns the number of images inside the given file The function imcount returns the number of pages in a multi-page image (e.g. TIFF), the number of frames in an animation (e.g. AVIF), and 1 otherwise. If the image cannot be decoded, 0 is returned. - Name of file to be loaded. TODO: when cv::IMREAD_LOAD_GDAL flag used the return value will be 0 or 1 because OpenCV's GDAL decoder doesn't support multi-page reading yet.\n• \n• With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n• With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n• All images will be converted to 32-bit float (CV_32F).\n• With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With JPEG XL encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U) and 32-bit float(CV_32F) images can be saved.\n• JPEG XL images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) / 16-bit 4-channel (CV_16UC4) / 32-bit float 4-channel (CV_32FC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255/65535/1.0.\n• With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• PNG images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) / 16-bit 4-channel (CV_16UC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255/65535(see the code sample below).\n• With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With TIFF encoder, 8-bit unsigned (CV_8U), 8-bit signed (CV_8S), 16-bit unsigned (CV_16U), 16-bit signed (CV_16S), 32-bit signed (CV_32S), 32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n• Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n• 32-bit float 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel)\n• With GIF encoder, 8-bit unsigned (CV_8U) images can be saved.\n• GIF images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255.\n• 8-bit single-channel images (CV_8UC1) are not supported due to GIF's limitation to indexed color formats. If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp Saves an image to a specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U) single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp - Name of the file. - (Mat or vector of Mat) Image or Images to be saved.\n• \n• With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n• With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n• All images will be converted to 32-bit float (CV_32F).\n• With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With JPEG XL encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U) and 32-bit float(CV_32F) images can be saved.\n• JPEG XL images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) / 16-bit 4-channel (CV_16UC4) / 32-bit float 4-channel (CV_32FC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255/65535/1.0.\n• With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• PNG images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) / 16-bit 4-channel (CV_16UC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255/65535(see the code sample below).\n• With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With TIFF encoder, 8-bit unsigned (CV_8U), 8-bit signed (CV_8S), 16-bit unsigned (CV_16U), 16-bit signed (CV_16S), 32-bit signed (CV_32S), 32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n• Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n• 32-bit float 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel)\n• With GIF encoder, 8-bit unsigned (CV_8U) images can be saved.\n• GIF images with an alpha channel can be saved using this function. To achieve this, create an 8-bit 4-channel (CV_8UC4) BGRA image, ensuring the alpha channel is the last component. Fully transparent pixels should have an alpha value of 0, while fully opaque pixels should have an alpha value of 255.\n• 8-bit single-channel images (CV_8UC1) are not supported due to GIF's limitation to indexed color formats. If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp Saves an image to a specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U) single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp - Name of the file. - (Mat or vector of Mat) Image or Images to be saved.\n• Reads an image from a buffer in memory. The function imdecode reads an image from the specified buffer in the memory. If the buffer is too short or contains invalid data, the function returns an empty matrix ( Mat::data==NULL ). See cv::imread for the list of supported formats and flags description. Note: In the case of color images, the decoded images will have the channels stored in B G R order. - The same flags as in cv::imread, see cv::ImreadModes.\n• Reads a multi-page image from a buffer in memory. The function imdecodemulti reads a multi-page image from the specified buffer in the memory. If the buffer is too short or contains invalid data, the function returns false. See cv::imreadmulti for the list of supported formats and flags description. Note: In the case of color images, the decoded images will have the channels stored in B G R order. - The same flags as in cv::imread, see cv::ImreadModes. - A vector of Mat objects holding each page, if more than one.\n• Reads a multi-page image from a buffer in memory. The function imdecodemulti reads a multi-page image from the specified buffer in the memory. If the buffer is too short or contains invalid data, the function returns false. See cv::imreadmulti for the list of supported formats and flags description. Note: In the case of color images, the decoded images will have the channels stored in B G R order. - The same flags as in cv::imread, see cv::ImreadModes. - A vector of Mat objects holding each page, if more than one.\n• Encodes an image into a memory buffer. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period.\n• Encodes an image into a memory buffer. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period.\n• Encodes array of images into a memory buffer. The function is analog to cv::imencode for in-memory multi-page image compression. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period. - Vector of images to be written.\n• Encodes array of images into a memory buffer. The function is analog to cv::imencode for in-memory multi-page image compression. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period. - Vector of images to be written.\n• Checks if the specified image file can be decoded by OpenCV. The function haveImageReader checks if OpenCV is capable of reading the specified file. This can be useful for verifying support for a given image format before attempting to load an image. - The name of the file to be checked. true if an image reader for the specified file is available and the file can be opened, false otherwise. Note: The function checks the availability of image codecs that are either built into OpenCV or dynamically loaded. It does not check for the actual existence of the file but rather the ability to read the specified file type. If the file cannot be opened or the format is unsupported, the function will return false. SEE: cv::haveImageWriter, cv::imread, cv::imdecode\n• Checks if the specified image file or specified file extension can be encoded by OpenCV. The function haveImageWriter checks if OpenCV is capable of writing images with the specified file extension. This can be useful for verifying support for a given image format before attempting to save an image. - The name of the file or the file extension (e.g., \".jpg\", \".png\"). It is recommended to provide the file extension rather than the full file name. true if an image writer for the specified extension is available, false otherwise. Note: The function checks the availability of image codecs that are either built into OpenCV or dynamically loaded. It does not check for the actual existence of the file but rather the ability to write files of the given type. SEE: cv::haveImageReader, cv::imwrite, cv::imencode"
    },
    {
        "link": "https://docs.opencv.org/3.4/javadoc/org/opencv/imgcodecs/Imgcodecs.html",
        "document": "\n• \n• Raster and Vector geospatial data supported by GDAL (see the *Note* section) Note:\n• The function determines the type of an image by the content, not by the file extension.\n• In the case of color images, the decoded images will have the channels stored in B G R order.\n• When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ to the output of cvtColor()\n• On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware that currently these native image loaders give images with different pixel values because of the color management embedded into MacOSX.\n• On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with an OS image. Install the relevant packages (do not forget the development files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n• In the case you set *WITH_GDAL* flag to true in CMake and REF: IMREAD_LOAD_GDAL to load the image, then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting the following formats: [Raster](http://www.gdal.org/formats_list.html), [Vector](http://www.gdal.org/ogr_formats.html).\n• If EXIF information is embedded in the image file, the EXIF orientation will be taken into account and thus the image will be rotated accordingly except if the flags REF: IMREAD_IGNORE_ORIENTATION or REF: IMREAD_UNCHANGED are passed.\n• By default number of pixels must be less than 2^30. Limit can be set using system variable OPENCV_IO_MAX_IMAGE_PIXELS Loads an image from a file. imread The function imread loads an image from the specified file and returns it. If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format), the function returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported: - Name of file to be loaded. - Flag that can take values of cv::ImreadModes\n• \n• Raster and Vector geospatial data supported by GDAL (see the *Note* section) Note:\n• The function determines the type of an image by the content, not by the file extension.\n• In the case of color images, the decoded images will have the channels stored in B G R order.\n• When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ to the output of cvtColor()\n• On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware that currently these native image loaders give images with different pixel values because of the color management embedded into MacOSX.\n• On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with an OS image. Install the relevant packages (do not forget the development files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n• In the case you set *WITH_GDAL* flag to true in CMake and REF: IMREAD_LOAD_GDAL to load the image, then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting the following formats: [Raster](http://www.gdal.org/formats_list.html), [Vector](http://www.gdal.org/ogr_formats.html).\n• If EXIF information is embedded in the image file, the EXIF orientation will be taken into account and thus the image will be rotated accordingly except if the flags REF: IMREAD_IGNORE_ORIENTATION or REF: IMREAD_UNCHANGED are passed.\n• By default number of pixels must be less than 2^30. Limit can be set using system variable OPENCV_IO_MAX_IMAGE_PIXELS Loads an image from a file. imread The function imread loads an image from the specified file and returns it. If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format), the function returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported: - Name of file to be loaded.\n• Loads a multi-page image from a file. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR. SEE: cv::imread\n• Loads a multi-page image from a file. The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects. - Name of file to be loaded. - A vector of Mat objects holding each page. SEE: cv::imread\n• \n• With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n• With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n• All images will be converted to 32-bit float (CV_32F).\n• With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).\n• With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U), 32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n• Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n• 32-bit float 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel) If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp Saves an image to a specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U) single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp - Name of the file. - (Mat or vector of Mat) Image or Images to be saved.\n• \n• With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n• With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n• All images will be converted to 32-bit float (CV_32F).\n• With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).\n• With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U), 32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n• Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n• 32-bit float 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel) If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp Saves an image to a specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U) single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: INCLUDE: snippets/imgcodecs_imwrite.cpp - Name of the file. - (Mat or vector of Mat) Image or Images to be saved.\n• Reads an image from a buffer in memory. The function imdecode reads an image from the specified buffer in the memory. If the buffer is too short or contains invalid data, the function returns an empty matrix ( Mat::data==NULL ). See cv::imread for the list of supported formats and flags description. Note: In the case of color images, the decoded images will have the channels stored in B G R order. - The same flags as in cv::imread, see cv::ImreadModes.\n• Encodes an image into a memory buffer. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period.\n• Encodes an image into a memory buffer. The function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. - File extension that defines the output format. Must include a leading period."
    },
    {
        "link": "https://github.com/bytedeco/javacv-examples/blob/master/OpenCV_Cookbook/src/main/java/opencv_cookbook/OpenCVUtilsJava.java",
        "document": "* Load an image and show in a CanvasFrame. If image cannot be loaded the application will exit with code 1.\n\n* Load an image and show in a CanvasFrame. If image cannot be loaded the application will exit with code 1.\n\n* the alpha channel, if any, is stripped from the output image. For example, a 4-channel\n\n* Load an image. If image cannot be loaded the application will exit with code 1.\n\n* Load an image. If image cannot be loaded the application will exit with code 1.\n\n* the alpha channel, if any, is stripped from the output image. For example, a 4-channel\n\n* If the format, depth or channel order is different, use Mat::convertTo() , and cvtColor() to convert it before saving.\n\n* @param file file to save to. File name extension decides output image format."
    },
    {
        "link": "https://cloudinary.com/guides/front-end-development/java-for-image-processing-4-libraries-you-should-know",
        "document": "Java for Image Processing: 4 Libraries You Should Know\n\nImage processing involves manipulating digital images using various algorithms to enhance their quality, extract useful information, and make them suitable for specific applications. This process can range from improving visual aesthetics to preparing images for machine learning algorithms.\n\nIn programming, image processing covers a broad spectrum of techniques, such as smoothing, sharpening, edge detection, and segmentation. These techniques, including computer vision, face recognition, and self-driving cars, are crucial in modern technologies.\n\nJava, known for its powerful and flexible architecture, is well-suited for image processing tasks. It offers a robust set of APIs for handling and manipulating images. The Java Advanced Imaging (JAI) API provides high-performance image processing capabilities, while the Java2D API allows for advanced manipulation of 2D graphics and images.\n\nHowever, working directly with Java’s image APIs can be challenging. Thankfully, specialized Java image processing libraries simplify the process significantly. In this article, we’ll review three open-source libraries that make Java image processing more accessible and a free option that enables advanced image processing with AI in just one line of code.\n\nThis is part of a series of articles about image optimization\n• BoofCV for Java Image Processing\n• How to Set Up BoofCV\n• How to Load an Image with BoofCV\n• How to Edit an Image in BoofCV\n• JavaCV for Java Image Processing\n• How to Set Up JavaCV\n• How to Load an Image with JavaCV\n• How to Edit an Image in JavaCV\n• ImageJ for Java Image Processing\n• How to Set Up ImageJ\n• How to Load an Image with ImageJ\n• How to Edit an Image in ImageJ\n\nBoofCV is a comprehensive library designed for real-time computer vision and image processing applications. It focuses on providing simple and efficient algorithms for tasks such as image enhancement, feature detection, and object tracking.\n\nWritten in pure Java, the library is suitable for both desktop and mobile applications. BoofCV is versatile, supporting various image types and offering extensive tools for tasks like geometric and photometric calibration, stereo vision, structure from motion, and image stabilization.\n\nHow to Set Up BoofCV\n\nTo set up BoofCV, you first need to ensure that you have the Java Development Kit (JDK) installed on your system. When adding BoofCV to your project, include BoofCV dependencies in your pom.xml file if you are using Maven. An example dependency in your pom.xml might look like this:\n\nFor Gradle, add the dependency in your build.gradle file. Alternatively, you can manually download the JAR files directly from the BoofCV GitHub releases page and add them to your project’s classpath.\n\nTo verify the installation, create a simple Java class to import a BoofCV class (for example, ). If there are no import errors, the setup is successful.\n\nHow to Load an Image with BoofCV\n\nTo load an image using BoofCV, start by importing the necessary classes for file handling and image data structures, for example:\n\nYou can use to load an image from a file. For example, to load a grayscale image, use this code:\n\nHow to Edit an Image in BoofCV\n\nEditing an image in BoofCV involves importing image processing classes relevant to the operations you need, such as filters or transformations.\n\nFor instance, use this code to apply a binary threshold to an image:\n\nThis code snippet converts a grayscale image into a binary image with a threshold value of 100.\n\nAfter editing, save the modified image using this command:\n\nBoofCV offers a wide range of image processing operations, so you can experiment with different functions to achieve various effects, such as edge detection, smoothing, or geometric transformations.\n\nNote: If you are using Maven, don’t forget to add JUnit as a dependency in your project.\n\nJavaCV is a wrapper for commonly used libraries in computer vision, such as OpenCV, FFmpeg, and others. It offers a Java interface to these powerful native libraries, simplifying access to advanced capabilities in image processing and computer vision, like real-time filters, object detection, feature extraction, and video processing.\n\nJavaCV is suitable for high-performance image processing applications and is widely used in academia and industry for research, prototyping, and production-grade projects.\n\nHow to Set Up JavaCV\n\nTo set up JavaCV, first make sure you have the JDK installed on your system. To add JavaCV to your project, if you’re using Maven, you need to include JavaCV’s dependencies in your pom.xml file. Here’s an example:\n\nFor Gradle projects, add the dependency in your file. You also have the option to download the JAR files directly from the JavaCV GitHub releases page and manually add them to your project’s classpath.\n\nOnce you have added the dependencies, create a simple Java class to import a JavaCV class, for example, . If there are no import errors, installation is successful.\n\nHow to Load an Image with JavaCV\n\nTo load an image in JavaCV, begin by importing the necessary classes for image handling:\n\nYou can load an image from a file using JavaCV’s function. For example, to load an image into a Mat (matrix) object, use:\n\nThis function reads the specified file and loads the image into the Mat object.\n\nHow to Edit an Image in JavaCV\n\nEditing an image with JavaCV involves using the library’s various image processing capabilities. First, import the necessary JavaCV classes for your intended operations. For example, if you want to convert an image to grayscale, you would import .\n\nHere’s an example of how you might convert an RGB image to grayscale:\n\nThis code converts the image into a grayscale image stored in . After processing the image, you can save it as follows:\n\nJavaCV provides a broad spectrum of image processing functions, including filtering, transformations, and feature detection, allowing for extensive manipulation and analysis of images.\n\nImageJ is an open-source image processing program extensively used in the scientific community to analyze and process multidimensional images. It’s highly extensible, with thousands of plugins and scripts for performing a wide range of image processing tasks, data analysis, and visualization.\n\nImageJ supports a variety of image formats and offers functionalities such as image segmentation, geometric transformations, statistical analysis, and 3D visualizations.\n\nHow to Set Up ImageJ\n\nTo set up ImageJ, first, ensure you have a compatible version of Java installed on your system.\n\nTo install ImageJ, download the appropriate version for your operating system from the ImageJ website. The website offers versions for Windows, Mac OS, and Linux. After downloading, extract the files and run the ImageJ executable. No special installation process is required; ImageJ runs directly from the extracted folder.\n\nFor developers looking to integrate ImageJ into their Java projects, you can add ImageJ as a dependency. If you’re using Maven, include the dependency in your pom.xml file.\n\nAs an alternative, you can also download ImageJ packaged with Java here.\n\nHow to Load an Image with ImageJ\n\nLoading an image in ImageJ is straightforward. After starting ImageJ, you can open an image file by clicking on File in the menu bar, then Open, and select the image file you want to load. ImageJ supports a wide range of image formats, including TIFF, JPEG, GIF, and PNG.\n\nFor programmatic access or if you’re writing a script or plugin, you can use ImageJ’s API to load images. For example, you can use the method to load an image from a given file path. For example:\n\nThis method returns an object, which is a container for image data in ImageJ.\n\nHow to Edit an Image in ImageJ\n\nEditing an image in ImageJ can be done both manually through the GUI and programmatically using ImageJ’s API. The GUI provides a wide range of tools and options for image processing, including filters, color adjustments, transformations, and analysis tools.\n\nFor scripting or plugin development, ImageJ’s API offers extensive capabilities for image manipulation. For example, to convert an image to grayscale programmatically, you would use the method as follows:\n\nThis script loads an image and converts it to 8-bit grayscale. After processing the image, you can save it using the method:\n\nCloudinary is a powerful Image and Video API platform that empowers developers to efficiently manage, optimize, transform, and deliver images and videos at scale. Its powerful features make it an ideal choice for developers seeking to streamline their media workflows and enhance the performance of their applications.\n\nOne of Cloudinary’s standout features is its ability to process images dynamically using URLs. You can apply a wide range of transformations by simply modifying the URL, such as resizing, cropping, and filtering. For example, to resize an image to 300×300 pixels, you can use the following URL structure:\n\nThis approach allows for real-time image optimization without the need for pre-processing, making it perfect for applications requiring on-the-fly adjustments.\n\nFor more complex scenarios, Cloudinary also offers a robust API that can be integrated into your Java applications. Using the Cloudinary Java SDK, you can programmatically manage and transform images with ease. Here’s a quick example of how to upload and apply transformations to an image in Java:\n\nBy leveraging Cloudinary’s dynamic URLs and Java SDK, developers can seamlessly integrate powerful image processing capabilities into their workflows, ensuring high-quality media delivery and optimized performance.\n\nUnlock the full potential of your digital content with Cloudinary’s advanced editing and optimization tools. Sign up for free today!"
    },
    {
        "link": "https://opencv-java-tutorials.readthedocs.io",
        "document": "We are in the process to update these tutorials to use Java 8, only."
    },
    {
        "link": "https://stackoverflow.com/questions/56590239/how-to-assign-the-video-level-to-struct-avcodeccontext-in-ffmpeg",
        "document": "I am writting a C++ video encode API with ffmpeg.The video level is one important param, but I don't known how to assign it to AVCodecContext.\n\nI read the ffmpeg document and find out that \"level\" is int type,below is the definition at line 3014 of file avcodec.h.\n\naccording to my google search, the value of level is from 1.1(1.2,1.3,2...) to 5.2, obviously it is not an int type. I think level should be an enum type,but I can't find any definition about it.\n\nI have see some usage in internet, such as :\n\nbut I think these usages are wrong.. I think the correct way to assign is somehow like this:\n\nso I wonder if there is some relevant enum type definition about level and how to location it."
    },
    {
        "link": "https://stackoverflow.com/questions/59763027/how-to-change-the-settings-of-avcodeccontext-after-initialization-ffmpeg",
        "document": "I have a question about Libavcodec that I can't find the answer to online. I'm trying to use H.264 to encode frames. The issue I'm having is that the frames I wish to encode have variable widths and heights. I understand that to encode frames in Libavcodec, you need to pass a \"width\" and \"height\" parameter to the AvCodecContext struct, and then initialize it as such:\n\nLet's say that, after I've initialized this context, I need to encode a different frame that now has a width of . I can't simply just do because the context has already been set to width and initialized. I could create an entirely new AvCodecContext and delete the previous one with as follows:\n\nBut my program has been crashing unexpectedly when I do this, and I feel like recreating the AVCodecContext every time I need to change a simple width/height setting is inefficient to begin with. Does anyone have any suggestions as to how I can go about doing this? Thank you very much!"
    },
    {
        "link": "https://ffmpeg.org/doxygen/6.0/structAVCodecContext.html",
        "document": "This callback is called at the beginning of each frame to get data buffer(s) for it. There may be one contiguous buffer for all the data or there may be a buffer per each data plane or anything in between. What this means is, you may set however many entries in buf[] you feel necessary. Each buffer must be reference-counted using the AVBuffer API (see description of buf[] below). The following fields will be set in the frame before this callback is called:\n• sample_rate, channel_layout, nb_samples (audio only) Their values may differ from the corresponding values in AVCodecContext. This callback must use the frame values, not the codec context values, to calculate the required buffer size. This callback must fill the following fields in the frame:\n• extended_data:\n• if the data is planar audio with more than 8 channels, then this callback must allocate and fill extended_data to contain all pointers to all data planes. data[] must hold as many pointers as it can. extended_data must be allocated with av_malloc() and will be freed in av_frame_unref().\n• otherwise extended_data must point to data\n• buf[] must contain one or more pointers to AVBufferRef structures. Each of the frame's data and extended_data pointers must be contained in these. That is, one AVBufferRef for each allocated chunk of memory, not necessarily one AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(), and av_buffer_ref().\n• extended_buf and nb_extended_buf must be allocated with av_malloc() by this callback and filled with the extra buffers if there are more buffers than buf[] can hold. extended_buf will be freed in av_frame_unref(). If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call avcodec_default_get_buffer2() instead of providing buffers allocated by some other means. Each data plane must be aligned to the maximum required by the target CPU. If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused (read and/or written to if it is writable) later by libavcodec. avcodec_align_dimensions2() should be used to find the required width and height, as they normally need to be rounded up to the next multiple of 16. Some decoders do not support linesizes changing between frames. If frame multithreading is used, this callback may be called from a different thread, but not from more than one at once. Does not need to be reentrant. Decoders request a buffer of a particular size by setting AVFrame.nb_samples prior to calling get_buffer2(). The decoder may, however, utilize only part of the buffer by setting AVFrame.nb_samples to a smaller value in the output frame. As a convenience, av_samples_get_buffer_size() and av_samples_fill_arrays() in libavutil may be used by custom get_buffer2() functions to find the required data size and to fill data pointers and linesize. In AVFrame.linesize, only linesize[0] may be set for audio since all planes must be the same size.\n\nThe documentation for this struct was generated from the following file:"
    },
    {
        "link": "https://ffmpeg.org/ffmpeg.html",
        "document": "is a universal media converter. It can read a wide variety of inputs - including live grabbing/recording devices - filter, and transcode them into a plethora of output formats.\n\nreads from an arbitrary number of inputs (which can be regular files, pipes, network streams, grabbing devices, etc.), specified by the option, and writes to an arbitrary number of outputs, which are specified by a plain output url. Anything found on the command line which cannot be interpreted as an option is considered to be an output url.\n\nEach input or output can, in principle, contain any number of elementary streams of different types (video/audio/subtitle/attachment/data), though the allowed stream counts and/or types may be limited by the container format. Selecting which streams from which inputs will go into which output is either done automatically or with the option (see the Stream selection chapter).\n\nTo refer to inputs/outputs in options, you must use their indices (0-based). E.g. the first input is , the second is , etc. Similarly, streams within an input/output are referred to by their indices. E.g. refers to the fourth stream in the third input or output. Also see the Stream specifiers chapter.\n\nAs a general rule, options are applied to the next specified file. Therefore, order is important, and you can have the same option on the command line multiple times. Each occurrence is then applied to the next input or output file. Exceptions from this rule are the global options (e.g. verbosity level), which should be specified first.\n\nDo not mix input and output files – first specify all input files, then all output files. Also do not mix options which belong to different files. All options apply ONLY to the next input or output file and are reset between files.\n• Convert an input media file to a different format, by re-encoding media streams:\n• Set the video bitrate of the output file to 64 kbit/s:\n• Force the frame rate of the output file to 24 fps:\n• Force the frame rate of the input file (valid for raw formats only) to 1 fps and the frame rate of the output file to 24 fps:\n\nThe format option may be needed for raw input files.\n\nbuilds a transcoding pipeline out of the components listed below. The program’s operation then consists of input data chunks flowing from the sources down the pipes towards the sinks, while being transformed by the components they encounter along the way.\n\nThe following kinds of components are available:\n• Demuxers (short for \"demultiplexers\") read an input source in order to extract\n• global properties such as metadata or chapters;\n• list of input elementary streams and their properties One demuxer instance is created for each option, and sends encoded packets to decoders or muxers. In other literature, demuxers are sometimes called splitters, because their main function is splitting a file into elementary streams (though some files only contain one elementary stream). A schematic representation of a demuxer looks like this: ┌──────────┬───────────────────────┐ │ demuxer │ │ packets for stream 0 ╞══════════╡ elementary stream 0 ├──────────────────────► │ │ │ │ global ├───────────────────────┤ │properties│ │ packets for stream 1 │ and │ elementary stream 1 ├──────────────────────► │ metadata │ │ │ ├───────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├───────────────────────┤ │ │ │ packets for stream N │ │ elementary stream N ├──────────────────────► │ │ │ └──────────┴───────────────────────┘ ▲ │ │ read from file, network stream, │ grabbing device, etc. │\n• Decoders receive encoded (compressed) packets for an audio, video, or subtitle elementary stream, and decode them into raw frames (arrays of pixels for video, PCM for audio). A decoder is typically associated with (and receives its input from) an elementary stream in a demuxer, but sometimes may also exist on its own (see Loopback decoders). A schematic representation of a decoder looks like this:\n• Filtergraphs process and transform raw audio or video frames. A filtergraph consists of one or more individual filters linked into a graph. Filtergraphs come in two flavors - simple and complex, configured with the and options, respectively. A simple filtergraph is associated with an output elementary stream; it receives the input to be filtered from a decoder and sends filtered output to that output stream’s encoder. A simple video filtergraph that performs deinterlacing (using the deinterlacer) followed by resizing (using the filter) can look like this: ┌────────────────────────┐ │ simple filtergraph │ frames from ╞════════════════════════╡ frames for a decoder │ ┌───────┐ ┌───────┐ │ an encoder ────────────►├─►│ yadif ├─►│ scale ├─►│────────────► │ └───────┘ └───────┘ │ └────────────────────────┘ A complex filtergraph is standalone and not associated with any specific stream. It may have multiple (or zero) inputs, potentially of different types (audio or video), each of which receiving data either from a decoder or another complex filtergraph’s output. It also has one or more outputs that feed either an encoder or another complex filtergraph’s input. The following example diagram represents a complex filtergraph with 3 inputs and 2 outputs (all video): Frames from second input are overlaid over those from the first. Frames from the third input are rescaled, then the duplicated into two identical streams. One of them is overlaid over the combined first two inputs, with the result exposed as the filtergraph’s first output. The other duplicate ends up being the filtergraph’s second output.\n• Encoders receive raw audio, video, or subtitle frames and encode them into encoded packets. The encoding (compression) process is typically lossy - it degrades stream quality to make the output smaller; some encoders are lossless, but at the cost of much higher output size. A video or audio encoder receives its input from some filtergraph’s output, subtitle encoders receive input from a decoder (since subtitle filtering is not supported yet). Every encoder is associated with some muxer’s output elementary stream and sends its output to that muxer. A schematic representation of an encoder looks like this:\n• Muxers (short for \"multiplexers\") receive encoded packets for their elementary streams from encoders (the transcoding path) or directly from demuxers (the streamcopy path), interleave them (when there is more than one elementary stream), and write the resulting bytes into the output file (or pipe, network stream, etc.). A schematic representation of a muxer looks like this: ┌──────────────────────┬───────────┐ packets for stream 0 │ │ muxer │ ──────────────────────►│ elementary stream 0 ╞═══════════╡ │ │ │ ├──────────────────────┤ global │ packets for stream 1 │ │properties │ ──────────────────────►│ elementary stream 1 │ and │ │ │ metadata │ ├──────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├──────────────────────┤ │ packets for stream N │ │ │ ──────────────────────►│ elementary stream N │ │ │ │ │ └──────────────────────┴─────┬─────┘ │ write to file, network stream, │ grabbing device, etc. │ │ ▼\n\nThe simplest pipeline in is single-stream streamcopy, that is copying one input elementary stream’s packets without decoding, filtering, or encoding them. As an example, consider an input file called with 3 elementary streams, from which we take the second and write it to file . A schematic representation of such a pipeline looks like this:\n\nThe above pipeline can be constructed with the following commandline:\n• there are no input options for this input;\n• there are two output options for this output:\n• selects the input stream to be used - from input with index 0 (i.e. the first one) the stream with index 1 (i.e. the second one);\n• selects the encoder, i.e. streamcopy with no decoding or encoding.\n\nStreamcopy is useful for changing the elementary stream count, container format, or modifying container-level metadata. Since there is no decoding or encoding, it is very fast and there is no quality loss. However, it might not work in some cases because of a variety of factors (e.g. certain information required by the target container is not available in the source). Applying filters is obviously also impossible, since filters work on decoded frames.\n\nMore complex streamcopy scenarios can be constructed - e.g. combining streams from two input files into a single output:\n\nthat can be built by the commandline\n\nThe output option is used twice here, creating two streams in the output file - one fed by the first input and one by the second. The single instance of the option selects streamcopy for both of those streams. You could also use multiple instances of this option together with Stream specifiers to apply different values to each stream, as will be demonstrated in following sections.\n\nA converse scenario is splitting multiple streams from a single input into multiple outputs:\n\nNote how a separate instance of the option is needed for every output file even though their values are the same. This is because non-global options (which is most of them) only apply in the context of the file before which they are placed.\n\nThese examples can of course be further generalized into arbitrary remappings of any number of inputs into any number of outputs.\n\nTranscoding is the process of decoding a stream and then encoding it again. Since encoding tends to be computationally expensive and in most cases degrades the stream quality (i.e. it is lossy), you should only transcode when you need to and perform streamcopy otherwise. Typical reasons to transcode are:\n• you want to feed the stream to something that cannot decode the original codec.\n\nNote that will transcode all audio, video, and subtitle streams unless you specify for them.\n\nConsider an example pipeline that reads an input file with one audio and one video stream, transcodes the video and copies the audio into a single output file. This can be schematically represented as follows\n\nand implemented with the following commandline:\n\nNote how it uses stream specifiers and to select input streams and apply different values of the option to them; see the Stream specifiers section for more details.\n\nWhen transcoding, audio and video streams can be filtered before encoding, with either a simple or complex filtergraph.\n\nSimple filtergraphs are those that have exactly one input and output, both of the same type (audio or video). They are configured with the per-stream option (with and aliases for (video) and (audio) respectively). Note that simple filtergraphs are tied to their output stream, so e.g. if you have multiple audio streams, will create a separate filtergraph for each one.\n\nTaking the trancoding example from above, adding filtering (and omitting audio, for clarity) makes it look like this:\n\nComplex filtergraphs are those which cannot be described as simply a linear processing chain applied to one stream. This is the case, for example, when the graph has more than one input and/or output, or when output stream type is different from input. Complex filtergraphs are configured with the option. Note that this option is global, since a complex filtergraph, by its nature, cannot be unambiguously associated with a single stream or file. Each instance of creates a new complex filtergraph, and there can be any number of them.\n\nA trivial example of a complex filtergraph is the filter, which has two video inputs and one video output, containing one video overlaid on top of the other. Its audio counterpart is the filter.\n\nWhile decoders are normally associated with demuxer streams, it is also possible to create \"loopback\" decoders that decode the output from some encoder and allow it to be fed back to complex filtergraphs. This is done with the directive, which takes as a parameter the index of the output stream that should be decoded. Every such directive creates a new loopback decoder, indexed with successive integers starting at zero. These indices should then be used to refer to loopback decoders in complex filtergraph link labels, as described in the documentation for .\n\nDecoding AVOptions can be passed to loopback decoders by placing them before , analogously to input/output options.\n\nE.g. the following example:\n• (line 2) encodes it with at low quality;\n• (line 4) places decoded video side by side with the original input video;\n• (line 5) combined video is then losslessly encoded and written into .\n\nSuch a transcoding pipeline can be represented with the following diagram:\n\nprovides the option for manual control of stream selection in each output file. Users can skip and let ffmpeg perform automatic stream selection as described below. The options can be used to skip inclusion of video, audio, subtitle and data streams respectively, whether manually mapped or automatically selected, except for those streams which are outputs of complex filtergraphs.\n\nThe sub-sections that follow describe the various rules that are involved in stream selection. The examples that follow next show how these rules are applied in practice.\n\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous development and the code may have changed since the time of this writing.\n\nIn the absence of any map options for a particular output file, ffmpeg inspects the output format to check which type of streams can be included in it, viz. video, audio and/or subtitles. For each acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.\n\nIt will select that stream based upon the following criteria:\n• for video, it is the stream with the highest resolution,\n• for audio, it is the stream with the most channels,\n• for subtitles, it is the first subtitle stream found but there’s a caveat. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.\n\nIn the case where several streams of the same type rate equally, the stream with the lowest index is chosen.\n\nData or attachment streams are not automatically selected and can only be included using .\n\nWhen is used, only user-mapped streams are included in that output file, with one possible exception for filtergraph outputs described below.\n\nIf there are any complex filtergraph output streams with unlabeled pads, they will be added to the first output file. This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.\n\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n\nStream handling is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the option addressed to streams within a specific output file. In particular, codec options are applied by ffmpeg after the stream selection process and thus do not influence the latter. If no option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.\n\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.\n\nThe following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream selection methods.\n\nThey assume the following three input files.\n\nThere are three output files specified, and for the first two, no options are set, so ffmpeg will select streams for these two files automatically.\n\nis a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try to select one of each type.\n\n For video, it will select from , which has the highest resolution among all the input video streams.\n\n For audio, it will select from , since it has the greatest number of channels.\n\n For subtitles, it will select from , which is the first subtitle stream from among and .\n\naccepts only audio streams, so only from is selected.\n\nFor , since a option is set, no automatic stream selection will occur. The option will select all audio streams from the second input . No other streams will be included in this output file.\n\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will be the default ones registered by each output format, which may not match the codec of the selected input streams.\n\nFor the third output, codec option for audio streams has been set to , so no decoding-filtering-encoding operations will occur, or can occur. Packets of selected streams shall be conveyed from the input file and muxed within the output file.\n\nAlthough is a Matroska container file which accepts subtitle streams, only a video and audio stream shall be selected. The subtitle stream of is image-based and the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation for the subtitles is expected to fail and hence the stream isn’t selected. However, in , a subtitle encoder is specified in the command and so, the subtitle stream is selected, in addition to the video stream. The presence of disables audio stream selection for .\n\nA filtergraph is setup here using the option and consists of a single video filter. The filter requires exactly two video inputs, but none are specified, so the first two available video streams are used, those of and . The output pad of the filter has no label and so is sent to the first output file . Due to this, automatic selection of the video stream is skipped, which would have selected the stream in . The audio stream with most channels viz. in , is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\n\nThe 2nd output file, , only accepts text-based subtitle streams. So, even though the first subtitle stream available belongs to , it is image-based and hence skipped. The selected stream, in , is the first text-based subtitle stream.\n\nThe above command will fail, as the output pad labelled has been mapped twice. None of the output files shall be processed.\n\nThis command above will also fail as the hue filter output has a label, , and hasn’t been mapped anywhere.\n\nThe command should be modified as follows,\n\nThe video stream from is sent to the hue filter, whose output is cloned once using the split filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.\n\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those are the streams from and . The overlay output isn’t labelled, so it is sent to the first output file , regardless of the presence of the option.\n\nThe aresample filter is sent the first unused audio stream, that of . Since this filter output is also unlabelled, it too is mapped to the first output file. The presence of only suppresses automatic or manual stream selection of audio streams, not outputs sent from filtergraphs. Both these mapped streams shall be ordered before the mapped stream in .\n\nThe video, audio and subtitle streams mapped to are entirely determined by automatic stream selection.\n\nconsists of the cloned video output from the hue filter and the first audio stream from . \n\n\n\nAll the numerical options, if not specified otherwise, accept a string representing a number as input, which may be followed by one of the SI unit prefixes, for example: ’K’, ’M’, or ’G’.\n\nIf ’i’ is appended to the SI unit prefix, the complete prefix will be interpreted as a unit prefix for binary multiples, which are based on powers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit prefix multiplies the value by 8. This allows using, for example: ’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.\n\nOptions which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing the option name with \"no\". For example using \"-nofoo\" will set the boolean option with name \"foo\" to false.\n\nOptions that take arguments support a special syntax where the argument given on the command line is interpreted as a path to the file from which the actual argument value is loaded. To use this feature, add a forward slash ’/’ immediately before the option name (after the leading dash). E.g.\n\nwill load a filtergraph description from the file named .\n\nSome options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) a given option belongs to.\n\nA stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. contains the stream specifier, which matches the second audio stream. Therefore, it would select the ac3 codec for the second audio stream.\n\nA stream specifier can match several streams, so that the option is applied to all of them. E.g. the stream specifier in matches all audio streams.\n\nAn empty stream specifier matches all streams. For example, or would copy all the streams without reencoding.\n\nPossible forms of stream specifiers are:\n\nThese options are shared amongst the ff* tools.\n\nThese options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the option. They are separated into two categories:\n\nFor example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the private option of the MP3 muxer:\n\nAll codec AVOptions are per-stream, and thus a stream specifier should be attached to them:\n\nIn the above example, a multichannel audio stream is mapped twice for output. The first instance is encoded with codec ac3 and bitrate 640k. The second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.\n\nNote: the syntax cannot be used for boolean AVOptions, use / .\n\nNote: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.\n\nForce input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. Do not overwrite output files, and exit immediately if a specified output file already exists. Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. Allow forcing a decoder of a different media type than the one detected or designated by the demuxer. Useful for decoding media data muxed as data streams. Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. is the name of a decoder/encoder or a special value (output only) to indicate that the stream is not to be re-encoded. encodes all video streams with libx264 and copies all audio streams. For each stream, the last matching option is applied, so will copy all the streams except the second video, which will be encoded with libx264, and the 138th audio, which will be encoded with libvorbis. When used as an input option (before ), limit the of data read from the input file. When used as an output option (before an output url), stop writing the output after its duration reaches . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Stop writing the output or reading the input at . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Set the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is exceeded. The size of the output file is slightly more than the requested file size. When used as an input option (before ), seeks in this input file to . Note that in most formats it is not possible to seek exactly, so will seek to the closest seek point before . When transcoding and is enabled (the default), this extra segment between the seek point and will be decoded and discarded. When doing stream copy or when is used, it will be preserved. When used as an output option (before an output url), decodes but discards input until the timestamps reach . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. Like the option but relative to the \"end of file\". That is negative values are earlier in the file, 0 is at EOF. This will take the difference between the start times of the target and reference inputs and offset the timestamps of the target file by that difference. The source timestamps of the two inputs should derive from the same clock source for expected results. If is set then must also be set. If either of the inputs has no starting timestamp then no sync adjustment is made. Acceptable values are those that refer to a valid ffmpeg input index. If the sync reference is the target index itself or , then no adjustment is made to target timestamps. A sync reference may not itself be synced to any other input. must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. The offset is added to the timestamps of the input files. Specifying a positive offset means that the corresponding streams are delayed by the time duration specified in . Set the recording timestamp in the container. must be a date specification, see (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual. An optional may be given to set metadata on streams, chapters or programs. See documentation for details. This option overrides metadata set with . It is also possible to delete metadata by using an empty value. For example, for setting the title in the output file: To set the language of the first audio stream: Default value: by default, all disposition flags are copied from the input stream, unless the output stream this option applies to is fed by a complex filtergraph - in that case no disposition flags are set by default. is a sequence of disposition flags separated by ’+’ or ’-’. A ’+’ prefix adds the given disposition, ’-’ removes it. If the first flag is also prefixed with ’+’ or ’-’, the resulting disposition is the default value updated by . If the first flag is not prefixed, the resulting disposition is . It is also possible to clear the disposition by setting it to 0. If no options were specified for an output file, ffmpeg will automatically set the ’default’ disposition flag on the first stream of each type, when there are multiple streams of this type in the output file and no stream of that type is already marked as default. The option lists the known disposition flags. For example, to make the second audio stream the default stream: To make the second subtitle stream the default stream and remove the default disposition from the first subtitle stream: To add the ’original’ and remove the ’comment’ disposition flag from the first audio stream without removing its other disposition flags: To remove the ’original’ and add the ’comment’ disposition flag to the first audio stream without removing its other disposition flags: To set only the ’original’ and ’comment’ disposition flags on the first audio stream (and remove its other disposition flags): To remove all disposition flags from the first audio stream: Not all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG or PNG. Creates a program with the specified , and adds the specified (s) to it. Creates a stream group of the specified and , or by ping an input group, adding the specified (s) and/or previously defined (s) to it. can be one of the following: Groups s that belong to the same IAMF Audio Element For this group , the following options are available The Audio Element type. The following values are supported: Demixing information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to Recon gain information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to A layer defining a Channel Layout in the Audio Element. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options The following flags are available: Wether to signal if recon_gain is present as metadata in parameter blocks within frames Which channels output_gain applies to. The following flags are available: The ambisonics mode. This has no effect if audio_element_type is set to channel. The following values are supported: Each ambisonics channel is coded as an individual mono stream in the group Groups s that belong to all IAMF Audio Element the same IAMF Mix Presentation references For this group , the following options are available A sub-mix within the Mix Presentation. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options An identifier parameters blocks in frames may refer to, for post-processing the mixed audio signal to generate the audio signal for playback The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame References an Audio Element used in this Mix Presentation to generate the final output audio signal for playback. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The for an Audio Element which this sub-mix refers to An identifier parameters blocks in frames may refer to, for applying any processing to the referenced and rendered Audio Element before being summed with other processed Audio Elements The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame A key=value string describing the sub-mix element where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the one in the mix’s Indicates whether the input channel-based Audio Element is rendered to stereo loudspeakers or spatialized with a binaural renderer when played back on headphones. This has no effect if the referenced Audio Element’s is set to channel. The following values are supported: Specifies the layouts for this sub-mix on which the loudness information was measured. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The layout follows the loudspeaker sound system convention of ITU-2051-3. Channel layout matching one of Sound Systems A to J of ITU-2051-3, plus 7.1.2 and 3.1.2 This has no effect if is set to binaural. The program integrated loudness information, as defined in ITU-1770-4. The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4. The true peak of the audio signal, as defined in ITU-1770-4. The Dialogue loudness information, as defined in ITU-1770-4. The Album loudness information, as defined in ITU-1770-4. A key=value string string describing the mix where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the ones in all sub-mix element’s s E.g. to create an scalable 5.1 IAMF file from several WAV input files To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with four streams into an mp4 output Specify target file type ( , , , , ). may be prefixed with , or to use the corresponding standard. All the format options (bitrate, codecs, buffer sizes) are then set automatically. You can just type: Nevertheless you can specify additional options as long as you know they do not conflict with the standard, as in: The parameters set for each target are as follows. The target is identical to the target except that the pixel format set is for all three standards. Any user-set value for a parameter above will override the target preset value. In that case, the output may not comply with the target standard. As an input option, blocks all data streams of a file from being filtered or being automatically selected or mapped for any output. See option to disable streams individually. As an output option, disables data recording i.e. automatic selection or mapping of any data stream. For full manual control see the option. Set the number of data frames to output. This is an obsolete alias for , which you should use instead. Stop writing to the stream after frames. Use fixed quality scale (VBR). The meaning of / is codec-dependent. If is used without a then it applies only to the video stream, this is to maintain compatibility with previous behavior and as specifying the same codec specific value to 2 different codecs that is audio and video generally is not what is intended when no stream_specifier is used. Create the filtergraph specified by and use it to filter the stream. is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label , and the output to the label . See the ffmpeg-filters manual for more information about the filtergraph syntax. See the -filter_complex option if you want to create filtergraphs with multiple inputs and/or outputs. This boolean option determines if the filtergraph(s) to which this stream is fed gets reinitialized when input frame parameters change mid-stream. This option is enabled by default as most video and all audio filters cannot handle deviation in input frame properties. Upon reinitialization, existing filter state is lost, like e.g. the frame count reference available in some filters. Any frames buffered at time of reinitialization are lost. The properties where a change triggers reinitialization are, for video, frame resolution or pixel format; for audio, sample format, sample rate, channel count or channel layout. Defines how many threads are used to process a filter pipeline. Each pipeline will produce a thread pool with this many threads available for parallel processing. The default is the number of available CPUs. Specify the preset for matching stream(s). Log encoding progress/statistics as \"info\"-level log (see ). It is on by default, to explicitly disable it you need to specify . Set period at which encoding progress/statistics are updated. Default is 0.5 seconds. Progress information is written periodically and at the end of the encoding process. It is made of \" = \" lines. consists of only alphanumeric characters. The last key of a sequence of progress information is always \"progress\" with the value \"continue\" or \"end\". The update period is set using . For example, log progress information to stdout: Enable interaction on standard input. On by default unless standard input is used as an input. To explicitly disable interaction you need to specify . Disabling interaction on standard input is useful, for example, if ffmpeg is in the background process group. Roughly the same result can be achieved with but it requires a shell. Print timestamp/latency information. It is off by default. This option is mostly useful for testing and debugging purposes, and the output format may change from one version to another, so it should not be employed by portable scripts. See also the option . Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option will add a new stream to the file. It is then possible to use per-stream options on this stream in the usual way. Attachment streams created with this option will be created after all the other streams (i.e. those created with or automatic mappings). Note that for Matroska you also have to set the mimetype metadata tag: (assuming that the attachment stream will be third in the output file). Extract the matching attachment stream into a file named . If is empty, then the value of the metadata tag will be used. E.g. to extract the first attachment to a file named ’out.ttf’: To extract all attachments to files determined by the tag: Technical note – attachments are implemented as codec extradata, so this option can actually be used to extract extradata from any stream, not just attachments.\n\nSet pixel format. Use to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If is prefixed by a , ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If is a single , ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled. Set default flags for the libswscale library. These flags are used by automatically inserted filters and those within simple filtergraphs, if not overridden within the filtergraph definition. See the (ffmpeg-scaler)ffmpeg-scaler manual for a list of scaler options. Rate control override for specific intervals, formatted as \"int,int,int\" list separated with slashes. Two first values are the beginning and end frame numbers, last one is quantizer to use if positive, or quality factor if negative. Dump video coding statistics to . See the vstats file format section for the format description. Dump video coding statistics to . See the vstats file format section for the format description. Specify which version of the vstats format to use. Default is . See the vstats file format section for the format description. Force video tag/fourcc. This is an alias for . can take arguments of the following form: If the argument consists of timestamps, ffmpeg will round the specified times to the nearest output timestamp as per the encoder time base and force a keyframe at the first frame having timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too coarse, then the keyframes may be forced on frames with timestamps lower than the specified time. The default encoder time base is the inverse of the output framerate but may be set otherwise via . If one of the times is \" [ ]\", it is expanded into the time of the beginning of all chapters in the file, shifted by , expressed as a time in seconds. This option can be useful to ensure that a seek point is present at a chapter mark or any other designated place in the output file. For example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning of every chapter: If the argument is prefixed with , the string is interpreted like an expression and is evaluated for each frame. A key frame is forced in case the evaluation is non-zero. The expression in can contain the following constants: the number of current processed frame, starting from 0 the number of the previous forced frame, it is when no keyframe was forced yet the time of the previous forced frame, it is when no keyframe was forced yet the time of the current processed frame For example to force a key frame every 5 seconds, you can specify: To force a key frame 5 seconds after the time of the last forced one, starting from second 13: If the argument is , ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source. In cases where this particular source frame has to be dropped, enforce the next available frame to become a key frame instead. Note that forcing too many keyframes is very harmful for the lookahead algorithms of certain encoders: using fixed-GOP options or similar would be more efficient. Automatically crop the video after decoding according to file metadata. Default is all. Apply both codec and container level croppping. This is the default mode. When doing stream copy, copy also non-key frames found at the beginning. Initialise a new hardware device of type called , using the given device parameters. If no name is specified it will receive a default name of the form \" %d\". The meaning of and the following arguments depends on the device type: is the number of the CUDA device. The following options are recognized: If set to 1, uses the primary device context instead of creating a new one. Choose the second device on the system. Choose the first device and use the primary device context. is the number of the Direct3D 9 display adapter. is the number of the Direct3D 11 display adapter. If not specified, it will attempt to use the default Direct3D 11 display adapter or the first Direct3D 11 display adapter whose hardware VendorId is specified by ‘ ’. Create a d3d11va device on the Direct3D 11 display adapter specified by index 1. Create a d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is 0x8086. is either an X11 display name, a DRM render node or a DirectX adapter index. If not specified, it will attempt to open the default X11 display ($DISPLAY) and then the first DRM render node (/dev/dri/renderD128), or the default DirectX adapter on Windows. The following options are recognized: When is not specified, use this option to specify the name of the kernel driver associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled. When and are not specified, use this option to specify the vendor id associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled and kernel_driver is not specified. Create a vaapi device on a device associated with kernel driver ‘ ’. Create a vaapi device on a device associated with vendor id ‘ ’. is an X11 display name. If not specified, it will attempt to open the default X11 display ($DISPLAY). selects a value in ‘ ’. Allowed values are: If not specified, ‘ ’ is used. (Note that it may be easier to achieve the desired result for QSV by creating the platform-appropriate subdevice (‘ ’ or ‘ ’ or ‘ ’) and then deriving a QSV device from that.) The following options are recognized: Specify a DRM render node on Linux or DirectX adapter on Windows. Choose platform-appropriate subdevice type. On Windows ‘ ’ is used as default subdevice type when is specified at configuration time, ‘ ’ is used as default subdevice type when is specified at configuration time. On Linux user can use ‘ ’ only as subdevice type. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Create a QSV device with ‘ ’ on DirectX adapter 1 with subdevice type ‘ ’. Create a VAAPI device called ‘ ’ on , then derive a QSV device called ‘ ’ from device ‘ ’. selects the platform and device as platform_index.device_index. The set of devices can also be filtered using the key-value pairs to find only devices matching particular platform or device strings. The strings usable as filters are: The indices and filters must together uniquely select a device. Choose the second device on the first platform. Choose the device with a name containing the string Foo9000. Choose the GPU device on the second platform supporting the cl_khr_fp16 extension. If is an integer, it selects the device by its index in a system-dependent list of devices. If is any other string, it selects the first device with a name containing that string as a substring. The following options are recognized: If set to 1, enables the validation layer, if installed. If set to 1, images allocated by the hwcontext will be linear and locally mappable. A plus separated list of additional instance extensions to enable. A plus separated list of additional device extensions to enable. Choose the second device on the system. Choose the first device with a name containing the string RADV. Choose the first device and enable the Wayland and XCB instance extensions. Initialise a new hardware device of type called , deriving it from the existing device with the name . List all hardware device types supported in this build of ffmpeg. Pass the hardware device called to all filters in any filter graph. This can be used to set the device to upload to with the filter, or the device to map to with the filter. Other filters may also make use of this parameter when they require a hardware device. Note that this is typically only required when the input is not already in hardware frames - when it is, filters will derive the device they require from the context of the frames they receive as input. This is a global setting, so all filters will receive the same device. Use hardware acceleration to decode the matching stream(s). The allowed values of are: Do not use any hardware acceleration (the default). Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration. Use the Intel QuickSync Video acceleration for video transcoding. Unlike most other values, this option does not enable accelerated decoding (that is used automatically whenever a qsv decoder is selected), but accelerated transcoding, without copying the frames into the system memory. For it to work, both the decoder and the encoder must support QSV acceleration and no filters must be used. This option has no effect if the selected hwaccel is not available or not supported by the chosen decoder. Note that most acceleration methods are intended for playback and will not be faster than software decoding on modern CPUs. Additionally, will usually need to copy the decoded frames from the GPU memory into the system memory, resulting in further performance loss. This option is thus mainly useful for testing. Select a device to use for hardware acceleration. This option only makes sense when the option is also specified. It can either refer to an existing device created with by name, or it can create a new device as if ‘ ’ : were called immediately before. List all hardware acceleration components enabled in this build of ffmpeg. Actual runtime availability depends on the hardware and its suitable driver being installed. Set a specific output video stream as the heartbeat stream according to which to split and push through currently in-progress subtitle upon receipt of a random access packet. This lowers the latency of subtitles for which the end packet or the following subtitle has not yet been received. As a drawback, this will most likely lead to duplication of subtitle events in order to cover the full duration, so when dealing with use cases where latency of when the subtitle event is passed on to output is not relevant this option should not be utilized. Requires to be set for the relevant input subtitle stream for this to have any effect, as well as for the input subtitle stream having to be directly mapped to the same output in which the heartbeat stream resides.\n\nCreate one or more streams in the output file. This option has two forms for specifying the data source(s): the first selects one or more streams from some input file (specified with ), the second takes an output from some complex filtergraph (specified with ). In the first form, an output stream is created for every stream from the input file with the index . If is given, only those streams that match the specifier are used (see the Stream specifiers section for the syntax). A character before the stream identifier creates a \"negative\" mapping. It disables matching streams from already created mappings. An optional may be given after the stream specifier, which for multiview video specifies the view to be used. The view specifier may have one of the following formats: select a view by its ID; may be set to ’all’ to use all the views interleaved into one stream; select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc. select a view by its display position; may be or The default for transcoding is to only use the base view, i.e. the equivalent of . For streamcopy, view specifiers are not supported and all views are always copied. A trailing after the stream index will allow the map to be optional: if the map matches no streams the map will be ignored instead of failing. Note the map will still fail if an invalid input file index is used; such as if the map refers to a non-existent input. An alternative form will map outputs from complex filter graphs (see the option) to the output file. must correspond to a defined output link label in the graph. This option may be specified multiple times, each adding more streams to the output file. Any given input stream may also be mapped any number of times as a source for different output streams, e.g. in order to use different encoding options and/or filters. The streams are created in the output in the same order in which the options are given on the commandline. Using this option disables the default mappings for this output file. To map ALL streams from the first input file to output If you have two audio streams in the first input file, these streams are identified by and . You can use to select which streams to place in an output file. For example: will map the second input stream in to the (single) output stream in . To select the stream with index 2 from input file (specified by the identifier ), and stream with index 6 from input (specified by the identifier ), and copy them to the output file : To select all video and the third audio stream from an input file: To map all the streams except the second audio, use negative mappings To map the video and audio streams from the first input, and using the trailing , ignore the audio mapping if no audio streams exist in the first input: Ignore input streams with unknown type instead of failing if copying such streams is attempted. Allow input streams with unknown type to be copied instead of failing if copying such streams is attempted. Set metadata information of the next output file from . Note that those are file indices (zero-based), not filenames. Optional parameters specify, which metadata to copy. A metadata specifier can have the following forms: global metadata, i.e. metadata that applies to the whole file per-stream metadata. is a stream specifier as described in the Stream specifiers chapter. In an input metadata specifier, the first matching stream is copied from. In an output metadata specifier, all matching streams are copied to. If metadata specifier is omitted, it defaults to global. By default, global metadata is copied from the first input file, per-stream and per-chapter metadata is copied along with streams/chapters. These default mappings are disabled by creating any mapping of the relevant type. A negative file index can be used to create a dummy mapping that just disables automatic copying. For example to copy metadata from the first stream of the input file to global metadata of the output file: To do the reverse, i.e. copy global metadata to all audio streams: Note that simple would work as well in this example, since global metadata is assumed by default. Copy chapters from input file with index to the next output file. If no chapter mapping is specified, then chapters are copied from the first input file with at least one chapter. Use a negative file index to disable any chapter copying. Show benchmarking information at the end of an encode. Shows real, system and user time used and maximum memory consumption. Maximum memory consumption is not supported on all systems, it will usually display as 0 if not supported. Show benchmarking information during the encode. Shows real, system and user time used in various steps (audio/video encode/decode). Exit after ffmpeg has been running for seconds in CPU user time. When dumping packets, also dump the payload. Its value is a floating-point positive number which represents the maximum duration of media, in seconds, that should be ingested in one second of wallclock time. Default value is zero and represents no imposed limitation on speed of ingestion. Value represents real-time speed and is equivalent to . Mainly used to simulate a capture device or live input stream (e.g. when reading from a file). Should not be used with a low value when input is an actual capture device or live stream as it may cause packet loss. It is useful for when flow speed of output packets is important, such as live streaming. Read input at native frame rate. This is equivalent to setting . Set an initial read burst time, in seconds, after which will be enforced. If either the input or output is blocked leading to actual read speed falling behind the specified readrate, then this rate takes effect till the input catches up with the specified readrate. Must not be lower than the primary readrate. Set video sync method / framerate mode. vsync is applied to all output video streams but can be overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future. For compatibility reasons some of the values for vsync can be specified as numbers (shown in parentheses in the following table). Each frame is passed with its timestamp from the demuxer to the muxer. Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. Chooses between cfr and vfr depending on muxer capabilities. This is the default method. Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option is enabled. With -map you can select from which stream the timestamps should be taken. You can leave either video or audio unchanged and sync the remaining stream(s) to the unchanged one. Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In frame rate units, so 1.0 is one frame. The default is -1.1. One possible usecase is to avoid framedrops in case of noisy timestamps or to increase frame drop precision in case of exact timestamps. Pad the output audio stream(s). This is the same as applying . Argument is a string of filter parameters composed the same as with the filter. must be set for this output for the option to take effect. Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value. Note that, depending on the option or on specific muxer processing (e.g. in case the format option is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected. When used with , shift input timestamps so they start at zero. This means that using e.g. will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at. Specify how to set the encoder timebase when stream copying. is an integer numeric value, and can assume one of the following values: The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate. The time base is copied to the output encoder from the corresponding input decoder. Try to make the choice automatically, in order to generate a sane output. Set the encoder timebase. can assume one of the following values: Assign a default value according to the media type. For video - use 1/framerate, for audio - use 1/samplerate. Use the timebase from the demuxer. Use the timebase from the filtergraph. Use the provided number as the timebase. This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number (e.g. 0.04166, 2.0833e-5) Note that this option may require buffering frames, which introduces extra latency. The maximum amount of this latency may be controlled with the option. The option may require buffering potentially large amounts of data when at least one of the streams is \"sparse\" (i.e. has large gaps between frames – this is typically the case for subtitles). This option controls the maximum duration of buffered frames in seconds. Larger values may allow the option to produce more accurate results, but increase memory use and latency. The default value is 10 seconds. The timestamp discontinuity correction enabled by this option is only applied to input formats accepting timestamp discontinuity (for which the flag is enabled), e.g. MPEG-TS and HLS, and is automatically disabled when employing the option (unless wrapping is detected). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will remove the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta value. The timestamp correction enabled by this option is only applied to input formats not accepting timestamp discontinuity (for which the flag is not enabled). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will drop the PTS/DTS timestamp value. The default value is (30 hours), which is arbitrarily picked and quite conservative. Assign a new stream-id value to an output stream. This option should be specified prior to the output filename to which it applies. For the situation where multiple output files exist, a streamid may be reassigned to a different value. For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file: Apply bitstream filters to matching streams. The filters are applied to each packet as it is received from the demuxer (when used as an input option) or before it is sent to the muxer (when used as an output option). is a comma-separated list of bitstream filter specifications, each of the form Any of the ’,=:’ characters that are to be a part of an option value need to be escaped with a backslash. Use the option to get the list of bitstream filters. applies the bitstream filter (which converts MP4-encapsulated H.264 stream to Annex B) to the input video stream. applies the bitstream filter (which extracts text from MOV subtitles) to the output subtitle stream. Note, however, that since both examples use , it matters little whether the filters are applied on input or output - that would change if transcoding was happening. Specify Timecode for writing. is ’:’ for non drop timecode and ’;’ (or ’.’) for drop. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. For simple graphs – those with one input and one output of the same type – see the options. is a description of the filtergraph, as described in the “Filtergraph syntax” section of the ffmpeg-filters manual. This option may be specified multiple times - each use creates a new complex filtergraph. Inputs to a complex filtergraph may come from different source types, distinguished by the format of the corresponding link label:\n• To connect an input stream, use (i.e. the same syntax as ). If matches multiple streams, the first one will be used. For multiview video, the stream specifier may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect a loopback decoder use [dec: ], where is the index of the loopback decoder to be connected to given input. For multiview video, the decoder index may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect an output from another complex filtergraph, use its link label. E.g the following example:\n• (line 2) uses a complex filtergraph with one input and two outputs to scale the video to 1920x1080 and duplicate the result to both outputs;\n• (line 3) encodes one scaled output with and writes the result to ;\n• (line 5) places the output of the loopback decoder (i.e. the -encoded video) side by side with the scaled original input;\n• (line 6) combined video is then losslessly encoded and written into . Note that the two filtergraphs cannot be combined into one, because then there would be a cycle in the transcoding pipeline (filtergraph output goes to encoding, from there to decoding, then back to the same graph), and such cycles are not allowed. An unlabeled input will be connected to the first unused input stream of the matching type. Output link labels are referred to with . Unlabeled outputs are added to the first output file. Note that with this option it is possible to use only lavfi sources without normal input files. For example, to overlay an image over video Here refers to the first video stream in the first input file, which is linked to the first (main) input of the overlay filter. Similarly the first video stream in the second input is linked to the second (overlay) input of overlay. Assuming there is only one video stream in each input file, we can omit input labels, so the above is equivalent to Furthermore we can omit the output label and the single output from the filter graph will be added to the output file automatically, so we can simply write As a special exception, you can use a bitmap subtitle stream as input: it will be converted into a video with the same size as the largest video in the file, or 720x576 if no video is present. Note that this is an experimental and temporary solution. It will be removed once libavfilter has proper support for subtitles. For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the subtitles by 1 second: To generate 5 seconds of pure red video using lavfi source: Defines how many threads are used to process a filter_complex graph. Similar to filter_threads but used for graphs only. The default is the number of available CPUs. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent to . This option enables or disables accurate seeking in input files with the option. It is enabled by default, so seeking is accurate when transcoding. Use to disable it, which may be useful e.g. when copying some streams and transcoding the others. This option enables or disables seeking by timestamp in input files with the option. It is disabled by default. If enabled, the argument to the option is considered an actual timestamp, and is not offset by the start time of the file. This matters only for files which do not start from timestamp 0, such as transport streams. For input, this option sets the maximum number of queued packets when reading from the file or device. With low latency / high rate live streams, packets may be discarded if they are not read in a timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as soon as they arrive. By default ffmpeg only does this if multiple inputs are specified. For output, this option specified the maximum number of packets that may be queued to each muxing thread. Print sdp information for an output stream to . This allows dumping sdp information when at least one output isn’t an rtp stream. (Requires at least one of the output formats to be rtp). Allows discarding specific streams or frames from streams. Any input stream can be fully discarded, using value whereas selective discarding of frames from a stream occurs at the demuxer and is not supported by all demuxers. Stop and abort on various conditions. The following flags are available: No packets were passed to the muxer, the output is empty. No packets were passed to the muxer in some of the output streams. Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return exit code 69. Crossing this threshold does not terminate processing. Range is a floating-point number between 0 to 1. Default is 2/3. When transcoding audio and/or video streams, ffmpeg will not begin writing into the output until it has one packet for each such stream. While waiting for that to happen, packets for other streams are buffered. This option sets the size of this buffer, in packets, for the matching output stream. The default value of this option should be high enough for most uses, so only touch this option if you are sure that you need it. This is a minimum threshold until which the muxing queue size is not taken into account. Defaults to 50 megabytes per stream, and is based on the overall size of packets passed to the muxer. Enable automatically inserting format conversion filters in all filter graphs, including those defined by , , and . If filter format negotiation requires a conversion, the initialization of the filters will fail. Conversions can still be performed by inserting the relevant conversion filter (scale, aresample) in the graph. On by default, to explicitly disable it you need to specify . Declare the number of bits per raw sample in the given output stream to be . Note that this option sets the information provided to the encoder/muxer, it does not change the stream to conform to this value. Setting values that do not match the stream properties may result in encoding failures or invalid output files. Write per-frame encoding information about the matching streams into the file given by . writes information about raw video or audio frames right before they are sent for encoding, while writes information about encoded packets as they are received from the encoder. writes information about packets just as they are about to be sent to the muxer. Every frame or packet produces one line in the specified file. The format of this line is controlled by / / . When stats for multiple streams are written into a single file, the lines corresponding to different streams will be interleaved. The precise order of this interleaving is not specified and not guaranteed to remain stable between different invocations of the program, even with the same options. Specify the format for the lines written with / / . is a string that may contain directives of the form . is backslash-escaped — use \\{, \\}, and \\\\ to write a literal {, }, or \\, respectively, into the output. The directives given with may be one of the following: Index of the output stream in the file. Frame number. Pre-encoding: number of frames sent to the encoder so far. Post-encoding: number of packets received from the encoder so far. Muxing: number of packets submitted to the muxer for this stream so far. Input frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this output frame or packet. -1 if unavailable. Timebase in which this frame/packet’s timestamps are expressed, as a rational number . Note that encoder and muxer may use different timebases. Timebase for , as a rational number . Available when is available, otherwise. Presentation timestamp of the frame or packet, as an integer. Should be multiplied by the timebase to compute presentation time. Presentation timestamp of the input frame (see ), as an integer. Should be multiplied by to compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available. Presentation time of the frame or packet, as a decimal number. Equal to multiplied by . Presentation time of the input frame (see ), as a decimal number. Equal to multiplied by . Printed as inf when not available. Decoding timestamp of the packet, as an integer. Should be multiplied by the timebase to compute presentation time. Decoding time of the frame or packet, as a decimal number. Equal to multiplied by . Number of audio samples sent to the encoder so far. Number of audio samples in the frame. Size of the encoded packet in bytes. Current bitrate in bits per second. Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at this point. Character ’K’ if the packet contains a keyframe, character ’N’ otherwise. Directives tagged with packet may only be used with and . Directives tagged with frame may only be used with . Directives tagged with audio may only be used with audio streams. In the future, new items may be added to the end of the default formatting strings. Users who depend on the format staying exactly the same, should prescribe it manually. Note that stats for different streams written into the same file may have different formats.\n\nA preset file contains a sequence of = pairs, one for each line, specifying a sequence of options which would be awkward to specify on the command line. Lines starting with the hash (’#’) character are ignored and are used to provide comments. Check the directory in the FFmpeg source tree for examples.\n\nThere are two types of preset files: ffpreset and avpreset files.\n\nffpreset files are specified with the , , , and options. The option takes the filename of the preset instead of a preset name as input and can be used for any kind of codec. For the , , and options, the options specified in a preset file are applied to the currently selected codec of the same type as the preset option.\n\nThe argument passed to the , , and preset options identifies the preset file to use according to the following rules:\n\nFirst ffmpeg searches for a file named .ffpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ) or in a folder along the executable on win32, in that order. For example, if the argument is , it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named - .ffpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\navpreset files are specified with the option. They work similar to ffpreset files, but they only allow encoder- specific options. Therefore, an = pair specifying an encoder cannot be used.\n\nWhen the option is specified, ffmpeg will look for files with the suffix .avpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ), in that order.\n\nFirst ffmpeg searches for a file named - .avpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named .avpreset in the same directories.\n\nThe and options enable generation of a file containing statistics about the generated video outputs.\n\nThe option controls the format version of the generated file.\n\nWith version the format is:\n\nWith version the format is:\n\nThe value corresponding to each key is described below:\n\nSee also the -stats_enc options for an alternative way to show encoding statistics.\n\nIf you specify the input format and device then ffmpeg can grab video and audio directly.\n\nOr with an ALSA audio source (mono input, card id 1) instead of OSS:\n\nNote that you must activate the right video source and channel before launching ffmpeg with any TV viewer such as xawtv by Gerd Knorr. You also have to set the audio recording levels correctly with a standard mixer.\n\nGrab the X11 display with ffmpeg via\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable. 10 is the x-offset and 20 the y-offset for the grabbing.\n\nAny supported file format and protocol can serve as input to ffmpeg:\n• You can use YUV files as input: It will use the files: The Y files use twice the resolution of the U and V files. They are raw files, without header. They can be generated by all decent video decoders. You must specify the size of the image with the option if ffmpeg cannot guess it.\n• You can input from a raw YUV420P file: test.yuv is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by the U and V planes at half vertical and horizontal resolution.\n• You can output to a raw YUV420P file:\n• You can set several input files and output files: Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.\n• You can also do audio and video conversions at the same time:\n• You can encode to several formats at the same time and define a mapping from input stream to output streams: Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map file:index’ specifies which input stream is used for each output stream, in the order of the definition of output streams.\n• You can transcode decrypted VOBs: This is a typical DVD ripping example; the input is a VOB file, the output an AVI file with MPEG-4 video and MP3 audio. Note that in this command we use B-frames so the MPEG-4 stream is DivX5 compatible, and GOP size is 300 which means one intra frame every 10 seconds for 29.97fps input video. Furthermore, the audio stream is MP3-encoded so you need to enable LAME support by passing to configure. The mapping is particularly useful for DVD transcoding to get the desired audio language. NOTE: To see the supported input formats, use .\n• You can extract images from a video, or create a video from many images: This will extract one video frame per second from the video and will output them in files named , , etc. Images will be rescaled to fit the new WxH values. If you want to extract just a limited number of frames, you can use the above command in combination with the or option, or in combination with -ss to start extracting from a certain point in time. For creating a video from many images: The syntax specifies to use a decimal number composed of three digits padded with zeroes to express the sequence number. It is the same syntax supported by the C printf function, but only formats accepting a normal integer are suitable. When importing an image sequence, -i also supports expanding shell-like wildcard patterns (globbing) internally, by selecting the image2-specific option. For example, for creating a video from filenames matching the glob pattern :\n• You can put many streams of the same type in the output: The resulting output file will contain the first four streams from the input files in reverse order.\n• The four options lmin, lmax, mblmin and mblmax use ’lambda’ units, but you may use the QP2LAMBDA constant to easily convert from ’q’ units:\n\nFor details about the authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg), e.g. by typing the command in the FFmpeg source directory, or browsing the online repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file in the source code tree.\n\nThis document was generated on March 22, 2025 using makeinfo."
    },
    {
        "link": "https://github.com/bytedeco/javacpp-presets/blob/master/ffmpeg/src/gen/java/org/bytedeco/ffmpeg/global/avcodec.java",
        "document": ""
    }
]