[
    {
        "link": "https://filemagic.readthedocs.io/en/latest/guide.html",
        "document": ""
    },
    {
        "link": "https://pypi.org/project/python-magic",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://blog.trailofbits.com/2022/07/01/libmagic-the-blathering",
        "document": "A couple of years ago we released PolyFile: a utility to identify and map the semantic structure of files, including polyglots, chimeras, and schizophrenic files. It’s a bit like , , and Kaitai Struct all rolled into one. PolyFile initially used the TRiD definition database for file identification. However, this database was both too slow and prone to misclassification, so we decided to switch to libmagic, the ubiquitous library behind the command.\n\nWhat follows is a compendium of the oddities that we uncovered while developing our pure Python cleanroom implementation of libmagic.\n\nThe libmagic library is older than over half of the human population of Earth, yet it is still in active development and is in the 99.9th percentile of most frequently installed Ubuntu packages. The library’s ongoing development is not strictly limited to bug fixes and support for matching new file formats; the library frequently receives breaking changes that add new core features to its matching engine.\n\nlibmagic has a custom domain specific language (DSL) for specifying file format patterns. Run to read its documentation. The program compiles its DSL database of file format patterns into a single definition file that is typically installed to . libmagic is written in C and includes several manually written parsers to identify various file types that would otherwise be difficult to represent in its DSL (for example, JSON and CSV). Unsurprisingly, these parsers have led to a number of memory safety bugs and numerous CVEs.\n\nPolyFile is written in Python. While libmagic does have both official and independent Python wrappers, we chose to create a cleanroom implementation. Aside from the native library’s security issues, there are several additional reasons why we decided to create something new:\n• PolyFile is already written in pure Python, and we did not want to introduce a native dependency if we could avoid it.\n• PolyFile is intended to detect polyglots and other funky file formats that libmagic would otherwise miss, so we would have had to extend libmagic anyway.\n• PolyFile preserves lexical information like input byte offsets throughout its parsing, in order to map semantics back to the original file locations. There was no straightforward way to do this with libmagic.\n\nThe idea of reimplementing libmagic in a language with more memory safety than C is not novel. An effort to do so in Ruby, called Arcana, occurred concurrently with PolyFile’s implementation, but it is still incomplete. PolyFile, on the other hand, correctly parses libmagic’s entire pattern database and passes all but two of libmagic’s unit tests, and correctly identifies at least as many MIME types as libmagic on Ange Albertini’s 900+ file Corkami corpus.\n\nIn order to appreciate the eldritch horrors we unearthed when reimplementing libmagic, we need to offer a brief overview of its esoteric DSL. Each DSL file contains a series of tests—one per line—that match the file’s subregions. These tests can be as simple as matching against magic byte sequences, or as complex as seemingly Turing-complete expressions. (Proving Turing-completeness is left as an exercise to the reader.)\n\nThe command executes the DSL tests to classify the input file. The tests are organized in the DSL as a tree-like hierarchy. First, each top-level test is executed. If a test passes, then its children are each tested, in order. Tests at any level can optionally print out a message or associate the input file with a MIME type classification.\n\nEach line in the DSL file is a test, which includes an offset, type, expected value, and message, delimited by whitespace. For example:\n\nThis line will do the following:\n• Start at byte offset 10 in the input file\n• If those bytes equal 0x100, then print “this is a test”\n\nNow let’s add a child test, and associate it with a MIME type:\n\nThe “>” before the “20” offset in the second test means that it is a child of the previously defined test at the higher level.\n\nThis new version will do the following:\n• If, and only if, the first test matches, then attempt the second test.\n• If the byte at file offset 20 equals 0xFF, then print out “test two” and also associate the entire file with the MIME type\n\nNote that the message for a parent test will be printed even if its children do not match. A child test will only be executed if its parent is matched. Children can be arbitrarily nested with additional “>” prefixes:\n\nIf a test passes, then all of its children will be tested.\n\nSo far, all of the offsets in these examples have been absolute, but the libmagic DSL also allows relative offsets:\n\nas well as indirect offsets:\n\nThe here means: read a little-endian short at absolute byte offset 20 in the file and use that value as the offset to read the signed little-endian long ( ) that will be tested. Indirect offsets can also include arithmetic modifiers:\n\nRelative and indirect offsets can also be combined:\n\nDespite having existed for decades, the libmagic pattern DSL is still in active development.\n\nIn developing our independent implementation of libmagic—to the point where it can parse the file command’s entire collection of magic definitions and pass all of the official unit tests— we discovered many undocumented DSL features and apparent upstream bugs.\n\nFor example, the DSL patterns for matching MSDOS files contain a poorly documented use of parenthesis within indirect offsets:\n\nThe semantics are ambiguous; this could mean, “Read the offset from the little-endian long 0x10 bytes past the parent match decremented by four,” or it could mean, “Read the offset from the little-endian long 0x10 bytes past the parent match and add the value read from the last four bytes in the file.” It turns out that it is the latter.\n\nThe elf pattern uses an undocumented ${x?true:false} ternary operator syntax. This syntax can also occur inside a !:mime directive!\n\nSome specifications, like the CAD file format, use the undocumented regex /b modifier. It is unclear from the libmagic source code whether this modifier is simply ignored or if it has a purpose. PolyFile currently ignores it and allows regexes to be applied to both ASCII and binary data.\n\nAccording to the documentation, the search keyword—which performs a literal string search from a given offset—is supposed to be followed by an integer search range. But this search range is apparently optional.\n\nSome specifications, like BER, use “search/b64”, which is undocumented syntax. PolyFile treats this as equivalent to the compliant .\n\nThe regex keyword has an undocumented T modifier. What is a T modifier? Judging from libmagic’s code, it appears to trim whitespace from the resulting match.\n\nThe libmagic DSL has a type specifically for matching globally unique identifiers (GUIDs) that follows a standardized structure as defined by RFC 4122. One of the definitions in the DSL for Microsoft’s Advanced Systems Format (ASF) multimedia container does not conform to RFC 4122—it is two bytes short. Presumably libmagic silently ignores invalid GUIDs. We caught it because PolyFile validates all GUIDs against RFC 4122. This bug was present in libmagic from December of 2019 until we reported it to the libmagic maintainers in April 2022. In the meantime, PolyFile has a workaround for the bug and has always used the correct GUID.\n\nPolyFile is a safer alternative to libmagic that is nearly feature-compatible.\n\nPolyFile even has an interactive debugger, modeled after gdb, to debug DSL patterns during matching. (See the option.) This is useful for DSL developers both for libmagic and PolyFile. But PolyFile can do so much more! For example, it can optionally output an interactive HTML hex viewer that maps out the structure of a file. It’s free and open source. You can install it right now by running or clone its GitHub repository."
    },
    {
        "link": "https://github.com/gitpan/File-LibMagic/blob/master/INSTALL.md",
        "document": "Installing File-LibMagic requires that you have the libmagic.so library and the magic.h header file installed. Once those are installed, this module is installed like any other Perl distributions.\n\nOn Mac you can use homebrew (http://brew.sh/):\n\nIf you have cpanm, you only need one line:\n\nIf you are installing into a system-wide directory, you may need to pass the \"-S\" flag to cpanm, which uses sudo to install the module:\n\nAlternatively, if your CPAN shell is set up, you should just be able to do:\n\nAs a last resort, you can manually install it. Download the tarball, untar it, then build it:\n\nIf you are installing into a system-wide directory, you may need to run:\n\nOn some systems, you may need to pass additional lib and include directories to the Makefile.PL. You can do this with the and parameters:\n\nYou can pass these parameters multiple times to specify more than one location.\n\nFile-LibMagic documentation is available as POD. You can run perldoc from a shell to read the documentation:"
    },
    {
        "link": "https://man7.org/linux/man-pages/man3/libmagic.3.html",
        "document": ""
    },
    {
        "link": "https://pypi.org/project/python-magic",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/ahupp/python-magic",
        "document": "python-magic is a Python interface to the libmagic file type identification library. libmagic identifies file types by checking their headers according to a predefined list of file types. This functionality is exposed to the command line by the Unix command .\n\nThere is also a class that provides more direct control, including overriding the magic database file and turning on character encoding detection. This is not recommended for general use. In particular, it's not safe for sharing across multiple threads and will fail throw if this is attempted.\n\nYou can also combine the flag options:\n\nThe current stable version of python-magic is available on PyPI and can be installed by running .\n\nThis module is a simple wrapper around the libmagic C library, and that must be installed as well:\n\nIf python-magic fails to load the library it may be in a non-standard location, in which case you can set the environment variable to point to it.\n• Depending on your ./configure --prefix settings set your LD_LIBRARY_PATH to /lib\n• 'MagicException: could not find any magic files!': some installations of libmagic do not correctly point to their magic database file. Try specifying the path to the file explicitly in the constructor: .\n• 'WindowsError: [Error 193] %1 is not a valid Win32 application': Attempting to run the 32-bit libmagic DLL in a 64-bit build of python will fail with this error. Here are 64-bit builds of libmagic for windows: https://github.com/pidydx/libmagicwin64. Newer version can be found here: https://github.com/nscaife/file-windows.\n• 'WindowsError: exception: access violation writing 0x00000000 ' This may indicate you are mixing Windows Python and Cygwin Python. Make sure your libmagic and python builds are consistent.\n\npython-magic is a thin layer over the libmagic C library. Historically, most bugs that have been reported against python-magic are actually bugs in libmagic; libmagic bugs can be reported on their tracker here: https://bugs.astron.com/my_view_page.php. If you're not sure where the bug lies feel free to file an issue on GitHub and I can triage it.\n\nWe use the test runner which can be installed with .\n\nTo run tests locally across all available python versions:\n\nOr to run just against a single version:\n\nTo run the tests across a variety of linux distributions (depends on Docker):\n\nThe python bindings shipped with libmagic use a module name that conflicts with this package. To work around this, python-magic includes a compatibility layer for the libmagic API. See COMPAT.md for a guide to libmagic / python-magic compatibility.\n\nMinor version bumps should be backwards compatible. Major bumps are not.\n\nWritten by Adam Hupp in 2001 for a project that never got off the ground. It originally used SWIG for the C library bindings, but switched to ctypes once that was part of the python standard library.\n\nYou can contact me via my website or GitHub.\n\npython-magic is distributed under the MIT license. See the included LICENSE file for details.\n\nI am providing code in the repository to you under an open source license. Because this is my personal repository, the license you receive to my code is from me and not my employer (Facebook)."
    },
    {
        "link": "https://stackoverflow.com/questions/19705634/how-to-add-new-types-of-files-when-using-python-magic-library",
        "document": "I need to use a python library for identifying the file type, and after reading the posts on this subject, python-magic seems to be what I am looking for. However, I can't find in the documentation how can I add new types of files when using this library?\n\nThere is a default set of file types - such as pdf, text, etc, but I need to be able to identify much more types than that. Thanks!"
    },
    {
        "link": "https://studio.bioturing.com/package/conda-forge-linux-64-python-magic",
        "document": ""
    },
    {
        "link": "https://github.com/aliles/filemagic",
        "document": "filemagic is a ctypes wrapper for libmagic, the library that supports the file command on most Unix systems. The package provides a simple Python API for identifying files using the extensive database of magic strings that ships with libmagic.\n• Documentation for filemagic is hosted on Read the Docs.\n• Packages are hosted by the Python Package Index.\n\nfilemagic has been tested against libmagic 5.11. It supports both Python2 and Python3, as well as CPython and PyPy.\n\nBelow is a short snippet of code showing how to use filemagic to identifying this README file.\n\nIt is recommended that magic.Magic be used with a context manager (the with statement) to avoid leaking resources from libmagic when instances go out of scope. Otherwise the close() method must be called explicitly.\n\nRefer to the filemagic documenation for further references."
    },
    {
        "link": "https://github.com/Yelp/elastalert/issues/1927",
        "document": "I believe this may be an issue with the package used by\n\nAfter installing elastalert v 0.1.3.6 I get the following stacktrace when I try to run an elastalert test with a folder of rules\n\nHas anyone else experienced this issue?"
    },
    {
        "link": "https://github.com/ahupp/python-magic/issues/238",
        "document": "I tried installing libmagic with both Homebrew and Macports (on a new Macbook Air M1 2020), but I'm unable to get it to work. What am I missing?"
    },
    {
        "link": "https://stackoverflow.com/questions/76639423/installing-libmagic-with-pip-fails",
        "document": "After installing in my Jupyter Notebook (as a container of JupyterLab as jovan user without access to root) the while having already installed in the conda env. I try to install install libmagic with pip:\n\nbut I keep getting error:"
    },
    {
        "link": "https://stackoverflow.com/questions/73398716/difficulty-importing-module-in-python-that-was-installed-via-homebrew-on-m1-pro",
        "document": "I'm currently developing a script called that makes use of the package. I used to install it via ZSH shell on an M1 Pro Mac.\n\nAs with any homebrew package installation, I used and it installed successfully, but by the time I tried to import it to my program with , the was thrown.\n\nAt first, I thought the module was not found because it was installed as a third party module, so I added the path to and I verified it via printing each entries with . But, I still get the same error.\n\nOne assumption I made here is that the path I gave to is where the module is located, but I think I have done something wrong here because the module search path clearly has the path I included so why is it still throwing the same error?\n\nClearly, the path listed in was included as shown below, so why can't the module be found?\n\nI'm suspecting that I'm not using the right directory for my and most tutorials out there uses an Intel chip which has a different file structure than the one in M1 Pro. The packages installed in the M1 Pro are stored under and I might have missed some important steps.\n\nAnybody who has experienced similar problems, please show me the way. Thank you."
    },
    {
        "link": "https://itsourcecode.com/importerror/importerror-failed-to-find-libmagic-check-your-installation",
        "document": "When working with handling file types, you may come across various errors. One of these is .\n\nThis error could hinder the execution of your code.\n\nBut in this article, we will dive into the details of this error, understand its causes, and explore effective solutions to resolve it.\n\nWhat is importerror: failed to find libmagic. check your installation?\n\nThe is an error message that can occur when trying to use the python-magic library.\n\nFortunately, this error message indicates that the libmagic library could not be found on your system.\n\nHowever, there are several ways to fix this issue depending on the operating system you are using.\n\nBut prior to that, let’s know first what is libmagic library.\n\nThe is a library used for recognizing the type of data contained in the computer file based on its content rather than its file extension.\n\nCommonly, it is utilized by Unix command files and it is also available in C library for other program purposes.\n\nMeanwhile, this Python-magic library is a Python wrapper for the library which allows you to use its functionality in Python programs.\n\nThere are a few potential causes for this error\n• The library might not be installed on your system.\n• The library path might not be set correctly.\n• If you are working within a virtual environment, it’s possible that the library is not installed or accessible within that environment.\n• Another cause is platforms may have specific requirements or issues related to .\n\nHere is an example of how this error occurs:\n\nHow to fix failed to find libmagic. check your installation\n\nThis error typically occurs when the library is missing or cannot be located.\n\n\n\nHere’s a step-by-step solution:\n• Check if library is installed First, make sure you have the library installed on your system.\n\n\n\nYou can check if it’s installed by running the following command in your terminal or command prompt:\n\n\n\n \n\nIf the command is not found or returns an error, it means the library is not installed.\n• Install libmagic Use the appropriate package manager for your operating system to install .\n\n\n\nHere are some examples:\n\n\n\nFor Ubuntu or Debian-based systems, run the following command:\n\n\n\n \n\nFor CentOS or Fedora-based systems, use the following command:\n\n\n\n \n\nFor macOS with Homebrew, run the following command:\n• Set the library path (if necessary) In some cases, you may need to set the MAGIC_LIBRARY environment variable to the correct path of the library.\n\n\n\nThis step is required if the library is installed in a non-standard location.\n\n\n\nFor example, in Linux, you can set it using the following command:\n\n\n\n \n\nReplace with the actual path to the library file.\n• Test the installation After installing and setting the library path (if necessary), try importing the python-magic library again in your Python code.\n\n\n\nThe error should no longer occur.\n\nBy following these steps, you should be able to resolve the error and successfully use the python-magic library in your Python projects.\n\nAnyway besides this error, we also have here fixed errors that might help you when you encounter them.\n• Importerror: cannot import name ‘parse_rule’ from ‘werkzeug.routing’\n\nIn conclusion, error can be frustrating, but with the right approach, you can overcome it.\n\nIn this article, we explored the causes of this error and provided several solutions to help you fix it.\n\nRemember to check your libmagic installation, update or reinstall the library if necessary, and ensure the correct configuration of paths and environment variables.\n\nBy following these steps and applying troubleshooting tips, you should be able to resolve the “ImportError: failed to find libmagic” error and continue with your development tasks seamlessly.\n\nI think that’s all for this error. I hope you have gained something to fix their issues."
    }
]