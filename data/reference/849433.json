[
    {
        "link": "https://flutter.dev/multi-platform",
        "document": "NOTICE: Flutter hopes this directory is useful for customers seeking consultants with Flutter experience; however, Flutter makes no representation to you or anyone else that the listed consultants are Flutter or Google partners, and Flutter does not represent or warrant their qualifications or the quality of services you may receive. Your relationship is strictly between you and the consultants."
    },
    {
        "link": "https://docs.flutter.dev/get-started/install",
        "document": "If you want to use Flutter in China, check out using Flutter in China. If you're not developing in China, ignore this notice and follow the other instructions on this page."
    },
    {
        "link": "https://flutter.dev",
        "document": "NOTICE: Flutter hopes this directory is useful for customers seeking consultants with Flutter experience; however, Flutter makes no representation to you or anyone else that the listed consultants are Flutter or Google partners, and Flutter does not represent or warrant their qualifications or the quality of services you may receive. Your relationship is strictly between you and the consultants."
    },
    {
        "link": "https://docs.flutter.dev",
        "document": "To see changes to the site since our last release, see What's new.\n\nOnce you've Set up Flutter, you should follow the Write your first Flutter app codelab and read Flutter fundamentals. These resources are opinionated documentation that guide you through the most important parts of building a Flutter app.\n\nComing from another platform? Check out Flutter for: Android, SwiftUI, UIKit, React Native, and Xamarin.Forms developers.\n\nCheck out the Introducing Flutter series. Learn Flutter basics like how do I make my first Flutter app? In Flutter, \"everything is a widget\"! Learn more about and widgets in What is State?\n\nDive deeper into how Flutter works under the hood! Learn why you write standalone widgets instead of using helper methods or what is \"BuildContext\" and how is it used?\n\nTo learn about all of the Flutter video series, see our videos page.\n\nWe release new videos almost every week on the Flutter YouTube channel:\n\nThank you for your feedback! Thank you for your feedback! Please let us know what we can do to improve. Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-03-12. View source or report an issue."
    },
    {
        "link": "https://docs.flutter.dev/platform-integration/desktop",
        "document": "Flutter provides support for compiling a native Windows, macOS, or Linux desktop app. Flutter's desktop support also extends to plugins—you can install existing plugins that support the Windows, macOS, or Linux platforms, or you can create your own.\n\nYou can use the following steps to create a new project with desktop support.\n\nConsult the guide for your target desktop environment:\n\nIf finds problems or missing components for a platform that you don't want to develop for, you can ignore those warnings. Or you can disable the platform altogether using the command, for example:\n\nAfter enabling desktop support, restart your IDE so that it can detect the new device.\n\nCreating a new project with desktop support is no different from creating a new Flutter project for other platforms.\n\nOnce you've configured your environment for desktop support, you can create and run a desktop application either in the IDE or from the command line.\n\nAfter you've configured your environment to support desktop, make sure you restart the IDE if it was already running.\n\nCreate a new application in your IDE and it automatically creates iOS, Android, web, and desktop versions of your app. From the device pulldown, select windows (desktop), macOS (desktop), or linux (desktop) and run your application to see it launch on the desktop.\n\nTo create a new application that includes desktop support (in addition to mobile and web support), run the following commands, substituting with the name of your project:\n\nTo launch your application from the command line, enter one of the following commands from the top of the package:\n\nTo generate a release build, run one of the following commands:\n\nTo add desktop support to an existing Flutter project, run the following command in a terminal from the root project directory:\n\nThis adds the necessary desktop files and directories to your existing Flutter project. To add only specific desktop platforms, change the list to include only the platform(s) you want to add.\n\nFlutter on the desktop supports using and creating plugins. To use a plugin that supports desktop, follow the steps for plugins in using packages. Flutter automatically adds the necessary native code to your project, as with any other platform.\n\nWhen you start building your own plugins, you'll want to keep federation in mind. Federation is the ability to define several different packages, each targeted at a different set of platforms, brought together into a single plugin for ease of use by developers. For example, the Windows implementation of the is really , but a Flutter developer can simply add the package to their as a dependency and the build process pulls in the correct implementation based on the target platform. Federation is handy because different teams with different expertise can build plugin implementations for different platforms. You can add a new platform implementation to any endorsed federated plugin on pub.dev, so long as you coordinate this effort with the original plugin author.\n\nFor more information, including information about endorsed plugins, see the following resources:\n• Developing packages and plugins, particularly the Federated plugins section.\n• How to write a Flutter web plugin, part 2, covers the structure of federated plugins and contains information applicable to desktop plugins.\n\nYou can run the following samples as desktop apps, as well as download and inspect the source code to learn more about Flutter desktop support."
    },
    {
        "link": "https://apriorit.com/dev-blog/web-mobile-cross-platform-app-development-react-native",
        "document": "Developing separate applications to cover several target platforms is difficult, time-consuming, and expensive. No wonder cross-platform app development has become so popular — it allows businesses to reach a wider audience and reduce development costs by creating a single app.\n\nYou may already know that cross-platform technologies like React Native allow you to develop mobile applications for both Android and iOS. But did you know that you can also use React Native to adapt your mobile app to web and desktop platforms and even to create browser extensions?\n\nThis detailed guide shows you how to build cross-platform apps with React Native. Additionally, we include a link to our GitHub repository containing all code required for this setup, making it easy to follow along and implement it in your own projects.\n\nThis article will be helpful for team leads and business owners who want to streamline the development process and reduce costs and time to market for their products. It will also be useful for your React developers to expand their horizons in cross-platform app development. If your developers already know React, it will be easy for them to learn React Native, since both frameworks have similar syntax, concepts, approaches, and patterns.\n\nThere’s a simple principle in software development: If you want to attract many end users, make sure your app is available on all platforms your target audience uses. Some users prefer Android smartphones; others are dedicated to Apple devices; and some use web or desktop software.\n\nTo ensure your app is present on all platforms, you’ll need a diverse team of specialists that will most likely consist of a:\n\nEven if you hire top specialists, there are still risk factors. First, it’s always a challenge to gather a diverse team of developers, QA engineers, and project managers with expertise relevant to your specific project. Moreover, maintaining and managing such teams requires a lot of money and effort on the part of your business.\n\nAlso, you’ll have multiple projects, one for each platform. The pacing may differ, so you risk releasing your products on different dates. Additionally, any changes, updates, and maintenance activities will be multiplied by the number of platforms you support.\n\nOne way to tackle these issues when delivering your application to several different platforms is to use the cross-platform development approach.\n\nCross-platform development uses specific frameworks that contain universal technologies, wrappers, and tools to run on multiple platforms. These technologies commonly include:\n\nIn this article, we focus on JavaScript, as it’s the primary technology used in React Native — the framework we’ve dedicated this article to.\n\nLet’s discuss the pros and cons of cross-platform app development in general, starting with the benefits of this approach:\n• Fast. Applying a cross-platform approach, developers can create applications quickly. There’s no need to develop a separate codebase for each platform.\n• Easy to maintain. With cross-platform development, solution maintenance is easier, since developers only have to update a single codebase rather than multiple.\n• Consistent user experience. By using cross-platform technologies, developers can ensure the user experience is consistent across all platforms. Having a familiar and convenient interface across platforms can improve user satisfaction and loyalty and consequently decrease the churn rate.\n• Interchangeable team. Instead of hiring developers with diverse skill sets, you can get a team of JavaScript developers who will be able to cover all your needs. Also, it will be easy for you to find new developers and expand the team due to the popularity of JavaScript.\n• Cost-efficient. Creating a single app for multiple platforms significantly cuts costs, as you don’t need to create a separate codebase for each platform and keep various developers on staff.\n• Wide reach. You can cover a wide range of platforms with a single codebase and expand your pool of potential users.\n\nNow, let’s take a look at general disadvantages and potential issues you may encounter in cross-platform development:\n• Performance. Native technologies are more efficient than cross-platform technologies, as they use a platform’s core programming language and APIs to compile. A cross-platform framework, on the other hand, transforms code into the language of the platform. This results in slower data processing that can affect the performance of complex applications like games or video editors.\n• Large app size. Even the simplest cross-platform app often weighs 80–100MB without optimization. On the bright side, developers now have ways to reduce the size of an application, and modern mobile networks allow users to download large apps.\n• Integration issues. Cross-platform technologies often don’t give access to all the possibilities of an operating system (OS) because they don’t keep up with OS updates. You may need to wait till the cross-platform framework’s developers add functionality present in the new version of an OS.\n\nCross-platform technologies are suitable for a wide range of applications. Many world-famous products use cross-platform technologies, including Slack, Skype, Figma, Airbnb, Uber, and Dropbox.\n\nFrom our experience, cross-platform frameworks like React Native are the most suitable choice for applications such as:\n\nHowever, cross-platform technologies have their limitations too and may not be suitable for all types of applications. For instance, applications that require heavy graphics processing or intensive computations on the client side may not perform well in a cross-platform environment.\n\nTherefore, it’s important to carefully consider application requirements before choosing this development approach.\n\nLet’s talk about the technologies that allow world-class products to provide a consistent user experience on multiple platforms simultaneously.\n\nYour developers can use many technologies to build an efficient cross-platform application. Let’s briefly overview the most popular.\n\nA Progressive Web Application (PWA) is a type of website that is designed to work like a native mobile or desktop app. PWAs use modern web technologies to provide features like offline access, push notifications, and access to device hardware (such as cameras or GPS).\n\nYou can convert a WordPress website into a PWA, and then it can be installed on a user’s device and launched from the home screen like a regular app.\n\nA downside of this technology, however, is that Apple doesn’t permit it, so it’s more suitable for self-hosted corporate applications.\n\nHybrid mobile apps use web technologies such as HTML, CSS, and JavaScript and are then wrapped in a native app shell. This shell allows a hybrid app to run as a native app, giving it access to device-specific features such as the camera, contacts, and GPS.\n\nApache Cordova and Ionic are the most popular hybrid app frameworks. Unlike PWAs, you can deploy hybrid apps to both the App Store and Google Play Store.\n\nFlutter is a framework made by Google. It uses Dart, which allows for faster compilation speed. Flutter boasts native-like performance, widget-based logic, and ease of development.\n\nProgrammers can adapt Flutter apps to all platforms, from iOS and Android to web, macOS, Linux, and Windows.\n\nMade and backed by Facebook, React Native allows developers to use JavaScript to build mobile apps for iOS and Android. The React Native cross-platform mobile app development is based on components that are bundled with the application, which provide access to underlying device hardware.\n\nDevelopers can also expand their mobile apps to desktop and web apps and even create browser extensions.\n\nReact Native is a well-supported technology that offers lots of useful opportunities for application development. Let’s discuss the advantages of React Native in more detail.\n\nWhat is React Native and why use it for cross-platform development?\n\nReact Native is an open-source framework for building cross-platform mobile applications. It was developed and maintained by Facebook, which gives confidence in its future. React Native is based on the popular React library for building web applications.\n\nReact Native offers excellent performance, as it compiles into native code for each platform rather than running the app through a web view or emulator. This approach ensures that the application runs smoothly and performs well on both iOS and Android devices.\n\nOne of the benefits of React Native is its large and active community of developers who continue to improve and enhance the framework. So even if you run into a problem, there’s a good chance you’ll find a solution online.\n\nReact Native is an excellent choice for cross-platform app development, as it allows developers to build apps for iOS, Android, Windows, macOS, and the web using a single codebase. It also has the potential to support other platforms through third-party libraries and tools.\n\nOne of the biggest advantages of using React Native for cross-platform development is the significant time and cost savings it offers. Instead of having to develop and maintain a separate codebase for each platform, developers can use a single codebase, which leads to faster development, easier maintenance, a consistent user experience, and reduced costs.\n\nWith React Native, you can reuse web development skills and knowledge, as it’s based on the popular React library for web development. This makes it easier for developers already familiar with React to learn and work with React Native.\n\nLet’s now create our own React Native project and adapt it for all platforms.\n\nTo show a practical example of using React Native for cross-platform development, we’ll create a small project and set it up to run on the following platforms:\n\nWe’ll also discuss the specifics of cross-platform development for these platforms:\n\nWe’ll keep the application simple, so it won’t contain any complex business logic. What it will contain are a few components that are typical for app development, such as:\n• A simple form with an input field and a submit button\n\nWe’ll start with a basic project in React Native, then create the user interface (UI) in it. By this point, we’ll be able to run the project on the Android and iOS mobile platforms.\n\nThen, with the help of the React-Native-Web library and the Webpack builder, we will turn our app into a website.\n\nNext, we will discuss how to get browser extensions from the website. To do this, we will need to add just a few files. Finally, we will port the product to Windows using the React-Native-Windows package.\n\nTo get started, you’ll need equipment. You can use React Native on different operating systems: macOS, Windows, or Linux. But you will only be able to develop for the iOS platform using a Mac, so it’s ideal to have one. We used an M1 Mac for this project. Later, we will also need a Windows PC to develop a desktop app.\n\nNext, we set up the development environment. The official documentation describes this well, so you can follow the steps depending on the OS you’re using for development.\n\nThere are two main sets of tools and services for building, deploying, and managing React Native apps: Expo and React Native Command-Line Interface (CLI).\n\nExpo is simpler to use, but it can be somewhat limiting for larger projects. However, it’s perfect for quick prototyping.\n\nCLI, on the other hand, is more complex and requires experience with native development and offers a number of advantages compared to Expo:\n• Fast access to the latest React Native updates and features\n\nWe’ll be using CLI for this tutorial.\n\nWe start with installing the necessary software and tools, setting the environment variables, and creating a default project. Installing all components can take around an hour.\n\nWe created a project called RNEverywhere using the following command:\n\nWe chose the Yarn package manager and installed it with this command:\n\nNext, we went through all the steps for both Android and iOS and installed the Android emulator and iOS simulator according to the documentation. In the end, you should be able to run the default app on the Android emulator with the following command:\n\nFor the iOS simulator, use this command:\n\nThis is what you should see after completing the steps above:\n\nTogether with the emulator and simulator, Yarn also runs Metro, a JavaScript bundler for React Native applications. It is responsible for packaging your application code and all its dependencies into a single bundle file that can be run on a mobile device.\n\nNow we can open our project folder in a code editor — VS Code, in our case. This is the folder structure you should have if you did everything as described:\n\nThe package.json file contains the scripts we can run with yarn <scriptName> and a set of application dependencies and their versions.\n\nThe App.tsx file contains the contents of our application, including the set of React Native components. These components make up the UI of the app. You can read more about React Native components in the official documentation.\n\nYou can play around with them, for example, by changing some text in this file and seeing the changes in the emulator. After saving the file, the changes should be applied automatically.\n\nNow, it’s time to tweak the default UI. Our new interface will contain a couple of pages, so let’s add a routing package. In the terminal, in the project folder, run:\n\nThen replace the code of the App.tsx file with the following code:\n\nAt the top of the file, we import several components from the library we just installed in order to organize routing in the application. We also import a couple of components from React Native.\n\nThe App function returns the user interface structure, which includes navigation links and a set of routes. The Link components represent clickable links to different pages in the application, and the Routes component defines the mapping between URL paths and the corresponding components to render. By organizing our components in this way, we enable users to navigate between pages seamlessly, making our application more interactive and user-friendly.\n\nWe used the Text and View components from the React Native library. The Text component allows you to display and render content within the user interface, while the View component helps you build the structure and the layout of your application. If you need to show some text in the application, it must be wrapped in the <Text></Text> tag. You can think of the <View> tag as the <div> in HTML.\n\nAt the bottom of the file, we created a Styles object, which we pass as props to our components. The style names look just like CSS names, only in camel case (backgroundColor rather than background-color).\n\nComponent alignment in React Native is achieved with Flexbox. Unlike on the web, Flexbox’s default direction is a column. You can find more details about styles in the official React Native documentation.\n\nAlso, at the top of the file, we import the Home and About components. These custom components that we create ourselves will represent our pages.\n\nTo make them, we create the src folder in the project folder — it will contain the source code of our components. Then we create the pages subfolder and place these two files in the pages: Home.tsx and About.tsx.\n\nNow, we paste the following code into the About.tsx folder:\n\nThis component is quite straightforward, showing the page title, the secondary text, and text styling.\n\nNow, we paste the following code into the Home.tsx file:\n\nThis component is a bit more complicated and contains a few new components:\n• TextInput — shows the input box on the page\n• Pressable — is used to implement buttons\n\nWe used the useState hook to create and manage two variables that store and update the application’s state.\n\nThe first variable stores the text the user has put into the input box. We pass it as a prop into TextInput and change the state of this variable by passing the onChangeText callback to the same component.\n\nThe second variable stores the state of the dialog box (open/closed). When we type something in the input field and click Submit, the dialog box will show up with the text that has been typed.\n\nOur app is ready! Now we can run the Android emulator and the iOS simulator again, and we should get the following:\n\nSo far, we have created our own app that works on Android and iOS. Now it’s time to turn it into a web application.\n\nThanks to the React Native community, we have the opportunity to turn our mobile app into a web application. To do this, we will use React Native Web.\n\nReact Native Web is an open-source library that allows us to build web applications using React Native components. It supports all the core React Native components and APIs and uses React DOM to render the application in the browser.\n\nTo start, let’s add a couple of modules to our project. In the terminal, run:\n\nNext, we need to install some dev dependencies:\n\nHere, in addition to react-native-web itself, we installed:\n• react-dom — used by react-native-web to render the application in the browser\n• webpack — a module bundler for JavaScript applications that packages and bundles different modules and assets, such as JavaScript files, CSS stylesheets, images, and fonts, into a single bundle file that can be served to a web browser\n• babel-loader — used by Webpack to transform modern JavaScript code, such as ES6 and JSX, into a format that older browsers can understand\n• url-loader — a Webpack loader that transforms files into Base64 URIs; we will use it to handle images\n• babel-plugin-react-native-web — a Babel plugin that will alias react-native to react-native-web\n• html-webpack-plugin — a Webpack plugin we’ll use to create HTML files that will automatically include our Webpack bundles to run on the web\n\nNow our package.json will look something like this:\n\nIf you experience any problems or errors later on, you can change the versions of the packages in this file to the ones used here and run the yarn command. This command will read the package. Json file in your project and install the corresponding package versions specified in it. This will ensure that you have the correct package versions installed and help resolve any compatibility issues.\n\nNext, create a top-level web folder and create three files in it:\n\nHere’s the code these files will contain.\n\nThis is a basic HTML file template with some styles from the react-native-web documentation and a div in which our application will be rendered. This will allow us to apply the styles from our mobile app to the web application and ensure a consistent design across all platforms.\n\nThis file is almost a copy of the index.js file from the root of the project with a small addition that will be used by react-native-web to render our application in the div with the root id.\n\nBy rendering the React application inside the div element with the root id, React Native for Web can ensure that the application appears in the correct location on the web page and has the appropriate styling applied to it.\n\nIn this file, we created the configuration that will do all the work:\n• babelLoaderConfiguration — transpiles all JavaScript and TypeScript files into a format that browsers can understand so that our app is compatible with a wide range of browsers\n• imageLoaderConfiguration — handles the image files we will use in our application\n• entry — the entry point to our application\n• output — tells Webpack what to name the compiled files and where to save them to the disk\n• resolve — changes how modules are resolved; will alias the react-native module so all references to it can be resolved to the same file\n• devServer — contains dev server settings; will open the application in the browser on port 3000 and allow us to see changes immediately and test our app in a local development environment\n• module.rules — allows you to specify how different types of files should be processed and transformed by Webpack\n• HtmlWebpackPlugin — simplifies the process of generating and updating the HTML file for the application and injects the JavaScript bundle into the HTML file so it’s properly loaded\n\nYou can find more details about Webpack configuration in the official Webpack documentation.\n\nFinally, add these two lines to the scripts section of package.json:\n\nNow you can run this command in the terminal:\n\n…and get the desired web version of your React Native app:\n\nThe second script will build the application’s production bundle:\n\nThis will trigger the Webpack build process, which will compile and optimize the code and assets for production. When the build is complete, a build folder will be created in the web folder containing all required production-ready assets, such as JavaScript, CSS, and image files.\n\nNow, we have an app that runs on the web, Android, and iOS. Let’s talk about platform-specific cases and how to adapt your app to React Native supported platforms.\n\nAll platforms have their specific UI and UX layouts and rules, so it’s necessary to adapt your application so it looks native to the platform.\n\nFor example, in our case, the full-screen width button looks odd when we open our app in the web browser. Also, our app may use an API on mobile platforms that’s not available on the web, and vice versa.\n\nFor such cases, when we want specific code for a specific platform in React Native, we need to create a platform-dependent component. To do this, you need to create a file with a platform-specific extension. For example:\n\nTo demonstrate this, let’s change our web layout to horizontal. First, we’ll need to create a components folder in the src folder and add two files to it: Layout.tsx and Layout.web.tsx.\n\nThis is a normal layout that will render all of its nested components as they are.\n\nAs you can see, we add some additional styles to the web version.\n\nIn the App.tsx file, wrap everything in this Layout component instead of View. Note that you should import it from the Layout.tsx file. The bundler will do the rest of the work for us.\n\nHere’s the result: two different layouts for web and mobile platforms.\n\nAs you can see, the mobile UI has not changed, but the layout of the buttons is different in the web version. It does look better, but the buttons are still horizontally aligned.\n\nFor smaller platform-specific differences like this, React Native provides an API that determines which platform the application is running on. This is the second way to work with platform-specific code.\n\nImport the Platform module from the react-native library and add some changes to it:\n\nThe buttons are now displayed in a column for the web.\n\nNow that we have learned how to adapt a React Native application to web and mobile platforms, let’s talk about the browser extension you can create from the same codebase.\n\nSometimes, depending on the project you’re developing, you may need to create a browser extension. This applies if you’re working on a solution such as a/an:\n\nBrowser extensions can be more convenient and accessible compared to traditional web applications and provide your users with enhanced security features, some offline functionality, and more.\n\nAnd now that we have a web version of our app, we only need to take a few more steps to turn it into a browser extension. Let’s explore how to do so for the Chrome and Firefox browsers.\n\nThe manifest file is a key component of your extension that defines its permissions, content, and functionality. The manifest file is a JSON file that includes information such as the extension’s name, version, description, and icons. Let’s create the manifest.chrome.json file in the web folder:\n\nThere’s a minimum set of fields that the manifest file can include in order for the extension to work properly. You can find more information about this in the Chrome documentation.\n\nHere are the mandatory fields your extension should have:\n• manifest_version specifies the version of the manifest format being used\n• name is the name of the extension\n• version is the version number of the extension\n• description is a brief description of the extension\n• icons is a set of icons that represent the extension\n• browser_action or page_action specifies the behavior of the extension when the user clicks on the browser or page action icon\n\nNote that if your extension is complex, you’ll need additional fields.\n\nThe icon object should specify different icon files with different resolutions. For the sake of simplicity, we specify the same file everywhere. Therefore, we need to add the logo.png file to the web folder. You can put any icon there.\n\nWe also need to specify the dimensions of our extension’s popup. Again, for the sake of simplicity, we specify them directly in index.html:\n\nNow, we add the following line to the scripts section of package.json:\n\nWhen you run yarn chrome:build, the extension assets will be generated in the web/build folder. If you have a lot of icons and other files, you may want to use the Copy Webpack Plugin to automatically copy them to the build folder during the build process.\n\nHowever, since we only have the logo and manifest file, we simply copy them using a script. Additionally, we rename the manifest file to manifest.json because this is the required name to work properly in the browser.\n\nFinally, we put the chrome://extensions/ in your Chrome browser address bar and enable the developer mode slider in the top right corner. Select Load unpacked and select a build folder to load the extension in your browser:\n\nTurning your React Native app into a browser extension works almost the same for Firefox as it does for Chrome. First, we create manifest.firefox.json in the web folder:\n\nYou can find more details about Firefox extensions in the official Firefox documentation.\n\nNext, we add the following line to the scripts section of package.json:\n\nNow, we run the yarn firefox:build script to build the extension files.\n\nFinally, put into the address bar of your Firefox browser, click Load Temporary Add-on… and select the manifest file in the build/web folder. It should look like this:\n\nNow that we have covered both mobile and web platforms, let’s learn how to transform our React Native app into a Windows desktop application.\n\nThe React Native cross-platform tool set allows us to turn our app into a Windows desktop app. All we need is a tool called React Native Windows. It is an open-source framework developed and maintained by Microsoft that allows developers to build Windows 10+ applications using the React Native library.\n\nThis React Native extension provides components and APIs specifically for the Windows platform, including support for Windows-specific features. React Native for Windows also allows for building desktop applications using the Universal Windows Platform (UWP) and Win32 APIs.\n\nTo get started, we need to:\n• Get our code on a Windows machine\n• Set up the necessary environment on this machine to work with React Native according to the documentation\n• Run yarn in the root of the project to install all dependencies\n\nMicrosoft has done a great job, as we can install all missing dependencies automatically by running a single script. Start an elevated PowerShell window and run:\n\nThis will guide you through all the missing components and ask your permission to install them.\n\nNow, to add React Native Windows to our project, run the following command in the root folder:\n\nAll the preparation work is done, and we can launch our project. Run:\n\nAfter waiting a while for everything to build, this is what you’ll see:\n\nWindows has automatically applied some platform-specific styles. We can override this in the “Styles” object, of course, if needed.\n\nBut if we play with the application a little bit, type some string into the input field, and click Submit, we get an error message like this:\n\nWe expected to see Modal, but something went wrong. If we search information about this bug on the internet, we find out that Modal is not implemented in React Native for Windows. This issue has been discussed in the repository in various issues for four years now, but it still hasn’t been resolved.\n\nWe need to find some workaround. One option is to use the Popup component that React Native Windows provides.\n\nTo do this, we use the technique discussed above. Let’s create two files in the src/components folder: Modal.tsx and Modal.windows.tsx.\n\nIn this file, we employ the Modal component from the React Native library and pass all the properties (props) it received from the parent component to the Modal component. Additionally, we include all nested components inside the Modal component so they can be displayed along with the Modal content.\n\nIn this file, we use the Popup component from react-native-windows, pass all nested components inside, and match the properties.\n\nThe Popup component uses the isOpen property for the visibility state, while the Modal component uses the visible property. So we will pass the visible property to isOpen in the Modal component. The rest of the properties should also be treated like this if necessary.\n\nOn the Home page, instead of importing Modal from the React Native library, we will use the component imported from our component folder:\n\nIt is not an unusual case in cross-platform development that a component or API is not supported on one of the platforms. It can take quite a long time before the developers of the corresponding packages make the necessary changes or implement a solution.\n\nSo with cross-platform development, you need to be ready to look for workarounds and challenging solutions, sometimes make compromises, study the limitations that packages impose, and think ahead about whether product requirements can be met with cross-platform technology.\n\nFor example, an application built with React Native Windows works on Windows versions 10 and higher, but some features may not work on all versions. You can find out more details on this in the React Native for Windows documentation.\n\nYou may have noticed in the React Native for Windows documentation that the prototype is called React Native for Windows + macOS. Indeed, Microsoft has gone further and implemented the ability to turn your app into a macOS desktop application as well.\n\nUnfortunately, React Native for macOS works with React Native version 0.64 at the time of writing, while we started the project with React Native 0.71.6. It is possible to set up a repository for cross-platform development with different versions of React Native for different platforms to allow for sharing common code across platforms. This approach is called a monolithic repository, or monorepo.\n\nThe monorepo setup is more complicated, though, so we won’t cover macOS in this article, as we’ve looked for the easiest setup for cross-platform app development. If you’d like to port your application to the macOS platform, you can always use the instructions provided in the Microsoft documentation.\n\nIt’s also possible to create a desktop app for Linux out of the web version of your React Native app. To do this, we can use the Electron framework to port our app to Linux/Windows/Mac.\n\nElectron is a popular framework for building cross-platform desktop applications using web technologies such as HTML, CSS, and JavaScript.\n\nAnother option is using Valence Native. It’s a React Native wrapper that uses a cross-platform application framework called Qt to render the user interface and provide platform-specific functionality for Linux, macOS, and Windows.\n\nThere is also a community-driven project called React Native TVOS for development of React Native applications for Apple TV and Android TV devices. It provides a set of tools and components for developing React Native applications specifically for TV platforms, including tools for focus management, a TV remote event system, and a TV menu system to help developers build TV applications more easily.\n\nReact Native is evolving rapidly, and its growing community is constantly creating new solutions that expand the possibilities. Our recommendation is to check the React Native documentation regularly for updates.\n\nCross-platform technologies like React Native provide businesses with a cost-effective way to expand their product to a wide user base with minimal effort. By using cross-platform technologies, you can decrease your development time, budget, and team size.\n\nIn this article, you’ve learned how to build cross-platform apps with React Native and adapt them to multiple platforms from a single codebase. We also showed you how to adapt your app for different platforms so the UI is both consistent and natural for each platform.\n\nAt Apriorit, we can help you bring your product to all platforms. Our mobile development team will gladly assist you in creating a cost-efficient and scalable mobile solution that will run on Android and iOS. Our web development team will then expand your project to the web and transform it into a desktop app or browser extensions.\n\nContact us so we can help you choose the optimal cross-platform approach to building your solution!"
    },
    {
        "link": "https://reactnative.dev",
        "document": "Meta released React Native in 2015 and has been maintaining it ever since.\n\nIn 2018, React Native had the 2nd highest number of contributors for any repository in GitHub. Today, React Native is supported by contributions from individuals and companies around the world including Callstack, Expo, Infinite Red, Microsoft and Software Mansion.\n\nOur community is always shipping exciting new projects and exploring platforms beyond Android and iOS with repos like React Native Windows, React Native macOS and React Native Web."
    },
    {
        "link": "https://reactnative.dev/architecture/xplat-implementation",
        "document": "In the previous render system of React Native, the React Shadow Tree, layout logic, and View Flattening algorithm were implemented once for each platform. The current renderer was designed to be a cross-platform solution by sharing a core C++ implementation.\n\nThe React Native team intends to incorporate an animation system into the render system and also extend the React Native render system to new platforms such as Windows, and operating systems in game consoles, televisions, and more.\n\nLeveraging C++ for the core render system introduces several advantages. A single implementation reduces the cost of development and maintenance. It improves the performance of creating React Shadow Trees and layout calculation because the overhead of integrating Yoga with the renderer is minimized on Android (i.e. no more JNI for Yoga). Finally, the memory footprint of each React Shadow Node is smaller in C++ than it would be if allocated from Kotlin or Swift.\n\nThe team is also leveraging C++ features that enforce immutability to ensure there are no issues related to concurrent access to shared but not protected resources.\n\nIt is important to recognize that the renderer use case for Android still incurs the cost of JNI for two primary use cases:\n• Layout calculation of complex views (e.g. , , etc.) requires sending props over JNI.\n\nThe team is exploring replacing with a new mechanism to serialize data using to reduce overhead of JNI. Our goal is to reduce overhead of JNI by 35–50%.\n\nThe renderer provides two sides of its C++ APIs:\n• (ii) to communicate with the host platform\n\nFor (i), React communicates with the renderer to render a React Tree and to “listen” for events (e.g. , , touch, etc).\n\nFor (ii), the React Native renderer communicates with the host platform to mount host views on the screen (create, insert, update or delete of host views) and it listens for events that are generated by the user on the host platform."
    },
    {
        "link": "https://appwrite.io/blog/post/building-cross-platform-applications-with-react-native",
        "document": "Android, iOS, macOS, Linux, Windows, and the Web. Different platforms with different codebases. As a developer, you might have faced the challenge of building one application for multiple platforms. Considering the challenge of mastering all of the skills to build an application that performs well cross-platform, it’s no wonder we have seen the rise of cross platform frameworks such as React Native and Flutter. These frameworks allow you to create applications that run smoothly on multiple operating systems from a single codebase. This saves time, reduces costs, and reaches a larger user base.\n\nWhy might one choose cross-platform development over developing applications for each platform? Based on the intro, it might seem logical, but let’s take a deeper look at why this is beneficial in some cases.\n\nThere might be several reasons, but the most important ones are as follows:\n• None Broader target: cross platform development enables developers to reach a broader target from the beginning by targeting multiple platforms.\n• None Cost: cross platform development saves costs, as fewer developers are required to develop applications for multiple platforms.\n• None Feature parity: Features across platforms can be deployed in parallel without discriminating the users.\n• None Faster development time: With a single codebase, development cycles are shorter. Features bug fixes are implemented just once for all the platforms, increasing the delivery speed.\n• None Simple codebase management: managing a single codebase is much simpler than managing multiple projects with different platform-specific languages and APIs.\n• None Uniform design: It is easy to implement uniform designs across platforms and also platform specific changes if and when required.\n\nBut as good as it might sound, there are also situations when choosing cross platform is not the best idea.\n• None Advanced device features: When your application relies on advanced device features, and cutting-edge platform-specific features, then it’s a good idea to choose native over cross-platform development\n• None High-performance requirements: Native development is preferred over cross-platform development for applications with maximum performance requirements, such as highly intensive graphical and computational requirements.\n• None Fine control over memory management and processing: Native development is preferred when your application requires fine-grained control over memory management, processing power, and background tasks. For instance, an application that runs intensive algorithms on large datasets in real-time would benefit a lot by going native due to access to low-level APIs and system resources.\n• None Development skill set: If your team is already fluent in Native development but have to learn cross-platform development from scratch and you don’t have time and resource for that, it’s beneficial to choose native development.\n\nChoosing the right tool for your application is crucial whether going native or cross-platform, and as we've seen, cross-platform development offers a range of benefits that are hard to ignore. Some of these can be a major win for businesses trying to save cost and target large user bases. However, you should decide based on your project's requirement and your team's skillset and preferences.\n\nCross platform frameworks provide a high level unified API in a single language. For example, Flutter uses Dart, React Native uses Javascript, and Xamarin (now .NET MAUI) uses C#.\n\nThe code written in these languages is compiled for specific platforms mostly ahead of time during the build and deployed mostly as native code. Some frameworks like React Native also use bridging, where the framework interprets the javascript code and communicates with the native element through the bridge.\n\nUI elements can be rendered in two ways\n• None Native rendering: map the UI to native platform specific components. React Native does this. this allows apps to maintain a native look and feel\n• None Custom rendering engine: A framework like Flutter completely bypasses the native UI and renders the components with its own rendering engine. This provides more control over the appearance and behavior of the UI\n\nFinally, when the application needs to handle native device-specific functionalities, all cross-platform frameworks do this via plugins. Plugins write the platform-specific codes required for each platform and provide a high-level API for developers to use. Whenever there is a lack of specific functionalities, the framework provides a way for developers to write their own custom plugins to handle those specific functionalities.\n\nTry React Native for your next project\n\nThere are many great cross-platform framework technologies, like Flutter, .NET MAUI, Ionic, and more. Each cross-platform frameworks have their advantages and disadvantages and we are not here to say one is better. Which framework to choose depends on one’s preference, previous knowledge and skill set, project requirements, and more. But to celebrate the release of the Appwrite React Native SDK in open beta, we want to share a few points that make React Native an attractive choice.\n• None Learn once, write anywhere: If you already know JavaScript and React, you can easily learn and start using React Native. So, this is already an attractive choice for JavaScript developers, and it might be the one framework with the easiest learning curve\n• None Native performance: React native communicates with native platform components directly, which leads to a responsive user experience close to native performance\n• None Large community and ecosystem: React and React Native, created by Facebook, are popular frameworks, leading to large community and ecosystem support with content and packages. React Native applications also benefit from the huge number of packages of JavaScript\n• None Live and hot reloading: Live and hot reloading features enhance developer productivity by allowing developers to iterate faster.\n• None Integrating with existing applications: Another major attraction point is developers can integrate React Native into their existing applications if they already have one.\n\nGet started with React Native and Appwrite\n\nReact Native allows you to create applications that run on multiple operating systems from a single codebase, whereas Appwrite provides you with a full-functioning backend with just a few lines of code. This means that you can build a full functioning app, targetting users across iOS, Android, Mac OS, Linux, Windows, and the Web, and cut down your development time tremendously.\n\nTo get started, follow these steps.\n\nFirst, you must set up an Appwrite project. To do so, you must either create an Appwrite Cloud account or self-host Appwrite on your system.\n\nOnce that is done, under Add a platform, add an Android app or an Apple app. You can skip optional steps.\n• None iOS steps: Add your app name and Bundle ID. You can find your Bundle Identifier in the General tab for your app's primary target in XCode.\n• None Android steps: Add your app's name and package name. Your package name is generally the applicationId in your app-level build.gradle file.\n\nOnce Appwrite is up and running, install the React Native SDK in your project. This will connect your React Native app with Appwrite's suite of backend services. You can install the SDK (and necessary dependencies) using the following command:\n\nFamiliarize yourself with Appwrite's documentation. It's packed with tutorials, examples, and API references designed to get you up to speed in no time.\n\nWith everything in place, you're ready to start building your app. The React Native SDK is designed to be intuitive, allowing you to implement features like authentication, database operations, and file storage with ease.\n\nRead the quick start to get started or find a tutorial to build an ideas tracker with React Native.\n\nVisit our documentation to learn more about our SDKs, join us on Discord to be part of the discussion, view our blog and YouTube channel, or visit our GitHub repository to see our source code."
    },
    {
        "link": "https://stackoverflow.com/questions/45909260/react-native-cross-platform-example-write-once-and-use-anywhere-or-dry",
        "document": "I am very new to React-Native and love it so far. Really great technology and very impressive tooling. I would like to propose it for use in my company.\n\nHowever ... react-native examples demoing code-sharing btw Android and IOS platform are simply nowhere to find??? All I have found after 3-4 weeks looking into it is few excellent but only IOS examples. Below, are just few examples of articles lacking this. Although some of them claim in their title to cover both, they cover only IOS:\n\n... , this list could continue on and on but it should be enough to demonstrate the lack of good resources I'm talking about.\n\nI understand react-native is cross platform in terms that you can write code for both Android and IOS, that is all clear and great.\n\nBut is it sharing the code? In other words, is it DRY? From what I see, it is write once for each platform rather than write once for all platforms. Again, I understand some Views (but not all) are platform specific but again, there is no example to show even that on both Android and IOS in the same project.\n\nWhere is a non-hello-world (real life) example to clearly demonstrates and teaches how to do that? React native used to have it in version 0.20 or so but it was removed and replaced with a HelloWorld example? Seriously @Facebook???\n\nAs per links above, lots of React-Native articles out-there are titled to cover both platforms but then they only talk about IOS without even mentioning any other platform? Very few talk about Android only, again, not even touching other platform in the same project. ... and lots of them are outdated!\n\nI understand that the technology is very new (and very good from what I have seen so far, I really love it).\n\nBut assuming I have to propose React-Native as a next-gen platform to a company, I do not see any convincing cross-platform, code-sharing examples demoing this for both Android, IOS (UWP??) that I could help me learn, understand, build, and demo an example for that proposal.\n\nI am not looking for chatty comments or links to courses but rather examples to show how to do this in more than just CRNA generated HelloWorld app."
    },
    {
        "link": "https://tech-on-diapers.hashnode.dev/creating-cross-platform-applications-with-c-and-xamarin",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/cross-platform/cross-platform-mobile-development-in-visual-studio?view=vs-2022",
        "document": "You can build apps for Android, iOS, Mac Catalyst, and Windows devices by using Visual Studio. As you design your app, use tools in Visual Studio to easily add connected services such as Microsoft 365, Azure App Service, and Application Insights.\n\nBuild your apps by using C# an .NET, HTML and JavaScript, or C++. Share code, strings, images, and in some cases even the user interface.\n\nIf you want to build a game or immersive graphical app, install Visual Studio Tools for Unity (VSTU) and enjoy all of the powerful productivity features of Visual Studio with Unity, the popular cross-platform game/graphics engine and development environment for apps that run on iOS, Android, Windows, and other platforms.\n\nBuild an app for Android, iOS, Mac Catalyst, and Windows (.NET)\n\nWith .NET Multi-platform App UI (.NET MAUI) you can target Android, iOS, Mac Catalyst, and Windows in the same solution, sharing code and even UI.\n\n.NET MAUI is a cross-platform framework for creating native mobile and desktop apps with C# and XAML. .NET MAUI is the evolution of Xamarin.Forms, extended from mobile to desktop scenarios, with UI controls rebuilt from the ground up for performance and extensibility. If you've previously used Xamarin.Forms to build cross-platform user interfaces, you'll notice many similarities with .NET MAUI. However, there are also some differences. Using .NET MAUI, you can create multi-platform apps using a single project, but you can add platform-specific source code and resources if necessary. One of the key aims of .NET MAUI is to enable you to implement as much of your app logic and UI layout as possible in a single code-base.\n\nTo get started, install Visual Studio, select the .NET Multi-platform App UI development option in the installer. If you already have Visual Studio installed, rerun the Visual Studio Installer and select the same .NET Multi-platform App UI development option. When you're done, project templates appear in the New Project dialog box. The easiest way to find .NET MAUI templates is to just search on \"MAUI\". For more information about installing .NET MAUI and building your first app, see Installation and Build your first app.\n\n.NET MAUI exposes the native functionality of Android, iOS, Mac Catalyst, and Windows as .NET classes and methods. Your apps have full access to native APIs and native controls, and they're as responsive as apps written in the native platform languages.\n\nAfter you create a project, you'll use all of the productivity features of Visual Studio. For example, you'll use IntelliSense to explore the native APIs of the mobile platforms, and hot reload to modify your managed source code while the app is running, without the need to manually pause or hit a breakpoint. When you're ready to run your app and see how it looks, you can use the Android SDK emulator and run Windows apps natively. You can also use tethered Android and Windows devices directly. For iOS projects, connect to a networked Mac and start the iOS emulator from Visual Studio, or connect to a tethered device.\n• Android apps built using .NET MAUI compile from C# into an intermediate language (IL) which is then just-in-time (JIT) compiled to a native assembly when the app launches.\n• iOS apps built using .NET MAUI are fully ahead-of-time (AOT) compiled from C# into native ARM assembly code.\n• macOS apps built using .NET MAUI use Mac Catalyst, a solution from Apple that brings your iOS app built with UIKit to the desktop, and augments it with additional AppKit and platform APIs as required.\n• Windows apps built using .NET MAUI use the Windows UI 3 (WinUI 3) library to create native apps that target the Windows desktop.\n\nFor more information about .NET MAUI, see What is .NET MAUI?.\n\nIf you want to create a single app that targets the full breadth of Windows 10 devices, create a universal Windows app. You'll design the app by using a single project and your pages will render properly no matter what device is used to view them.\n\nStart with a Universal Windows Platform (UWP) app project template. Design your pages visually, and then open them in a preview window to see how they appear for various types of devices. If you don't like how a page appears on a device, you can optimize the page to better fit the screen size, resolution, or various orientations such as landscape or portrait mode. You can do all of that by using intuitive tool windows and easily accessible menu options in Visual Studio. When you're ready to run your app, and step through your code, you'll find all of the device emulators and simulators for different types of devices together in one dropdown list that is located on the Standard toolbar.\n\nBuild an app for Android, iOS, and Windows (C++)\n\nFirst, install Visual Studio and the Mobile Development with C++ workload. Then, you can build a native activity application for Android, or an app that targets Windows or iOS. You can target Android, iOS, and Windows in the same solution if you want, and then share code between them by using a cross-platform static or dynamic shared library.\n\nIf you need to build an app for Android that requires any sort of advanced graphics manipulation, such as a game, you can use C++ to do it. Start with the Native Activity Application (Android) project. This project has full support for the Clang toolchain.\n\nWhen you're ready to run your app and see how it looks, use the Android Emulator. It's fast, reliable, and easy to install and configure.\n\nYou can also build an app that targets the full breadth of Windows 10 devices by using C++ and a Universal Windows Platform (UWP) app project template. Read more about this in the Target Windows 10 devices section that appears earlier in this article.\n\nYou can share C++ code between Android, iOS, and Windows by creating a static or dynamic shared library.\n\nYou can consume that library in a Windows, iOS, or Android project, like the ones described earlier in this article. You can also consume it in an app that you build by using .NET MAUI, Java, or any language that lets you invoke functions in an unmanaged DLL.\n\nAs you write code in these libraries, you can use IntelliSense to explore the native APIs of the Android and Windows platforms. These library projects are fully integrated with the Visual Studio debugger so you can set breakpoints. Step through code, and find and fix issues by using all of the advanced features of the debugger.\n\nVisual Studio Tools for Unity (VSTU) is a free extension for Visual Studio that integrates Visual Studio's powerful code editing, productivity, and debugging tools with Unity, the popular cross-platform gaming/graphics engine and development environment for immersive apps that target Windows, iOS, Android, and other platforms including the web.\n\nWith Visual Studio Tools for Unity (VSTU), you can use Visual Studio to write game and editor scripts in C# and then use its powerful debugger to find and fix errors. The latest release of VSTU brings support for Unity 2019.4 and includes syntax coloring for Unity's ShaderLab shader language, better synchronization with Unity, richer debugging, and improved code generation for the MonoBehavior wizard. VSTU also brings your Unity project files, console messages, and the ability to start your game into Visual Studio so you can spend less time switching to and from the Unity Editor while writing code."
    },
    {
        "link": "https://github.com/MicrosoftDocs/xamarin-docs/blob/live/docs/cross-platform/app-fundamentals/building-cross-platform-applications/understanding-the-xamarin-mobile-platform.md",
        "document": "The Xamarin platform consists of many elements that allow you to develop applications for iOS and Android:\n• C# language – Allows you to use a familiar syntax and sophisticated features like Generics, LINQ, and the Parallel Task Library.\n• Mono .NET framework – Provides a cross-platform implementation of the extensive features in Microsoft’s .NET framework.\n• Compiler – Depending on the platform, produces a native app (for example, iOS) or an integrated .NET application and runtime (for example, Android). The compiler also performs many optimizations for mobile deployment such as linking away unused code.\n• IDE tools – The Visual Studio on Mac and Windows allows you to create, build, and deploy Xamarin projects.\n\nIn addition, because the underlying language is C# with the .NET framework, projects can be structured to share code that can also be deployed to Windows Phone.\n\nAlthough Xamarin allows you to write apps in C#, and share the same code across multiple platforms, the actual implementation on each system is different.\n\nThe C# source makes its way into a native app in different ways on each platform:\n• iOS – C# is ahead-of-time (AOT) compiled to ARM assembly language. The .NET framework is included, with unused classes being stripped out during linking to reduce the application size. Apple does not allow runtime code generation on iOS, so some language features are not available (see Xamarin.iOS Limitations ).\n• Android – C# is compiled to IL and packaged with MonoVM + JIT’ing. Unused classes in the framework are stripped out during linking. The application runs side by side with Java/ART (Android runtime) and interacts with the native types via JNI (see Xamarin.Android Limitations ).\n• Windows – C# is compiled to IL and executed by the built-in runtime, and does not require Xamarin tools. Designing Windows applications following Xamarin’s guidance makes it simpler to reuse the code on iOS and Android. The Universal Windows Platform also has a .NET Native option, which behaves similarly to Xamarin.iOS' AOT compilation.\n\nThe linker documentation for Xamarin.iOS and Xamarin.Android provides more information about this part of the compilation process.\n\nRuntime 'compilation' – generating code dynamically with – should be avoided.\n\nApple’s kernel prevents dynamic code generation on iOS devices, therefore emitting code on-the-fly will not work in Xamarin.iOS. Likewise, the Dynamic Language Runtime features cannot be used with Xamarin tools.\n\nSome reflection features do work (for example, MonoTouch.Dialog uses it for the Reflection API), but not code generation.\n\nXamarin makes the features provided by the platform-specific SDK easily accessible with familiar C# syntax:\n• iOS – Xamarin.iOS exposes Apple’s CocoaTouch SDK frameworks as namespaces that you can reference from C#. For example the UIKit framework that contains all the user interface controls can be included with a simple statement.\n• Android – Xamarin.Android exposes Google’s Android SDK as namespaces, so you can reference any part of the supported SDK with a using statement, such as to access the user interface controls.\n• Windows – Windows apps are built using Visual Studio on Windows. Project types include Windows Forms, WPF, WinRT, and the Universal Windows Platform (UWP).\n\nThe beauty of Xamarin is that despite the differences under the hood, Xamarin.iOS, and Xamarin.Android (coupled with Microsoft’s Windows SDKs) offer a seamless experience for writing C# code that can be reused across all three platforms.\n\nBusiness logic, database usage, network access, and other common functions can be written once and reused on each platform, providing a foundation for platform-specific user interfaces that look and perform as native applications.\n\nXamarin development can be done in Visual Studio on either Mac or Windows. The IDE you choose will be determined by the platforms you wish to target.\n\nBecause Windows apps can only be developed on Windows, to build for iOS, Android, and Windows requires Visual Studio for Windows. However it's possible to share projects and files between Windows and Mac computers, so iOS and Android apps can be built on a Mac and shared code could later be added to a Windows project.\n\nThe development requirements for each platform are discussed in more detail in the Requirement guide.\n\nDeveloping iOS applications requires a Mac computer, running macOS. You can also use Visual Studio to write and deploy iOS applications with Xamarin in Visual Studio. However, a Mac is still needed for build and licensing purposes.\n\nApple’s Xcode IDE must be installed to provide the compiler and simulator for testing. You can test on your own devices for free, but to build applications for distribution (for example, the App Store) you must join Apple’s Developer Program ($99 USD per year). Each time you submit or update an application, it must be reviewed and approved by Apple before it is made available for customers to download.\n\nCode is written with the Visual Studio IDE and screen layouts can be built programmatically or edited with Xcode on a Mac.\n\nRefer to the Xamarin.iOS Installation Guide for detailed instructions on getting set up.\n\nAndroid application development requires the Java and Android SDKs to be installed. The SDKs provide the compiler, emulator, and other tools required for building, deployment, and testing. Java, Google’s Android SDK and Xamarin’s tools can all be installed and run on Windows and macOS. The following configurations are recommended:\n\nXamarin provides a unified installer that will configure your system with the pre-requisite Java, Android, and Xamarin tools (including a visual designer for screen layouts). Refer to the Xamarin.Android Installation Guide for detailed instructions.\n\nYou can build and test applications on a real device without any license from Google, however to distribute your application through a store (such as Google Play, Amazon, or Barnes & Noble) a registration fee may be payable to the operator. Google Play will publish your app instantly, while the other stores have an approval process similar to Apple’s.\n\nWindows apps (WinForms, WPF, or UWP) are built with Visual Studio. They do not use Xamarin directly. However, C# code can be shared across Windows, iOS, and Android. Visit Microsoft’s Dev Center to learn about the tools required for Windows development.\n\nA key benefit of using Xamarin is that the application user interface uses native controls on each platform, creating apps that are indistinguishable from an application written in Objective-C or Java (for iOS and Android respectively).\n\nWhen building screens in your app, you can either lay out the controls in code or create complete screens using the design tools available for each platform.\n\nEach platform allows user interface controls to be added to a screen using code. This can be time-consuming as it can be difficult to visualize the finished design when hard-coding pixel coordinates for control positions and sizes.\n\nProgrammatically creating controls does have benefits though, particularly on iOS for building views that resize or render differently across the iPhone and iPad screen sizes.\n\nEach platform has a different method for visually laying out screens:\n• iOS – Storyboards contain multiple Views and Controls, and can be accessed in the .Storyboard file that is included in your project.\n• Android – Xamarin provides an Android drag-and-drop UI designer for Visual Studio.\n• Windows – Microsoft provides a drag-and-drop UI designer in Visual Studio and Blend. The screen layouts are stored as .XAML files.\n\nThese screenshots show the visual screen designers available on each platform:\n\nIn all cases the elements that you create visually can be referenced in your code.\n\nA key benefit of using Xamarin to build cross platform applications is that they can take advantage of native UI toolkits to present a familiar interface to the user. The UI will also perform as fast as any other native application.\n\nSome UI metaphors work across multiple platforms (for example, all three platforms use a similar scrolling-list control) but in order for your application to ‘feel’ right the UI should take advantage of platform-specific user interface elements when appropriate. Examples of platform-specific UI metaphors include:\n• iOS – hierarchical navigation with soft back button, tabs on the bottom of the screen.\n• Android – hardware/system-software back button, action menu, tabs on the top of the screen.\n• Windows – Windows apps can run on desktops, tablets (such as Microsoft Surface), and phones. Windows 10 devices may have hardware back button and live tiles, for example.\n\nIt is recommended that you read the design guidelines relevant to the platforms you are targeting:\n\nThe Xamarin platform allows reuse of existing C# code across all platforms and the integration of libraries written natively for each platform.\n\nBecause Xamarin products use C# and the .NET framework, lots of existing source code (both open source and in-house projects) can be reused in Xamarin.iOS or Xamarin.Android projects. Often the source can simply be added to a Xamarin solution and it will work immediately. If an unsupported .NET framework feature has been used, some tweaks may be required.\n\nExamples of C# source that can be used in Xamarin.iOS or Xamarin.Android include: SQLite-NET, NewtonSoft.JSON, and SharpZipLib.\n\nXamarin provides a tool called btouch that helps create bindings that allow Objective-C libraries to be used in Xamarin.iOS projects. Refer to the Binding Objective-C Types documentation for details on how this is done.\n\nExamples of Objective-C libraries that can be used in Xamarin.iOS include: RedLaser barcode scanning, Google Analytics, and PayPal integration. Open-source Xamarin.iOS bindings are available on GitHub.\n\nXamarin supports using existing Java libraries in Xamarin.Android. Refer to the Binding a Java Library documentation for details on how to use a .JAR file from Xamarin.Android.\n\nOpen-source Xamarin.Android bindings are available on GitHub.\n\n\"Platform Invoke\" technology (P/Invoke) allows managed code (C#) to call methods in native libraries as well as support for native libraries to call back into managed code.\n\nFor example, the SQLite-NET library uses statements like this:\n\nThis binds to the native C-language SQLite implementation in iOS and Android. Developers familiar with an existing C API can construct a set of C# classes to map to the native API and utilize the existing platform code. There is documentation for linking native libraries in Xamarin.iOS, similar principles apply to Xamarin.Android.\n\nMiguel explains CXXI (now called CppSharp) on his blog. An alternative to binding to a C++ library directly is to create a C wrapper and bind to that via P/Invoke."
    },
    {
        "link": "https://developer.okta.com/blog/2018/01/10/build-app-for-ios-android-with-xamarin",
        "document": "Xamarin is a cross-platform technology that makes it possible to build native applications for Android and iOS using a single, shared codebase. Like other technologies such as React Native and NativeScript, it allows development teams to spend less time writing code for both platforms.\n\nXamarin is open-source (and free). Under the hood, it uses Mono (a version of the Microsoft .NET runtime), so Xamarin apps are usually written in C#. You can build Xamarin apps on Windows using Visual Studio, or Mac using Visual Studio for Mac. Even though Xamarin apps are not written in Swift (or Java), they still look and feel like real, native apps on the device.\n\nIn this tutorial, I’ll show you how to use Xamarin to build a basic app for both iOS and Android, even if you’ve never done any app development before!\n\nSkip to the next section if you have a Mac!\n\nIf you don’t have Visual Studio installed, download the free Community Edition from Microsoft.\n\nWhen you install Visual Studio, be sure to pick the Mobile development with .NET workload, which installs the Xamarin tools you need:\n\nIf Visual Studio is already installed, open the Visual Studio Installer to make sure you have the above workload selected.\n\nOnce you have these tools installed, you’re ready to create a Xamarin project! Skip the next section.\n\nIf you have a Mac, you’ll need to install Visual Studio for Mac. Follow the official instructions to install the free Community Edition.\n\nOnce the application is installed, you’re ready to create a Xamarin project!\n\nThe base Xamarin SDK contains API bindings for each mobile platform, so you can call Android or iOS APIs from C# code. This allows you to build native apps using shared C# code, but you still need to design the UI separately for each platform.\n\nXamarin.Forms is an additional library that makes it possible to build your UI once (in XAML, a markup language for describing UI layouts). Xamarin.Forms then does the hard work of translating your XAML layout into the appropriate UI elements on the target platform. You can drop down to the “lower” Xamarin SDK level and interact with the platform APIs whenever you need to.\n\nDeciding whether to use Xamarin.Forms in your project depends on how complex your app is. If you’re building an app that needs UI ultra-tailored for each platform or includes a lot of complex user interactions (such as a game), you’re better off with base Xamarin.\n\nHowever, if you’re building a straightforward app that doesn’t need much platform-specific functionality or custom UI, using Xamarin.Forms means you can write even less code. Data-entry apps, productivity tools, and prototypes are great candidates. Since the goal of this tutorial is building a simple demo app, you’ll use Xamarin.Forms here!\n\nIn Visual Studio, choose File - New Project, pick the Cross-Platform category, and choose the Cross-Platform App (Xamarin.Forms) template. Name the project HelloWorldApp.\n\nThen, pick the Blank App template and the platforms you want to build the app for. Choose Xamarin.Forms as the UI Technology, and .NET Standard as the Code Sharing Strategy:\n\nIn Visual Studio for Mac, choose File - New Solution, pick the Multiplatform - App category, and choose the Blank Forms App template:\n\nCreating the new project may take a few minutes. The Blank App template creates a solution with a few sub-projects:\n• HelloWorldApp: Contains the XAML and shared code for each platform-specific project.\n• HelloWorldApp.Android (or Droid): Android-specific code. For a simple project, you won’t have to change much here.\n• HelloWorldApp.iOS: iOS-specific code. You won’t have to change much here, either.\n\nIf you picked Windows (UWP) as a platform, your solution will contain an additional project targeting Windows devices.\n\nIn this tutorial, you’ll only need to modify the shared code project: HelloWorldApp.\n\nUI views are called “pages” in Xamarin.Forms lingo, and your app already contains one called (or in Visual Studio for Mac). Double-click the XAML file in the Solution Explorer, and replace everything within the tags with this markup:\n\nThis XAML markup creates a basic layout containing Label, Entry (text box), and Button elements. The element names (specified with ) will be used to refer to these elements later in code. These XAML elements are generic and aren’t yet tied to a specific platform. Xamarin.Forms will automatically translate the elements in proper or views when your app runs on iOS or Android.\n\nThe attribute on the Button element wires up the button click event to a handler called , which doesn’t exist yet. You’ll write that next.\n\nEach XAML file is paired with a C# code file, sometimes called a “code-behind”. Open up the code for the (or ) file by expanding it in the Solution Explorer and selecting the file.\n\nBelow the method, add the new method:\n\nYou may need to add the following declaration at the top of the file:\n\nBecause it’s referenced in the attribute, this method will run when the button is pressed or tapped on the XAML page. First, the value of the textbox is assigned to the variable, and then the method is called to display a modal alert on the device.\n\nThat’s it! Your new Xamarin app is ready to go. To test it, you can use a simulator, or you can use Xamarin Live Player to test it on a live device.\n\nTest Your Xamarin App on Your Own Device\n\nThe quickest (and coolest) way to test a Xamarin project is with Xamarin Live Player, a small app you can download onto your own phone or device. After downloading the app, pair it with Visual Studio. Then, pick Live Player as the device target.\n\nStart debugging by pressing the play icon, or choose Run - Start Debugging on the Mac. You’ll be asked to scan a QR code to pair Visual Studio with your device, and Live Player will connect to your computer. (If it hangs, make sure your computer and your device are on the same wi-fi network).\n\nAfter Live Player connects, you’ll be able to immediately start using your app on your device! You can even make changes to the code in Visual Studio and Live Player will refresh the app on your device automatically. Super cool.\n\nIf you have the Visual Studio Android Emulator installed, testing the Android version of your Xamarin app is simple. In the Visual Studio toolbar, pick the HelloWorldApp.Android project and choose an Android device to emulate. Then, click the play button to start the emulator.\n\nThe Android emulator can be slow to load, so give it some time. If everything builds properly, you’ll see your app running on Android:\n\nTesting your Xamarin app on iOS is a little trickier, because it requires a Mac to provide the simulator. (Unless you’re already on a Mac and using Visual Studio for Mac, in which case, you’re good to go!)\n\nIf you’re on Windows and have a Mac handy, follow the official instructions to set up the Mac agent and connect it to Visual Studio. Then, pick the HelloWorld.iOS project, and switch the architecture to iPhone Simulator. Choose a device version and click play.\n\nAfter the project builds, the simulator will launch on the Mac:\n\nThis tutorial only scratches the surface. There’s a ton more you can do with Xamarin!\n• Developing Enterprise Apps using Xamarin.Forms and the accompanying free eBook\n\nDo you want to learn more about Xamarin? What about other cross-platform app stacks like React Native, NativeScript, or Flutter? Let me know in the comments below!"
    },
    {
        "link": "https://reddit.com/r/dotnet/comments/1av5y4y/is_c_right_for_developing_android_apps",
        "document": "Hi ! I've seen the only available frameworks for android app development are Xamarin (abandoned) and MAUI (updated and maintained Xamarin). Though, I feel discouraged by all the internet posts saying how bad it is (errors, huge memory size, hard to use, bad for medium-complex apps).\n\nIs there any truth to that?\n\nI've also heard about Avalonia, but despite having good opinions, I've not really seen it to be as popular as Xamarin."
    }
]