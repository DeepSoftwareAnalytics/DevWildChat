[
    {
        "link": "https://stackoverflow.com/questions/15328256/how-do-i-find-a-certain-value-across-all-tables-and-columns-in-sql-server",
        "document": "I have a hospital database from Philips, but the hospital I work at doesn't have the funding to get them to help me find where data in the application lives in the backend SQL Server database. The schema documentation isn't well done. I need to build a query to find the data but I don't yet know where the data lives.\n\nI'm looking for a highly unique value that will tell me the column where most of the data I need is one I find it.\n\nI'd really not like to pull in all of the greater than 100 tables into Access or Filemaker to try to figure out where the data lives.\n\nIs there an easier method where you can query an entire database, and it will search for a certain value in all columns, across all tables to tell you which table and column that bit of data lives?\n\nI'd also be ok with a software solution like Business Objects that might be able to do something like this (not that I know if Business Objects has that ability... I just know that it can help you find data in a database a little earlier so far).\n\nSo does anyone know the best approach to accomplishing this?"
    },
    {
        "link": "https://sqlservercentral.com/forums/topic/search-all-tables-for-a-specific-value-return-the-location",
        "document": "I need to find a Value in a database and have seen some useful code to do this.\n\nThe only thig is there's littl explanation on how to use it or how it works.\n\nMy needs are slightly different, I just want to search for a value, whether it be Numeric or Text and get a return the Table & Field it belongs to, and if there's more than one match, collect that as well.\n\nCan anyone help?"
    },
    {
        "link": "https://stackoverflow.com/questions/15757263/find-a-string-by-searching-all-tables-in-sql-server",
        "document": "I want to search for string say john . The result should show the tables and their respective row that contain john .\n\nIs there any way to search for a string in all tables of a database in SQL Server?\n\nThis question already has answers here :\n\nWhy not try some of the third party tools that can be integrated into SSMS? I’ve worked with ApexSQL Search with good success for both schema and data search and there is also SSMS tools pack that has this feature. Stored procedure above is really great; it’s just that this is way more convenient in my opinion. Also, it would require some slight modifications if you want to search for datetime columns or GUID columns and such…\n\nTo update TechDo's answer for SQL server 2012. You need to change: to Other wise you will get the following error: Deprecated feature 'Table hint without WITH' is not supported in this version of SQL Server. Below is the complete updated stored procedure: CREATE PROC SearchAllTables ( @SearchStr nvarchar(100) ) AS BEGIN CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) SET @TableName = '' SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''') WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = '' SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) ), 'IsMSShipped' ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal') AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO #Results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) FROM ' + @TableName + 'WITH (NOLOCK) ' + ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2 ) END END END SELECT ColumnName, ColumnValue FROM #Results END\n\nI have written a SP for the this which returns the search results in form of Table name, the Column names in which the search keyword string was found as well as the searches the corresponding rows as shown in below screen shot. This might not be the most efficient solution but you can always modify and use it according to your need. IF OBJECT_ID('sp_KeywordSearch', 'P') IS NOT NULL DROP PROC sp_KeywordSearch GO CREATE PROCEDURE sp_KeywordSearch @KeyWord NVARCHAR(100) AS BEGIN DECLARE @Result TABLE (TableName NVARCHAR(300), ColumnName NVARCHAR(MAX)) DECLARE @Sql NVARCHAR(MAX), @TableName NVARCHAR(300), @ColumnName NVARCHAR(300), @Count INT DECLARE @tableCursor CURSOR SET @tableCursor = CURSOR LOCAL SCROLL FOR SELECT N'SELECT @Count = COUNT(1) FROM [dbo].[' + T.TABLE_NAME + '] WITH (NOLOCK) WHERE CAST([' + C.COLUMN_NAME + '] AS NVARCHAR(MAX)) LIKE ''%' + @KeyWord + N'%''', T.TABLE_NAME, C.COLUMN_NAME FROM INFORMATION_SCHEMA.TABLES AS T WITH (NOLOCK) INNER JOIN INFORMATION_SCHEMA.COLUMNS AS C WITH (NOLOCK) ON T.TABLE_SCHEMA = C.TABLE_SCHEMA AND T.TABLE_NAME = C.TABLE_NAME WHERE T.TABLE_TYPE = 'BASE TABLE' AND C.TABLE_SCHEMA = 'dbo' AND C.DATA_TYPE NOT IN ('image', 'timestamp') OPEN @tableCursor FETCH NEXT FROM @tableCursor INTO @Sql, @TableName, @ColumnName WHILE (@@FETCH_STATUS = 0) BEGIN SET @Count = 0 EXEC sys.sp_executesql @Sql, N'@Count INT OUTPUT', @Count OUTPUT IF @Count > 0 BEGIN INSERT INTO @Result (TableName, ColumnName) VALUES (@TableName, @ColumnName) END FETCH NEXT FROM @tableCursor INTO @Sql, @TableName, @ColumnName END CLOSE @tableCursor DEALLOCATE @tableCursor SET @tableCursor = CURSOR LOCAL SCROLL FOR SELECT SUBSTRING(TB.Sql, 1, LEN(TB.Sql) - 3) AS Sql, TB.TableName, SUBSTRING(TB.Columns, 1, LEN(TB.Columns) - 1) AS Columns FROM (SELECT R.TableName, (SELECT R2.ColumnName + ', ' FROM @Result AS R2 WHERE R.TableName = R2.TableName FOR XML PATH('')) AS Columns, 'SELECT * FROM ' + R.TableName + ' WITH (NOLOCK) WHERE ' + (SELECT 'CAST(' + R2.ColumnName + ' AS NVARCHAR(MAX)) LIKE ''%' + @KeyWord + '%'' OR ' FROM @Result AS R2 WHERE R.TableName = R2.TableName FOR XML PATH('')) AS Sql FROM @Result AS R GROUP BY R.TableName) TB ORDER BY TB.Sql OPEN @tableCursor FETCH NEXT FROM @tableCursor INTO @Sql, @TableName, @ColumnName WHILE (@@FETCH_STATUS = 0) BEGIN PRINT @Sql SELECT @TableName AS [Table], @ColumnName AS Columns EXEC(@Sql) FETCH NEXT FROM @tableCursor INTO @Sql, @TableName, @ColumnName END CLOSE @tableCursor DEALLOCATE @tableCursor END\n\nNot to take away from the excellent answer by @Brandon but the OP requested \"The result should show the tables and their respective row\". I created a record-level solution based on the original answer from @Brandon that also avoids the use of CURSORs used by others here by simply concatenating all the appropriate columns into one string. (I have the feeling this would perform better but I honestly haven't compared results - feel free to do so and provide feedback here.) NB I have used the STRING_AGG function to concatenate the columns. If you have an older version of SQL Server you may need to use one of the alternate methods that can be found online. CREATE PROC [dbo].[SearchAllTablesByRecord] ( @SearchStr NVARCHAR(100) ) AS BEGIN SET NOCOUNT ON DECLARE @TableName NVARCHAR(256), @SearchStr2 NVARCHAR(110) DECLARE @ColumnList NVARCHAR(2048), @ColumnJoin NVARCHAR(2048) SET @TableName = '' SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''') WHILE @TableName IS NOT NULL BEGIN SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) ), 'IsMSShipped' ) = 0 ) PRINT @TableName -- For progress monitoring SET @ColumnList = ( SELECT STRING_AGG(QUOTENAME(COLUMN_NAME),',') FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar') ) SET @ColumnJoin = REPLACE(@ColumnList,',','+') IF @ColumnList <> '' EXEC ( 'SELECT ''' + @TableName + ''' AS [Table],' + @ColumnList + ' INTO #Results FROM ' + @TableName + ' (NOLOCK) ' + ' WHERE ' + @ColumnJoin + ' LIKE ' + @SearchStr2 + ' IF @@ROWCOUNT > 0 SELECT * FROM #Results' ) END END\n\nThere are lots of workable answers already. Just thought I would add one I came up with that has a lot of optional funcionality. --======================================================================= -- MSSQL Unified Search -- Minimum compatibility level = 130 (SQL Server 2016) -- NOTE: The minimum compatibility level is required by the built-in STRING_SPLIT() function. -- However, you can create the STRING_SPLIT() function at the bottom of this script for -- lower versions of MSSQL Server. -- -- Usage: -- Set the parameters below and execute this script. -- /************************ Enter Parameters Here ************************/ /**/ /**/ DECLARE @SearchString VARCHAR(1000) = 'string to search for'; -- Accepts SQL wilcards /**/ /**/ DECLARE @IncludeUserTables BIT = 1; /**/ DECLARE @IncludeViews BIT = 0; /**/ DECLARE @IncludeStoredProcedures BIT = 0; /**/ DECLARE @IncludeFunctions BIT = 0; /**/ DECLARE @IncludeTriggers BIT = 0; /**/ /**/ DECLARE @DebugMode BIT = 0; /**/ DECLARE @ExcludeColumnTypes NVARCHAR(500) = 'text, ntext, char, nchar, timestamp, bigint, tinyint, smallint, bit, date, time, smalldatetime, datetime, datetime2, real, money, float, decimal, binary, varbinary, image'; -- Comma delimited list /**/ /***********************************************************************/ SET NOCOUNT ON; SET @SearchString = QUOTENAME(@SearchString,''''); DECLARE @Results TABLE ([ObjectType] NVARCHAR(200), [ObjectName] NVARCHAR(200), [ColumnName] NVARCHAR(400), [Value] NVARCHAR(MAX), [SelectStatement] NVARCHAR(1000)); DECLARE @ExcludeColTypes TABLE (system_type_id INT); INSERT INTO @ExcludeColTypes ([system_type_id]) SELECT [system_type_id] FROM sys.types WHERE [name] IN ( SELECT LTRIM(RTRIM([value])) FROM STRING_SPLIT(@ExcludeColumnTypes,',') ); DECLARE @ObjectType NVARCHAR(200); DECLARE @ObjectName NVARCHAR(200); DECLARE @Value NVARCHAR(MAX); DECLARE @SelectStatement NVARCHAR(1000); DECLARE @Query NVARCHAR(4000); /********************* Table Objects *********************/ IF (@IncludeUserTables = 1) BEGIN DECLARE @TableObjectId INT = (SELECT MIN([object_id]) FROM sys.tables); DECLARE @ColumnId INT; WHILE @TableObjectId IS NOT NULL BEGIN SELECT @ObjectType = 'USER TABLE'; SELECT @ObjectName = '[' + SCHEMA_NAME([schema_id]) + '].[' + OBJECT_NAME(@TableObjectId) + ']' FROM sys.tables WHERE [object_id] = @TableObjectId; SET @ColumnId = (SELECT MIN([column_id]) FROM sys.columns WHERE [system_type_id] NOT IN (SELECT [system_type_id] FROM @ExcludeColTypes) AND [object_id] = @TableObjectId); WHILE @ColumnId IS NOT NULL BEGIN SELECT @Value = '[' + [name] +']' FROM sys.columns WHERE [object_id] = @TableObjectId AND column_id = @ColumnId; SET @SelectStatement = 'SELECT * FROM ' + @ObjectName + ' WHERE CAST(' + @Value + ' AS NVARCHAR(4000)) LIKE ' + @SearchString + ';'; SET @Query = 'SELECT ' + QUOTENAME(@ObjectType, '''') + ', ' + QUOTENAME(@ObjectName, '''') + ', ' + QUOTENAME(@Value, '''') + ', ' + @Value + ', ''' + REPLACE(@SelectStatement,'''','''''') + '''' + ' FROM ' + @ObjectName + ' WHERE CAST(' + @Value + ' AS NVARCHAR(4000)) LIKE ' + @SearchString + ';'; IF @DebugMode = 0 BEGIN INSERT INTO @Results EXEC(@Query); END; ELSE BEGIN PRINT 'Select Statement: ' + @SelectStatement; PRINT 'Query: ' + @Query; END; SET @ColumnId = (SELECT MIN([column_id]) FROM sys.columns WHERE [system_type_id] NOT IN (SELECT [system_type_id] FROM @ExcludeColTypes) AND [object_id] = @TableObjectId AND [column_id] > @ColumnId); END; SET @TableObjectId = (SELECT MIN([object_id]) FROM sys.tables WHERE [object_id] > @TableObjectId); END; END; /********************* Objects Other than Tables *********************/ SET @Query = 'SELECT ' + 'ObjectType = CASE ' + 'WHEN b.[type] = ''V'' THEN ''VIEW'' ' + 'WHEN b.[type] = ''P'' THEN ''STORED PROCEDURE'' ' + 'WHEN b.[type] = ''FN'' THEN ''SCALAR-VALUED FUNCTION'' ' + 'WHEN b.[type] = ''IF'' THEN ''TABLE-VALUED FUNCTION'' ' + 'WHEN b.[type] = ''TR'' THEN ''TRIGGER'' ' + 'END ' + ',[ObjectName] = ''['' + SCHEMA_NAME(b.[schema_id]) + ''].['' + OBJECT_NAME(a.[object_id]) + '']'' ' + ',[ColumnName] = NULL ' + ',[Value] = a.[definition] ' + ',[SelectStatement] = ''SP_HELPTEXT '' + QUOTENAME(''['' + SCHEMA_NAME(b.[schema_id]) + ''].['' + OBJECT_NAME(a.[object_id]) + '']'','''''''') + '';'' ' + 'FROM [sys].[sql_modules] a ' + 'JOIN [sys].[objects] b ON a.[object_id] = b.[object_id] ' + 'WHERE ' + '( ' + ' a.[definition] LIKE ' + @SearchString + ') ' + 'AND ' + '( ' + ' ( ' + CAST(@IncludeViews AS VARCHAR(1)) + ' = 1 ' + ' AND ' + ' b.[type] IN (''V'') ' + ' ) ' + ' OR ' + ' ( ' + CAST(@IncludeStoredProcedures AS VARCHAR(1)) + ' = 1 ' + ' AND ' + ' b.[type] IN (''P'') ' + ' ) ' + ' OR ' + ' ( ' + CAST(@IncludeFunctions AS VARCHAR(1)) + ' = 1 ' + ' AND ' + ' b.[type] IN (''FN'',''IF'') ' + ' ) ' + ' OR ' + ' ( ' + CAST(@IncludeTriggers AS VARCHAR(1)) + ' = 1 ' + ' AND ' + ' b.[type] IN (''TR'') ' + ' ) ' + '); '; IF @DebugMode = 0 BEGIN INSERT INTO @Results EXEC(@Query); END; ELSE BEGIN PRINT 'Select Statement: ' + @SelectStatement; PRINT 'Query: ' + @Query; END; IF @DebugMode = 0 BEGIN SELECT [ObjectType] ,[ObjectName] ,[ColumnName] ,[Value] ,[Count] = CASE WHEN [ObjectType] IN ('USER TABLE') THEN COUNT(1) ELSE NULL END ,[SelectStatement] FROM @Results GROUP BY [ObjectType], [ObjectName], [ColumnName], [Value], [SelectStatement] ORDER BY [Value]; END; /********************** STRING_SPLIT() FUNCTION ********************** CREATE FUNCTION STRING_SPLIT ( @Expression nvarchar(4000) ,@Delimiter nvarchar(100) ) RETURNS @Ret TABLE ([value] NVARCHAR(4000)) AS BEGIN DECLARE @Start INT = 0, @End INT, @Length INT; SELECT @End = CHARINDEX(@Delimiter,@Expression), @Length = @End - @Start; IF @End <= 0 BEGIN INSERT INTO @Ret ([value]) VALUES (@Expression); END ELSE BEGIN WHILE @Length >= 0 BEGIN INSERT INTO @Ret ([value]) SELECT ltrim(rtrim(substring(@Expression,@Start,@Length))); SELECT @Start = @End + LEN(@Delimiter) SELECT @End = CHARINDEX(@Delimiter,@Expression,@Start) IF @End < 1 SELECT @End = LEN(@Expression) + 1; SELECT @Length = @End - @Start; END; END; RETURN; END; *********************************************************************/\n\nThis was very helpful. I wanted to import this function to a Postgre SQL database. Thought i would share it with anyone who is interested. Will have them a few hours. Note: this function creates a list of SQL statements that can be copied and executed on the Postgre database. Maybe someone smarter then me can get Postgre to create and execute the statements all in one function. CREATE OR REPLACE FUNCTION SearchAllTables(_search text) RETURNS TABLE( txt text ) as $funct$ DECLARE __COUNT int; __SQL text; BEGIN EXECUTE 'SELECT COUNT(0) FROM INFORMATION_SCHEMA.COLUMNS WHERE DATA_TYPE = ''text'' AND table_schema = ''public'' ' INTO __COUNT; RETURN QUERY SELECT CASE WHEN ROW_NUMBER() OVER (ORDER BY table_name) < __COUNT THEN 'SELECT ''' || table_name ||'.'|| column_name || ''' AS tbl, \"' || column_name || '\" AS col FROM \"public\".\"' || \"table_name\" || '\" WHERE \"'|| \"column_name\" || '\" ILIKE ''%' || _search || '%'' UNION ALL' ELSE 'SELECT ''' || table_name ||'.'|| column_name || ''' AS tbl, \"' || column_name || '\" AS col FROM \"public\".\"' || \"table_name\" || '\" WHERE \"'|| \"column_name\" || '\" ILIKE ''%' || _search || '%''' END AS txt FROM INFORMATION_SCHEMA.COLUMNS WHERE DATA_TYPE = 'text' AND table_schema = 'public'; END $funct$ LANGUAGE plpgsql;\n\nThe answer that was mentioned in this post already several times I have adopted a little bit because I needed to search in only one table too: ALTER PROC dbo.db_compare_SearchAllTables_sp ( @SearchStr nvarchar(100), @TableName nvarchar(256) = '' ) AS BEGIN if PARSENAME(@TableName, 2) is null set @TableName = 'dbo.' + QUOTENAME(@TableName, '\"') declare @results TABLE(ColumnName nvarchar(370), ColumnValue nvarchar(3630)) SET NOCOUNT ON DECLARE @ColumnName nvarchar(128) = '', @SearchStr2 nvarchar(110) SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''') IF @TableName <> '' WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar') AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO @results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) FROM ' + @TableName + ' WITH (NOLOCK) ' + ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2 ) END END ELSE WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = '' SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) ), 'IsMSShipped' ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar') AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO @results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) FROM ' + @TableName + ' WITH (NOLOCK) ' + ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2 ) END END END SELECT ColumnName, ColumnValue FROM @results END\n\nThis script allows searching through all occurrences of all fields in all tables within a database, regardless of the data type! Indeed, if it is a field with a numeric data type, the function attempts to convert the expression into the correct data type. If the conversion succeeds, it returns the converted value. If the conversion fails, it returns instead of raising an exception. This is very convenient when you are unsure of the data type or want to use the same script for any search. DECLARE @searchValue NVARCHAR(255) = '1856' -- Text or Number (text is converted in number if necessary) IF OBJECT_ID('tempdb..#SearchResults') IS NOT NULL BEGIN DROP TABLE #SearchResults END CREATE TABLE #SearchResults ( TableName NVARCHAR(128), ColumnName NVARCHAR(128), Value NVARCHAR(MAX) ) DECLARE @tableName NVARCHAR(128) DECLARE @columnName NVARCHAR(128) DECLARE @query NVARCHAR(MAX) DECLARE @type NVARCHAR(50) DECLARE db_cursor CURSOR FOR SELECT t.name AS TableName, c.name AS ColumnName, ty.name AS Type FROM sys.tables t JOIN sys.columns c ON t.object_id = c.object_id JOIN sys.types ty ON c.user_type_id = ty.user_type_id WHERE ty.name IN ('nvarchar', 'varchar', 'int', 'bigint', 'smallint', 'tinyint') OPEN db_cursor FETCH NEXT FROM db_cursor INTO @tableName, @columnName, @type WHILE @@FETCH_STATUS = 0 BEGIN IF @type IN ('nvarchar', 'varchar') BEGIN SET @query = 'INSERT INTO #SearchResults (TableName, ColumnName, Value) SELECT DISTINCT ''' + @tableName + ''', ''' + @columnName + ''', ' + 'CONVERT(NVARCHAR(MAX), ' + @columnName + ') FROM ' + @tableName + ' WHERE ' + @columnName + ' LIKE ''%' + @searchValue + '%''' END ELSE IF @type IN ('int', 'bigint', 'smallint', 'tinyint') BEGIN SET @query = 'INSERT INTO #SearchResults (TableName, ColumnName, Value) SELECT DISTINCT ''' + @tableName + ''', ''' + @columnName + ''', ' + 'CONVERT(NVARCHAR(MAX), ' + @columnName + ') FROM ' + @tableName + ' WHERE ' + @columnName + ' = TRY_CAST(' + QUOTENAME(@searchValue, '''') + ' AS ' + @type + ')' END EXEC sp_executesql @query FETCH NEXT FROM db_cursor INTO @tableName, @columnName, @type END CLOSE db_cursor DEALLOCATE db_cursor SELECT * FROM #SearchResults DROP TABLE #SearchResults"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/208017/search-a-value-in-all-database",
        "document": "A Microsoft extension to the ANSI SQL language that includes procedural programming, local variables, and various support functions."
    },
    {
        "link": "https://reddit.com/r/SQL/comments/1gt8su/sql_server_how_do_i_search_for_a_specific_value",
        "document": "I have been tasked to search and find which table a certain field lives in, but the tables were originally named very poorely.\n\nI have this query below that has helped searching for a column name within a table. The results show me the Table Name, Schema Name and Column Name. But now I need to search for a value, and I need to know which table the value is in. For example, I would like the results to show \"Table Name\", \"Schema Name\" and \"Column Name\" when I search for \"Value1\". Please let me know if you can help.\n\nHere is the query I use to search for Column Name:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/cursors?view=sql-server-ver16",
        "document": "Operations in a relational database act on a complete set of rows. For example, the set of rows returned by a statement consists of all the rows that satisfy the conditions in the clause of the statement. This complete set of rows returned by the statement is known as the result set. Applications, especially interactive online applications, can't always work effectively with the entire result set as a unit. These applications need a mechanism to work with one row or a small block of rows at a time. Cursors are an extension to result sets that provide that mechanism.\n• None Allowing positioning at specific rows of the result set.\n• None Retrieving one row or block of rows from the current position in the result set.\n• None Supporting data modifications to the rows at the current position in the result set.\n• None Supporting different levels of visibility to changes made by other users to the database data that is presented in the result set.\n• None Providing Transact-SQL statements in scripts, stored procedures, and triggers access to the data in a result set.\n\nIn some scenarios, if there's a primary key on a table, a loop can be used instead of a cursor, without incurring in the overhead of a cursor.\n\nHowever, there are scenarios where cursors aren't only unavoidable, they're actually needed. When that is the case, if there's no requirement to update tables based on the cursor, then use firehose cursors, meaning fast-forward and read-only cursors.\n\nCursors can use worktables. Just like aggregation or sort operations that spill, these incur I/O costs, and are a potential performance bottleneck. cursors use worktables from its inception. For more information, see the worktables section in the Query processing architecture guide.\n\nA forward-only cursor is specified as and and doesn't support scrolling. These are also called firehose cursors and support only fetching the rows serially from the start to the end of the cursor. The rows aren't retrieved from the database until they're fetched. The effects of all , , and statements made by the current user or committed by other users that affect rows in the result set are visible as the rows are fetched from the cursor.\n\nBecause the cursor can't be scrolled backward, most changes made to rows in the database after the row was fetched aren't visible through the cursor. In cases where a value used to determine the location of the row within the result set is modified, such as updating a column covered by a clustered index, the modified value is visible through the cursor.\n\nAlthough the database API cursor models consider a forward-only cursor to be a distinct type of cursor, SQL Server doesn't. SQL Server considers both forward-only and scroll as options that can be applied to static, keyset-driven, and dynamic cursors. Transact-SQL cursors support forward-only static, keyset-driven, and dynamic cursors. The database API cursor models assume that static, keyset-driven, and dynamic cursors are always scrollable. When a database API cursor attribute or property is set to forward-only, SQL Server implements this as a forward-only dynamic cursor.\n\nThe complete result set of a static cursor is built in when the cursor is opened. A static cursor always displays the result set as it was when the cursor was opened. Static cursors detect few or no changes, but consume relatively few resources while scrolling.\n\nThe cursor doesn't reflect any changes made in the database that affect either the membership of the result set or changes to the values in the columns of the rows that make up the result set. A static cursor doesn't display new rows inserted in the database after the cursor was opened, even if they match the search conditions of the cursor statement. If rows making up the result set are updated by other users, the new data values aren't displayed in the static cursor. The static cursor displays rows deleted from the database after the cursor was opened. No , , or operations are reflected in a static cursor (unless the cursor is closed and reopened), not even modifications made using the same connection that opened the cursor.\n\nBecause the result set of a static cursor is stored in a worktable in , the size of the rows in the result set can't exceed the maximum row size for a SQL Server table.\n\nFor more information, see the worktables section in the Query processing architecture guide. For more information on max row size, see Maximum capacity specifications for SQL Server.\n\nTransact-SQL uses the term insensitive for static cursors. Some database APIs identify them as snapshot cursors.\n\nThe membership and order of rows in a keyset-driven cursor are fixed when the cursor is opened. Keyset-driven cursors are controlled by a set of unique identifiers, or keys, known as the keyset. The keys are built from a set of columns that uniquely identify the rows in the result set. The keyset is the set of the key values from all the rows that qualified for the statement at the time the cursor was opened. The keyset for a keyset-driven cursor is built in when the cursor is opened.\n\nDynamic cursors are the opposite of static cursors. Dynamic cursors reflect all changes made to the rows in their result set when scrolling through the cursor. The data values, order, and membership of the rows in the result set can change on each fetch. All , , and statements made by all users are visible through the cursor. Updates are visible immediately if they're made through the cursor using either an API function such as or the Transact-SQL clause. Updates made outside the cursor aren't visible until they're committed, unless the cursor transaction isolation level is set to read uncommitted. For more information on isolation levels, see SET TRANSACTION ISOLATION LEVEL (Transact-SQL).\n• The Transact-SQL language supports a syntax for using cursors modeled after the ISO cursor syntax.\n• SQL Server supports the cursor functionality of these database APIs:\n\nAn application should never mix these two methods of requesting a cursor. An application that uses the API to specify cursor behaviors shouldn't then execute a Transact-SQL statement to also request a Transact-SQL cursor. An application should only execute if it sets all the API cursor attributes back to their defaults.\n\nIf neither a Transact-SQL nor API cursor is requested, SQL Server defaults to returning a complete result set, known as a default result set, to the application.\n\nTransact-SQL cursors and API cursors have different syntax, but the following general process is used with all SQL Server cursors:\n• None Associate a cursor with the result set of a Transact-SQL statement, and define characteristics of the cursor, such as whether the rows in the cursor can be updated.\n• None Execute the Transact-SQL statement to populate the cursor.\n• None Retrieve the rows in the cursor you want to see. The operation to retrieve one row or one block of rows from a cursor is called a fetch. Performing a series of fetches to retrieve rows in either a forward or backward direction is called scrolling.\n• None Optionally, perform modification operations (update or delete) on the row at the current position in the cursor."
    },
    {
        "link": "https://stackoverflow.com/questions/58141/why-is-it-considered-bad-practice-to-use-cursors-in-sql-server",
        "document": "I knew of some performance reasons back in the SQL 7 days, but do the same issues still exist in SQL Server 2005? If I have a resultset in a stored procedure that I want to act upon individually, are cursors still a bad choice? If so, why?\n\nBecause cursors take up memory and create locks. What you are really doing is attempting to force set-based technology into non-set based functionality. And, in all fairness, I should point out that cursors do have a use, but they are frowned upon because many folks who are not used to using set-based solutions use cursors instead of figuring out the set-based solution. But, when you open a cursor, you are basically loading those rows into memory and locking them, creating potential blocks. Then, as you cycle through the cursor, you are making changes to other tables and still keeping all of the memory and locks of the cursor open. All of which has the potential to cause performance issues for other users. So, as a general rule, cursors are frowned upon. Especially if that's the first solution arrived at in solving a problem.\n\nThe above comments about SQL being a set-based environment are all true. However there are times when row-by-row operations are useful. Consider a combination of metadata and dynamic-sql. As a very simple example, say I have 100+ records in a table that define the names of tables that I want to copy/truncate/whatever. Which is best? Hardcoding the SQL to do what I need to? Or iterate through this resultset and use dynamic-SQL (sp_executesql) to perform the operations? There is no way to achieve the above objective using set-based SQL. So, to use cursors or a while loop (pseudo-cursors)? SQL Cursors are fine as long as you use the correct options: INSENSITIVE will make a temporary copy of your result set (saving you from having to do this yourself for your pseudo-cursor). READ_ONLY will make sure no locks are held on the underlying result set. Changes in the underlying result set will be reflected in subsequent fetches (same as if getting TOP 1 from your pseudo-cursor). Read about the available options before ruling all cursors as evil.\n\nThere is a work around about cursors that I use every time I need one. I create a table variable with an identity column in it. insert all the data i need to work with in it. Then make a while block with a counter variable and select the data I want from the table variable with a select statement where the identity column matches the counter. This way i dont lock anything and use alot less memory and its safe, i will not lose anything with a memory corruption or something like that. And the block code is easy to see and handle. This is a simple example: DECLARE @TAB TABLE(ID INT IDENTITY, COLUMN1 VARCHAR(10), COLUMN2 VARCHAR(10)) DECLARE @COUNT INT, @MAX INT, @CONCAT VARCHAR(MAX), @COLUMN1 VARCHAR(10), @COLUMN2 VARCHAR(10) SET @COUNT = 1 INSERT INTO @TAB VALUES('TE1S', 'TE21') INSERT INTO @TAB VALUES('TE1S', 'TE22') INSERT INTO @TAB VALUES('TE1S', 'TE23') INSERT INTO @TAB VALUES('TE1S', 'TE24') INSERT INTO @TAB VALUES('TE1S', 'TE25') SELECT @MAX = @@IDENTITY WHILE @COUNT <= @MAX BEGIN SELECT @COLUMN1 = COLUMN1, @COLUMN2 = COLUMN2 FROM @TAB WHERE ID = @COUNT IF @CONCAT IS NULL BEGIN SET @CONCAT = '' END ELSE BEGIN SET @CONCAT = @CONCAT + ',' END SET @CONCAT = @CONCAT + @COLUMN1 + @COLUMN2 SET @COUNT = @COUNT + 1 END SELECT @CONCAT\n\nCursors are usually not the disease, but a symptom of it: not using the set-based approach (as mentioned in the other answers). Not understanding this problem, and simply believing that avoiding the \"evil\" cursor will solve it, can make things worse. For example, replacing cursor iteration by other iterative code, such as moving data to temporary tables or table variables, to loop over the rows in a way like: Such an approach, as shown in the code of another answer, makes things much worse and doesn't fix the original problem. It's an anti-pattern called cargo cult programming: not knowing WHY something is bad and thus implementing something worse to avoid it! I recently changed such code (using a #temptable and no index on identity/PK) back to a cursor, and updating slightly more than 10000 rows took only 1 second instead of almost 3 minutes. Still lacking set-based approach (being the lesser evil), but the best I could do that moment. Another symptom of this lack of understanding can be what I sometimes call \"one object disease\": database applications which handle single objects through data access layers or object-relational mappers. Typically code like: The first will usually flood the database with tons of SELECTs, one round trip for each, especially when object trees/graphs come into play and the infamous SELECT N+1 problem strikes. This is the application side of not understanding relational databases and set based approach, just the same way cursors are when using procedural database code, like T-SQL or PL/SQL!\n\nThere are very, very few cases where the use of a cursor is justified. There are almost no cases where it will outperform a relational, set-based query. Sometimes it is easier for a programmer to think in terms of loops, but the use of set logic, for example to update a large number of rows in a table, will result in a solution that is not only many less lines of SQL code, but that runs much faster, often several orders of magnitude faster. Even the fast forward cursor in Sql Server 2005 can't compete with set-based queries. The graph of performance degradation often starts to look like an n^2 operation compared to set-based, which tends to be more linear as the data set grows very large.\n\nSometimes the nature of the processing you need to perform requires cursors, though for performance reasons it's always better to write the operation(s) using set-based logic if possible. I wouldn't call it \"bad practice\" to use cursors, but they do consume more resources on the server (than an equivalent set-based approach) and more often than not they aren't necessary. Given that, my advice would be to consider other options before resorting to a cursor. There are several types of cursors (forward-only, static, keyset, dynamic). Each one has different performance characteristics and associated overhead. Make sure you use the correct cursor type for your operation. Forward-only is the default. One argument for using a cursor is when you need to process and update individual rows, especially for a dataset that doesn't have a good unique key. In that case you can use the FOR UPDATE clause when declaring the cursor and process updates with UPDATE ... WHERE CURRENT OF. Note that \"server-side\" cursors used to be popular (from ODBC and OLE DB), but ADO.NET does not support them, and AFAIK never will."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/declare-cursor-transact-sql?view=sql-server-ver16",
        "document": "Defines the attributes of a Transact-SQL server cursor, such as its scrolling behavior and the query used to build the result set on which the cursor operates. accepts both a syntax based on the ISO standard and a syntax using a set of Transact-SQL extensions.\n\nThe name of the Transact-SQL server cursor defined. cursor_name must conform to the rules for identifiers.\n\nDefines a cursor that makes a temporary copy of the data to be used by the cursor. All requests to the cursor are answered from this temporary table in . Therefore, base table modifications aren't reflected in the data returned by fetches made to this cursor, and this cursor doesn't allow modifications. When ISO syntax is used, if is omitted, committed deletes and updates made to the underlying tables (by any user) are reflected in subsequent fetches.\n\nSpecifies that all fetch options ( , , , , , ) are available. If isn't specified in an ISO , is the only fetch option supported. can't be specified if is also specified. If isn't specified, then only the fetch option is available, and the cursor becomes .\n\nA standard statement that defines the result set of the cursor. The keywords , and aren't allowed within select_statement of a cursor declaration.\n\nSQL Server implicitly converts the cursor to another type if clauses in select_statement conflict with the functionality of the requested cursor type.\n\nPrevents updates made through this cursor. The cursor can't be referenced in a clause in an or statement. This option overrides the default capability of a cursor to be updated.\n\nDefines updatable columns within the cursor. If is specified, only the columns listed allow modifications. If is specified without a column list, all columns can be updated.\n\nThe name of the Transact-SQL server cursor defined. cursor_name must conform to the rules for identifiers.\n\nSpecifies that the scope of the cursor is local to the batch, stored procedure, or trigger in which the cursor was created. The cursor name is only valid within this scope. The cursor can be referenced by local cursor variables in the batch, stored procedure, or trigger, or a stored procedure parameter. An parameter is used to pass the local cursor back to the calling batch, stored procedure, or trigger, which can assign the parameter to a cursor variable to reference the cursor after the stored procedure terminates. The cursor is implicitly deallocated when the batch, stored procedure, or trigger terminates, unless the cursor was passed back in an parameter. If it passes back in an parameter, the cursor is deallocated when the last variable referencing it is deallocated or goes out of scope.\n\nSpecifies that the scope of the cursor is global to the connection. The cursor name can be referenced in any stored procedure or batch executed by the connection. The cursor is only implicitly deallocated at disconnect.\n\nSpecifies that the cursor can only move forward and be scrolled from the first to the last row. is the only supported fetch option. All insert, update, and delete statements made by the current user (or committed by other users) that affect rows in the result set, are visible as the rows are fetched. Because the cursor can't be scrolled backward, however, changes made to rows in the database after the row was fetched aren't visible through the cursor. Forward-only cursors are dynamic by default, meaning that all changes are detected as the current row is processed. This provides faster cursor opening and enables the result set to display updates made to the underlying tables. While forward-only cursors don't support backward scrolling, applications can return to the beginning of the result set by closing and reopening the cursor.\n\nIf is specified without the , , or keywords, the cursor operates as a dynamic cursor. When or aren't specified, is the default, unless the keywords , , or are specified. , , and cursors default to . Unlike database APIs such as ODBC and ADO, is supported with , , and Transact-SQL cursors.\n\nSpecifies that the cursor always displays the result set as it was when the cursor was first opened, and makes a temporary copy of the data to be used by the cursor. All requests to the cursor are answered from this temporary table in . Therefore inserts, updates, and deletes made to base tables aren't reflected in the data returned by fetches made to this cursor, and this cursor doesn't detect changes made to the membership, order, or values of the result set after the cursor is opened. Static cursors might detect their own updates, deletes, and inserts, although they aren't required to do so.\n\nFor example, suppose a static cursor fetches a row, and another application then updates that row. If the application refetches the row from the static cursor, the values it sees are unchanged, despite the changes made by the other application. All types of scrolling are supported.\n\nSpecifies that the membership and order of rows in the cursor are fixed when the cursor is opened. The set of keys that uniquely identify the rows is built into a table in known as the keyset. This cursor provides functionality between a static and a dynamic cursor in its ability to detect changes. Like a static cursor, it doesn't always detect changes to the membership and order of the result set. Like a dynamic cursor, it does detect changes to the values of rows in the result set.\n\nKeyset-driven cursors are controlled by a set of unique identifiers (keys) known as the keyset. The keys are built from a set of columns that uniquely identify the rows in the result set. The keyset is the set of key values from all the rows returned by the query statement. With keyset-driven cursors, a key is built and saved for each row in the cursor and stored either on the client workstation or on the server. When you access each row, the stored key is used to fetch the current data values from the data source. In a keyset-driven cursor, result set membership is frozen when the keyset is fully populated. Thereafter, additions or updates that affect membership aren't a part of the result set until it reopens.\n\nChanges to data values (made either by the keyset owner or other processes) are visible as the user scrolls through the result set:\n• None If a row is deleted, an attempt to fetch the row returns an of because the deleted row appears as a gap in the result set. The key for the row exists in the keyset, but the row no longer exists in the result set.\n• None Inserts made outside the cursor (by other processes) are visible only if the cursor is closed and reopened. Inserts made from inside the cursor are visible at the end of the result set.\n• None Updates of key values from outside the cursor resemble a delete of the old row followed by an insert of the new row. The row with the new values isn't visible, and attempts to fetch the row with the old values return an of . The new values are visible if the update is done through the cursor by specifying the clause.\n\nDefines a cursor that reflects all data changes made to the rows in its result set as you scroll around the cursor and fetch a new record, regardless of whether the changes occur from inside the cursor or by other users outside the cursor. Therefore all insert, update, and delete statements made by all users are visible through the cursor. The data values, order, and membership of the rows can change on each fetch. The fetch option isn't supported with dynamic cursors. Updates made outside the cursor aren't visible until they're committed (unless the cursor transaction isolation level is set to ).\n\nFor example, suppose a dynamic cursor fetches two rows, and another application then updates one of those rows and deletes the other. If the dynamic cursor then fetches those rows, it doesn't find the deleted row, but it displays the new values for the updated row.\n\nSpecifies a , cursor with performance optimizations enabled. can't be specified if or is also specified. This type of cursor doesn't allow data modifications from inside the cursor.\n\nPrevents updates made through this cursor. The cursor can't be referenced in a clause in an or statement. This option overrides the default capability of a cursor to be updated.\n\nSpecifies that positioned updates or deletes made through the cursor are guaranteed to succeed. SQL Server locks the rows as they are read into the cursor to ensure their availability for later modifications. can't be specified if or is also specified.\n\nSpecifies that positioned updates or deletes made through the cursor don't succeed, if the row was updated since it was read into the cursor. SQL Server doesn't lock rows as they're read into the cursor. It instead uses comparisons of timestamp column values, or a checksum value if the table has no timestamp column, to determine whether the row was modified after it was read into the cursor.\n\nIf the row was modified, the attempted positioned update or delete fails. can't be specified if is also specified.\n\nIf is specified along with the cursor argument, the combination of the two are implicitly converted to the equivalent of the combination of using and arguments, or the and arguments.\n\nSpecifies that a warning message is sent to the client when the cursor is implicitly converted from the requested type to another.\n\nNo warning is sent to the client when the combination of and cursor arguments are used, and the cursor is implicitly converted to the equivalent of a or cursor. The conversion to turns into a and cursor from a clients' perspective.\n\nA standard statement that defines the result set of the cursor. The keywords , , , and aren't allowed within select_statement of a cursor declaration.\n\nSQL Server implicitly converts the cursor to another type if clauses in select_statement conflict with the functionality of the requested cursor type.\n\nDefines updatable columns within the cursor. If is supplied, only the columns listed allow modifications. If is specified without a column list, all columns can be updated, unless the concurrency option was specified.\n\ndefines the attributes of a Transact-SQL server cursor, such as its scrolling behavior and the query used to build the result set on which the cursor operates. The statement populates the result set, and returns a row from the result set. The statement releases the current result set associated with the cursor. The statement releases the resources used by the cursor.\n\nThe first form of the statement uses the ISO syntax for declaring cursor behaviors. The second form of uses Transact-SQL extensions that allow you to define cursors using the same cursor types used in the database API cursor functions of ODBC or ADO.\n\nYou can't mix the two forms. If you specify the or keywords before the keyword, you can't use any keywords between the and keywords. If you specify any keywords between the and keywords, you can't specify or before the keyword.\n\nIf a using Transact-SQL syntax doesn't specify , , or , the default is as follows:\n• None If the statement doesn't support updates (insufficient permissions, accessing remote tables that don't support updates, and so on), the cursor is .\n\nCursor names can only be referenced by other Transact-SQL statements. They can't be referenced by database API functions. For example, after declaring a cursor, the cursor name can't be referenced from OLE DB, ODBC, or ADO functions or methods. The cursor rows can't be fetched using the fetch functions or methods of the APIs; the rows can only be fetched by Transact-SQL statements.\n\nAfter a cursor is declared, these system stored procedures can be used to determine the characteristics of the cursor.\n\nVariables might be used as part of the select_statement that declares a cursor. Cursor variable values don't change after a cursor is declared.\n\nPermissions of default to any user that has permissions on the views, tables, and columns used in the cursor.\n\nYou can't use cursors or triggers on a table with a clustered columnstore index. This restriction doesn't apply to nonclustered columnstore indexes. You can use cursors and triggers on a table with a nonclustered columnstore index.\n\nThe result set generated at the opening of this cursor includes all rows and all columns in the table. This cursor can be updated, and all updates and deletes are represented in fetches made against this cursor. is the only fetch available because the option isn't specified.\n\nThe following example shows how cursors can be nested to produce complex reports. The inner cursor is declared for each vendor."
    },
    {
        "link": "https://brentozar.com/sql-syntax-examples/cursor-example",
        "document": "Here’s an easy example of a cursor that loops through MyTable and gets an ID and a string from each row:\n\n/* Set up variables to hold the current record we're working on */ DECLARE @CurrentID INT, @CurrentString VARCHAR(100); DECLARE cursor_results CURSOR FOR SELECT MyID, MyString FROM dbo.MyTable; OPEN cursor_results FETCH NEXT FROM cursor_results into @CurrentID, @CurrentString WHILE @@FETCH_STATUS = 0 BEGIN /* Do something with your ID and string */ EXEC dbo.MyStoredProcedure @CurrentID, @CurrentString; FETCH NEXT FROM cursor_results into @CurrentID, @CurrentString END /* Clean up our work */ CLOSE cursor_results; DEALLOCATE cursor_results; /* Set up variables to hold the current record we're working on */ /* Do something with your ID and string */\n\nCursors do row-by-row processing – or as Jeff Moden calls it, ReBAR – Row By Agonizing Row. This is a common approach for developers who think like application servers think – and hey, I used to write my T-SQL the same way myself!\n\nHowever, at scale – when you’re running dozens or hundreds of cursor operations per minute – this can quickly run into higher CPU use and lock escalation problems. (That sounds kind of funny for me to say, because in the database world, “scale” is more along the lines of thousands of operations per second, but you’re not likely to achieve those levels with cursors in code.)\n\nIn the database world, you’re much better off performing set-based operations: working on all of the data at once, in a single statement. This lets SQL Server take a single set of quick locks on exactly the rows it needs, perform a quick update, and then get out.\n\nFor an example, check out this Stack Overflow answer on converting a cursor to set-based operation.\n\nSometimes cursors are fine – like for one-time utility code or database maintenance routines – but if you find yourself writing cursors as part of a transactional operation, it’s time to think about set-based operations instead. If you really need to use cursors and you need them to be fast, check out Brad Schulz’s The Truth About Cursors: Part 1. If you’re curious about cursors, Part 2 and Part 3 are also worth reading.\n\nIn this 16-minute video, Doug Lane explains how to use a date table, which will help you work around cursors that loop through date lists:"
    },
    {
        "link": "https://mssqltips.com/sqlservertip/1599/cursor-in-sql-server",
        "document": "I know SQL cursors exist, but I am not sure how or why to use them. Can you provide a SQL cursor example? Can you give any guidance on when to use a SQL Server cursor?\n\nSQL cursors are rarely used in many organizations. In others, they are a last resort. And, in other groups, they are used regularly. Each of these camps, have different reasons for their stand on cursor usage in the DBMS. Regardless, they probably have a place in particular circumstances and not others. It boils down to your understanding of the coding technique, then your understanding of the problem at hand to decide if cursor-based processing is appropriate.\n\nLet’s do the following in this SQL tutorial:\n• Look at an example cursor\n• Break down the components of the cursor\n• Analyze the pros and cons of cursor usage\n\nLet’s first provide a SQL Server cursor example and then answer all pertinent questions in this SQL tutorial.\n\nThis SQL Server cursor example (Simple script to backup all SQL Server databases) issues backups in a serial manner:\n\nA SQL Server cursor is a set of T-SQL logic that loops over a predetermined number of rows one at a time. The purpose of the cursor may be to update one row at a time or perform an administrative process, such as SQL Server database backups, in a sequential manner. Development, DBA, and ETL processes rely on SQL Server cursors.\n\nThere are many options and types of cursors, such as:\n\nHow to Write a Cursor in SQL Server with Transact-SQL\n\nCreating a SQL Server cursor with T-SQL is a consistent method that can process data on a set of rows. Once you learn the steps, you can easily duplicate them with various sets of logic to loop through data. Let’s walk through the steps:\n\nDeclare the variables (file names, database names, account numbers, etc.) needed in the logic and initialize the variables. Specify the variable name and data type.\n• Update the logic based on your needs.\n\nDeclare the cursor with a specific name (i.e., db_cursor in this tip) that you will use throughout the logic along with the business logic (SELECT SQL statement) to populate the records.\n• Update the logic based on your needs.\n\nFetch a record from the cursor to begin the data processing.\n\nThe data process is unique to each set of logic. Logic includes inserting, updating or deleting, for each fetched row.\n• Update the logic based on your needs.\n\nFetch the next record from the cursor and repeat step 3 and step 4.\n\nClose the cursor once all the data has been processed. As a final and important step, you need to deallocate the cursor to release all the internal resources SQL Server is holding.\n\nBased on the code and explanations above, let’s break down the SQL Server cursor example and notate which sections need to be updated when using this code.\n\nBased on the SQL cursor example above, cursors include these components:\n• DECLARE statements – Declare variables used in the code block.\n• SET\\SELECT statements – Initialize the variables to a specific value.\n• DECLARE CURSOR statement – Populate the cursor with values that will be evaluated.\n• NOTE – There are an equal number of variables in the DECLARE CURSOR FOR statement as there are in the SELECT statement. This could be one or many variables and associated columns.\n• FETCH statements – Assign the specific values from the cursor to the variables to match the DECLARE CURSOR FOR and SELECT statement.\n• NOTE – This logic is used for the initial population before the WHILE statement and then again during each loop in the process as a portion of the WHILE statement.\n• WHILE statement – Condition to begin and continue data processing.\n• BEGIN…END statement – Start and end of the code block.\n• NOTE – Based on the data processing, multiple BEGIN…END statements can be used.\n• Data processing – In this example, this logic is to backup a database to a specific path and file name, but this could be any DML or administrative logic.\n• CLOSE statement – Releases the current data and associated locks, but permits the cursor to be re-opened.\n\nWhy Use a Cursor in SQL Server?\n\nAlthough using an INSERT, UPDATE, or DELETE statement to modify all of the applicable data in one transaction is generally the best way to work with data in SQL Server, a cursor may be needed for:\n• Iterating over data one row at a time\n• Completing a process in a serial manner, such as SQL Server database backups\n• Correcting data with a predefined set of data as the input to the cursor\n\nWhen to Use a SQL Server Cursor\n\nThe analysis below is intended to serve as insight into various scenarios where cursor-based logic may or may not be beneficial:\n\nIn most OLTP environments, SET based logic (INSERT, UPDATE, or DELETE on applicable rows) makes the most sense for short transactions. Our team has run into a third-party application that uses cursors for all its processing, which has caused issues, but this has been a rare occurrence. Typically, SET based logic is more than feasible, and cursors are rarely needed.\n\nBased on the design of the reports and the underlying design, cursors are typically not needed. However, our team has seen reporting requirements where referential integrity does not exist on the underlying database, and it is necessary to use a cursor to correctly calculate the reporting values. We have had the same experience when needing to aggregate data for downstream processes. A cursor-based approach was quick to develop and performed in an acceptable manner to meet the need.\n\nIf you need to complete a process in a serialized manner, cursors are a viable option.\n\nMany administrative tasks, such as database backups or Database Consistency Checks, need to be executed in a serial manner, which fits nicely into cursor-based logic. But, other system-based objects exist to fulfill the need. In some of those circumstances, cursors are used to complete the process.\n\nWith large data sets you could run into one or more of the following:\n• Cursor based logic may not scale to meet the processing needs.\n• With large set-based operations on servers with a minimal amount of memory, the data may be paged or monopolize the SQL Server, which is time-consuming and can cause contention and memory issues. As such, a cursor-based approach may meet the need.\n• Some tools inherently cache the data to a file under the covers, so processing the data in memory may or may not actually be the case.\n• If the data can be processed in a staging SQL Server database, the impacts to the production environment only occur when the final data is processed. All resources on the staging server can be used for the ETL processes then the final data can be imported.\n• SSIS supports batching sets of data, which may resolve the overall need to break up a large data set into more manageable sizes and perform better than a row-by-row approach with a cursor.\n• Depending on how the cursor or SSIS logic is coded, it may be possible to restart at the point of failure based on a checkpoint or marking each row with the cursor. However, with a set-based approach, that may not be the case until an entire set of data is completed. As such, troubleshooting the row with the problem may be more difficult.\n\nSimon Liew has written a detailed technical tip on five Different ways to Write a Cursor (read here), which includes the following:\n\nThis tip provides sample code that can be used to expand SQL Server cursor options beyond the syntax in this tip.\n\nLearn more about SQL Server cursors and alternatives:\n• The Many Uses of Coalesce in SQL Server\n\nHow to Avoid Cursors in SQL Server\n• Set based logic\n• INSERT or SELECT INTO or INSERT… SELECT to add records to a table as a single transaction.\n• UPDATE to modify one or many rows in a single transaction.\n• DELETE or TRUNCATE to remove records from a table.\n• MERGE branching logic to INSERT, UPDATE, or DELETE data based on criteria.\n• Consider SQL Server Integration Services (SSIS) to loop through data primarily for data extraction, transformation, and loading processes between databases.\n• WHILE command to loop over records in a sequential manner.\n• Optimize Large SQL Server Insert, Update and Delete Processes by Using Batches\n• COALSCE command to process NON-NULL values.\n• The Many Uses of Coalesce in SQL Server\n• sp_MSforeachdb SQL Server system stored procedure to loop over each database on an instance.\n• Run The Same SQL Command Against All SQL Server Databases\n• sp_MSforeachtable SQL Server system stored procedure to loop over each table in a database.\n• CASE expression, which can include some branching logic to process data with a SELECT statement.\n• Using the CASE expression instead of dynamic SQL in SQL Server\n• Repeat a batch with the GO command.\n\nDifference Between While Loop and Cursor in SQL Server\n\nDaniel Farina wrote an interesting article (SQL Server Loop through Table Rows without Cursor) comparing the SQL Server While Loop and Cursors. He covers the following:\n• Using a While Loop Instead of Cursors in SQL Server\n• Pros and Cons of Using Cursors to Iterate Through Table Rows in SQL Server\n• Pros and Cons of Using a While Loop to Iterate Through Table Rows in SQL Server\n• Example of a Basic Cursor to Loop through Table Rows in SQL Server\n• Example of a Basic While Loop to Cycle through Table Rows in SQL Server\n\nThe code samples in this tip are valuable to illustrate the differences between cursors in SQL Server and the While Loop.\n\nIn the example above, backups are issued via a cursor. Check out these other tips that leverage cursor-based logic:\n• SQL Server script to rebuild all indexes for all tables and all databases\n• SQL Server Index Analysis Script for All Indexes on All Tables\n• Standardize your SQL Server data with this text lookup and replace function\n• Searching and finding a string value in all columns in a SQL Server table\n• Script to create commands to disable, enable, drop and recreate Foreign Key constraints in SQL Server\n• Automate Restoration of Log Shipping Databases for Failover in SQL Server\n• Determining space used for each table in a SQL Server database\n• SQL Server Find and Replace Values in All Tables and All Text Columns\n• What is the use of a cursor in SQL Server?\n• When you are faced with a data processing decision, determine where you stand with SQL Server cursor usage. They may or may not have a place in your application or operational processes. There are many ways to complete a task. Using a cursor could be a reasonable alternative or not. You be the judge.\n• If you run into issues with another coding technique and need to get something done quickly, using a cursor may be a viable alternative. It may take longer to process the data, but the coding time might be much less. If you have a one-time process or nightly processing, this could do the trick.\n• If cursors are shunned in your environment, be sure to select another viable alternative. Be sure the process will not cause other issues. As an example, if a cursor is used and millions of rows are processed, will this potentially flush all of the data from cache and cause further contention? Or, with a large data set, will the data be paged to disk or written to a temporary directory?\n• As you evaluate a cursor-based approach versus other alternatives, make a fair comparison of the techniques in terms of time, contention, and resources needed. Hopefully, these factors will drive you to the proper technique."
    }
]