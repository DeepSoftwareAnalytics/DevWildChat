[
    {
        "link": "https://create.roblox.com/docs/education/battle-royale-series/creating-a-gui",
        "document": "Right now, much of the game information is currently in the Output window, invisible to players. So players can be informed of what's happening in the game, you'll create a graphical user interface (GUI) and code it.\n\nFor this game a text label will display the current game status as well as the remaining player count and time.\n\nFirst, create a Screen GUI object to hold the different text elements. When the player moves the camera, the screen GUI stays in the same place on their screen.\n\nTo ensure all players see the same display, place the GUI in the StarterGUI folder. At game startup, this folder is copied to all players.\n• None In the StarterGUI folder, create a new ScreenGUI. Then in ScreenGUI, add a new TextLabel named StatusText.\n• None To move the label, in the Explorer, select StatusText. Then, in the game view, drag the label where you would like it. Your numbers may differ from the video. The label can also be resized using the anchor points on the corners.\n\nTo reflect changes in the game, scripts will need to update the GUI elements. For instance, the game status, whether it's an intermission or active round, will be stored in a StringValue and updated using local scripts.\n\nThe StatusDisplay script will be used to update the player's GUI whenever the game state changes.\n• None In ReplicatedStorage, create a folder named DisplayValues. In that folder, add a StringValue named Status. To test the value later, give it a temporary value, like \"Welcome to the Battle!\". Because local scripts only run on a player's device, they can't be stored in Server folders like ServerStorage. ReplicatedStorage is a folder that's available both to the client (device) and server.\n• None In StarterGUI > ScreenGUI > Status, add a new local script named StatusDisplay. Scripts that affect the GUI are often parented to that GUI element.\n• None Open StatusDisplay and define the following variables for the follow:\n\nTo change the text in the label, use a Changed event so whenever the Status string is changed by another script, the text label will be updated.\n• None Code a new function named updateText(). In that function, set the Text property of textLabel to status.Value.\n• None Connect the function to the Changed event.\n• None So players see the most up to date status when starting the game, run updateText() at the end of the script.\n• None Run the game and confirm that you see the temporary value in the display.\n\nDuring a game, the text label will need to get information from GameManager, MatchManager, and possibly other scripts. So these different scripts can update the text label when needed, create a module script named DisplayManager.\n\nBecause DisplayManager needs to communicate with other scripts, it'll be a module script.\n• None In ServerStorage > ModuleScripts, create a new module script named DisplayManager. Rename the module table to match the script name.\n• None Add local variables for the following: Replicated Storage, DisplayValues folder, Status.\n• None Create a new module function named updateStatus() that updates the string in the Status value. Other scripts will be able to call this function.\n\nWith the Display Manager set up, it can be used in other scripts to update the GUI text label. As the first message in the GUI, show the start and end of the intermission through the GameManager script.\n• None In ServerScriptService > GameManager, create a variable named displayManager and require the DisplayManager module in ServerStorage.\n• None As the first line after the while true do statement, call displayManager > updateStatus() and pass in a message about waiting for players.\n• None After the end of the repeat loop for the intermission, call updateStatus() and pass in a string announcing the match is starting. Since you'll be testing with the GUI, delete the two print statements for noting the start and end of the intermission.\n• None Test the game with and without your minimum players. The message should read the following:\n\nAt this point, if the text label doesn't display the first message, or still displays \"Label\", try one of the following below.\n• None Make sure in the StatusDisplay local script that is called at the bottom of the script. This ensures that the player gets the most up to date message.\n• None Check that the Status StringValue is in ReplicatedStorage. Due to the unique nature of client-server relations, if it's in ServerStorage, a local script won't be able to find it.\n\nDuring a match, the GUI will display two numbers: remaining player count and time. As these numbers change, the text label will change as well.\n\nIntValues will be used to store the player count and time left.\n• None In ReplicatedStorage > DisplayValues, create two IntValues named PlayersLeft and TimeLeft.\n• None In DisplayManager, add variables to store the players left and time left values.\n• None Create a local function named updateMatchStatus(). Then, set the value of status to display the number of players left and the remaining time.\n• None For both IntValue variables, connect updateRoundStatus() to the Changed event. Don't test yet. Nothing has updated the PlayersLeft or TimeLeft values, so the status won't be changed once a round starts.\n\nNext, add the code for displaying the number of players at the start of a game. Later lessons will update the PlayersLeft value as players are eliminated from the game.\n• None In PlayerManager, add local variables for ReplicatedStorage service, DisplayValues folder and PlayersLeft IntValue.\n• None Show the starting player count by setting the value of playersLeft to the size of the active players array. Then, in sendPlayersToMatch(), under the for loop, type: playersLeft.Value = #activePlayers\n\nRemember that module scripts are used to centralize similar code. Since the timer is tracked in MatchManager, update the TimeLeft value using functions from the Timer script. The display manager will listen for changes to the TimeLeft, and update to match the new value.\n• None In MatchManager, create variables to store the ReplicatedStorage service, DisplayValues folder and TimeLeft value.\n• None Find the startTimer() function. After the timer's Finished event, copy and paste the whole, highlighted while loop below. The code runs a loop to update the timeLeft value as long as the timer is still active. -- Adding +1 makes sure the timer display ends at 1 instead of 0. -- By not setting the time for wait, it offers more accurate looping When added in, the code should look like the sample below. -- Adding +1 makes sure the timer display ends at 1 instead of 0. -- By not setting the time for wait, it offers more accurate looping\n• None Run the game with the minimum players. Check that the status text displays:\n• None The correct amount of starting players. Remember, this number won't change until additional code is added in a future lesson.\n• None Time decreases each second until it stops at 1.\n\nBelow are completed scripts to double check your work."
    },
    {
        "link": "https://create.roblox.com/docs/ui",
        "document": "You can quickly create high-quality graphical user interfaces with minimal scripting requirements using built-in UI objects. Depending on where you create it, UI renders either on-screen or within an experience's 3D world.\n\nOn-screen containers hold UI objects that you want to display on a user's screen. All on-screen UI objects and code are stored and changed on the client.\n\nIn-experience containers such as SurfaceGuis and BillboardGuis hold UI objects that you want to display within your experience's 3D world.\n\nMost UI elements are GuiObjects, 2D graphical user interface objects that you can parent to containers. The four most common are frames, labels, buttons, and text input objects.\n\nUsing the Position, Size, AnchorPoint, and ZIndex properties, you have complete control on how to position, size, and layer GuiObjects. You can also use tweening to transition a GuiObject smoothly from one state to another and provide dynamic visual feedback.\n\nBeyond basic properties for adjusting position and size, Roblox also provides layout structures like list/flex and grid, as well as size modifiers and appearance modifiers.\n\nIn addition to the core user interface objects, the following frameworks provide built‑in and customizable interactivity for your experiences.\n\nProximity prompts are unique built-in UI objects which prompt user interaction to trigger an action when they approach in-experience objects such as doors, light switches, and buttons.\n\nUI drag detectors facilitate and encourage interaction with 2D user interface elements such as sliders, spinners, and more.\n\n3D drag detectors encourage physical interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, grabbing and tossing a bowling ball, pulling back and firing a slingshot, and much more."
    },
    {
        "link": "https://devforum.roblox.com/t/simple-tutorial-for-each-roblox-studio-ui-components/2173189",
        "document": "Please note that this tutorial will only contain the basics and a bit of scripting tutorial.\n\n\n\n To first create a GUI head over to StarterGUI\n\nWhen that’s done, you can add:\n\n a frame / text label / text button\n\nand you can add in the text label your own text which can’t be modified by an user.\n\n image / video\n\n Used to show a video / decal from the ROBLOX library, you can even upload your own images as long as they respect TOS\n\nThere can be multiple UI’s contained in one UI, that means that you could add a localscript in an imagebutton that when pressed can enable an UI.\n\nCode used for the button\n\nYou can also have the GUI as a model or folder , as I’m showing here.\n\n\n\nTo change the aspect of the UI we can use two things (I’m going to explain only 1 because they’re the most important).\n\nYou can change them in two ways:\n\nFor the script one:\n\nOk we can start our coding!\n\nLet’s say we want to change the text color of a text, this is how you do it:\n\nFirst thing: Variables very useful if you want it to be minified.\n\nNow it’s time to actually add the script that will make the text color change. Let’s add another variable, shall we?\n\nAnd you can do this for (almost) every property!\n\nGoodbye fellow scripters, and if you have any problems you can find a more in-depth explanation in the links."
    },
    {
        "link": "https://devforum.roblox.com/t/how-would-you-reference-a-players-gui-from-a-script-inside-the-character/1750017",
        "document": "I’m trying to create a system where if a script detects a RopeConstraint in the HumanoidRootPart, it will turn a GUI frame green, and if not, red. But, I keep getting the error,"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/GuiObject",
        "document": "GuiObject is an abstract class (much like BasePart) for a 2D user interface object. It defines all the properties relating to the display of a graphical user interface (GUI) object such as Size and Position. It also has some useful read‑only properties like AbsolutePosition, AbsoluteSize, and AbsoluteRotation. To manipulate the layout of GUI objects in special ways, you can use a layout structure such as list/flex or grid, and you can style them beyond their core properties through appearance modifiers. Although it's possible to detect mouse button events on any GUI object using InputBegan and InputEnded, only ImageButton and TextButton have convenient dedicated events such as Activated to detect click/press.\n\nThis property determines whether the GuiObject will sink input to 3D space, such as underlying models with a ClickDetector class like DragDetector. For GuiButton objects (ImageButton and TextButton), this property determines whether Activated fires (AutoButtonColor will still work for those as well). The events InputBegan, InputChanged, and InputEnded work as normal no matter the value of this property. -- Place this LocalScript within a TextButton (or ImageButton) This property determines the origin point of a GuiObject, relative to its absolute size. The origin point determines from where the element is positioned (through GuiObject.Position) and from which the rendered GuiObject.Size expands. See here for illustrated diagrams and details. This property is used to automatically size parent UI objects based on the size of its descendants. You can use this property to dynamically add text and other content to a UI object at edit or run time, and the size will adjust to fit that content. When AutomaticSize is set to an Enum.AutomaticSize value to anything other than None, this UI object may resize depending on its child content. For more information on how to use this property and how it works, please see here. This property determines the color of a GuiObject background (the fill color). If your element contains text, such as a TextBox, TextButton, or TextLabel, make sure the color of your background contrasts the text's color. Another property that determines the visual properties of the background is GuiObject.BackgroundTransparency; if this is set to 1, neither the background nor the border will render. -- Put this code in a LocalScript in a Frame -- If we loop from 0 to 1 repeatedly, we get a rainbow! This property determines the transparency of the GuiObject background and border. It does not, however, determine the transparency of text if the GUI is a TextBox, TextButton, or TextLabel; text transparency is determined TextBox.TextTransparency, TextButton.TextTransparency, and TextLabel.TextTransparency respectively. If this property is set to 1, neither the background nor the border will render and the GUI background will be completely transparent. Determines the color of the GuiObject rectangular border (also known as the stroke color). This is separate from the object's GuiObject.BackgroundColor3. You will not be able to see the object's border if its GuiObject.BorderSizePixel property is set to 0. Note that the UIStroke component allows for more advanced border effects. -- Put me inside some GuiObject, preferrably an ImageButton/TextButton -- Our default state is \"not hovered\" This property determines in what manner the GuiObject border is laid out relative to its dimensions using the enum of the same name, Enum.BorderMode. Note that UIStroke can override this property and allow for more advanced border effects. This property determines how wide the GuiObject border renders, in pixels. Setting this to 0 disables the border altogether. Note that UIStroke can override this property and allow for more advanced border effects. -- Put me inside some GuiObject, preferrably an ImageButton/TextButton -- Our default state is \"not hovered\" This property determines if the GuiObject will clip (make invisible) any portion of descendant GUI elements that would otherwise render outside the bounds of the rectangle. Note that Rotation isn't supported by this property. If this or any ancestor GUI has a non‑zero Rotation, this property is ignored and descendant GUI elements will be rendered regardless of this property's value. When the player's finger is being tapped and held on the GuiObject, the GuiState of the GuiObject will be set to Press. Similarly, When the player's finger is being released from the GuiObject, the GuiState of the GuiObject will be set to Idle, and when Interactable is turned off on the GuiObject, the Class.GuiState of the GuiObject will be set to NonInteractable. Determines whether the GuiButton can be interacted with or not, or if the GuiState of the GuiObject is changing or not.\n• None setting on the is set to , the will no longer be able to be pressed or clicked, and the will be constantly set to . When thesetting on theis set to, thewill no longer be able to be pressed or clicked, and thewill be constantly set to\n• None setting on the is set to , the will behave normally again and the will behave normally. When thesetting on theis set to, thewill behave normally again and thewill behave normally.\n• None setting on the is set to , the will be constantly set to . When thesetting on theis set to, thewill be constantly set to\n• None setting on the is set to , the will behave normally again. When thesetting on theis set to, thewill behave normally again. This property controls the sorting order of the GuiObject when using a UIGridStyleLayout (such as UIListLayout or UIPageLayout) with SortOrder set to Enum.SortOrder.LayoutOrder. It has no functionality if the object does not have a sibling UI layout structure. GuiObjects are sorted in ascending order where lower values take priority over higher values. Objects with equal values fall back to the order they were added in. If you are unsure if you'll need to add an element between two existing elements in the future, it's a good practice to use multiples of 100 (0, 100, 200, etc.). This ensures a large gap of layout order values which you can use for elements ordered in-between other elements. See also ZIndex which determines the object's rendering order instead of sorting order. This property sets the GuiObject selected when the user moves the gamepad selector downward. If this property is empty, moving the gamepad downward will not change the selected GUI. Moving the gamepad selector downward sets the GuiService.SelectedObject to this object unless the GUI is not Selectable. Note that this property can be set to a GUI element even if it is not Selectable, so you should ensure that the value of a GUI's selectable property matches your expected behavior. See also NextSelectionUp, NextSelectionLeft, and NextSelectionRight. -- Setup the Gamepad selection grid using the code below -- Test the Gamepad selection grid using the code below This property sets the GuiObject selected when the user moves the gamepad selector to the left. If this property is empty, moving the gamepad to the left will not change the selected GUI. Moving the gamepad selector to the left sets the GuiService.SelectedObject to this object unless the GUI is not Selectable. Note that this property can be set to a GUI element even if it is not Selectable, so you should ensure that the value of a GUI's selectable property matches your expected behavior. See also NextSelectionUp, NextSelectionDown, and NextSelectionRight. -- Setup the Gamepad selection grid using the code below -- Test the Gamepad selection grid using the code below This property sets the GuiObject selected when the user moves the gamepad selector to the right. If this property is empty, moving the gamepad to the right will not change the selected GUI. Moving the gamepad selector to the right sets the GuiService.SelectedObject to this object unless the GUI is not Selectable. Note that this property can be set to a GUI element even if it is not Selectable, so you should ensure that the value of a GUI's selectable property matches your expected behavior. See also NextSelectionUp, NextSelectionDown, and NextSelectionLeft. -- Setup the Gamepad selection grid using the code below -- Test the Gamepad selection grid using the code below This property sets the GuiObject selected when the user moves the gamepad selector upward. If this property is empty, moving the gamepad upward will not change the selected GUI. Moving the gamepad selector upward sets the GuiService.SelectedObject to this object unless the GUI is not Selectable. Note that this property can be set to a GUI element even if it is not Selectable, so you should ensure that the value of a GUI's selectable property matches your expected behavior. -- Setup the Gamepad selection grid using the code below -- Test the Gamepad selection grid using the code below This property determines the GuiObject pixel and scalar position using a UDim2. Position is centered around the object's GuiObject.AnchorPoint. The scalar position is relative to the size of the parent GUI element, if any. The pixel portions of the UDim2 value are the same regardless of the parent GUI's size. The values represent the position of the object in pixels. An object's actual pixel position can be read from the GuiBase2d.AbsolutePosition property. This property determines the number of degrees by which the GuiObject is rotated. Rotation is relative to the center of the object, not the AnchorPoint, meaning you cannot change the point of rotation. Additionally, this property is not compatible with ClipsDescendants. This property determines whether the GuiObject can be selected when navigating GUIs using a gamepad. If this property is true, a GUI can be selected. Selecting a GUI also sets the GuiService.SelectedObject property to that object. When this is false, the GUI cannot be selected. However, setting this to false when a GUI is selected will not deselect it nor change the value of the GuiService.SelectedObject property. Add GuiObject.SelectionGained and GuiObject.SelectionLost will not fire for the element. To deselect a GuiObject, you must change the GuiService.SelectedObject property. This property is useful if a GUI is connected to several GUIs via properties such as this GuiObject.NextSelectionUp, GuiObject.NextSelectionDown, NextSelectionRight, or NextSelectionLeft. Rather than change all of the properties so that the Gamepad cannot select the GUI, you can disable its Selectable property to temporarily prevent it from being selected. Then, when you want the gamepad selector to be able to select the GUI, simply re-enable its selectable property. -- The FocusLost and FocusGained event will fire because the textBox This property overrides the default selection adornment used for gamepads. Note that the chosen SelectionImageObject overlays the selected GuiObject with the Size of the image. For best results, you should size the custom SelectionImageObject via the scale UDim2 values to help ensure that the object scales properly over the selected element. Changing the SelectionImageObject for a GuiObject element only affects that element. To affect all of a user's GUI elements, set the PlayerGui.SelectionImageObject property. To determine or set which GUI element is selected by the user, you can use the GuiService.SelectedObject property. The player uses the gamepad to select different GUI elements, invoking the NextSelectionUp, NextSelectionDown, NextSelectionLeft, and NextSelectionRight events. GuiObjects with a lower SelectionOrder are selected earlier than GuiObjects with a higher SelectionOrder when starting the gamepad selection or calling GuiService:Select() on an ancestor. This property does not affect directional navigation. Default value is 0. This property determines the GuiObject scalar and pixel size using a UDim2. The scalar size is relative to the size of the parent GUI element, if any. The pixel portions of the UDim2 value are the same regardless of the parent GUI's size. The values represent the size of the object in pixels. An object's actual pixel size can be read from the GuiBase2d.AbsoluteSize property. If the GuiObject has a parent, its size along each axis is also influenced by the parent's SizeConstraint. -- Paste script into a LocalScript that is -- This function is called when the humanoid's health changes -- Change the size of the inner bar -- Change the color of the health bar -- This function runs is called the player spawns in -- Pattern: update once now, then any time the health changes -- Connect our spawn listener; call it if already spawned This property sets the Size axes that the GuiObject will be based on, relative to the size of its parent. This property is useful for creating GUI objects that are meant to scale with either the width or height of a parent object, but not both, effectively preserving the aspect ratio of the object. This property is deprecated and indexing it will return BackgroundTransparency. This property whether the GuiObject and its descendants will be rendered. The rendering of individual components of a GuiObject can be controlled individually through transparency properties such as GuiObject.BackgroundTransparency, TextLabel.TextTransparency and ImageLabel.ImageTransparency. When this property is false, the GuiObject will be ignored by layout structures such as UIListLayout, UIGridLayout, and UITableLayout. In other words, the space that the element would otherwise occupy in the layout is used by other elements instead. -- Flip a boolean using the `not` keyword This property determines the order in which a GuiObject renders relative to others. By default, GuiObjects render in ascending priority order where those with lower ZIndex values are rendered under those with higher values. You can change the render order within a ScreenGui, SurfaceGui, or BillboardGui by changing the value of its ZIndexBehavior. If you are unsure if you'll need to add an element between two existing elements in the future, it's a good practice to use multiples of 100 (0, 100, 200, etc.). This ensures a large gap of render order values which you can use for elements layered in-between other elements. See also LayoutOrder which controls the sorting order of a GuiObject when used with a layout structure such as UIListLayout or UIGridLayout.\n\nThis event fires when a user begins interacting with the GuiObject via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc). The UserInputService has a similarly named event that is not restricted to a specific UI element: UserInputService.InputBegan. This event will always fire regardless of game state. See also GuiObject.InputEnded and GuiObject.InputChanged. An InputObject, which contains useful data for querying user input such as thetype of input, state of input, and screen coordinates of the input. \n\n Tracking the Beginning of Input on a GuiObject -- In order to use the InputBegan event, you must specify the GuiObject -- A sample function providing multiple usage cases for various types of user input \"A key is being pushed down! Key:\" \"The left mouse button has been pressed down at\" \"The right mouse button has been pressed down at\" \"A button is being pressed on a gamepad! Button:\" This event fires when a user changes how they're interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc). The UserInputService has a similarly named event that is not restricted to a specific UI element: UserInputService.InputChanged. This event will always fire regardless of game state. See also GuiObject.InputBegan and GuiObject.InputEnded. An InputObject, which contains useful data for querying user input such as thetype of input, state of input, and screen coordinates of the input. \n\n \"The mouse has been moved!\" \"The mouse wheel has been scrolled!\" \"The left thumbstick has been moved!\" \"The right thumbstick has been moved!\" \"The pressure being applied to the left trigger has changed!\" \"The pressure being applied to the right trigger has changed!\" \"The user's finger is moving on the screen!\" \"The rotation of the user's mobile device has been changed!\" \"The acceleration of the user's mobile device has been changed!\" The InputEnded event fires when a user stops interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc). The UserInputService has a similarly named event that is not restricted to a specific UI element: UserInputService.InputEnded. This event will always fire regardless of game state. See also GuiObject.InputBegan and GuiObject.InputChanged. An InputObject, which contains useful data for querying user input such as theEnum.UserInputType, Enum.UserInputState, and InputObject.Position. \n\n Tracking the End of Input on a GuiObject -- In order to use the InputChanged event, you must specify a GuiObject -- A sample function providing multiple usage cases for various types of user input \"The left mouse button has been released at\" \"The right mouse button has been released at\" \"A touchscreen input has been released at\" \"A button has been released on a gamepad! Button:\" The MouseEnter event fires when a user moves their mouse into a GuiObject element. Please do not rely on the x and y arguments passed by this event as a fool-proof way to determine where the user's mouse is when it enters a GUI. These coordinates may vary even when the mouse enters the GUI via the same edge - particularly when the mouse enters the element quickly. This is due to the fact the coordinates indicate the position of the mouse when the event fires rather than the exact moment the mouse enters the GUI. This event fires even when the GUI element renders beneath another element. If you would like to track when a user's mouse leaves a GUI element, you can use the GuiObject.MouseLeave event. The mouse's X screen coordinate in pixels, relative to the top left corner of the screen. The mouse's Y screen coordinate in pixels, relative to the top left corner of the screen. \n\n \"The user's mouse cursor has entered the GuiObject at position\" The MouseLeave event fires when a user moves their mouse out of a GuiObject element. Please do not rely on the x and y arguments passed by this event as a fool-proof way to determine where the user's mouse is when it leaves a GUI. These coordinates may vary even when the mouse leaves the GUI via the same edge - particularly when the mouse leaves the element quickly. This is due to the fact the coordinates indicate the position of the mouse when the event fires rather than the exact moment the mouse leaves the GUI. This event fires even when the GUI element renders beneath another element. The mouse's X screen coordinate in pixels, relative to the top left corner of the screen. The mouse's Y screen coordinate in pixels, relative to the top left corner of the screen. \n\n Fires whenever a user moves their mouse while it is inside a GuiObject element. It is similar to Mouse.Move, which fires regardless whether the user's mouse is over a GUI element. Note, this event fires when the mouse's position is updated, therefore it will fire repeatedly while being moved. The x and y arguments indicate the updated screen coordinates of the user's mouse in pixels. These can be useful to determine the mouse's location on the GUI, screen, and delta since the mouse's previous position if it is being tracked in a global variable. The code below demonstrates how to determine the Vector2 offset of the user's mouse relative to a GUI element: Note that this event may not fire exactly when the user's mouse enters or exits a GUI element. Therefore, the x and y arguments may not match up perfectly to the coordinates of the GUI's edges. The mouse's X screen coordinate in pixels, relative to the top left corner of the screen. The mouse's Y screen coordinate in pixels, relative to the top left corner of the screen. \n\n The WheelBackward event fires when a user scrolls their mouse wheel back when the mouse is over a GuiObject element. It is similar to Mouse.WheelBackward, which fires regardless whether the user's mouse is over a GUI element. This event fires merely as an indicator of the wheel's backward movement. This means that the x and y mouse coordinate arguments don't change as a result of this event. These coordinates only change when the mouse moves, which can be tracked by the GuiObject.MouseMoved event. The mouse's X screen coordinate in pixels, relative to the top left corner of the screen. The mouse's Y screen coordinate in pixels, relative to the top left corner of the screen. \n\n The WheelForward event fires when a user scrolls their mouse wheel forward when the mouse is over a GuiObject element. It is similar to Mouse.WheelForward, which fires regardless whether the user's mouse is over a GUI element. This event fires merely as an indicator of the wheel's forward movement. This means that the X and Y mouse coordinate arguments do not change as a result of this event. These coordinates only change when the mouse moves, which can be tracked by the GuiObject.MouseMoved event. The mouse's X screen coordinate in pixels, relative to the top left corner of the screen. The Y coordinate of the user's mouse. \n\n This event fires when the Gamepad selector starts focusing on the GuiObject. If you want to check from the Gamepad select stops focusing on the GUI element, you can use the GuiObject.SelectionLost event. When a GUI gains selection focus, the value of the SelectedObject property also changes to the that gains selection. To determine which GUI gained selection, check the value of this property. \n\n \"The user has selected this button with a gamepad.\" This event fires when the Gamepad selector stops focusing on the GuiObject. If you want to check from the Gamepad select starts focusing on the GUI element, you can use the GuiObject.SelectionGained event. When a GUI loses selection focus, the value of the SelectionObject property changes either to nil or to the GUI element that gains selection focus. To determine which GUI gained selection, or if no GUI is selected, check the value of this property. \n\n \"The user no longer has this selected with their gamepad.\" This event fires after a brief moment when the player holds their finger on the UI element using a touch-enabled device. It fires with a table of Vector2 that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires multiple times: Enum.UserInputState.Begin after a brief delay, Enum.UserInputState.Change if the player moves their finger during the gesture, and finally Enum.UserInputState.End. The delay is platform dependent; in Studio it is a little longer than one second. Since this event only requires one finger, this event can be simulated in Studio using the emulator and a mouse. An array of Vector2 that describe the relative positions of the fingers involved in the gesture. A Enum.UserInputState that describes the state of the gesture:\n• None Begin fires once at the beginning of the gesture (after the brief delay)\n• None Change fires if the player moves their finger while pressing down\n• None End fires once at the end of the gesture when they release their finger. \n\n -- Color the frame to indicate the drag is happening This event fires when the player moves their finger on the UI element using a touch-enabled device. It fires shortly before GuiObject.TouchSwipe would, and does not fire with GuiObject.TouchTap. This event is useful for allowing the player to manipulate the position of UI elements on the screen. This event fires with a table of Vector2 that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires multiple times: Enum.UserInputState.Begin after a brief delay, Enum.UserInputState.Change when the player moves their finger during the gesture, and finally with Enum.UserInputState.End. This event cannot be simulated in Studio using the emulator and a mouse; you must have a real touch-enabled device to fire it. A Lua array of Vector2 objects, each indicating the position of all the fingers involved in the gesture. Indicates how far the pan gesture has gone from its starting point. Indicates how quickly the gesture is being performed in each dimension. Indicates the Enum.UserInputState of the gesture. \n\n This event fires when the player uses two fingers to make a pinch or pull gesture on the UI element using a touch-enabled device. A pinch happens when two or more fingers move closer together, and a pull happens when they move apart. This event fires in conjunction with GuiObject.TouchPan. This event is useful for allowing the player to manipulate the scale (size) of UI elements on the screen, and is most often used for zooming features. This event fires with a table of Vector2 that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires multiple times: Enum.UserInputState.Begin after a brief delay, Enum.UserInputState.Change when the player moves a finger during the gesture, and finally with Enum.UserInputState.End. It should be noted that the scale should be used multiplicatively. Since this event requires at least two fingers, it is not possible to simulate it in Studio using the emulator and a mouse; you must have a real touch-enabled device. A Lua array of Vector2 objects, each indicating the position of all the fingers involved in the pinch gesture. A float that indicates the difference from the beginning of the pinch gesture. A float indicating how quickly the pinch gesture is happening. Indicates the Enum.UserInputState of the gesture. \n\n This event fires when the player uses two fingers to make a pinch or pull gesture on the UI element using a touch-enabled device. Rotation occurs when the angle of the line between two fingers changes. This event fires in conjunction with GuiObject.TouchPan. This event is useful for allowing the player to manipulate the rotation of UI elements on the screen. This event fires with a table of Vector2 that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires multiple times: Enum.UserInputState.Begin after a brief delay, Enum.UserInputState.Change when the player moves a finger during the gesture, and finally with Enum.UserInputState.End. Since this event requires at least two fingers, it is not possible to be simulated in Studio using the emulator and a mouse; you must have a real touch-enabled device. A Lua array of Vector2 objects, each indicating the position of all the fingers involved in the gesture. A float indicating how much the rotation has gone from the start of the gesture. A float that indicates how quickly the gesture is being performed. Indicates the Enum.UserInputState of the gesture. \n\n This event fires when the player performs a swipe gesture on the UI element using a touch-enabled device. It fires with the direction of the gesture (Up, Down, Left or Right) and the number of touch points involved in the gesture. Swipe gestures are often used to change tabs in mobile UIs. Since this event only requires one finger, it can be simulated in Studio using the emulator and a mouse. A Enum.SwipeDirection indicating the direction of the swipe gesture (Up, Down, Left or Right). The number of touch points involved in the gesture (usually 1). \n\n -- How far the frame should bounce on a successful swipe -- Change the BackgroundColor3 based on the swipe direction -- Update the color and bounce the frame a little This event fires when the player performs a tap gesture on the UI element using a touch-enabled device. A tap is a quick single touch without any movement involved (a longer press would fire GuiObject.TouchLongPress, and moving during the touch would fire GuiObject.TouchPan and/or GuiObject.TouchSwipe). It fires with a table of Vector2 objects that describe the relative positions of the fingers involved in the gesture. Since this event only requires one finger, it can be simulated in Studio using the emulator and a mouse. An array of Vector2 that describe the relative positions of the fingers involved in the gesture."
    },
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628",
        "document": "DISCLAIMER: THIS THREAD IS OLD AND OUTDATED, REFER TO THE NEWEST VERSION OF THIS THREAD: How To Use Roblox Pathfinding Service 2.0\n\nHello everyone! This is my first tutorial. Please correct me anything if I taught something wrong.\n\nIn this post, I will be teaching you guys on how to use the Pathfinding service in Roblox! This tutorial is specially for people who are decent at scripting and new to this service. Anyway without ay further ado...\n\nWhat the heck is Pathfinding service? In Roblox, PathfindingService is a service used to find a clear path between 2 points/destination. Imagine an NPC that can walk with this service. Pretty uninteresting right? Well, with PathfindingService, the NPC will find a clear path to walk to it’s destination without getting stuck at blocking obstacles. This will make the NPC smart enough to get to a specific position.\n\nThis is because, as I’ve stated earlier, PathfindingService allows an NPC to find a clear path between 2 destination points. If you get the idea, a clear path means a path with nothing to block the path. You might be asking, why can’t we just use the MoveTo() function from the humanoid instead? This is because MoveTo() function will ONLY find the fastest path, which is a straight line, from one point to an end point. This makes it hard for the NPC to reach because imagine there’s gaps between the path, blocking obstacles, jumping platforms and even more! With PathfindingService, this issue will be resolved.\n\nHow can we use it? Glad you asked! Follow the steps below.\n• Make sure you use a server script for this, and maybe try to parent it in a NPC model so we can script more easily.\n• Remove the code inside it and get the service of it.\n• Now, let’s create some variables for the NPC’s root part, humanoid and the destination/position we want it to walk to. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead.\n• Cool! Now we can start the real stuffs here. We need to create a path so we can tell the NPC to walk to that destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath()\n• Alright, now we need to give the two points to the path variable so that we will successfully create a path between the starting point and the ending point. Okay, you might be a bit confused. But let me explain. We re calling our path variable and then we use a function called ComputeAsync() which will create a clear path between 2 points. The first parameter of the function is the starting point of our path, in this case we use rootPart.Position as the starting point, then we use destination as our ending point of the path, which is the second argument we need to pass in this function. NOTE: IF YOU'RE NOT USING VECTOR3 AS THE DESTINATION, YOU CAN USE A PART'S POSITION AS THE ENDING POINT. MAKE SURE TO ADD .Position !!! WHICH WILL BE LIKE ComputeAsync(rootPart.Position,part.Position).\n• Now that we have computed the path, it will provide a series of waypoints, which we will tell the NPC to move to each waypoint until it reached it’s destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints()\n• Now, we will use a for loop so that we can tell the NPC to move to each waypoint after they’ve reached the previous ones. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints() for i,v in pairs(waypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end Okay, so what we did is, for every waypoint that’s being iterated in the table of waypoints, we tell the NPC to move to that waypoint using MoveTo(). The gaps between each waypoint is small enough for the NPC to walk to the next waypoint in a straight line. Then, you’ll notice there’s an if statement to it. This checks if whether the NPC reaches a waypoint that needs the humanoid to jump or not. Waypoints have a property called Action and this have 2 values, Jump and Walk. The waypoint will determine whether it’s action is either Jump or Walk. So, we use an if statement to check if the action is jump using an enumeration of PathWaypointAction. If it’s true, we will set the humanoid’s jump to true. And this should work now! Play the game and see the magic happens. Due to my trashy laptop, I’m unable to record it working in Roblox Studio. And there you go! You successfully make a smart NPC!\n\nWait! How can we make it so that when it handles blocked paths? This got me hard when I was trying to find a solution of it. While you can actually use path.Blocked event, I can’t manage to find how to use this event to handle this issue. But, the best thing we can solve this issue is to create a new path and compute it constantly. So for this, we will use RunService.Heartbeat as an alternative way for while true do loop. Then, instead of making a script that’s not good-looking, we will create functions which will do a separate job. So we will create a function that creates a path and returns it, then another function which will tell the NPC to move to each waypoints. The key is to tell the script to constantly create a new path, and compute it, as creating a path and compute it only once only keeps that path forever, so if we do this method, it will create a new clear path constantly. So if you want the full code instead of just trying to create the functions by yourself, here it is. NOTE: I wouldn’t recommend you guys to copy this code. Try to be creative and use your brain instead! local pathfinding = game:GetService(\"PathfindingService\") local run = game:GetService(\"RunService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local hum = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local function GetPath(destination) local path = pathfinding:CreatePath() if typeof(destination) == \"Vector3\" then -- This line is untested yet. Please tell me if it works. path:ComputeAsync(rootPart.Position,destination) else path:ComputeAsync(rootPart.Position,destination.Position) end return path end local function WalkToWaypoints(tableWaypoints) for i,v in pairs(tableWaypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end end local function WalkTo(destination) local path = GetPath(destination) if path.Status == Enum.PathStatus.Success then -- the path will return either success as true value or nopath as false value if it's computed. WalkToWaypoints(path:GetWaypoints()) end end run.Heartbeat:Connect(function() WalkTo(destination) end)\n\nThank you for reading my post! Again, please leave feedbacks and any mistakes and corrections under this post. I will update the post if I did anything wrong.\n\nEDIT 1: I made a spelling mistake while spelling humanoid in the scripts. I accidentally spell it hum as humanoid. If you wanna change it, you can use Ctrl + H or Cmd + H while typing in the script to change these spellings immediately. Sorry for the mistake!"
    },
    {
        "link": "https://devforum.roblox.com/t/pathfinder-a-pathfinding-character-control-module-for-npcs/3422290",
        "document": "While I was working with pathfinding NPCs, I noticed that some commonly used methods such as using in between waypoints makes the character stop or not follow a specific path in a lot of cases, and realised a need for a character control module which is easy to use, configurable, can follow a part/model or pathfind to a location once, and applicable for most cases. That is why I made Pathfinder, I first got the idea from an NPC character I was working on and decided to expand it to an open source module form.\n\nThe GitHub repository is the main source for all information related with this module and you can find everything there, plus lots of extras.\n\nWhile the module is tested and the methods I used were used in a live game before, the module itself as a whole was not. If you experience any issues, please create an issue on the GitHub repository.\n\nWhat does Pathfinder do?\n• Pathfinder uses PathfindingService for waypoints and waypoint actions, which means it supports every PathfindingService features Roblox offers.\n• Pathfinder uses custom logic (instead of MoveToFinished) to control the delays the character needs to follow the target, which can be a still or a moving target.\n• Pathfinder offers defaults which will be useful for most of the use cases, however, is designed to be configurable.\n• Pathfinder offers user-made actions for NPC characters (example, NPC can jump to the target player if the distance is less than an amount).\n\nWhat does Pathfinder NOT do?\n• Pathfinder is not a replacement to PathfindingService. It actively uses PathfindingService to create the waypoints.\n• Pathfinder is not made for non-Humanoid or non-character (such as cars) entities. They might or might not work.\n• Pathfinder will not work as fast as non-pathfinding character control methods, such as the plain MoveTo.\n• Pathfinder will not add new waypoints, although it can skip some waypoints to move without stopping, which means your paths will be as good as your navigation mesh in most cases.\n\nExample usage: (please check the GitHub repository for detailed examples and explanations)\n\nAfter this code I would just need to run it with .\n\n This example does not demonstrate moving targets or the optional configurations, the rest is in the repository.\n\nYou can get the module from Creator Store here, for wally and manual installations please check out the GitHub repository.\n\nBefore reporting any issues, please set on your Pathfinder instance ( will also be helpful but if you have many NPCs, the prints might lag Studio) and make sure that the nodes are where you would expect them to be. You might need to adjust your agentParameters or you might need to check your NavigationMesh (File → Studio Settings → Studio → Show Navigation Mesh and enable) and optimize your environment for a more ideal NavigationMesh. If there is something unexpected with your Navigation Mesh, module’s accuracy might also be affected.\n\nIf you think that the issue is with the module after checking these, you can report the issues and suggestions to the repository to keep everything organized, however I’ll also respond to this topic."
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://devforum.roblox.com/t/how-do-i-make-pathfinding-npc-move-to-players-towards-them-smooth-without-stopping/3300875",
        "document": "Hello dear developers. I’m trying to build my own horror game to make players have fun.\n\nI’m building a killer that chases nearest players to kill them. I scripted the NPC with my own pathfinding code.\n\nbut the main problem is the ai only chases old waypoints but not new way points.\n\nfor an example when player moves far away from the NPC the NPC only walks to old waypoints to reach the player. this almost becomes impossible for NPC to kill players.\n\nif you guys still do not understood, heres an example of video:"
    },
    {
        "link": "https://devforum.roblox.com/t/best-practices-handbook/2593598",
        "document": "Hey, my name is Jack. I’ve collaborated with several prominent Roblox groups and have accumulated a plethora of knowledge to share with you all. In this handbook, I’ll be covering the best practices for general programming and specific Lua related challenges.\n\nI wish I had this resource when I was learning.\n\nClick To See More Do you know what this variable stands for? Well I certainty wouldn’t know what it meant.\n\n Let’s try this again: This is much better. Using ineffective variables names will not only hurt your co-workers but will eventually confuse you.\n\nClick To See More Guard clauses are conditionals that exit a function/loop with a return/break/continue statement. Here’s an example of nested conditionals that can be replaced with guard clauses. function checkUsernameStatus(userNameValid : boolean, premiumSubscription : boolean) if premiumSubscription then if userNameValid then return \"Username is valid\" end end end function checkUsernameStatus(userNameValid : boolean, premiumSubscription : boolean) if not userNameValid or not premiumSubscription then return end return \"Username is valid\" end Notice how the code no longer has nested if statements. In large systems, guard clauses will come in handy when dealing with a multitude of conditionals.\n\nClick To See More Module Scripts are arguably the most useful script object in Roblox. Module scripts allow you to create clean and reusable code. Repetitive code is a thing of the past once you have harnessed the power of module scripts. Some popular frameworks employ the use of module scripts instead of scripts and localscripts (e.g. Knit Framework). Why rewrite code when you can just reference a single function or class? This is a basic example of module scripts. However when combined with OOP, module scripts go to the next level. I’ll leave a tutorial to OOP below as well.\n\nClick To See More Type Checking is extremely useful, even more so when working with bigger projects.\n\n In fact, if you have ever used a roblox service, you have seen typechecking. For example, let’s take a look at tween service:\n\n \n\n In this picture I am creating a new tween, and you can see it showing a typechecking UI when I’m filling out the parameters. The orange underlines resemble variables while the red underlines resemble the type.\n\n This is useful information because you now know what the method’s parameters are looking for.\n\n You can typecheck variables, parameters, and function returns. Now let’s make our own method using type checking: Now, string1 and string2 expect a type of string. And the function expects to return a string.\n\nClick To See More Duplicating your code in multiple places will ultimately lead to confusing code and impossible changes. function findClosestPlayer(plr) local distance = nil local nearPlayer = nil for i, v in pairs(players:GetPlayers()) do local distanceBetween = v:DistanceFromCharacter(plr.Character.HumanoidRootPart.Position) if not v.Character or (distance and distanceBetween >= distance) or v.Name == plr.Name then continue end distance = distanceBetween nearPlayer = v end end Now imagine if this was not a function and you duplicated this code 10 times throughout your script.\n\n First of all, this will cause readability to decrease. Let’s say I need to change part of this code. Looks like we have to change all 10 occurrences of this code. However, If this code was in a function, you could change the code in the function and you would be all good.\n\nClick To See More Documenting your code is important when working on projects with a team or just your self. Imagine you write a complex system. Three months later, you need to make some changes to your code. However, you don’t know how everything works in your system. If your code was documented, it would have saved a couple hours of confusion. Also, did you know that the word “TODO” is a keyword? In studio, the word “TODO” will be bolded.\n\nClick To See More A lot of newer-intermediate programmers will often make the mistake of making memory leaks by having a misinterpretation of connections and memory. Let’s look at the following code: Let’s say you only need this code to run once. After the first time this code runs, it will be useless to you. And, this connection will still be in memory. It’s only until the part get’s deleted will the connection get garbage collected. Let’s go ahead and fix this problem: Now, this touched event is only in memory until the first time it’s touched. For an alternative solution, you can use Event:Once(). This will make sure the event only fires once and is garbage collected:\n\nClick To See More Instance.new is already performance heavy, so utilize this best practice.\n\n Do not use the second argument of instance.new to set the parent of an object. The following code is the worst way you can use Instance.new. It uses the second argument of Instance.new. In this case, it takes Roblox ten performance expensive steps to execute the code. This code queues useless replication changes which is heavy on CPU and bandwidth usage. -- What not to do local newPart = Instance.new(\"Part\", workspace) newPart.Position = Vector3.new(1,1,1) newPart.Size = Vector3.new(1,1,1) Instead, you should always set the parent property last: -- What to do local newPart = Instance.new(\"Part\") newPart.Position = Vector3.new(1,1,1) newPart.Size = Vector3.new(1,1,1) newPart.Parent = workspace This code only takes Roblox five steps. This is the most optimal solution. This code’s property updates are extremely fast. When the object is inserted into the game, it’s in it’s final state. If you don’t set the parent argument last, you will not get the desired performance. In fact, most Roblox core scripts and tools use this bad practice… Set up Instance.new in the following order:\n\n A. Instance.new\n\n B. Assign properties\n\n C. Assign Parent\n\n D. Connect signals For more information:\n\n PSA: Don't use Instance.new() with parent argument\n\nGetService instead of referring to services"
    },
    {
        "link": "https://gamedevblog.com/2020/03/best-practices-for-roblox-development.html",
        "document": ""
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-handle-script-timeout-exhausted-allowed-execution-time/533353",
        "document": "You can disable the timeout in Studio with the following command (or just set the setting manually):\n\nLong-running scripts should basically never happen on live servers (blocking important server stuff) and clients (player experiences lag), so you should find a way to batch if that’s where you’re going.\n\nA dumb but effective way to “batch” is to yield conditionally based on execution time. For example:\n\nThreads eventually need to yield back to the engine, or they will time out. Top-level code in a script, as well as event listeners, are resumed by the engine, so these are what eventually need to yield. The entry point is when the engine resumes a thread, and the exit point is when the thread yields back to the engine.\n\nHere is an example, along with steps describing how it executes.\n• When the script runs, the thread of the script (let’s call it “Root”) is resumed by the engine.\n• Root calls , which yields back to the engine.\n\ndoesn’t do anything special to get the running thread to be resumed later (this used to be the case, but not anymore), so Root is effectively killed.\n\nConsider the same example as a separate thread:\n• At this point, Root continues running. There’s no more code, so Root dies, yielding back to Engine.\n\nNow consider this slightly altered example:\n\nHere, execution moves back and forth between Root and Work, but never actually yields back to the engine. This will eventually cause a timeout, and demonstrates that it is not enough just to yield a thread. You have to consider what you’re yielding back to.\n\nTo drive the point home, let’s see what happens when is used instead of :\n• Work calls , adding Work to the engine’s scheduler queue, then yielding back to Root.\n• Work calls , adding Work to the engine’s scheduler queue, then yielding back to Root.\n• Work calls , adding Work to the engine’s scheduler queue, then yielding back to Root.\n\nEventually, a timeout occurs, then the scheduler gets to work emptying its queue by resuming the Work thread over and over again. Because threads scheduled by run on a budget, this is rolled out slowly over a lengthy amount of time.\n\nThe problem here is that, by calling , the Work thread is being managed by both the scheduler and Root’s resume loop. The simple resolution to this is to let the engine do all the work managing threads:\n• Root calls , adding Root to the engine’s scheduler queue, then yielding back to Engine."
    },
    {
        "link": "https://devforum.roblox.com/t/need-help-with-a-day-night-cycle-script/2387705",
        "document": "I initially went into studio to implement this in a game i’ve been collaborating on with some other guys on the platform for fun intending it for it to maybe be a 10 minute job or less and ended up staring at the code with no actual idea how to implement this correctly. I wanted to create one that is easy on the eyes so that the other devs know what they’re dealing with (they don’t know how to code). I have a config property set up with some attributes and a manual script (redundant but why not) with the main code being this:\n\nthe GetMinutesAfterMidnight function was referenced by this following code from another thread/post and now I realize I don’t really understand what it actually does."
    },
    {
        "link": "https://devforum.roblox.com/t/how-would-i-organize-my-scripting-better/254551",
        "document": "Generally minimising the number of scripts running at once and using module scripts to extend the functionality of these scripts is beneficial and preferred.\n\nBoring bit of history here which is semi irrelevant but gives a bit of background into why we do things this way. Feel free to skip this though.\n\nNow why do I say this? First of all I would like to say that this is generally true with all of programming. If you look at the control flow of pretty much all major languages there is a single entry point (beginning of program) which goes on through lots of different files to eventually build up into the whole program. Let’s take C for example, you declare a main function which is our entry point and you require other code via the use of header files. Or Java, again you define a main function and import classes to use them.\n\nWhy is this preferred? Well originally all computers were single threaded. It made absolutely no sense to try running multiple bit of a program at the same time because they couldn’t run at the same time. And if you schedule them to emulate running at the same time by implementing a scheduler then you’ve just made a load more work for yourself. Not only do you need to make a scheduler but you now have multiple paths to try debug through if anything goes wrong. Bleh.\n\nNowadays schedulers are built into operating systems and we even have many cores to run things properly at the same time. Here it could make sense to run multiple bits of your program at the same time. But now we get into horrible confusing multithreaded problems such as one program writing a value at the same time as another. Then we get nonsense like 1+1=3? or 1+1+1=2? It gets messy fast.\n\nNow we can get onto Lua. Lua runs on a single thread and runs one script after another making it seem like they are running at the same time. While this is a useful abstraction it’s helpful to remember. You can either have lots of scripts which lua will run back to back and weave into a single thread for you, or you can do this yourself and have full control. And when you think about it, why wouldn’t you want this?\n\nWith a single thread your program has to start somewhere. If you only have one entry point then it’s obvious where that is. You also know exactly in what order your code will execute. You know exactly what is assigning what to where. You don’t have to worry about things modifying other things in odd orders.\n\nNow that boring part is out of the way let’s get to the fun analogies.\n\nYou can think of scripts as little workers. On their own they can’t do a lot. Now you could just chuck a whole pile of workers at a problem and make some amazing things (look at the pyramids!) but you can intuitively feel how inefficient this is. Instead you could give your worker some tools.\n\nModulescripts should be thought of as tools. Tools are fit for a specific purpose. They do one job and they do it well. They can be reused and have many copies made. You can give these tools to your workers and they will be able to achieve a lot more! I know I would definitely prefer to have a couple workers with amazing tools than have so many workers I can’t even remember their names!\n\nEven better when you move to a new project you might have to hire some new workers however you can probably provide them with the same tools again. You can imagine how much faster this makes development.\n\nWhile this is quite an abstract metaphor I hope it helps subtly convey the true nature of why modulescripts are useful."
    }
]