[
    {
        "link": "https://vuejs.org/api/sfc-script-setup",
        "document": "is a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal syntax:\n• More succinct code with less boilerplate\n• Ability to declare props and emitted events using pure TypeScript\n• Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n• Better IDE type-inference performance (less work for the language server to extract types from code)\n\nTo opt-in to the syntax, add the attribute to the block:\n\nThe code inside is compiled as the content of the component's function. This means that unlike normal , which only executes once when the component is first imported, code inside will execute every time an instance of the component is created.\n\nWhen using , any top-level bindings (including variables, function declarations, and imports) declared inside are directly usable in the template:\n\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the option:\n\nReactive state needs to be explicitly created using Reactivity APIs. Similar to values returned from a function, refs are automatically unwrapped when referenced in templates:\n\nValues in the scope of can also be used directly as custom component tag names:\n\nThink of as being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent also works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\n\nSince components are referenced as variables instead of registered under string keys, we should use dynamic binding when using dynamic components inside :\n\nNote how the components can be used as variables in a ternary expression.\n\nAn SFC can implicitly refer to itself via its filename. E.g. a file named can refer to itself as in its template.\n\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\n\nYou can use component tags with dots like to refer to components nested under object properties. This is useful when you import multiple components from a single file:\n\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with , but they must follow the naming scheme :\n\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\n\nTo declare options like and with full type inference support, we can use the and APIs, which are automatically available inside :\n• None and are compiler macros only usable inside . They do not need to be imported, and are compiled away when is processed.\n• None accepts the same value as the option, while accepts the same value as the option.\n• None and provide proper type inference based on the options passed.\n• None The options passed to and will be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it can reference imported bindings since they are in the module scope as well.\n\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to or :\n• None or can only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.\n• None When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\n• None In dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here is inferred from the type. If the type is a reference to an imported type, the inferred result will be (equal to type) since the compiler does not have information of external files.\n• None In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into )\n• None In version 3.2 and below, the generic type parameter for were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nIn Vue 3.5 and above, variables destructured from the return value of are reactive. Vue's compiler automatically prepends when code in the same block accesses variables destructured from :\n\nThe above is compiled to the following equivalent:\n\nIn addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:\n\nIn 3.5 and above, default values can be naturally declared when using Reactive Props Destructure. But in 3.4 and below, Reactive Props Destructure is not enabled by default. In order to declare props default values with type-based declaration, the compiler macro is needed:\n\nThis will be compiled to equivalent runtime props options. In addition, the helper provides type checks for the default values, and ensures the returned type has the optional flags removed for properties that do have default values declared.\n• Only available in 3.4+\n\nThis macro can be used to declare a two-way binding prop that can be consumed via from the parent component. Example usage is also discussed in the Component guide.\n\nUnder the hood, this macro declares a model prop and a corresponding value update event. If the first argument is a literal string, it will be used as the prop name; Otherwise the prop name will default to . In both cases, you can also pass an additional object which can include the prop's options and the model ref's value transform options.\n\nTo access modifiers used with the directive, we can destructure the return value of like this:\n\nWhen a modifier is present, we likely need to transform the value when reading or syncing it back to the parent. We can achieve this by using the and transformer options:\n\nLike and , can also receive type arguments to specify the types of the model value and the modifiers:\n\nComponents using are closed by default - i.e. the public instance of the component, which is retrieved via template refs or chains, will not expose any of the bindings declared inside .\n\nTo explicitly expose properties in a component, use the compiler macro:\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape (refs are automatically unwrapped just like on normal instances).\n\nThis macro can be used to declare component options directly inside without having to use a separate block:\n• This is a macro. The options will be hoisted to module scope and cannot access local variables in that are not literal constants.\n\nThis macro can be used to provide type hints to IDEs for slot name and props type checking.\n\nonly accepts a type parameter and no runtime arguments. The type parameter should be a type literal where the property key is the slot name, and the value type is the slot function. The first argument of the function is the props the slot expects to receive, and its type will be used for slot props in the template. The return type is currently ignored and can be , but we may leverage it for slot content checking in the future.\n\nIt also returns the object, which is equivalent to the object exposed on the setup context or returned by .\n\nUsage of and inside should be relatively rare, since you can access them directly as and in the template. In the rare case where you do need them, use the and helpers respectively:\n\nand are actual runtime functions that return the equivalent of and . They can be used in normal composition API functions as well.\n\ncan be used alongside normal . A normal may be needed in cases where we need to:\n• Declare options that cannot be expressed in , for example or custom options enabled via plugins (Can be replaced by in 3.3+).\n• Run side effects or create objects that should only execute once.\n\nSupport for combining and in the same component is limited to the scenarios described above. Specifically:\n• Do NOT use a separate section for options that can already be defined using , such as and .\n• Variables created inside are not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\n\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit function, instead of using .\n\nTop-level can be used inside . The resulting code will be compiled as :\n\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the .\n\nImport statements in vue follow ECMAScript module specification. In addition, you can use aliases defined in your build tool configuration:\n\nGeneric type parameters can be declared using the attribute on the tag:\n\nThe value of works exactly the same as the parameter list between in TypeScript. For example, you can use multiple parameters, constraints, default types, and reference imported types:\n\nIn order to use a reference to a generic component in a you need to use the library as won't work.\n• Due to the difference in module execution semantics, code inside relies on the context of an SFC. When moved into external or files, it may lead to confusion for both developers and tools. Therefore, cannot be used with the attribute."
    },
    {
        "link": "https://learnvue.co/articles/script-setup",
        "document": "If you’ve been working in Vite and Vue 3 recently, you’ll notice that when you start a new project, your script section looks like this with this script syntax in your Vue components.\n\nYou may be wondering, “What is this? Is this the Options API? Composition API? where’s the setup method?”\n\nThe <script setup> type is a proposed change in the Vue’s Git RFCs. To be clear, this is not intended to completely replace any of the current ways to write code. Its purpose is to provide developers with a more concise syntax to write their single file components.\n\nIn this article, we’re going to be taking a look at exactly how it works and some of the ways that it can be useful.\n\nIn , we don’t have to declare an and a method – instead, all top-level bindings are exposed to the template\n\nIn the Composition API, we’re used to having to create our setup method and then return anything that we want exposed. Something like this…\n\nBut with , we can rewrite the same code like this..\n\nAnd it’s not just data, computed properties, and methods! Even imported directives and components that are on the top level of our setup scope are automatically available in our template.\n\nLook at this example of importing a component.\n\nSo….what’s the point of this?\n\nIn the exact words of the RFC, “the proposal’s main goal is reducing the verbosity of Composition API usage inside SFCs by directly exposing the context of script setup to the template.”\n\nAnd that’s exactly what we just saw, by not having to worry about creating a method and returning exactly what we want to expose, we can simplify our code.\n\nPlus there’s no worry of forgetting to return something from our setup method (something I know I do all the time).\n\nNow that we know what even is and why it can be useful, let’s take a look at some of its more advanced features.\n\nFirst off, you may be wondering how to perform standard Vue operations like….\n\nIn the Composition API, these were simply arguments on our setup method,\n\nHowever, in the script setup syntax, we can access these same options with 3 imports from Vue.\n• – as the name suggests, allows us to define props for our component\n• – lets us define the events that our component can emit\n• – gives us access to the slots and attributes of our component\n\nWith these 3 imports we can get the functionality that we’re used to having on our traditional setup method.\n\nAnother cool feature of the script setup is how easy it is to create an async setup function.\n\nThis is useful for loading in apis as your component is created, and even tying in your code to the experimental suspense feature.\n\nAll we have to do to make our setup function asynchronous, is use a top level await inside our script setup.\n\nFor example, if we’re using the Fetch API, we can just use await like this…\n\n…and our resulting function will be asynchronous just like that.\n\ncreates its own script scope for its top level bindings. But in certain cases, there is code that must be executed in the module scope.\n\nThe 2 specific examples in this RFC are…\n• Creating global side effects that only execute once.\n\nThis can be done by adding a normal block alongside your script setup like this.\n\nAnd there you have it\n\nCurrently, this script setup is opt-in only so if you want to try it out, just add setup to your script tag.\n\nIf you never want to think about it and just want to write your code the way you’re used to, go for it. The choice is yours.\n\nTo learn more about the script setup, here’s the link to the full RFC with its motivations, exact syntax, and more technical implementations.\n\nSo that’s all for this article, I hope it helped clear up what this new syntax that’s inside your Vite app!\n\nIf you have any questions, leave them in the comments below!"
    },
    {
        "link": "https://stackoverflow.com/questions/66382293/how-to-use-props-in-script-setup-in-vue3",
        "document": "To use props with you need to call with the component prop options as the argument, this defines the props on the component instance and returns a object with the props which you can use as follows:\n\nIf you are using typescript the alternative way to do this is pass a type only declaration and infer the prop types from that. Pro's are that you'll get stricter type safety but you cannot have default values.\n\nDefaults with type only props are now possible:"
    },
    {
        "link": "https://fadamakis.com/vue-3-script-setup-macros-ab754266363f",
        "document": "Vue 3 Script Setup is the recommended syntax if you are using both Single File Components and Composition API. It provides a clean and concise structure that significantly reduces boilerplate code.\n\nThe main idea behind composition API is to explicitly import every helper that you need to use. For example, in the following code, both and are imported from the Vue Core.\n\nBut there are some helpers that don't need to be imported and are always available in our components. These helpers are called compiler macros. Let’s explore five of them: , , and .\n\nThis is an essential macro that you probably got familiar with during your first interactions with script setup. It allows you to declare props with the same syntax as in Options API but with full TypeScript type inference support.\n\nEvery best practice to declare and validate a prop still applies with this syntax.\n\nInside the template, every prop will be automatically available.\n\nIn case you want to use a prop inside the script setup you need to assign the return value of the macro to a variable.\n\nThe macro is similar to but is used to declare custom events emitted by the component. It ensures that emitted events are properly documented and provides type inference.\n\nIn this example, we use to declare two custom events: and . The variable returned by allows you to emit these events within your component's logic.\n\nEmits can also be declared using pure-type syntax by passing a literal type argument to :\n\nThe macro is a bit trickier. It is used to explicitly expose properties or methods from your component's block. By default, components using script setup are closed, meaning their internal bindings are not exposed to the parent component.\n\nHowever, in some cases, you may want to make certain properties or methods accessible from the parent component.\n\nIn this example, we expose the variable and the method to the parent component. They can be accessed from the parent using a template ref:\n\nThis way the parent component can have access to the child component's internal state and methods which is sometimes useful especially when developing a third-party library. But be aware that this pattern might cause component coupling. For our example moving the child’s state to a composable is probably a better choice.\n\nThe macro allows you to declare additional component options inside the block. This can be useful when you need to specify options that cannot be expressed using script setup macros alone.\n\nNote that is introduced in Vue 3.3. In previous versions, we had to use two separate scripts.\n\nThis is another addition of Vue 3.3 that aims to simplify two-way data binding inside script setup reduce boilerplate and improve development experience.\n\nPreviously to support two-way binding with v-model, we needed to declare a prop and emit a corresponding event.\n\nWe can do the same with the new macro. The macro automatically registers a prop and returns a ref that can be directly mutated.\n\nIn conclusion, while the usefulness of these macros varies, each of them is essential when writing code in Vue 3 and Script Setup. You can find out more about them in the official Vue documentation and see some additional options in the Vue Macros external library."
    },
    {
        "link": "https://vuejs.org/guide/essentials/template-syntax",
        "document": "Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\n\nUnder the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\n\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.\n\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\n\nThe mustache tag will be replaced with the value of the property from the corresponding component instance. It will also be updated whenever the property changes.\n\nThe double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the directive:\n\nHere we're encountering something new. The attribute you're seeing is called a directive. Directives are prefixed with to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the property on the current active instance.\"\n\nThe contents of the will be replaced with the value of the property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\n\nMustaches cannot be used inside HTML attributes. Instead, use a directive:\n\nThe directive instructs Vue to keep the element's attribute in sync with the component's property. If the bound value is or , then the attribute will be removed from the rendered element.\n\nBecause is so commonly used, it has a dedicated shorthand syntax:\n\nAttributes that start with may look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.\n\nIf the attribute has the same name with the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:\n\nThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.\n\nBoolean attributes are attributes that can indicate true / false values by their presence on an element. For example, is one of the most commonly used boolean attributes.\n\nThe attribute will be included if has a truthy value. It will also be included if the value is an empty string, maintaining consistency with . For other falsy values the attribute will be omitted.\n\nIf you have a JavaScript object representing multiple attributes that looks like this:\n\nYou can bind them to a single element by using without an argument:\n\nSo far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:\n\nThese expressions will be evaluated as JavaScript in the data scope of the current component instance.\n\nIn Vue templates, JavaScript expressions can be used in the following positions:\n• In the attribute value of any Vue directives (special attributes that start with )\n\nEach binding can only contain one single expression. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after .\n\nTherefore, the following will NOT work:\n\nIt is possible to call a component-exposed method inside a binding expression:\n\nTemplate expressions are sandboxed and only have access to a restricted list of globals. The list exposes commonly used built-in globals such as and .\n\nGlobals not explicitly included in the list, for example user-attached properties on , will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to .\n\nDirectives are special attributes with the prefix. Vue provides a number of built-in directives, including and which we have introduced above.\n\nDirective attribute values are expected to be single JavaScript expressions (with the exception of , and , which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take as an example:\n\nHere, the directive would remove or insert the element based on the truthiness of the value of the expression .\n\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the directive is used to reactively update an HTML attribute:\n\nHere, is the argument, which tells the directive to bind the element's attribute to the value of the expression . In the shorthand, everything before the argument (i.e., ) is condensed into a single character, .\n\nAnother example is the directive, which listens to DOM events:\n\nHere, the argument is the event name to listen to: . has a corresponding shorthand, namely the character. We will talk about event handling in more detail too.\n\nIt is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n\nHere, will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, , whose value is , then this binding will be equivalent to .\n\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n\nIn this example, when 's value is , will be equivalent to .\n\nDynamic arguments are expected to evaluate to a string, with the exception of . The special value can be used to explicitly remove the binding. Any other non-string value will trigger a warning.\n\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n\nIf you need to pass a complex dynamic argument, it's probably better to use a computed property, which we will cover shortly.\n\nWhen using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n\nThe above will be converted to in in-DOM templates. If your component has a property instead of , your code won't work. Templates inside Single-File Components are not subject to this constraint.\n\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the modifier tells the directive to call on the triggered event:\n\nYou'll see other examples of modifiers later, for and for , when we explore those features."
    },
    {
        "link": "https://vuejs.org/guide/typescript/composition-api",
        "document": "When using , the macro supports inferring the props types based on its argument:\n\nThis is called \"runtime declaration\", because the argument passed to will be used as the runtime option.\n\nHowever, it is usually more straightforward to define props with pure types via a generic type argument:\n\nThis is called \"type-based declaration\". The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.\n\nYou can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.\n\nWe can also move the props types into a separate interface:\n\nThis also works if is imported from an external source. This feature requires TypeScript to be a peer dependency of Vue.\n\nIn version 3.2 and below, the generic type parameter for were limited to a type literal or a reference to a local interface.\n\nThis limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nWhen using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by using Reactive Props Destructure :\n\nIn 3.4 and below, Reactive Props Destructure is not enabled by default. An alternative is to use the compiler macro:\n\nThis will be compiled to equivalent runtime props options. In addition, the helper provides type checks for the default values, and ensures the returned type has the optional flags removed for properties that do have default values declared.\n\nIf not using , it is necessary to use to enable props type inference. The type of the props object passed to is inferred from the option.\n\nWith type-based declaration, a prop can use a complex type much like any other type:\n\nFor runtime declaration, we can use the utility type:\n\nThis works in much the same way if we're specifying the option directly:\n\nThe option is more commonly used with the Options API, so you'll find more detailed examples in the guide to TypeScript with Options API. The techniques shown in those examples also apply to runtime declarations using .\n\nIn , the function can also be typed using either runtime declaration OR type declaration:\n\nThe type argument can be one of the following:\n• A callable function type, but written as a type literal with Call Signatures. It will be used as the type of the returned function.\n• A type literal where the keys are the event names, and values are array / tuple types representing the additional accepted parameters for the event. The example above is using named tuples so each argument can have an explicit name.\n\nAs we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.\n\nWhen not using , is able to infer the allowed events for the function exposed on the setup context:\n\nRefs infer the type from the initial value:\n\nSometimes we may need to specify complex types for a ref's inner value. We can do that by using the type:\n\nOr, by passing a generic argument when calling to override the default inference:\n\nIf you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes :\n\nalso implicitly infers the type from its argument:\n\nTo explicitly type a property, we can use interfaces:\n\ninfers its type based on the getter's return value:\n\nYou can also specify an explicit type via a generic argument:\n\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\n\nWithout type annotation, the argument will implicitly have a type of . This will also result in a TS error if or are used in . It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of :\n\nProvide and inject are usually performed in separate components. To properly type injected values, Vue provides an interface, which is a generic type that extends . It can be used to sync the type of the injected value between the provider and the consumer:\n\nIt's recommended to place the injection key in a separate file so that it can be imported in multiple components.\n\nWhen using string injection keys, the type of the injected value will be , and needs to be explicitly declared via a generic type argument:\n\nNotice the injected value can still be , because there is no guarantee that a provider will provide this value at runtime.\n\nThe type can be removed by providing a default value:\n\nIf you are sure that the value is always provided, you can also force cast the value:\n\nWith Vue 3.5 and 2.1 (powering both the IDE language service and ), the type of refs created by in SFCs can be automatically inferred for static refs based on what element the matching attribute is used on.\n\nIn cases where auto-inference is not possible, you can still cast the template ref to an explicit type via the generic argument:\n\nTo get the right DOM interface you can check pages like MDN.\n\nNote that for strict type safety, it is necessary to use optional chaining or type guards when accessing . This is because the initial ref value is until the component is mounted, and it can also be set to if the referenced element is unmounted by .\n\nWith Vue 3.5 and 2.1 (powering both the IDE language service and ), the type of refs created by in SFCs can be automatically inferred for static refs based on what element or component the matching attribute is used on.\n\nIn cases where auto-inference is not possible (e.g. non-SFC usage or dynamic components), you can still cast the template ref to an explicit type via the generic argument.\n\nIn order to get the instance type of an imported component, we need to first get its type via , then use TypeScript's built-in utility to extract its instance type:\n\nIn cases where the exact type of the component isn't available or isn't important, can be used instead. This will only include properties that are shared by all components, such as :\n\nIn cases where the component referenced is a generic component, for instance :\n\nIt needs to be referenced using from the library as won't work.\n\nNote that with 2.1+, static template refs' types can be automatically inferred and the above is only needed in edge cases."
    },
    {
        "link": "https://vuejs.org/guide/typescript/options-api",
        "document": "Type inference for props in Options API requires wrapping the component with . With it, Vue is able to infer the types for the props based on the option, taking additional options such as and into account:\n\nHowever, the runtime options only support using constructor functions as a prop's type - there is no way to specify complex types such as objects with nested properties or function call signatures.\n\nTo annotate complex props types, we can use the utility type:\n\nIf your TypeScript version is less than , you have to be careful when using function values for and prop options - make sure to use arrow functions:\n\nThis prevents TypeScript from having to infer the type of inside these functions, which, unfortunately, can cause the type inference to fail. It was a previous design limitation, and now has been improved in TypeScript 4.7.\n\nWe can declare the expected payload type for an emitted event using the object syntax of the option. Also, all non-declared emitted events will throw a type error when called:\n\nA computed property infers its type based on its return value:\n\nIn some cases, you may want to explicitly annotate the type of a computed property to ensure its implementation is correct:\n\nExplicit annotations may also be required in some edge cases where TypeScript fails to infer the type of a computed property due to circular inference loops.\n\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\n\nWithout type annotation, the argument will implicitly have a type of . This will also result in a TS error if or are used in . It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of :\n\nSome plugins install globally available properties to all component instances via . For example, we may install for data-fetching or for internationalization. To make this play well with TypeScript, Vue exposes a interface designed to be augmented via TypeScript module augmentation:\n\nWe can put this type augmentation in a file, or in a project-wide file. Either way, make sure it is included in . For library / plugin authors, this file should be specified in the property in .\n\nIn order to take advantage of module augmentation, you will need to ensure the augmentation is placed in a TypeScript module. That is to say, the file needs to contain at least one top-level or , even if it is just . If the augmentation is placed outside of a module, it will overwrite the original types rather than augmenting them!\n\nSome plugins, for example , provide support for custom component options such as :\n\nWithout proper type augmentation, the arguments of this hook will implicitly have type. We can augment the interface to support these custom options:\n\nNow the option will be properly typed. Note this is just an example - well-typed libraries like should automatically perform these augmentations in their own type definitions.\n\nThe placement of this augmentation is subject to the same restrictions as global property augmentations."
    },
    {
        "link": "https://stackoverflow.com/questions/65002098/how-to-define-type-for-refbinding-on-template-in-vue3-using-typescript",
        "document": "Well, that would depend on whether or not you need it typed and to provide member information (public properties, methods, etc). If you do, then yes you need to define a type for it; otherwise, you don't have to, and can simply access the unwrapped reference with which leaves it as type (I bet you figured out this one).\n\nBut if you have to, you need to tell the compiler what it is or what it's going to be assigned on. To do that, you'll want to use the third overload of (with no argument) and explicitly set the generic type to the desired type—in your case, you want (or simply if you don't care about the specific members it has to offer).\n\nIn JavaScript, you don't have type checking, so passing on the function is as good as not passing anything (which is especially okay for template refs)*; it could even come across as being misleading in a sense that the unwrapped value actually resolves to something else but .\n\n* When using the Composition API, the concept of \"reactive refs\" and \"template refs\" are unified. And the reason we're accessing this particular type of on the mounted hook is because the DOM element will be assigned to it after initial render."
    },
    {
        "link": "https://vue-macros.dev/macros/define-options.html",
        "document": "Options API can be declared using the in , specifically to be able to set , , , and inside of one function.\n\nFor Vue >= 3.3, this feature will be turned off by default.\n\nif you need feature only, the standalone version is more appropriate for you."
    },
    {
        "link": "https://stackoverflow.com/questions/66322622/using-refs-with-vue-3-typescript-options-api",
        "document": "I am trying to understand the best way to use refs together with TypeScript and the Options API. In the docs they reference it like below, but that is without using TS. When it comes to TS, they only explain how to use it with Composition API.\n\nWhen I use it throws this error\n\nI know that I can cast it and use it like this: but that I feel shouldn't be necessary to do for every ref every single time.\n\nWhat is the correct way to use a reference with Options API + TS?"
    }
]