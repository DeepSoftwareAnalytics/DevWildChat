[
    {
        "link": "https://scaledrone.com/docs/tutorials/chatroom/1-javascript",
        "document": "In this tutorial you are going to build a client side chatroom. Users will be able to send messages and display incoming messages in a chat window.\n\nCheck out the live editable example on JS Bin.\n\nLets start with the basic layout for the chatroom that includes some HTML and CSS.\n\nNext you're going to connect to Scaledrone. Start by creating a new channel in the admin panel, you're going to use the channel's ID to connect to it.\n\nOnce you have received an event you can subscribe to a room. All messages are sent inside rooms. For this tutorial you're going to need a single room called .\n\nBesides the event that rooms emit you can also listen to a event. This event will get triggered when someone publishes some data to the room. Once you receive a message from the room you will append an element to the chat area.\n\nNow that you are listening to new messages. Let's add the send functionality! The form has two fields: and . You are going to send messages to the same room that you are listening to."
    },
    {
        "link": "https://scaledrone.com/docs/api-clients/javascript",
        "document": "To include the Scaledrone client library in your website, add the Scaledrone JavaScript library script tag to the section of your HTML file.\n\nYou can choose between two JS library versions:\n\nDo not host this file yourself.\n\nTo connect to a channel you need to first create it in the admin panel of Scaledrone's website. One instance of Scaledrone establishes a single connection.\n\nA connection has been opened. The argument indicates a problem with the connection.\n\nAn error has occurred with the connection.\n\nConnection to Scaledrone has been closed. After this event, Scaledrone will not try to automatically reconnect.\n\nUser has disconnected and Scaledrone is trying to reconnect.\n\nAll messages move within rooms. To listen to messages, you need to subscribe to a specific room. \n\n Users can connect to multiple rooms (this does not create extra connections).\n\nReceived a message that was sent to the room. The object structure looks like this:\n\nAll users subscribed to the room will receive the message (also the publishing user, if it's subscribed). You don't have to be subscribed to a room when publishing to it.\n\nThe message can be anything that can be stringified as JSON and then parsed (for example a Number, String or an Object).\n\nStops listening to messages from the room.\n\nTo keep track of users that are connected to a room see the observable rooms documentation.\n\nClient authentication is an optional step and can only be used when you have set up a JWT server. Read more about this from the authentication documentation\n\nMake sure you replace the string with your Scaledrone channel's ID from the dashboard."
    },
    {
        "link": "https://github.com/ScaleDrone/javascript-chat-room-tutorial",
        "document": "These are the project files for the JavaScript chat room tutorial.\n\nTo run this example make sure to replace the in"
    },
    {
        "link": "https://github.com/ScaleDrone/javascript-chat-room-tutorial/blob/master/index.html",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://apitracker.io/a/scaledrone",
        "document": "Copyright © 2025 API Tracker , an Apideck product. Mentioned product names and logos are the property of their respective owners.\n\nDisclaimer: We do our best to ensure that the data we release is complete, accurate, and useful. However, because we are not able to verify all the data, and because the processing required to make the data useful is complex, we cannot be held liable for omissions or inaccuracies."
    },
    {
        "link": "https://scaledrone.com/blog/javascript-chat-room-tutorial",
        "document": "We're going to be building a real-time JavaScript chat room similar to Twitch.tv's chat using JavaScript and Scaledrone realtime messaging service. The app is going to be using Websockets on modern browsers and fallback technologies on older ones.\n\nFor the live users list feature to work we will be using Scaledrone's new observable rooms feature. The observable rooms feature will let us keep track of who is currently connected to the chat room.\n\nCheck out the working live example and grab the source code from GitHub.\n\nThe chat room app is broken into three sections\n• Message input area - A form for sending messages to the chat window\n\nSetting up the skeleton of the app\n\nThe app is quite simple, it consists of two files:\n\nGrab the file from here. The file contains:\n• HTML Markup for the three sections\n\nFirst, we'll need to connect to a Scaledrone channel which you can create here for free. We'll also be generating a random name and color which we'll pass to Scaledrone to distinct the user.\n\nWe'll assign a random hex color and a random name to each user generated from a list of adjectives and a list of nouns.\n\nWe'll connect to a room called . Any room name will work, but for the live users functionality to work, we'll need to prefix the room name with .\n\nNext, let's set up the code for handling users joining and leaving the room. A user who connects to a room is called a member in Scaledrone lingo.\n\nLet's define a global members array to keep track of the current online users state.\n\nNow that we have a members array we can add and remove joining members from it.\n\nWe'll need a data event an listener to listen to the messages sent by users.\n\nYou can now test out the app. Check the console logs, you should see a message that you successfully connected to the room.\n\nWe won't be using any fancy frameworks but rather use the regular DOM API. Let's write a function to update the who's online display called and a function to add a new message to the chat window called . Make sure you uncomment those two function calls in the previous code.\n\nLastly, let's hook up the submit button. When receiving the submit event (which can be triggered by clicking \"Send\" or pressing Enter) we'll clear the input and send the message into the room.\n\nAnd we're done! You can grab the full file from here.\n\nIf you have any questions or feedback feel free to contact us."
    },
    {
        "link": "https://scaledrone.com/blog/webrtc-chat-tutorial",
        "document": "This tutorial will teach you:\n• How to create a 1-on-1 text chat where users can enter their username and be assigned a random emoji avatar\n• How to use to send peer to peer messages\n• How to use Scaledrone realtime messaging service for signaling so that no server coding is needed\n\nFor a WebRTC video chat tutorial check out our other post.\n\nWebRTC is a collection of communications protocols and APIs that enable real-time peer to peer connections within the browser. It's perfect for multiplayer games, chat, video and voice conferences or file sharing.\n\nWebRTC is available in most modern browsers except Safari. It's currently supported by Chrome, Firefox, Edge and Opera. Safari has listed support for WebRTC as being in development.\n\nThe discovery and negotiation process of WebRTC peers is called signaling. For two devices in different networks to find each other they need to use a central service called a signaling server. Using the signaling server two devices can discover each other and exchange negotiation messages. WebRTC does not specify signaling; different technologies such as WebSockets can be used for it.\n\nTwo peers exchange ICE candidates until they find a method of communication that they both support. After the connection has been established ICE candidates can be traded again to upgrade to a better and faster communication method.\n\nSTUN servers are used to get an external network address and to pass firewalls.\n\nOur chat will have two sections: the messages section where chat bubbles appear and the footer from where you can insert and send a message.\n\nTo render the incoming messages, we'll use a element. The template element will not be rendered in DOM but will be accessible from our JavaScript code.\n\nThe full file along with some CSS can be found from here.\n\nFirst, let's set up some initial variables.\n\nEach user will be assigned a random emoji to act as an avatar. If animals are not your thing, feel free to replace them with emojis of your choice.\n\nAsk the user for their name.\n\nEach 1-on-1 chat will be held on a separate URL so that users could share a direct link with a friend.\n\nFor WebRTC specific code we'll define a variable defining a url to Google's public STUN server. We'll also define the global and variables.\n\nFor two peers in different networks to find each other they need to use a central service called a signaling server. WebRTC does not define signaling and many means of transportation can be used.\n\nTo avoid writing server side code, we will use Scaledrone realtime messaging service. Create a free Scaledrone account and replace the channel ID. If you wish to write your own signaling server, this tutorial will still work fine without using Scaledrone.\n\nTo import the Scaledrone JavaScript library into your project add this script tag before the closing tag.\n\nScaledrone works as a central socket server between remote devices. Once a device joins a room it can see who else is connected to that room and send them messages.\n\nThe event will trigger with a list of connected devices (including ourselves).\n• When we are the first user connected, let's wait for an offer from another user.\n• When we are the second user connected, let's send an offer to the other user.\n• If there are more than two users connected the room is full.\n\nThe function will be used to send a signaling message to devices connected to the Scaledrone room.\n\nThe instance represents a WebRTC connection between the local and a remote peer.\n• returns locally generated ICE candidates for signaling to other users. We pass it on to our signaling service.\n• is triggered when a change has occurred which requires session negotiation. This event starts the process and is only handled by the user that is an offerer.\n• is emitted when an is added to the connection by the remote peer.\n\nIf the user is an offerer, we'll create the ourselves.\n\nWhen creating the ourselves by calling or when listening to the event we call the function to set up data channel specific listeners.\n\nTo listen to messages from the signaling service define a function. We are interested in two types of messages; these are the same messages that we send out using the function:\n• - Session Description Protocol is a string describing the local end of the remote connection. After receiving an offer or answer from another peer, we can answer it.\n• - add the new ICE candidate to our connections remote description.\n\ngets called when creating an offer and when answering one. It updates the local description of the connection.\n\nWe'll render a new message on three occasions:\n• We receive a message from the remote peer through the event.\n• We send out a message ourselves using the form in the footer.\n• Administrative messages showing us the state of the application.\n\nEarlier in the tutorial we defined an HTML template with the data attribute. We can now query this template and use it to create message elements. Then we will insert those message elements into the messages list.\n\nLastly, let's hook up the form so we could write and send our messages.\n\nWhen the form's event is triggered we'll send our name, emoji and content as a JSON string using the . After that our message gets inserted into the DOM and the form gets cleared.\n\nCheck out the live demo and full source code. For a WebRTC video chat tutorial check out our other post."
    },
    {
        "link": "https://stackoverflow.com/questions/60292624/how-do-i-refresh-all-connected-clients-using-scaledrone",
        "document": "I own a website where it is a chatroom that most of my school uses to talk. There are some annoying spammers and just recently I made a way to ban them but they have to refresh. Is there any way I can make a way to refresh everyones screen who is on my website and have the spammer banned? It would also be useful to use this and refresh everyone when I release an update.\n\nIs there a way to do this using Scaledrone, which is the library that I am using?"
    },
    {
        "link": "https://github.com/ScaleDrone/webrtc",
        "document": "We read every piece of feedback, and take your input very seriously."
    },
    {
        "link": "https://stackoverflow.com/questions/18120105/push-notifications-messaging-in-html5-web-app",
        "document": "I am looking to integrate Push Notification in my Jquery mobile web App using PhoneGap for Android. Is there any solution to put cloud messaging in web app like push notification. My app is based on getting friends location and checked in new location so i was looking for messaging or push notification in web app.\n\ni am also read about http://www.html5rocks.com/en/tutorials/eventsource/basics/\n\nbut this was not helpful for me.\n\nIf real time Push Notification not possible in HTML5 web app Please let me about asynchronous messaging like offline messaging in my app."
    }
]