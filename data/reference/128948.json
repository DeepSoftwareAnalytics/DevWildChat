[
    {
        "link": "https://docs.kernel.org/dev-tools/kselftest.html",
        "document": "The kernel contains a set of “self tests” under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nRunning the selftests (hotplug tests are run in limited mode)¶ To build and run the tests with a single command, use: Note that some tests will require root privileges. Kselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to “Running a subset of selftests” section below. To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT The O= assignment takes precedence over the KBUILD_OUTPUT environment variable. The above commands by default run the tests and print full pass/fail report. Kselftest supports “summary” option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to “Running a subset of selftests” section below.\n\nYou can use the “TARGETS” variable on the make command line to specify single test to run, or a list of tests to run. To run only tests targeted for a single subsystem: You can specify multiple tests to build and run: To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT Additionally you can use the “SKIP_TARGETS” variable on the make command line to specify one or more targets to exclude from the TARGETS list. To run all tests but a single subsystem: You can specify multiple tests to skip: You can also specify a restricted list of tests to run together with a dedicated skiplist: See the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named to run the tests. You can simply do the following to run the installed Kselftests. Please note some tests will require root privileges: To see the list of available tests, the option can be used: The option can be used to run all the tests from a test collection, or the option for specific single tests. Either can be used multiple times: For other features see the script usage output, seen with the option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the or the argument. For example to use 165 seconds instead one would use: You can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest: Note that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you’ll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to . Here we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• None Create the test script that will run (load/unload) the module e.g. # Assumes you have booted a fresh build of this kernel tree /path/to/linux/tree make kselftest-merge make modules sudo make modules_install make lib kselftest A bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above. The tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example. Optional debug logging function available for use in tests. Logging may be enabled or disabled by defining TH_LOG_ENABLED. E.g., #define TH_LOG_ENABLED 1 If no definition is provided, logging is enabled by default. Defines the test function and creates the registration stub Defines a test by name. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Defines a test by name and the expected term signal. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Wraps the struct name so we have one less argument to pass around Almost always, you want just instead (see below). This call may be used when the type of the fixture data is needed. In general, this should not be needed unless the self is being passed to a helper directly. Called once per fixture to setup the data and register Defines the data provided to -defined tests as self. It should be populated and cleaned up using and . Prepares the setup function for the fixture. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “setup” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation. ASSERT_* are valid for use in this context and will prempt the execution of any dependent fixture tests. A bare “return;” statement may be used to return early. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “teardown” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation to clean up. A bare “return;” statement may be used to return early. Optionally called once per fixture to declare fixture variant Defines type of constant parameters provided to , and FIXTURE_TEARDOWN as variant. Variants allow the same tests to be run with different arguments. Called once per fixture variant to setup and register the data name of the parameter set Defines a variant of the test fixture, provided to and as variant. Tests of each fixture will be run once for each variant. Defines a test that depends on a fixture (e.g., is part of a test case). Very similar to except that self is the setup instance of fixture’s datatype exposed for use by the implementation. The _metadata object is shared (MAP_SHARED) with all the potential forked processes, which enables them to use EXCEPT_*() and ASSERT_*(). The self object is only shared with the potential forked processes if FIXTURE_TEARDOWN_PARENT() is used instead of . Use once to append a main() to the test file. Operators for use in and . ASSERT_* calls will stop test execution immediately. EXPECT_* calls will emit a failure warning, note it, and continue."
    },
    {
        "link": "https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/kselftest.rst",
        "document": "The kernel contains a set of \"self tests\" under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nFor documentation on the kselftests themselves, see:\n\nTo build and run the tests with a single command, use:\n\nNote that some tests will require root privileges.\n\nKselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to \"Running a subset of selftests\" section below.\n\nTo build, save output files in a separate directory with O=\n\nTo build, save output files in a separate directory with KBUILD_OUTPUT\n\nThe O= assignment takes precedence over the KBUILD_OUTPUT environment variable.\n\nThe above commands by default run the tests and print full pass/fail report. Kselftest supports \"summary\" option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to \"Running a subset of selftests\" section below.\n\nYou can use the \"TARGETS\" variable on the make command line to specify single test to run, or a list of tests to run.\n\nTo run only tests targeted for a single subsystem:\n\nYou can specify multiple tests to build and run:\n\nTo build, save output files in a separate directory with O=\n\nTo build, save output files in a separate directory with KBUILD_OUTPUT\n\nAdditionally you can use the \"SKIP_TARGETS\" variable on the make command line to specify one or more targets to exclude from the TARGETS list.\n\nTo run all tests but a single subsystem:\n\nYou can specify multiple tests to skip:\n\nYou can also specify a restricted list of tests to run together with a dedicated skiplist:\n\nSee the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nNote that some tests will require root privileges.\n\nYou can use the \"install\" target of \"make\" (which calls the kselftest_install.sh tool) to install selftests in the default location (tools/testing/selftests/kselftest_install), or in a user specified location via the INSTALL_PATH \"make\" variable.\n\nTo install selftests in a user specified location:\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named run_kselftest.sh to run the tests.\n\nYou can simply do the following to run the installed Kselftests. Please note some tests will require root privileges:\n\nTo see the list of available tests, the -l option can be used:\n\nThe -c option can be used to run all the tests from a test collection, or the -t option for specific single tests. Either can be used multiple times:\n\nFor other features see the script usage output, seen with the -h option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the -o or the --override-timeout argument. For example to use 165 seconds instead one would use:\n\nYou can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nIn some cases packaging is desired, such as when tests need to run on a different system. To package selftests, run:\n\nThis generates a tarball in the INSTALL_PATH/kselftest-packages directory. By default, .gz format is used. The tar compression format can be overridden by specifying a FORMAT make variable. Any value recognized by tar's auto-compress option is supported, such as:\n\nmake gen_tar invokes make install so you can use it to package a subset of tests by using variables specified in Running a subset of selftests section:\n\nIn general, the rules for selftests are\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest:\n\nNote that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you'll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to .\n\nHere we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• Create the test script that will run (load/unload) the module e.g.\n\nA bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above.\n\nThe tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example."
    },
    {
        "link": "https://kernel.org/doc/html/next/dev-tools/kselftest.html",
        "document": "The kernel contains a set of “self tests” under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nRunning the selftests (hotplug tests are run in limited mode)¶ To build and run the tests with a single command, use: Note that some tests will require root privileges. Kselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to “Running a subset of selftests” section below. To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT The O= assignment takes precedence over the KBUILD_OUTPUT environment variable. The above commands by default run the tests and print full pass/fail report. Kselftest supports “summary” option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to “Running a subset of selftests” section below.\n\nYou can use the “TARGETS” variable on the make command line to specify single test to run, or a list of tests to run. To run only tests targeted for a single subsystem: You can specify multiple tests to build and run: To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT Additionally you can use the “SKIP_TARGETS” variable on the make command line to specify one or more targets to exclude from the TARGETS list. To run all tests but a single subsystem: You can specify multiple tests to skip: You can also specify a restricted list of tests to run together with a dedicated skiplist: See the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named to run the tests. You can simply do the following to run the installed Kselftests. Please note some tests will require root privileges: To see the list of available tests, the option can be used: The option can be used to run all the tests from a test collection, or the option for specific single tests. Either can be used multiple times: For other features see the script usage output, seen with the option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the or the argument. For example to use 165 seconds instead one would use: You can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest: Note that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you’ll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to . Here we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• None Create the test script that will run (load/unload) the module e.g. # Assumes you have booted a fresh build of this kernel tree /path/to/linux/tree make kselftest-merge make modules sudo make modules_install make lib kselftest A bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above. The tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example. Optional debug logging function available for use in tests. Logging may be enabled or disabled by defining TH_LOG_ENABLED. E.g., #define TH_LOG_ENABLED 1 If no definition is provided, logging is enabled by default. Defines the test function and creates the registration stub Defines a test by name. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Defines a test by name and the expected term signal. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Wraps the struct name so we have one less argument to pass around Almost always, you want just instead (see below). This call may be used when the type of the fixture data is needed. In general, this should not be needed unless the self is being passed to a helper directly. Called once per fixture to setup the data and register Defines the data provided to -defined tests as self. It should be populated and cleaned up using and . Prepares the setup function for the fixture. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “setup” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation. ASSERT_* are valid for use in this context and will prempt the execution of any dependent fixture tests. A bare “return;” statement may be used to return early. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “teardown” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation to clean up. A bare “return;” statement may be used to return early. Optionally called once per fixture to declare fixture variant Defines type of constant parameters provided to , and FIXTURE_TEARDOWN as variant. Variants allow the same tests to be run with different arguments. Called once per fixture variant to setup and register the data name of the parameter set Defines a variant of the test fixture, provided to and as variant. Tests of each fixture will be run once for each variant. Defines a test that depends on a fixture (e.g., is part of a test case). Very similar to except that self is the setup instance of fixture’s datatype exposed for use by the implementation. The _metadata object is shared (MAP_SHARED) with all the potential forked processes, which enables them to use EXCEPT_*() and ASSERT_*(). The self object is only shared with the potential forked processes if FIXTURE_TEARDOWN_PARENT() is used instead of . Use once to append a main() to the test file. Operators for use in and . ASSERT_* calls will stop test execution immediately. EXPECT_* calls will emit a failure warning, note it, and continue."
    },
    {
        "link": "https://github.com/WindRiver-Labs/linux-yocto-4.12/blob/master/Documentation/kselftest.txt",
        "document": "The kernel contains a set of \"self tests\" under the tools/testing/selftests/\n\ndirectory. These are intended to be small tests to exercise individual code\n\npaths in the kernel. Tests are intended to be run after building, installing\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and\n\nmemory to be ready to be offlined. A special hot-plug target is created\n\nin safe mode with a limited scope. In limited mode, cpu-hotplug test is\n\nrun on a single cpu as opposed to all hotplug capable cpus, and memory\n\nhotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nTo build and run the tests with a single command, use:\n\nYou can use the \"TARGETS\" variable on the make command line to specify\n\nsingle test to run, or a list of tests to run.\n\nYou can specify multiple tests to build and run:\n\nSee the top-level tools/testing/selftests/Makefile for the list of all\n\nYou can use kselftest_install.sh tool installs selftests in default\n\nlocation which is tools/testing/selftests/kselftest or a user specified\n\nKselftest install as well as the Kselftest tarball provide a script\n\nYou can simply do the following to run the installed Kselftests. Please\n\nIn general, the rules for selftests are\n\n* Do as much as you can if you're not root;\n\nexecutable which is not tested by default.\n\nTEST_FILES, TEST_GEN_FILES mean it is the file which is used by"
    },
    {
        "link": "https://android.googlesource.com/kernel/arm64/+/android-8.1.0_r0.71/Documentation/kselftest.txt",
        "document": "The kernel contains a set of \"self tests\" under the tools/testing/selftests/\n\ndirectory. These are intended to be small unit tests to exercise individual\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and\n\nmemory to be ready to be offlined. A special hot-plug target is created\n\nin safe mode with a limited scope. In limited mode, cpu-hotplug test is\n\nrun on a single cpu as opposed to all hotplug capable cpus, and memory\n\nhotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nTo build and run the tests with a single command, use:\n\nYou can use the \"TARGETS\" variable on the make command line to specify\n\nsingle test to run, or a list of tests to run.\n\nTo install selftests in an user specified location:\n\nIn general, the rules for selftests are\n\n* Do as much as you can if you're not root;\n\n* Don't break the build on any architecture, and\n\n* Don't cause the top-level \"make run_tests\" to fail if your feature is"
    },
    {
        "link": "https://docs.kernel.org/dev-tools/kselftest.html",
        "document": "The kernel contains a set of “self tests” under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nRunning the selftests (hotplug tests are run in limited mode)¶ To build and run the tests with a single command, use: Note that some tests will require root privileges. Kselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to “Running a subset of selftests” section below. To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT The O= assignment takes precedence over the KBUILD_OUTPUT environment variable. The above commands by default run the tests and print full pass/fail report. Kselftest supports “summary” option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to “Running a subset of selftests” section below.\n\nYou can use the “TARGETS” variable on the make command line to specify single test to run, or a list of tests to run. To run only tests targeted for a single subsystem: You can specify multiple tests to build and run: To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT Additionally you can use the “SKIP_TARGETS” variable on the make command line to specify one or more targets to exclude from the TARGETS list. To run all tests but a single subsystem: You can specify multiple tests to skip: You can also specify a restricted list of tests to run together with a dedicated skiplist: See the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named to run the tests. You can simply do the following to run the installed Kselftests. Please note some tests will require root privileges: To see the list of available tests, the option can be used: The option can be used to run all the tests from a test collection, or the option for specific single tests. Either can be used multiple times: For other features see the script usage output, seen with the option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the or the argument. For example to use 165 seconds instead one would use: You can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest: Note that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you’ll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to . Here we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• None Create the test script that will run (load/unload) the module e.g. # Assumes you have booted a fresh build of this kernel tree /path/to/linux/tree make kselftest-merge make modules sudo make modules_install make lib kselftest A bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above. The tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example. Optional debug logging function available for use in tests. Logging may be enabled or disabled by defining TH_LOG_ENABLED. E.g., #define TH_LOG_ENABLED 1 If no definition is provided, logging is enabled by default. Defines the test function and creates the registration stub Defines a test by name. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Defines a test by name and the expected term signal. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Wraps the struct name so we have one less argument to pass around Almost always, you want just instead (see below). This call may be used when the type of the fixture data is needed. In general, this should not be needed unless the self is being passed to a helper directly. Called once per fixture to setup the data and register Defines the data provided to -defined tests as self. It should be populated and cleaned up using and . Prepares the setup function for the fixture. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “setup” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation. ASSERT_* are valid for use in this context and will prempt the execution of any dependent fixture tests. A bare “return;” statement may be used to return early. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “teardown” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation to clean up. A bare “return;” statement may be used to return early. Optionally called once per fixture to declare fixture variant Defines type of constant parameters provided to , and FIXTURE_TEARDOWN as variant. Variants allow the same tests to be run with different arguments. Called once per fixture variant to setup and register the data name of the parameter set Defines a variant of the test fixture, provided to and as variant. Tests of each fixture will be run once for each variant. Defines a test that depends on a fixture (e.g., is part of a test case). Very similar to except that self is the setup instance of fixture’s datatype exposed for use by the implementation. The _metadata object is shared (MAP_SHARED) with all the potential forked processes, which enables them to use EXCEPT_*() and ASSERT_*(). The self object is only shared with the potential forked processes if FIXTURE_TEARDOWN_PARENT() is used instead of . Use once to append a main() to the test file. Operators for use in and . ASSERT_* calls will stop test execution immediately. EXPECT_* calls will emit a failure warning, note it, and continue."
    },
    {
        "link": "https://docs.kernel.org/5.17/dev-tools/kselftest.html",
        "document": "The kernel contains a set of “self tests” under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nRunning the selftests (hotplug tests are run in limited mode)¶ To build and run the tests with a single command, use: Note that some tests will require root privileges. Kselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to “Running a subset of selftests” section below. To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT The O= assignment takes precedence over the KBUILD_OUTPUT environment variable. The above commands by default run the tests and print full pass/fail report. Kselftest supports “summary” option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to “Running a subset of selftests” section below.\n\nYou can use the “TARGETS” variable on the make command line to specify single test to run, or a list of tests to run. To run only tests targeted for a single subsystem: You can specify multiple tests to build and run: To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT Additionally you can use the “SKIP_TARGETS” variable on the make command line to specify one or more targets to exclude from the TARGETS list. To run all tests but a single subsystem: You can specify multiple tests to skip: You can also specify a restricted list of tests to run together with a dedicated skiplist: See the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named to run the tests. You can simply do the following to run the installed Kselftests. Please note some tests will require root privileges: To see the list of available tests, the option can be used: The option can be used to run all the tests from a test collection, or the option for specific single tests. Either can be used multiple times: For other features see the script usage output, seen with the option.\n\nIn some cases packaging is desired, such as when tests need to run on a different system. To package selftests, run: This generates a tarball in the directory. By default, format is used. The tar compression format can be overridden by specifying a make variable. Any value recognized by tar’s auto-compress option is supported, such as: invokes so you can use it to package a subset of tests by using variables specified in Running a subset of selftests section:\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest: Here we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• None Create the test script that will run (load/unload) the module e.g. # Assumes you have booted a fresh build of this kernel tree /path/to/linux/tree make kselftest-merge make modules sudo make modules_install make lib kselftest A bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above. The tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example. Optional debug logging function available for use in tests. Logging may be enabled or disabled by defining TH_LOG_ENABLED. E.g., #define TH_LOG_ENABLED 1 If no definition is provided, logging is enabled by default. If there is no way to print an error message for the process running the test (e.g. not allowed to write to stderr), it is still possible to get the ASSERT_* number for which the test failed. This behavior can be enabled by writing before the check sequence that is unable to print. When an error occur, instead of printing an error message and calling , the test process call with the assert number as argument, which is then printed by the parent process. Defines the test function and creates the registration stub Defines a test by name. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Defines a test by name and the expected term signal. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Wraps the struct name so we have one less argument to pass around Almost always, you want just instead (see below). This call may be used when the type of the fixture data is needed. In general, this should not be needed unless the self is being passed to a helper directly. Called once per fixture to setup the data and register Defines the data provided to -defined tests as self. It should be populated and cleaned up using and . Prepares the setup function for the fixture. _metadata is included so that EXPECT_* and ASSERT_* work correctly. Populates the required “setup” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation. ASSERT_* are valid for use in this context and will prempt the execution of any dependent fixture tests. A bare “return;” statement may be used to return early. _metadata is included so that EXPECT_* and ASSERT_* work correctly. Populates the required “teardown” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation to clean up. A bare “return;” statement may be used to return early. Optionally called once per fixture to declare fixture variant Defines type of constant parameters provided to and as variant. Variants allow the same tests to be run with different arguments. Called once per fixture variant to setup and register the data name of the parameter set Defines a variant of the test fixture, provided to and as variant. Tests of each fixture will be run once for each variant. Defines a test that depends on a fixture (e.g., is part of a test case). Very similar to except that self is the setup instance of fixture’s datatype exposed for use by the implementation. Warning: use of ASSERT_* here will skip TEARDOWN. Use once to append a main() to the test file. Operators for use in and . ASSERT_* calls will stop test execution immediately. EXPECT_* calls will emit a failure warning, note it, and continue."
    },
    {
        "link": "https://kernelnewbies.org/OutreachyKernelSelftest_draft",
        "document": "Kernel selftests are run in userspace for testing kernel functions. They may be useful for regression testing of new kernels. Since they are run in userspace, the corresponding kernel has to be running for tests."
    },
    {
        "link": "https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/kselftest.rst",
        "document": "The kernel contains a set of \"self tests\" under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nFor documentation on the kselftests themselves, see:\n\nTo build and run the tests with a single command, use:\n\nNote that some tests will require root privileges.\n\nKselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to \"Running a subset of selftests\" section below.\n\nTo build, save output files in a separate directory with O=\n\nTo build, save output files in a separate directory with KBUILD_OUTPUT\n\nThe O= assignment takes precedence over the KBUILD_OUTPUT environment variable.\n\nThe above commands by default run the tests and print full pass/fail report. Kselftest supports \"summary\" option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to \"Running a subset of selftests\" section below.\n\nYou can use the \"TARGETS\" variable on the make command line to specify single test to run, or a list of tests to run.\n\nTo run only tests targeted for a single subsystem:\n\nYou can specify multiple tests to build and run:\n\nTo build, save output files in a separate directory with O=\n\nTo build, save output files in a separate directory with KBUILD_OUTPUT\n\nAdditionally you can use the \"SKIP_TARGETS\" variable on the make command line to specify one or more targets to exclude from the TARGETS list.\n\nTo run all tests but a single subsystem:\n\nYou can specify multiple tests to skip:\n\nYou can also specify a restricted list of tests to run together with a dedicated skiplist:\n\nSee the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nNote that some tests will require root privileges.\n\nYou can use the \"install\" target of \"make\" (which calls the kselftest_install.sh tool) to install selftests in the default location (tools/testing/selftests/kselftest_install), or in a user specified location via the INSTALL_PATH \"make\" variable.\n\nTo install selftests in a user specified location:\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named run_kselftest.sh to run the tests.\n\nYou can simply do the following to run the installed Kselftests. Please note some tests will require root privileges:\n\nTo see the list of available tests, the -l option can be used:\n\nThe -c option can be used to run all the tests from a test collection, or the -t option for specific single tests. Either can be used multiple times:\n\nFor other features see the script usage output, seen with the -h option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the -o or the --override-timeout argument. For example to use 165 seconds instead one would use:\n\nYou can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nIn some cases packaging is desired, such as when tests need to run on a different system. To package selftests, run:\n\nThis generates a tarball in the INSTALL_PATH/kselftest-packages directory. By default, .gz format is used. The tar compression format can be overridden by specifying a FORMAT make variable. Any value recognized by tar's auto-compress option is supported, such as:\n\nmake gen_tar invokes make install so you can use it to package a subset of tests by using variables specified in Running a subset of selftests section:\n\nIn general, the rules for selftests are\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest:\n\nNote that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you'll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to .\n\nHere we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• Create the test script that will run (load/unload) the module e.g.\n\nA bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above.\n\nThe tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example."
    },
    {
        "link": "https://dri.freedesktop.org/docs/drm/dev-tools/kselftest.html",
        "document": "The kernel contains a set of “self tests” under the tools/testing/selftests/ directory. These are intended to be small tests to exercise individual code paths in the kernel. Tests are intended to be run after building, installing and booting a kernel.\n\nKselftest from mainline can be run on older stable kernels. Running tests from mainline offers the best coverage. Several test rings run mainline kselftest suite on stable releases. The reason is that when a new test gets added to test existing code to regression test a bug, we should be able to run that test on an older kernel. Hence, it is important to keep code that can still test an older kernel and make sure it skips the test gracefully on newer releases.\n\nYou can find additional information on Kselftest framework, how to write new tests using the framework on Kselftest wiki:\n\nOn some systems, hot-plug tests could hang forever waiting for cpu and memory to be ready to be offlined. A special hot-plug target is created to run the full range of hot-plug tests. In default mode, hot-plug tests run in safe mode with a limited scope. In limited mode, cpu-hotplug test is run on a single cpu as opposed to all hotplug capable cpus, and memory hotplug test is run on 2% of hotplug capable memory instead of 10%.\n\nkselftest runs as a userspace process. Tests that can be written/run in userspace may wish to use the Test Harness. Tests that need to be run in kernel space may wish to use a Test Module.\n\nRunning the selftests (hotplug tests are run in limited mode)¶ To build and run the tests with a single command, use: Note that some tests will require root privileges. Kselftest supports saving output files in a separate directory and then running tests. To locate output files in a separate directory two syntaxes are supported. In both cases the working directory must be the root of the kernel src. This is applicable to “Running a subset of selftests” section below. To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT The O= assignment takes precedence over the KBUILD_OUTPUT environment variable. The above commands by default run the tests and print full pass/fail report. Kselftest supports “summary” option to make it easier to understand the test results. Please find the detailed individual test results for each test in /tmp/testname file(s) when summary option is specified. This is applicable to “Running a subset of selftests” section below.\n\nYou can use the “TARGETS” variable on the make command line to specify single test to run, or a list of tests to run. To run only tests targeted for a single subsystem: You can specify multiple tests to build and run: To build, save output files in a separate directory with O= To build, save output files in a separate directory with KBUILD_OUTPUT Additionally you can use the “SKIP_TARGETS” variable on the make command line to specify one or more targets to exclude from the TARGETS list. To run all tests but a single subsystem: You can specify multiple tests to skip: You can also specify a restricted list of tests to run together with a dedicated skiplist: See the top-level tools/testing/selftests/Makefile for the list of all possible targets.\n\nFound in the install directory, as well as in the Kselftest tarball, is a script named to run the tests. You can simply do the following to run the installed Kselftests. Please note some tests will require root privileges: To see the list of available tests, the option can be used: The option can be used to run all the tests from a test collection, or the option for specific single tests. Either can be used multiple times: For other features see the script usage output, seen with the option.\n\nSelftests are designed to be quick and so a default timeout is used of 45 seconds for each test. Tests can override the default timeout by adding a settings file in their directory and set a timeout variable there to the configured a desired upper timeout for the test. Only a few tests override the timeout with a value higher than 45 seconds, selftests strives to keep it that way. Timeouts in selftests are not considered fatal because the system under which a test runs may change and this can also modify the expected time it takes to run a test. If you have control over the systems which will run the tests you can configure a test runner on those systems to use a greater or lower timeout on the command line as with the or the argument. For example to use 165 seconds instead one would use: You can look at the TAP output to see if you ran into the timeout. Test runners which know a test must run under a specific time can then optionally treat these timeouts then as fatal.\n\nKselftest tests the kernel from userspace. Sometimes things need testing from within the kernel, one method of doing this is to create a test module. We can tie the module into the kselftest framework by using a shell script test runner. is designed to facilitate this process. There is also a header file provided to assist writing kernel modules that are for use with kselftest: Note that test modules should taint the kernel with TAINT_TEST. This will happen automatically for modules which are in the directory, or for modules which use the header above. Otherwise, you’ll need to add to your module source. selftests which do not load modules typically should not taint the kernel, but in cases where a non-test module is loaded, TEST_TAINT can be applied from userspace by writing to . Here we show the typical steps to create a test module and tie it into kselftest. We use kselftests for lib/ as an example.\n• None Create the test script that will run (load/unload) the module e.g. # Assumes you have booted a fresh build of this kernel tree /path/to/linux/tree make kselftest-merge make modules sudo make modules_install make lib kselftest A bare bones test module might look like this:\n\nThe kselftest_harness.h file contains useful helpers to build tests. The test harness is for userspace testing, for kernel space testing see Test Module above. The tests from tools/testing/selftests/seccomp/seccomp_bpf.c can be used as example. Optional debug logging function available for use in tests. Logging may be enabled or disabled by defining TH_LOG_ENABLED. E.g., #define TH_LOG_ENABLED 1 If no definition is provided, logging is enabled by default. Defines the test function and creates the registration stub Defines a test by name. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Defines a test by name and the expected term signal. Names must be unique and tests must not be run in parallel. The implementation containing block is a function and scoping should be treated as such. Returning early may be performed with a bare “return;” statement. EXPECT_* and ASSERT_* are valid in a { } context. Wraps the struct name so we have one less argument to pass around Almost always, you want just instead (see below). This call may be used when the type of the fixture data is needed. In general, this should not be needed unless the self is being passed to a helper directly. Called once per fixture to setup the data and register Defines the data provided to -defined tests as self. It should be populated and cleaned up using and . Prepares the setup function for the fixture. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “setup” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation. ASSERT_* are valid for use in this context and will prempt the execution of any dependent fixture tests. A bare “return;” statement may be used to return early. _metadata is included so that EXPECT_*, ASSERT_* etc. work correctly. Populates the required “teardown” function for a fixture. An instance of the datatype defined with will be exposed as self for the implementation to clean up. A bare “return;” statement may be used to return early. Optionally called once per fixture to declare fixture variant Defines type of constant parameters provided to , and FIXTURE_TEARDOWN as variant. Variants allow the same tests to be run with different arguments. Called once per fixture variant to setup and register the data name of the parameter set Defines a variant of the test fixture, provided to and as variant. Tests of each fixture will be run once for each variant. Defines a test that depends on a fixture (e.g., is part of a test case). Very similar to except that self is the setup instance of fixture’s datatype exposed for use by the implementation. The _metadata object is shared (MAP_SHARED) with all the potential forked processes, which enables them to use EXCEPT_*() and ASSERT_*(). The self object is only shared with the potential forked processes if FIXTURE_TEARDOWN_PARENT() is used instead of . Use once to append a main() to the test file. Operators for use in and . ASSERT_* calls will stop test execution immediately. EXPECT_* calls will emit a failure warning, note it, and continue."
    }
]