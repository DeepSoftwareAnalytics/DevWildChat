[
    {
        "link": "https://docs.osgi.org/specification/osgi.cmpn/7.0.0/service.component.html",
        "document": "Most bundles will require access to other services from the service registry. The dynamics of the service registry require care and attention of the programmer because referenced services, once acquired, could be unregistered at any moment. The component model simplifies the handling of these service dependencies significantly. The services that are selected by a reference are called the target services. These are the services selected by the method where the first argument is the reference's interface and the second argument is the reference's target property, which must be a valid filter. A component configuration becomes satisfied when each specified reference is satisfied. A reference is satisfied if it specifies optional cardinality or when the number of target services is equal to or more than the minimum cardinality of the reference. An activated component configuration that becomes unsatisfied must be deactivated. During the activation of a component configuration, SCR must bind some or all of the target services of a reference to the component configuration. Any target service that is bound to the component configuration is called a bound service. See Bound Services. A component instance must be able to use the services that are referenced by the component configuration, that is, the bound services of the references. The following techniques are available for a component instance to acquire these bound services:\n• Method injection - SCR calls a method on the component instance when a service becomes bound, when a service becomes unbound, or when its properties are updated. These methods are the bind, updated, and unbind methods specified by the reference. Method injection is useful if the component needs to be notified of changes to the bound services for a dynamic reference.\n• Field injection - SCR modifies a field in the component instance when a service becomes bound, when a service becomes unbound, or when its properties are updated.\n• Constructor injection - When SCR activates a component instance, the component instance must be constructed and constructor injection occurs. Bound services and activation objects can be parameters to the constructor.\n• Lookup strategy - A component instance can use one of the methods of its ComponentContext to locate a bound service. These methods take the of the reference as a parameter. If the reference has a dynamic policy, it is important to not store returned service objects but look them up every time they are needed. A component may use multiple strategies to access the bound services of a reference. When using method injection, SCR must call the component instance at the appropriate time. SCR must call on the following events:\n• - The bind method, if specified, is called to bind a new service to the component that matches the selection criteria. If the is then the bind method of a replacement service can be called before its corresponding unbind method.\n• - The updated method, if specified, is called when the service properties of a bound services are modified and the resulting properties do not cause the service to become unbound because it is no longer selected by the target property.\n• - The unbind method, if specified, is called when SCR needs to unbind the service. Each event is associated with an event method. An event method can take one or more parameters. Each parameter must be of one of the following types:\n• - A Service Reference for the bound service. This Service Reference may later be passed to the locateService(String,ServiceReference) method to obtain the actual service object. This approach is useful when the service properties need to be examined before accessing the service object. It also allows for the delayed activation of bound services when using method injection.\n• - A Component Service Objects for the bound service. This Component Service Objects can be used to obtain the actual service object or objects. This approach is useful when the referenced service has prototype service scope and the component instance needs multiple service objects for the service.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must additionally implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is . This method will receive a Service Reference for the bound service.\n• The method takes a single parameter and the type of the parameter is ComponentServiceObjects. This method will receive a Component Service Objects for the bound service.\n• The method takes a single parameter and the type of the parameter is the type specified by the reference's attribute. This method will receive the bound service object.\n• The method takes a single parameter and the type of the parameter is assignable from the type specified by the reference's attribute. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. This method will receive the bound service object.\n• The method takes a single parameter and the type of the parameter is . This method will receive an unmodifiable Map containing the service properties of the bound service.\n• The method takes two or more parameters and the types of the parameters must be one of: the type specified by the reference's attribute, a type assignable from the type specified by the reference's attribute, , ComponentServiceObjects, or . If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. In the case where the type specified by the reference's attribute is , ComponentServiceObjects, or , the first parameter of that type will receive the bound service object. If selected event method has more than one parameter of that type, the remaining parameters of that type will receive a Service Reference for the bound service, a Service Objects for the bound service, or an unmodifiable Map containing the service properties of the bound service. When searching for an event method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If no suitable method is located, SCR must log an error message with the Log Service, if present, and there will be no bind, updated, or unbind notification. The bind and unbind methods must be called once for each bound service. This implies that if the reference has multiple cardinality, then the methods may be called multiple times. The updated method can be called multiple times per service. In the following examples, a component requires the Logger Factory service. The first example uses the lookup strategy. The reference is declared without any bind, updated, and unbind methods: The component implementation class must now lookup the service. This looks like: Alternatively, the component could use method injection and ask to be notified with the Logger Factory service by declaring bind, updated, and unbind methods. The component implementation class looks like: Event methods can be declared private in the component class but are only looked up in the inheritance chain when they are protected, public, or have default access. See Locating Component Methods and Fields. When using field injection, SCR must modify fields in the component instance at the appropriate time. SCR must modify the fields on the following events:\n• - The field is modified to bind a new service to the component that matches the selection criteria.\n• - For certain field types, the field is modified when the service properties of a bound services are modified and the resulting properties do not cause the service to become unbound because it is no longer selected by the target property.\n• - The field is modified when SCR needs to unbind the service. For a reference with unary cardinality, a field must be of one of the following types:\n• - The bound service object. The type of the field can be the actual service type or it can be a type that is assignable from the actual service type.\n• - A Service Reference for the bound service. This Service Reference may later be passed to the locateService(String,ServiceReference) method to obtain the actual service object. This approach is useful when the service properties need to be examined before accessing the service object. It also allows for the delayed activation of bound services when using field injection.\n• - A Component Service Objects for the bound service. This Component Service Objects can be used to obtain the actual service object or objects. This approach is useful when the referenced service has prototype service scope and the component instance needs multiple service objects for the service.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must additionally implement with the method comparing service property maps using the same ordering as based upon service ranking and service id.\n• - An unmodifiable Map.Entry whose key is an unmodifiable Map containing the service properties of the bound service, as above, and whose value is the bound service object. This Map.Entry must additionally implement with the method comparing the service property map key using the same ordering as based upon service ranking and service id. If the actual service type is one of , , , or , the field will be set to the service object rather than the object about the service. For a reference with multiple cardinality, a field must be a collection of one of the following types:\n• A subtype of - This type can only be used for dynamic references using the reference field option. The component instance must initialize the field to a collection object in its constructor. The type of objects set in the collection are specified by the attribute in the component description:\n• - The bound service object. This is the default field collection type.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must implement , as above.\n• - An unmodifiable Map.Entry whose key is an unmodifiable Map containing the service properties of the bound service, as above, and whose value is the bound service object. This Map.Entry must implement , as above. Only instance fields of the field types above are supported. If a referenced field is declared with the modifier or has a type other than one of the above, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must locate a suitable field as specified in Locating Component Methods and Fields. If no suitable field is located, SCR must log an error message with the Log Service, if present, and no field will not be modified for the reference. Care must be taken by the component implementation regarding the field. SCR has no way to know if the component implementation itself may alter the field value. The component implementation should not alter the field value and allow SCR to manage it. SCR must treat the field as if the component implementation does not alter the field value so SCR may retain its own copy of the value set in the field. In the following examples, a component requires the Logger Factory service. The component implementation class looks like: Fields can be declared private in the component class but are only looked up in the inheritance chain when they are protected, public, or have default access. See Locating Component Methods and Fields. When using constructor injection, SCR must construct the component instance using the appropriate constructor passing activation objects and bound services as parameters. Since a component instance is only constructed once, constructor parameters for references must be for static references. A suitable constructor is selected using the following steps:\n• If the constructor is not public, then the constructor must not be considered.\n• If the constructor has a parameter count that does not match the value of the attribute in the element, then the constructor must not be considered. If the value of the attribute is 0, the default value, then the public no-parameter constructor must be used.\n• For the constructor parameters associated with a reference, that is, there is a reference with a attribute whose value matches the zero-based parameter number of the constructor parameter, if the parameter type is not one of the types supported for field injection for a static reference, then the constructor must not be considered. See Field Injection for information on types supported for field injection.\n• For the constructor parameters not associated with a reference, if the parameter type is not assignable from one of the activation object types, then the constructor must not be considered. See Activation Objects for information on activation object types.\n• If only a single constructor remains, this constructor must be used to construct the component instance.\n• If more than one constructor remains, this implies the constructor is overloaded and SCR may choose any of the remaining constructors to construct the component instance. When searching for the constructor to call, SCR must use reflection on the implementation class. If no suitable constructor is located, SCR must log an error message with the Log Service, if present, and the component configuration is not activated. If the constructor throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the component configuration is not activated. If the constructor parameter is associated with a reference having cardinality of and there is no bound service for the reference, then the value will be supplied as the constructor parameter. In the following examples, a component requires the Logger Factory service. The component implementation class looks like: A component implementation is always written with a certain cardinality for each reference in mind. The cardinality represents two important concepts:\n• Multiplicity - Does the component implementation assume a single service or does it explicitly handle multiple services? For example, when a component uses the Logger Factory service, it only needs to bind to one Logger Factory service to function correctly. Alternatively, when the Configuration Admin uses the Configuration Listener services it needs to bind to all target services present in the service registry to dispatch its events correctly.\n• Optionality - Can the component function without any bound service present? Some components can still perform useful tasks even when no service is available; other components must bind to at least one service before they can be useful. For example, the Configuration Admin in the previous example must still provide its functionality even if there are no Configuration Listener services present. Alternatively, an application that registers a Servlet with the Http Service has little to do when the Http Service is not present, it should therefore use a reference with a mandatory cardinality. The cardinality is expressed with the following syntax: The cardinality for a reference can be specified as one of four choices: The minimum cardinality is specified by the optionality part of the cardinality. This is either or . A minimum cardinality property can be used to raise the minimum cardinality of a reference from this initial value. For example, a cardinality in the component description can be raised into a cardinality at runtime by setting the minimum cardinality property for the reference to . This would typically be done by a deployer setting the minimum cardinality property in a configuration for the component. The minimum cardinality for a unary cardinality cannot exceed . See Minimum Cardinality Property for more information. A reference is satisfied if the number of target services is equal to or more than the minimum cardinality. The is irrelevant for the satisfaction of the reference. The only specifies if the component implementation is written to handle being bound to multiple services ( ) or requires SCR to select and bind to a single service ( ). When a satisfied component configuration is activated, there must be at most one bound service for each reference with a unary cardinality and at least as many bound services as the minimum cardinality for each reference. If the cardinality constraints cannot be maintained after a component configuration is activated, that is the reference becomes unsatisfied, the component configuration must be deactivated. If the reference has a unary cardinality and there is more than one target service for the reference, then the bound service must be the target service with the highest service ranking as specified by the property. If there are multiple target services with the same service ranking, then the bound service must be the target service with the highest service ranking and the lowest service id as specified by the property. In the following example, a component wants to register a resource with all Http Services that are available. Such a scenario has the cardinality of . The code must be prepared to handle multiple calls to the bind method for each Http Service in such a case. In this example, the code uses the method to register a directory for external access. A component implementation must be written to understand the service scope of referenced services. The reference scope defines whether the component expects the bundle to be exposed to a single service object for a bound service or to potentially multiple services objects. The following reference scopes are available:\n• bundle - For all references to a given bound service, all activated component instances within a bundle must use the same service object. That is, for a given bound service, all component instances within a bundle will be using the same service object. This is the default reference scope.\n• prototype - For all references to a given bound service, each activated component instance may use a single, distinct service object. That is, for a given bound service, each component instance may use a distinct service object but within a component instance all references to the bound service will use the same service object.\n• prototype_required - For all references to a given bound service, each activated component instance must use a single, distinct service object. That is, for a given bound service, each component instance will use a distinct service object but within a component instance all references to the bound service will use the same service object. For a bound service of a reference with bundle reference scope, SCR must get the service object from the OSGi Framework's service registry using the method on the component's Bundle Context. If the service object for a bound service has been obtained and the service becomes unbound, SCR must unget the service object using the method on the component's Bundle Context and discard all references to the service object. This ensures that the bundle will only be exposed to a single instance of the service object at any given time. For a bound service of a reference with prototype or prototype_required reference scope, SCR must use a Service Objects object obtained from the OSGi Framework's service registry using the component's Bundle Context to get any service objects. If service objects for a bound service have been obtained and the service becomes unbound, SCR must unget any unreleased service objects using the Service Objects object obtained from the OSGi Framework's service registry using the component's Bundle Context. This means that if a component instance used a Component Service Objects object to obtain service objects, SCR must track those service objects so that when the service becomes unbound, SCR can unget any unreleased service objects. Additionally, for a reference with prototype_required reference scope, only services registered with prototype service scope can be considered as target services. This ensures that each component instance can be exposed to a single, distinct instance of the service object. Using prototype_required reference scope effectively adds to the target property for the reference. A service that does not use prototype service scope cannot be used as a bound service for a reference with prototype_required reference scope since the service cannot provide a distinct service object for each component instance. Once all the references of a component are satisfied, a component configuration can be activated and therefore bound to target services. However, the dynamic nature of the OSGi service registry makes it likely that services are registered, modified and unregistered after target services are bound. These changes in the service registry could make one or more bound services no longer a target service thereby making obsolete any object references that the component has to these service objects. Components therefore must specify a policy how to handle these changes in the set of bound services. A policy-option can further refine how changes affect bound services. The static policy is the most simple policy and is the default policy. A reference with a static policy is called a static reference. A component instance never sees any of the dynamics of the static reference. The bind method is called and/or the field is set before the component instance is activated. Static references can also be used for parameters for constructor injection. Component configurations are deactivated before any bound service for the static reference becomes unavailable. If a target service is available to replace the bound service which became unavailable, the component configuration must be reactivated and the replacement service is bound to the new component instance. If the is then the registration of an additional target service for a reference must not result in deactivating and reactivating a component configuration. If the is then the component configuration must be reactivated when new applicable services become available. See Table 112.1 on page . If a static reference specifies an updated method and the bound service's properties change, SCR must call the updated method. The static policy can be very expensive if it depends on services that frequently unregister and re-register or if the cost of activating and deactivating a component configuration is high. Static policy is usually also not applicable if the cardinality specifies multiple bound services. The dynamic policy is slightly more complex since the component implementation must properly handle changes in the set of bound services that can occur on any thread at any time after the component instance is created. A reference with a dynamic policy is called a dynamic reference. With a dynamic reference, SCR can change the set of bound services without deactivating a component configuration. If the component uses method injection to access services, then the component instance will be notified of changes in the set of bound services by calls to the bind, updated, and unbind methods. If the is then a bound reference is not rebound even if a more suitable service becomes available for a 1..1 or 0..1 reference. If the is then the component must be unbound and rebound for that reference. See Table 112.1 on page . The previous example with the registering of a resource directory used a static policy. This implied that the component configurations are deactivated when there is a change in the bound set of Http Services. The code in the example can be seen to easily handle the dynamics of Http Services that come and go. The component description can therefore be updated to: The code is identical to the previous example. The reference policy option defines how eager the reference is to rebind when a new, potentially a higher ranking, target service becomes available. The reference policy option can have the following values:\n• - Minimize rebinding and reactivating. This is the default reference policy option.\n• - Maximize the use of the best service by deactivating static references or rebinding dynamic references. Table 112.1 defines the actions that are taken when a better target service becomes available. In this context, better is when the reference is not bound or when the new target service has a higher ranking than the bound service. Table 112.1 Action taken for policy-option when a new or higher ranking service becomes available Reactivate to bind the better target service. If no service is bound, bind to new target service. Otherwise, ignore new target service. If no service is bound, bind to better target service. Otherwise, unbind the bound service and bind the better target service. Reactivate to bind the better target service. Unbind the bound service, then bind the new service. \n\n For a reference using field injection, the reference field option defines how SCR must manage the field value. The reference field option can have the following values:\n• - SCR must set the field value. Any field value set by the constructor of the component instance is overwritten. This is the default reference field option.\n• - SCR must update the collection set in the field. This collection can be set by the constructor of the component instance. This reference field option can only be used for a dynamic reference with multiple cardinality. For a static reference, the replace option must be used. For a dynamic reference, the choice of reference field option is influenced by the cardinality of the reference. For unary cardinality, the replace option must be used. For multiple cardinality, either the replace or update option can be used. If the update option is used when not permitted, SCR must log an error message with the Log Service, if present, and the field must not be modified. If the field is declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified. For a static reference, SCR must set the field value before the component instance is activated and must not change the field while the component is active. This means there is a happens-before relationship between setting the field and activating the component instance, so the active component can safely read the field. For a dynamic reference, the field must be declared with the modifier so that field value changes made by SCR are visible to other threads. If the field is not declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified. For a reference with unary cardinality, SCR must set the field value with initial bound service, if any, before the component instance is activated. If the reference has optional cardinality and there is no bound service, SCR must set the field value to . If the reference is dynamic, when there is a new bound service or the service properties of the bound service are modified and the field holds service properties, SCR must replace the field value. If the reference has optional cardinality and there is no bound service, SCR must set the field value to . For a reference with multiple cardinality, the type of the field must be or . If the field has a different type, SCR must log an error message with the Log Service, if present, and the field must not be modified. Before the component instance is activated, SCR must set the field value with a new mutable collection that must contain the initial set of bound services sorted using the same ordering as based upon service ranking and service id. The collection may be empty if the reference has optional cardinality and there are no bound services. If the reference is dynamic, when there is a change in the set of bound services or the service properties of a bound service are modified and the collection holds service properties, SCR must replace the field value with a new mutable collection that must contain the updated set of bound services sorted using the same ordering as based upon service ranking and service id. The new collection may be empty if the reference has optional cardinality and there are no bound services. The update option can only be used for a dynamic reference with multiple cardinality. The component's constructor can set the field with its choice of collection implementation. In this case, the field can be declared with the modifier. The collection implementation used by the component should use identity rather than or to manage the elements of the collection. The collection implementation should also be thread-safe since SCR may update the collection from threads different than those used by the component instance. After constructing the component instance, if the field value is :\n• If the type of the field is or , SCR will set the field value to a new mutable empty collection or list object, respectively. If the field is declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified.\n• Otherwise, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must not change the field value while the component is active and only update the contents of the collection. SCR must update the collection before the component instance is activated by calling for each bound service. When there is a change to the set of bound services:\n• SCR must call for an unbound service.\n• If the service properties of a bound service are modified and the collection holds service properties, SCR must call for the replacement element followed by for the old element. The collection may be empty if the reference has optional cardinality and there are no bound services. The target services for a reference are constrained by the reference's interface name and target property. By specifying a filter in the target property, the programmer and deployer can constrain the set of services that should be part of the target services. For example, a component wants to track all Component Factory services that have a factory identification of . The following component description shows how this can be done. The filter is manifested as a component property called the target property. The target property can also be set by and elements, see Property and Properties Elements. The deployer can also set the target property by establishing a configuration for the component which sets the value of the target property. This allows the deployer to override the target property in the component description. See Target Property for more information. It is possible for a set of component descriptions to create a circular dependency. For example, if component references a service provided by component and component references a service provided by component then a component configuration of one component cannot be satisfied without accessing a partially activated component instance of the other component. SCR must ensure that a component instance is never accessible to another component instance or as a service until it has been fully activated, that is it has returned from its method if it has one. Circular references must be detected by SCR when it attempts to satisfy component configurations and SCR must fail to satisfy the references involved in the cycle and log an error message with the Log Service, if present. However, if one of the references in the cycle has optional cardinality SCR must break the cycle. The reference with the optional cardinality can be satisfied and bound to zero target services. Therefore the cycle is broken and the other references may be satisfied. SCR provides special support for components having references to the Logger Factory from the Log Service specification. If the reference uses method, field or constructor injection, the referenced service is of type , and the type of the parameter or field to receive the service object is of type or , then SCR must obtain the proper type of Logger from the bound Logger Factory service and use the obtained Logger as the service object rather than the service object for the bound Logger Factory service. To obtain the Logger object to use as the service object, SCR must call the method passing the bundle declaring the component as the first argument, the fully qualified name of the component implementation class as the second argument, and the type of the parameter or field, or , as the third argument. For example, the following code will have the field set to a Logger object created by SCR from the bound Logger Factory service.\n\nA component must first be enabled before it can be used. A component cannot be enabled unless the component's bundle is started. See Starting Bundles in OSGi Core Release 7. All components in a bundle become disabled when the bundle is stopped. So the life cycle of a component is contained within the life cycle of its bundle. Every component can be enabled or disabled. The initial enabled state of a component is specified in the component description via the attribute of the element. See Component Element. Component configurations can be created, satisfied and activated only when the component is enabled. The enabled state of a component can be controlled with the Component Context enableComponent(String) and disableComponent(String) methods. The purpose of later enabling a component is to be able to decide programmatically when a component can become enabled. For example, an immediate component can perform some initialization work before other components in the bundle are enabled. The component descriptions of all other components in the bundle can be disabled by having set to in their component descriptions. After any necessary initialization work is complete, the immediate component can call to enable the remaining components. The and methods must return after changing the enabled state of the named component. Any actions that result from this, such as activating or deactivating a component configuration, must occur asynchronously to the method call. Therefore a component can disable itself. All components in a bundle can be enabled by passing a as the argument to . Component configurations can only be activated when the component configuration is satisfied. A component configuration becomes satisfied when the following conditions are all satisfied:\n• If the component description specifies , then a object for the component is present in the Configuration Admin service.\n• Using the component properties of the component configuration, all the component's references are satisfied. A reference is satisfied when the reference specifies optional cardinality or the number of target services is equal to or more than the minimum cardinality of the reference. Once any of the listed conditions are no longer true, the component configuration becomes unsatisfied. An activated component configuration that becomes unsatisfied must be deactivated. A component is an immediate component when it must be activated as soon as its dependencies are satisfied. Once the component configuration becomes unsatisfied, the component configuration must be deactivated. If an immediate component configuration is satisfied and specifies a service, SCR must register the component configuration as a service in the service registry and then activate the component configuration. The service properties for this registration consist of the component properties as defined in Service Properties. The state diagram is shown in Figure 112.2. \n\n A key attribute of a delayed component is the delaying of class loading and object creation. Therefore, the activation of a delayed component configuration does not occur until there is an actual request for a service object. A component is a delayed component when it specifies a service but it is not a factory component and does not have the attribute of the element set to . SCR must register a service after the component configuration becomes satisfied. The registration of this service must look to observers of the service registry as if the component's bundle actually registered this service. This makes it possible to register services without creating a class loader for the bundle and loading classes, thereby allowing reduction in initialization time and a delay in memory footprint. When SCR registers the service on behalf of a component configuration, it must avoid causing a class load to occur from the component's bundle. SCR can ensure this by registering a object with the Framework for that service. By registering a object, the actual service object is not needed until the is called to provide the service object. The service properties for this registration consist of the component properties as defined in Service Properties. The activation of a component configuration must be delayed until its service is requested. When the service is requested, if the service has the attribute set to , SCR must create and activate a unique component configuration for each bundle requesting the service. If the service has the attribute set to , SCR must create and activate a unique component configuration for each distinct request for the service. Otherwise, if the service has the attribute set to , SCR must activate a single component configuration which is used by all requests for the service. A component instance can determine the bundle it was activated for by calling the getUsingBundle() method on the Component Context. The activation of delayed components is depicted in a state diagram in Figure 112.3. Notice that multiple component configurations can be created from the state if a delayed component specifies a service set to a value other than . If the service has the attribute set to , SCR must deactivate a component configuration when it stops being used as a service object since the component configuration must not be reused as a service object. If the service has the attribute set to or , SCR must deactivate a component configuration when it stops being used as a service object after a delay since the component configuration may be reused as a service object in the near future. This allows SCR implementations to reclaim component configurations not in use while attempting to avoid deactivating a component configuration only to have to quickly activate a new component configuration for a new service request. The delay amount is implementation specific and may be zero. \n\n SCR must register a Component Factory service as soon as the component factory becomes satisfied. The component factory is satisfied when the following conditions are all satisfied:\n• Using the component properties specified by the component description, all the component's references are satisfied. A reference is satisfied when the reference specifies optional cardinality or there is at least one target service for the reference The component factory, however, does not use any of the target services and does not bind to them. Once any of the listed conditions are no longer true, the component factory becomes unsatisfied and the Component Factory service must be unregistered. Any component configurations activated via the component factory are unaffected by the unregistration of the Component Factory service, but may themselves become unsatisfied for the same reason. The Component Factory service must be registered under the name with the following service properties:\n• - The name of the component.\n• - The value of the attribute. The service properties of the Component Factory service must not include the component properties. New component configurations are created and activated when the method of the Component Factory service is called. If the component description specifies a service, the component configuration is registered as a service under the provided interfaces. The service properties for this registration consist of the component properties as defined in Service Properties. The service registration must take place before the component configuration is activated. Service unregistration must take place before the component configuration is deactivated. \n\n A Component Factory service has a single method: newInstance(Dictionary). This method must create, satisfy and activate a new component configuration and register its component instance as a service if the component description specifies a service. It must then return a ComponentInstance object. This ComponentInstance object can be used to get the component instance with the getInstance() method. SCR must attempt to satisfy the component configuration created by before activating it. If SCR is unable to satisfy the component configuration given the component properties and the Dictionary argument to , the method must throw a . The client of the Component Factory service can also deactivate a component configuration with the dispose() method on the ComponentInstance object. If the component configuration is already deactivated, or is being deactivated, then this method is ignored. Also, if the component configuration becomes unsatisfied for any reason, it must be deactivated by SCR. Once a component configuration created by the Component Factory has been deactivated, that component configuration will not be reactivated or used again. Activating a component configuration consists of the following steps:\n• Set the activation fields, if any. See Activation Objects.\n• Call the method, if any. See Activate Method. Calling the method signals the completion of activating the component instance. Component instances must never be reused. Each time a component configuration is activated, SCR must create a new component instance to use with the activated component configuration. A component instance must complete activation before it can be deactivated. Once the component configuration is deactivated or fails to activate due to an exception, SCR must unbind all the component's bound services and discard all references to the component instance associated with the activation. When a component configuration's reference is satisfied, there is a set of zero or more target services for that reference. When the component configuration is activated, a subset of the target services for each reference are bound to the component configuration. The subset is chosen by the cardinality of the reference. See Reference Cardinality. Obtaining the service object for a bound service may result in activating a component configuration of the bound service which could result in an exception. If the loss of the bound service due to the exception causes the reference's cardinality constraint to be violated, then activation of this component configuration will fail. Otherwise the bound service which failed to activate will be considered unbound. The Component Context can be made available to a component instance during activation, modification, and deactivation. It provides the interface to the execution context of the component, much like the Bundle Context provides a bundle the interface to the Framework. A Component Context should therefore be regarded as a capability and not shared with other components or bundles. Each distinct component instance receives a unique Component Context. Component Contexts are not reused and must be discarded when the component configuration is deactivated. A component can have an method, activation fields, and also receive activation objects via its constructor. The following activation object types are supported:\n• - The Component Context for the component configuration.\n• - The Bundle Context of the component's bundle.\n• - An unmodifiable Map containing the component properties.\n• A component property type - An instance of the component property type which allows type safe access to component properties defined by the component property type. See Component Property Types. For activation fields, only instance fields of the activation object types above are supported. If an activation field is declared with the modifier or has a type other than one of the above, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must locate a suitable field as specified in Locating Component Methods and Fields. If no suitable field is located for an activation field name, SCR must log an error message with the Log Service, if present. When binding services, the references are processed in the order in which they are specified in the component description. That is, target services from the first specified reference are bound before services from the next specified reference. If the reference uses field injection, the field must be set. Then, if the reference uses method injection, the bind method must be called for each bound service of that reference. If a bind method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, but the activation of the component configuration does not fail. A component can have an method. The name of the method can be specified by the attribute. If the attribute is not specified, the default method name of is used. See Component Element. The activate method can take zero or more parameters. Each parameter must be assignable from one of the activation object types. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. When searching for the activate method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the component configuration is not activated. If an activate method is located, SCR must call this method to complete the activation of the component configuration. If the activate method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the component configuration is not activated. If an active component configuration has a dynamic reference with unary cardinality and the bound service is modified or unregistered and ceases to be a target service, or the is and a better target service becomes available then SCR must attempt to replace the bound service with a new bound service. If the reference uses field injection, the field must be set for the replacement bound service. Then, if the reference uses method injection, SCR must first bind the new bound service and then unbind the outgoing service. This reversed order allows the component to not have to handle the inevitable gap between the unbind and bind methods. However, this means that in the unbind method care must be taken to not overwrite the newly bound service. For example, the following code handles the associated concurrency issues and simplify handling the reverse order. If the dynamic reference falls below the minimum cardinality, the component configuration must be deactivated because the cardinality constraints will be violated. If a component configuration has a static reference and a bound service is modified or unregistered and ceases to be a target service, or the is and a better target service becomes available then SCR must deactivate the component configuration. Afterwards, SCR must attempt to activate the component configuration again if another target service can be used as a replacement for the outgoing service. If an active component is bound to a service that modifies its service properties then the component can be updated. If the reference uses field injection and the field holds the service properties, the field must be set for the updated bound service. Then, if the reference uses method injection and specifies an updated method, the updated method must be called. Modifying a component configuration can occur if the component description specifies the attribute and the component properties of the component configuration use a object from the Configuration Admin service and that object is modified without causing the component configuration to become unsatisfied. If this occurs, the component instance will be notified of the change in the component properties. If the attribute is not specified, then the component configuration will become unsatisfied if its component properties use a object and that Configuration object is modified in any way. Modifying a component configuration consists of the following steps:\n• Update the component context for the component configuration with the modified configuration properties.\n• Modify the bound services for the dynamic references if the set of target services changed due to changes in the target properties. See Bound Service Replacement.\n• If the component configuration is registered as a service, modify the service properties. A component instance must complete activation, or a previous modification, before it can be modified. See Configuration Changes for more information. The name of the modified method is specified by the attribute. See Component Element. The modified method can take zero or more parameters. Each parameter must be assignable from one of the activation object types. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the component configuration becomes unsatisfied and is deactivated as if the attribute was not specified. If a modified method is located, SCR must call this method to notify the component configuration of changes to the component properties. If the modified method throws an exception, SCR must log an error message containing the exception with the Log Service, if present and continue processing the modification. Deactivating a component configuration consists of the following steps:\n• Call the deactivate method, if present. See Deactivate Method.\n• Release all references to the component instance and component context. A component instance must complete activation or modification before it can be deactivated. A component configuration can be deactivated for a variety of reasons. The deactivation reason can be received by the deactivate method. The following reason values are defined: Once the component configuration is deactivated, SCR must discard all references to the component instance and component context associated with the activation. A component instance can have a deactivate method. The name of the deactivate method can be specified by the attribute. See Component Element. If the attribute is not specified, the default method name of is used. Activation fields must not be modified during deactivation. The deactivate method can take zero or more parameters. Each parameter must be assignable from one of the following types:\n• One of the activation object types.\n• or - The reason the component configuration is being deactivated. See Deactivation. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types, or . If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. When searching for the deactivate method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the deactivation of the component configuration will continue. If a deactivate method is located, SCR must call this method to commence the deactivation of the component configuration. If the deactivate method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the deactivation of the component configuration will continue. When a component configuration is deactivated, the bound services are unbound from the component configuration. When unbinding services, the references are processed in the reverse order in which they are specified in the component description. That is, target services from the last specified reference are unbound before services from the previous specified reference. If the reference uses method injection, the unbind method must be called for each bound service of that reference. If an unbind method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the deactivation of the component configuration will continue. Then, if the reference uses field injection, the field must be set to . A component could declare a dependency on the Http Service to register some resources. The component implementation code looks like: This example is depicted in a sequence diagram in Figure 112.5 with the following scenario:\n• A bundle with the component is started. At that time there is a Log Service and a Http Service registered. \n\n\n\nA number of retention annotations have been provided to allow tools to construct the component description XML from the Java class files. The Component Annotations are intended to be used during build time to generate the component description XML. Component Property Types, which are user defined annotations, can be used to describe component properties in the component description XML and to access those component properties at runtime in a type safe manner. The Component Annotations provide a convenient way to create the component description XML during build time. Since annotations are placed in the source file and can use types, fields, and methods, they can significantly simplify the use of Declarative Services. The Component Annotations are build time annotations because one of the key aspects of Declarative Services is its laziness. SCR can easily read the component description XML from the bundle, preprocess it, and cache the results between framework invocations. This way it is unnecessary to load a class from the bundle when the bundle is started and/or scan the classes for annotations. Component Annotations are not recognized by SCR at runtime. The Component Annotations are not inherited, they can only be used on a given class, annotations on its super class hierarchy or interfaces are not taken into account. The primary annotation is the Component annotation. It indicates that a class is a component. Its defaults create the easiest to use component:\n• Its name is the class name\n• It registers all of the class's directly implemented interfaces as services\n• The instance will be shared by all bundles\n• It is immediate if it has no services, otherwise it is delayed\n• It has an optional configuration policy\n• The configuration PID is the class name For example, the following class registers a Speech service that can run on a Macintosh: The previous example would be processed at build time into a component description similar to the following XML: It is possible to add activate and deactivate methods on the component with the Activate and Deactivate annotations. If the component wants to be updated for changes in the configuration properties than it can also indicated the modified method with the Modified annotation. For example: The Activate annotation can also be used on a field or a constructor. When used on a field, the field will be set during activation of the component. When used on a constructor, the constructor will be used to construct the component instances. If a component has dependencies on other services then they can be referenced with the Reference annotation that can be applied to a bind method, a field, or a constructor parameter. For a bind method, the defaults for the Reference annotation are:\n• The name of the bind method or field is used for the name of the reference.\n• The requested service is the type of the first parameter of the bind method.\n• It will infer a default unset method and updated method based on the name of the bind method. For a field, the defaults for the Reference annotation are:\n• The name of the bind method or field is used for the name of the reference.\n• 1:1 cardinality if the field is not a collection. 0..n cardinality if the field is a collection.\n• Static reluctant policy if the field is not declared volatile. Dynamic reluctant policy if the field is declared volatile.\n• The requested service is the type of the field. For a constructor parameter, the defaults for the Reference annotation are:\n• The name of the parameter is used for the name of the reference.\n• 1:1 cardinality if the field is not a collection. 0..n cardinality if the field is a collection.\n• The requested service is the type of the field. Component properties can be defined and accessed through a user defined annotation type, called a component property type, containing the property names, property types and default values. A component property type allows properties to be defined and accessed in a type safe manner. Component property types can themselves be annotated with the ComponentPropertyType meta-annotation. The following example shows the definition of a component property type called which defines three properties where the name of the property is the name of the method, the type of the property is the return type of the method and the default value for the property is the default value of the method. Component property types can be used in two ways:\n• Component property types can be used to annotate the component implementation class, along side the Component annotation. The annotation usage can specify property values which can be different than the default values declared in the component property type. To be used in this way, the component property type must be annotated with the ComponentPropertyType meta-annotation so that, at build time, the annotation is recognized as a component property type.\n• Component property types can be used as parameter types in the component's constructor and life cycle methods, or as field types for activation fields. The component implementation can use objects of a component property type at runtime to access component property values in a type safe manner. To be used in this way, it is recommended the component property type be annotated with the ComponentPropertyType meta-annotation but it is not required. Both ways define property names, types and values for the component. The following example shows the component implementation annotated with the example component property type which specifies a property value for the component which is different than the default value. The example also shows the activate method taking the example component property type as a parameter type and the method implementation accesses component property values by invoking methods on the component property type object. @Component @Config(names=\"myapp\") public class MyComponent { @Activate void activate(Config config) { if (config.enabled()) { // do something } for (String name:config.names()) { // do something with each name } } } If a component implementation needs to access component properties which are not represented by a component property type, it can use a type of Map to receive the properties map in addition to component property types. For example: @Component public class MyComponent { @Activate void activate(Config config, Map<String, ?> allProperties) { if (config.enabled()) { // do something } if (allProperties.get(\"other.prop\") != null) { // do something } } } Component property types must be defined as annotation types. This is done for several reasons. First, the limitations on annotation type definitions make them well suited for component property types. The methods must have no parameters and the return types supported are limited to a set which is well suited for component properties. Second, annotation types support default values which is useful for defining the default value of a component property. Finally, as annotations, they can be used to annotate component implementation classes. At build time, the component property types must be processed to potentially generate elements in the component description. See Ordering of Generated Component Properties. At runtime, when SCR needs to provide a component instance an activation object whose type is a component property type, SCR must construct an instance of the component property type whose methods are backed by the values of the component properties for the component instance. This object can then be used to obtain the property values in a type safe manner. Each method of a configuration property type is mapped to a component property. The property name is derived from the method name. Certain common property name characters, such as full stop ( ) and hyphen-minus ( ) are not valid in Java identifiers. So the name of a method must be converted to its corresponding property name as follows:\n• A single dollar sign ( ) is removed unless it is followed by:\n• A low line ( ) and a dollar sign in which case the three consecutive characters ( ) are converted to a single hyphen-minus ( ).\n• Another dollar sign in which case the two consecutive dollar signs ( ) are converted to a single dollar sign.\n• A single low line ( ) is converted into a full stop ( ) unless is it followed by another low line in which case the two consecutive low lines ( ) are converted to a single low line.\n• All other characters are unchanged.\n• If the component property type declares a field whose value is a compile-time constant String, then the property name is prefixed with the value of the field. Table 112.11 contains some name mapping examples. \n\n However, if the component property type is a single-element annotation, see 9.7.3 in [7] The Java Language Specification, Java SE 8 Edition, then the property name for the method is derived from the name of the component property type rather than the name of the method. In this case, the simple name of the component property type, that is, the name of the class without any package name or outer class name, if the component property type is an inner class, must be converted to the property name as follows:\n• When a lower case character is followed by an upper case character, a full stop ( ) is inserted between them.\n• Each upper case character is converted to lower case.\n• All other characters are unchanged.\n• If the component property type declares a field whose value is a compile-time constant String, then the property name is prefixed with the value of the field. Table 112.12 contains some mapping examples for the method. \n\n If the component property type is a marker annotation, see 9.7.2 in [7] The Java Language Specification, Java SE 8 Edition, then the property name is derived from the name of the component property type, as is described above for single-element annotations, and the value of the property is . Marker annotations can be used to annotate component implementation classes to set a component property to the value . However, since marker annotations have no methods, they are of no use as parameter types in the component's constructor and life cycle methods, or as field types for activation fields. The property type can be directly derived from the type of the method. All types supported for annotation elements can be used except for annotation types. Method types of an annotation type or array thereof are not supported. A tool processing the component property types must ignore such methods. If the method type is or , then the property type must be or , respectively, whose values are fully qualified class names in the form returned by the method. If the method type is an enumeration type or an array thereof, then the property type must be or , respectively, whose values are the names of the enum constants in the form returned by the method. When a component property type is used as an activation object type, SCR must create an object that implements the component property type and maps the methods of the component property type to component properties. The name of the method is converted to the property name as described in Component Property Mapping. The property value may need to be coerced to the type of the method. In Table 112.13, the columns are source types, that is, the type of the component property value, and the rows are target types, that is, the method types. The property value is v; number is a primitive numerical type and Number is a wrapper numerical type. An invalid coercion is represented by . Such a coercion attempt must result in throwing a Component Exception when the component property type method is called. Any other coercion error, such as parsing a non-numerical string to a number or the inability to coerce a string into a Class or enum object, must be wrapped in a Component Exception and thrown when the component property type method is called. Table 112.13 Coercion From Property Value to Method Type If has no elements, ; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. If has no elements, 0; otherwise the first element of is coerced. If has no elements, 0; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. A single element array is created and is coerced into the single element of the new array. An array the size of is created and each element of is coerced into the corresponding element of the new array. \n\n Component properties whose names do not map to component property type methods are ignored. If there is no corresponding component property for a component property type method, the component property type method must: Component property types for standard service properties are specified in the org.osgi.service.component.propertytypes package. The ServiceDescription component property type can be used to add the service property to a component. The ServiceRanking component property type can be used to add the service property to a component. The ServiceVendor component property type can be used to add the service property to a component. For example, using these component property types as annotations: will result in the following component properties: The ExportedService component property type can be used to specify service properties for remote services. The Component annotation contains two ways to define component properties via the property and properties elements. See Property and Properties Elements. If Component Annotations are used to describe the component, then any component property types used as the type of an activation object or used to annotate the component implementation class must also be processed since component property types can be used to define component property values as well. See Component Property Types. A tool processing the Component Annotations and the component property types must write the defined component properties into the generated component description in the following order.\n• Properties defined through component property types used as the type of an activation object. If any of the referenced component property types have methods with defaults, then the generated component description must include a element for each such method with the property name mapped from the method name, the property type mapped from the method type, and the property value set to the method's default value. See Component Property Mapping. The generated elements must be added to the component description by processing the component property types used as the type of an activation object in the following order:\n• The component property types used as parameters to the constructor.\n• The component property types used as activation fields. The fields are processed in lexicographical order, using , of the field names.\n• The component property types used as parameters to the activate method.\n• The component property types used as parameters to the modified method.\n• The component property types used as parameters to the deactivate method. If a method has more than one component property type parameter, the component property types are processed in the order of the method parameters. For component property type methods without a default value or with a default value of an empty array, a element must not be generated.\n• The generated component description must include a element for each such method with the property name mapped from the method name, the property type mapped from the method type, and the property value set to the method's value. See Component Property Mapping. The generated elements must be added to the component description by processing the component property types annotating the component implementation class in the order that the annotations appear in the component implementation's class file. However, the order of the and attributes in the class file is unspecified by [6] The Java Virtual Machine Specification, Java SE 8 Edition so care must be taken when using component property types of different that have method names in common. For component property type methods with a value of an empty array, a element must not be generated. This means that the properties defined through component property types are declared first in the generated component description, followed by all properties defined through the property element of the Component annotation and finally the properties entries defined through the properties element of the Component annotation. Since property values defined later in the component description override property values defined earlier in the component description, this means that property values defined in properties element of the Component annotation can override property values defined in property element of the Component annotation which can override values defined by values in the component property types.\n\nThis package is not used at runtime. Annotated classes are processed by tools to generate Component Descriptions which are used at runtime.\n• - Identify the annotated member as part of the activation of a Service Component.\n• - Identify the annotated method as the method of a Service Component.\n• - Identify the annotated method as the method of a Service Component.\n• - Identify the annotated member or parameter as a reference of a Service Component.\n• - This annotation can be used to require the Service Component Runtime to process Declarative Services components. Identify the annotated member as part of the activation of a Service Component. When this annotation is applied to a:\n• Method - The method is the method of the Component.\n• Constructor - The constructor will be used to construct the Component and can be called with activation objects and bound services as parameters.\n• Field - The field will contain an activation object of the Component. The field must be set after the constructor is called and before calling any other method on the fully constructed component instance. That is, there is a happens-before relationship between the field being set and calling any method on the fully constructed component instance such as the method. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The init, activate, and activation-fields attributes of the component element of a Component Description. The service collection type is used to indicate the collection holds the bound service objects. This is the default collection type. The reference collection type is used to indicate the collection holds Service References for the bound services. The serviceobjects collection type is used to indicate the collection holds Component Service Objects for the bound services. The properties collection type is used to indicate the collection holds unmodifiable Maps containing the service properties of the bound services. The Maps must implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. The tuple collection type is used to indicate the collection holds unmodifiable Map.Entries whose key is an unmodifiable Map containing the service properties of the bound service, as specified in PROPERTIES, and whose value is the bound service object. The Map.Entries must implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. The annotated class is the implementation class of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The name of this Component. If not specified, the name of this Component is the fully qualified type name of the class being annotated. The name attribute of the component element of a Component Description. The types under which to register this Component as a service. If no service should be registered, the empty value must be specified. If not specified, the service types for this Component are all the directly implemented interfaces of the class being annotated. The factory identifier of this Component. Specifying a factory identifier makes this Component a Factory Component. If not specified, the default is that this Component is not a Factory Component. The factory attribute of the component element of a Component Description. Declares whether this Component uses the OSGi ServiceFactory concept and each bundle using this Component's service will receive a different component instance. This element is ignored when the scope() element does not have the default value. If , this Component uses bundle service scope. If or not specified, this Component uses singleton service scope. If the factory() element is specified or the immediate() element is specified with , this element can only be specified with . The scope attribute of the service element of a Component Description. Declares whether this Component is enabled when the bundle declaring it is started. If or not specified, this Component is enabled. If , this Component is disabled. The enabled attribute of the component element of a Component Description. Declares whether this Component must be immediately activated upon becoming satisfied or whether activation should be delayed. If , this Component must be immediately activated upon becoming satisfied. If , activation of this Component is delayed. If this property is specified, its value must be if the factory() property is also specified or must be if the service() property is specified with an empty value. If not specified, the default is if the factory() property is specified or the service() property is not specified or specified with a non-empty value and otherwise. The immediate attribute of the component element of a Component Description. Each property string is specified as . The type of the property value can be specified in the name as . The type must be one of the property types supported by the attribute of the element of a Component Description. To specify a property with multiple values, use multiple name, value pairs. For example, . Specifies the name of an entry in the bundle whose contents conform to a standard Java Properties File. The entry is read and processed to obtain the properties and their values. The XML name space of the Component Description for this Component. If not specified, the XML name space of the Component Description for this Component should be the lowest Declarative Services XML name space which supports all the specification features used by this Component. The XML name space specified for a Component Description. The configuration policy of this Component. Controls whether component configurations must be satisfied depending on the presence of a corresponding Configuration object in the OSGi Configuration Admin service. A corresponding configuration is a Configuration object where the PID equals the name of the component. If not specified, the configuration policy is based upon whether the component is also annotated with the Meta Type Designate annotation.\n• Not annotated with - The configuration policy is OPTIONAL.\n• Annotated with - The configuration policy is OPTIONAL.\n• Annotated with - The configuration policy is REQUIRE. The configuration-policy attribute of the component element of a Component Description. The configuration PIDs for the configuration of this Component. Each value specifies a configuration PID for this Component. If no value is specified, the name of this Component is used as the configuration PID of this Component. A special string ( ) can be used to specify the name of the component as a configuration PID. The NAME constant holds this special string. For example: Tools creating a Component Description from this annotation must replace the special string with the actual name of this Component. The configuration-pid attribute of the component element of a Component Description. The service scope for the service of this Component. If not specified (and the deprecated servicefactory() element is not specified), the singleton service scope is used. If the factory() element is specified or the immediate() element is specified with , this element can only be specified with the singleton service scope. The scope attribute of the service element of a Component Description. The lookup strategy references of this Component. To access references using the lookup strategy, Reference annotations are specified naming the reference and declaring the type of the referenced service. The referenced service can be accessed using one of the methods of . To access references using method injection, bind methods are annotated with Reference. To access references using field injection, fields are annotated with Reference. To access references using constructor injection, constructor parameters are annotated with Reference. Each factory property string is specified as . The type of the factory property value can be specified in the name as . The type must be one of the factory property types supported by the attribute of the element of a Component Description. To specify a factory property with multiple values, use multiple name, value pairs. For example, . If specified, the factory() element must also be specified to indicate the component is a Factory Component. Specifies the name of an entry in the bundle whose contents conform to a standard Java Properties File. The entry is read and processed to obtain the factory properties and their values. If specified, the factory() element must also be specified to indicate the component is a Factory Component. Special string representing the name of this Component. This string can be used in configurationPid() to specify the name of the component as a configuration PID. For example: Tools creating a Component Description from this annotation must replace the special string with the actual name of this Component. Component Property Types can be applied as annotations to the implementation class of the Component. They can also be used as activation objects which means they can be used as parameter types for the component's constructor and life cycle methods Activate, Deactivate, and Modified as well as activation fields. Component Property Types do not have to be annotated with this annotation to be used as parameter types but they must be annotated with this annotation to be used as annotations on the implementation class of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. Controls whether component configurations must be satisfied depending on the presence of a corresponding Configuration object in the OSGi Configuration Admin service. A corresponding configuration is a Configuration object where the PID is the name of the component. Use the corresponding Configuration object if present but allow the component to be satisfied even if the corresponding Configuration object is not present. There must be a corresponding Configuration object for the component configuration to become satisfied. Always allow the component configuration to be satisfied and do not use the corresponding Configuration object even if it is present. Identify the annotated method as the method of a Service Component. The annotated method is the deactivate method of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The deactivate attribute of the component element of a Component Description. The update field option is used to update the collection referenced by the field when there are changes to the bound services. This field option can only be used when the field reference has dynamic policy and multiple cardinality. The replace field option is used to replace the field value with a new value when there are changes to the bound services. Identify the annotated method as the method of a Service Component. The annotated method is the modified method of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The modified attribute of the component element of a Component Description. Identify the annotated member or parameter as a reference of a Service Component. When the annotation is applied to a method, the method is the bind method of the reference. When the annotation is applied to a field, the field will contain the bound service(s) of the reference. When the annotation is applied to a parameter of a constructor, the parameter will contain the bound service(s) of the reference. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. In the generated Component Description for a component, the references must be ordered in ascending lexicographical order (using ) of the reference names. The name of this reference. The name of this reference must be specified when using this annotation in the Component.reference() element since there is no annotated member from which the name can be determined. If not specified, the name of this reference is based upon how this annotation is used:\n• Annotated method - If the method name begins with , or , that prefix is removed to create the name of the reference. Otherwise, the name of the reference is the method name.\n• Annotated field - The name of the reference is the field name.\n• Annotated constructor parameter - The name of the reference is the parameter name. The name attribute of the reference element of a Component Description. The type of the service for this reference. The type of the service for this reference must be specified when using this annotation in the Component.reference() element since there is no annotated member from which the type of the service can be determined. If not specified, the type of the service for this reference is based upon how this annotation is used:\n• Annotated method - The type of the service is the type of the first parameter of the method.\n• Annotated field - The type of the service is based upon the type of the field being annotated and the cardinality of the reference. If the cardinality is either 0..n, or 1..n, the type of the field must be one of , , or a subtype of so the type of the service is the generic type of the collection. Otherwise, the type of the service is the type of the field.\n• Annotated constructor parameter - The type of the service is based upon the type of the parameter being annotated and the cardinality of the reference. If the cardinality is either 0..n, or 1..n, the type of the parameter must be one of , , or a subtype of so the type of the service is the generic type of the collection. Otherwise, the type of the service is the type of the parameter. The interface attribute of the reference element of a Component Description. The cardinality of this reference. If not specified, the cardinality of this reference is based upon how this annotation is used:\n• Annotated field - The cardinality is based on the type of the field. If the type is either , , or a subtype of , the cardinality is 0..n. Otherwise the cardinality is 1..1.\n• Annotated constructor parameter - The cardinality is based on the type of the parameter. If the type is either , , or a subtype of , the cardinality is 0..n. Otherwise the cardinality is 1..1. The cardinality attribute of the reference element of a Component Description. The policy for this reference. If not specified, the policy of this reference is based upon how this annotation is used:\n• Annotated field - The policy is based on the modifiers of the field. If the field is declared , the policy is ReferencePolicy.DYNAMIC. Otherwise the policy is STATIC.\n• Annotated constructor parameter - The policy is STATIC. STATIC policy must be used for constructor parameters. The policy attribute of the reference element of a Component Description. The target property for this reference. If not specified, no target property is set. The target attribute of the reference element of a Component Description. The policy option for this reference. If not specified, the RELUCTANT reference policy option is used. The policy-option attribute of the reference element of a Component Description. The reference scope for this reference. If not specified, the bundle reference scope is used. The scope attribute of the reference element of a Component Description. The name of the bind method for this reference. If specified and this reference annotates a method, the specified name must match the name of the annotated method. If not specified, the name of the bind method is based upon how this annotation is used:\n• Annotated method - The name of the annotated method is the name of the bind method.\n• Annotated field - There is no bind method name.\n• Annotated constructor parameter - There is no bind method name.\n• Component.reference() element - There is no bind method name. If there is a bind method name, the component must contain a method with that name. The bind attribute of the reference element of a Component Description. The name of the updated method for this reference. If not specified, the name of the updated method is based upon how this annotation is used:\n• Annotated method - The name of the updated method is created from the name of the annotated method. If the name of the annotated method begins with , or , that prefix is replaced with to create the name candidate for the updated method. Otherwise, is prefixed to the name of the annotated method to create the name candidate for the updated method. If the component type contains a method with the candidate name, the candidate name is used as the name of the updated method. To declare no updated method when the component type contains a method with the candidate name, the value must be used.\n• Annotated field - There is no updated method name.\n• Annotated constructor parameter - There is no updated method name.\n• Component.reference() element - There is no updated method name. If there is an updated method name, the component must contain a method with that name. The updated attribute of the reference element of a Component Description. The name of the unbind method for this reference. If not specified, the name of the unbind method is based upon how this annotation is used:\n• Annotated method - The name of the unbind method is created from the name of the annotated method. If the name of the annotated method begins with , or , that prefix is replaced with , or , respectively, to create the name candidate for the unbind method. Otherwise, is prefixed to the name of the annotated method to create the name candidate for the unbind method. If the component type contains a method with the candidate name, the candidate name is used as the name of the unbind method. To declare no unbind method when the component type contains a method with the candidate name, the value must be used.\n• Annotated field - There is no unbind method name.\n• Annotated constructor parameter - There is no unbind method name.\n• Component.reference() element - There is no unbind method name. If there is an unbind method name, the component must contain a method with that name. The unbind attribute of the reference element of a Component Description. The name of the field for this reference. If specified and this reference annotates a field, the specified name must match the name of the annotated field. If not specified, the name of the field is based upon how this annotation is used:\n• Annotated method - There is no field name.\n• Annotated field - The name of the annotated field is the name of the field.\n• Annotated constructor parameter - There is no field name.\n• Component.reference() element - There is no field name. If there is a field name, the component must contain a field with that name. The field attribute of the reference element of a Component Description. The field option for this reference. If not specified, the field option is based upon how this annotation is used:\n• Annotated method - There is no field option.\n• Annotated field - The field option is based upon the policy and cardinality of the reference and the modifiers of the field. If the policy is ReferencePolicy.DYNAMIC, the cardinality is 0..n or 1..n, and the field is declared , the field option is FieldOption.UPDATE. Otherwise, the field option is FieldOption.REPLACE.\n• Annotated constructor parameter - There is no field option.\n• Component.reference() element - There is no field option. The field-option attribute of the reference element of a Component Description. The zero-based parameter number of the constructor parameter for this reference. If specified and this reference annotates an constructor parameter, the specified value must match the zero-based parameter number of the annotated constructor parameter. If not specified, the parameter number is based upon how this annotation is used:\n• Annotated method - There is no parameter number.\n• Annotated field - There is no parameter number.\n• Annotated constructor parameter - The zero-based parameter number of the parameter.\n• Component.reference() element - There is no parameter number. If there is a parameter number, the component must declare a constructor that has a parameter having the zero-based parameter number. The parameter attribute of the reference element of a Component Description. , The init attribute of the component element of a Component Description. The collection type for this reference. If not specified, the collection type is based upon how this annotation is used:\n• Annotated method - There is no collection type.\n• Annotated field - The collection type is based upon the cardinality of the reference and the generic type of the field. If the cardinality is 0..n or 1..n, the collection type is inferred from the generic type of the list or collection. Otherwise, there is no collection type\n• Annotated constructor method parameter - The collection type is based upon the cardinality of the reference and the generic type of the parameter. If the cardinality is 0..n or 1..n, the collection type is inferred from the generic type of the list or collection. Otherwise, there is no collection type\n• Component.reference() element - There is no collection type. The field-collection-type attribute of the reference element of a Component Description. Specifies if the reference is optional and if the component implementation support a single bound service or multiple bound services. The reference is optional and unary. That is, the reference has a cardinality of . The reference is mandatory and unary. That is, the reference has a cardinality of . The reference is optional and multiple. That is, the reference has a cardinality of . The reference is mandatory and multiple. That is, the reference has a cardinality of . The static policy is the most simple policy and is the default policy. A component instance never sees any of the dynamics. Component configurations are deactivated before any bound service for a reference having a static policy becomes unavailable. If a target service is available to replace the bound service which became unavailable, the component configuration must be reactivated and bound to the replacement service. The dynamic policy is slightly more complex since the component implementation must properly handle changes in the set of bound services. With the dynamic policy, SCR can change the set of bound services without deactivating a component configuration. If the component uses method injection to access services, then the component instance will be notified of changes in the set of bound services by calls to the bind and unbind methods. The reluctant policy option is the default policy option for both static and dynamic reference policies. When a new target service for a reference becomes available, references having the reluctant policy option for the static policy or the dynamic policy with a unary cardinality will ignore the new target service. References having the dynamic policy with a multiple cardinality will bind the new target service. The greedy policy option is a valid policy option for both static and dynamic reference policies. When a new target service for a reference becomes available, references having the greedy policy option will bind the new target service. A single service object is used for all references to the service in this bundle. If the bound service has prototype service scope, then each instance of the component with this reference can receive a unique instance of the service. If the bound service does not have prototype service scope, then this reference scope behaves the same as BUNDLE. Bound services must have prototype service scope. Each instance of the component with this reference can receive a unique instance of the service. This annotation can be used to require the Service Component Runtime to process Declarative Services components. It can be used directly, or as a meta-annotation. When the component is registered as a service, it must be registered as a bundle scope service but only a single instance of the component must be used for all bundles using the service. When the component is registered as a service, it must be registered as a bundle scope service and an instance of the component must be created for each bundle using the service. When the component is registered as a service, it must be registered as a prototype scope service and an instance of the component must be created for each distinct request for the service. Default element value for annotation. This is used to distinguish the default value for an element and should not otherwise be used.\n\nBundles wishing to use this package must list the package in the Import-Package header of the bundle's manifest. This package has two types of users: the consumers that use the API in this package and the providers that implement the API in this package. Example import for consumers using the API in this package: Example import for providers implementing the API in this package:\n• - A representation of an actual instance of a declared component description parameterized by component properties. A representation of an actual instance of a declared component description parameterized by component properties. This is the normal operational state of a component configuration. The representation of the component configuration's component description. This means the component configuration is satisfied but that either:\n• the constructor threw an exception, or The failure information from the exception is available from failure. The failure information if the component configuration state is FAILED_ACTIVATION. This is the failure exception converted to a String using: This must be if the component configuration state is not FAILED_ACTIVATION. The id of the component configuration. The id is a non-persistent, unique value assigned at runtime. The id is also available as the component property. The value of this field is unspecified if the state of this component configuration is unsatisfied. The component properties for the component configuration. Any services declared by the component description are registered. Each SatisfiedReferenceDTO in the array represents a satisfied reference of the component configuration. The array must be empty if the component configuration has no satisfied references. The registered service of the component configuration. This must be non- if the component configuration is registered as a service. Otherwise it must be . The current state of the component configuration. This is one of UNSATISFIED_CONFIGURATION, UNSATISFIED_REFERENCE, SATISFIED, ACTIVE, or FAILED_ACTIVATION. The component configuration is unsatisfied due to a missing required configuration. The component configuration is unsatisfied due to an unsatisfied reference. Each UnsatisfiedReferenceDTO in the array represents an unsatisfied reference of the component configuration. The array must be empty if the component configuration has no unsatisfied references. The name of the activate method. This is declared in the attribute of the element. This must be if the component description does not declare an activate method name. These are declared in the attribute of the element. The array must be empty if the component description does not declare any activation fields. These are declared in the attribute of the element. This must contain the default configuration pid if the component description does not declare a configuration pid. This is declared in the attribute of the element. This must be the default configuration policy if the component description does not declare a configuration policy. The name of the deactivate method. This is declared in the attribute of the element. This must be if the component description does not declare a deactivate method name. This is declared in the attribute of the element. This is declared in the attribute of the element. This must be if the component description is not declared as a factory component. These are declared in the component description by the and elements. This must be if the component description is not declared as a factory component. This is declared in the attribute of the element. The fully qualified name of the implementation class. This is declared in the attribute of the element. This is declared in the attribute of the element. This must be if the component description does not declare an attribute. The name of the modified method. This is declared in the attribute of the element. This must be if the component description does not declare a modified method name. The name of the component. This is declared in the attribute of the element. This must be the default name if the component description does not declare a name. These are declared in the component description by the and elements as well as the attribute of the elements. These are declared in the elements. The array must be empty if the component description does not declare references to any services. This is declared in the attribute of the element. This must be if the component description does not declare any service interfaces. The fully qualified names of the service interfaces. These are declared in the attribute of the elements. The array must be empty if the component description does not declare any service interfaces. The name of the bind method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a bind method for the reference. The cardinality of the reference. This is declared in the attribute of the element. This must be the default cardinality if the component description does not declare a cardinality for the reference. The collection type for the reference. This is declared in the attribute of the element. This must be if the component description does not declare a collection type for the reference. The name of the field of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a field for the reference. The field option of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a field for the reference. The service interface of the reference. This is declared in the attribute of the element. The name of the reference. This is declared in the attribute of the element. This must be the default name if the component description does not declare a name for the reference. The zero-based parameter number of the constructor parameter for the reference. This is declared in the attribute of the element. This must be if the component description does not declare a parameter number for the reference. The policy of the reference. This is declared in the attribute of the element. This must be the default policy if the component description does not declare a policy for the reference. The policy option of the reference. This is declared in the attribute of the element. This must be the default policy option if the component description does not declare a policy option for the reference. The scope of the reference. This is declared in the attribute of the element. This must be the default scope if the component description does not declare a scope for the reference. The target of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a target for the reference. The name of the unbind method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare an unbind method for the reference. The name of the updated method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare an updated method for the reference. Each ServiceReferenceDTO in the array represents a service bound to the satisfied reference. The array must be empty if there are no bound services. The name of the declared reference. This is declared in the attribute of the element of the component description. The target property of the satisfied reference. This is the value of the component property whose name is the concatenation of the declared reference name and \".target\". This must be if no target property is set for the reference. The name of the declared reference. This is declared in the attribute of the element of the component description. The target property of the unsatisfied reference. This is the value of the component property whose name is the concatenation of the declared reference name and \".target\". This must be if no target property is set for the reference. Each ServiceReferenceDTO in the array represents a target service for the reference. The array must be empty if there are no target services. The upper bound on the number of target services in the array is the upper bound on the cardinality of the reference."
    },
    {
        "link": "https://experienceleague.adobe.com/en/docs/experience-manager-cloud-service/content/implementing/deploying/configuring-osgi",
        "document": "OSGi is a fundamental element in the technology stack of Adobe Experience Manager (AEM). It is used to control the composite bundles of AEM and its configurations. OSGi provides the standardized primitives that allow applications to be constructed from small, reusable, and collaborative components. These components can be composed into an application and deployed. This allows easy management of OSGi bundles as they can be stopped, installed, started individually. The interdependencies are handled automatically. Each OSGi Component is contained in one of the various bundles. For more information, see the OSGi specification. You can manage the configuration settings for OSGi components through configuration files that are part of an AEM code project. You can use Cloud Manager to configure environment variables. For more information, consult the documentation here Configuration changes are defined in the AEM Project’s code packages ( ) as configuration files ( ) under runmode specific config folders: The format of OSGi configuration files is JSON-based using the format defined by the Apache Sling project. OSGi configurations target OSGi components via their Persistent Identity (PID), which defaults to the OSGi component’s Java™ class name. For example, to provide OSGi configuration for an OSGi service implemented by: an OSGi configuration file is defined at: Prior versions of AEM supported OSGi configuration files using different file formats such as , and as XML resource definitions. These formats are superseded by the OSGi configuration format. The OSGi configs are not stored under /apps like typical AEM instances in Cloud they are stored in an external location. Check in Cloud Manager Developer Console to view the OSGi configs.\n\nAEM 6.x supports custom runmodes, however AEM as a Cloud Service does not. AEM as a Cloud Service support an exact set of runmodes . Any variation in OSGi configurations between AEM as a Cloud Service environments must be handled using OSGi configuration environment variables Specific OSGi configurations can be targeted to specific AEM instances by using runmodes. To use runmode, create config folders under (where example is your project name), in the format: Any OSGi configurations in such folders are used if the runmodes defined in the config folder name match the runmodes used by AEM. For example, if AEM is using the runmodes author and dev, configuration nodes in and are applied, while configuration nodes in and are not applied. If multiple configurations for the same PID are applicable, the configuration with the highest number of matching run modes is applied. This rule’s granularity is at a PID level. This means you cannot define some properties for the same PID in and more specific ones in for the same PID. The configuration with the highest number of matching runmodes is effective for the entire PID. A OSGi configuration folder cannot be declared in the same way a can be declared folder. Instead, the preview tier inherits its OSGi configuration from the publish tier’s values. When developing locally, a runmode startup parameter, , is used to specify the runmode OSGI configuration.\n\nAEM as a Cloud Service runmodes are well defined based on the environment type and service. Review the complete list of available AEM as a Cloud Service runmodes. OSGi configuration values specified by runmode can be verified by:\n• Selecting the service tier(s) to inspect, using the Pod drop-down list The resulting view displays all OSGi component configurations for the selected tier(s) with their applicable OSGi configuration values. These values can be cross-referenced with the OSGi configuration values in the AEM project’s source code under . To verify the appropriate OSGi configuration values are applied:\n• Locate the representing the OSGi configuration to verify; this is the name of the OSGi configuration file in the AEM project’s source code.\n• Inspect the list for the and verify the key and values match the OSGi configuration file in the AEM project source code for the runmode being verified.= There are three varieties of OSGi configuration values that can be used with Adobe Experience Manager as a Cloud Service.\n• Inline values, which are values that are hard-coded into the OSGi configuration and stored in Git. For example:\n• Secret values, which are values that must not be stored in Git for security reasons. For example:\n• Environment-specific values, which are values that vary between Development environments, and thus cannot be accurately targeted by run mode (since there is a single runmode in Adobe Experience Manager as a Cloud Service). For example: A single OSGi configuration file can use any combination of these configuration value types in conjunction. For example:\n\nHow to Choose the Appropriate OSGi Configuration Value Type how-to-choose-the-appropriate-osgi-configuration-value-type The common case for OSGi uses inline OSGi configuration values. Environment-specific configurations are used only for specific use cases where a value differs between dev environments. Environment-specific configurations extend the traditional, statically defined OSGi configurations that contain inline values, providing the ability to manage the OSGi configuration values externally via the Cloud Manager API. It is important to understand when the common and traditional approach of defining inline values and storing them in Git, should be used, versus abstracting the values into environment-specific configurations. The following guidance addresses when to use non-secret and secret environment-specific configurations: When to Use Inline Configuration Values when-to-use-inline-configuration-values Inline configurations values are considered the standard approach, and should be used when possible. Inline configurations provide the benefits of:\n• They are maintained, with governance and version history in Git\n• They do not require any additional deployment considerations or coordination Whenever defining an OSGi configuration value, start with inline values, and only select secret or environment-specific configurations if necessary for the use case.\n\nInline values are formatted as standard name-value pairs, following standard JSON syntax. For example: OSGi configuration should assign a placeholder for the variable that is intended to be defined per environment: Customers should only use this technique for OSGi configuration properties related to their custom code; it must not be used to override Adobe-defined OSGi configuration. Placeholders cannot be used in repoinit statements OSGi configuration should assign a placeholder for the secret that is intended to be defined per environment: The following applies to both environment specific and secret configuration values. Variables names must follow the following rules: Values for the variables must not exceed 2048 characters. There are rules related to the use of certain prefixes for variable names:\n• Variable names prefixed with , , or are reserved by Adobe. Any customer-set variables that start with these prefixes are ignored.\n• Customers must not reference variables prefixed with or either.\n• Environment variables with the prefix are defined by the product as Public API to be used and set by customers.\n\nWhile customers can use and set environment variables starting with the prefix they should not define their own variables with this prefix.\n\nThe following applies to both environment specific and secret configuration values. If no per-environment value is set, at runtime the placeholder is not replaced and is left in place since no interpolation happened. To avoid this, a default value can be provided as part of the placeholder with the following syntax: With a default value provided, the placeholder is replaced either with the per-environment value if provided or the provided default value. The following applies to both environment specific and secret configuration values. Variables can be defined in the local environment so they are picked up by the local AEM at runtime. For example, on Linux®: It is recommended that a simple bash script is written which sets the environment variables used in the configurations and to execute it before starting AEM. Tools like https://direnv.net/ help with simplifying this approach. Depending on the type of the values, they might be checked into source code management, if they can be shared between everyone. The values for secrets are read from files. Therefore for each placeholder using a secret a text file containing the secret value must be created. For example, if is used, a text file named server_password must be created. All these secret files must be stored in the same directory and the framework property must be configured with that local directory. File extensions are not allowed for the text file. So for the above example, the text file must be named server_password - without a file extension. The is an Sling framework property; so this property is not set in the felix console (https://experienceleague.adobe.com/system/console?lang=en), but it is set in the sling.properties file that is used when the system boots. This file can be found in the /conf subdir of the extracted Jar/install folder (crx-quickstart/conf). example: add this line to the end of the ‘crx-quickstart/conf/sling.properties’-file to configure ‘crx-quickstart/secretsdir’ as secret folder:\n\nIf an OSGi property requires different values for author versus publish:\n• Separate and OSGi folders must be used, as described in the Runmode Resolution section.\n• There are two options of creating the independent variable names that should be used:\n• the first option, which is recommended: in all OSGi folders (like and ) declared to define different values, use the same variable name. For example\n\n , where the default corresponds to the default value for that tier (author or publish). When setting the environment variable via Cloud Manager API or via a client, differentiate between the tiers using the “service” parameter as described in the Cloud Manager API reference documentation. The “service” parameter will bind the variable’s value to the appropriate OSGi tier. It can be “author” or “publish” or “preview”.\n• the second option, which is to declare distinct variables using a prefix such as and In the examples below, assume that there are three dev environments, in addition to the stage and prod environments. The intent is for the value of the OSGi property to be the same for stage and prod, but differ for each of the three dev environments. The intent is for the value of the OSGi property to differ for stage, prod, and for each of the three dev environments. Thus the Cloud Manager API must be called to set the value for for each dev env. The intent is for the value of the OSGi property to be the same for stage, production, and just one of the dev environments, but for it to differ for the other two dev environments. In this case, the Cloud Manager API must be called to set the value of for each of the dev environments, including for the dev environment which should have the same value as stage and production. It will not inherit the value set in the folder config. Another way to accomplish this would be to set a default value for the replacement token in the config.dev folder such that it’s the same value as in the config folder.\n\nTo delete a variable, include it with an empty value. See Cloud Manager API for more information. Getting Values via the Command Line getting-values-via-cli $ aio cloudmanager:list-environment-variables ENVIRONMENT_ID Name Type Value MY_VAR1 string plaintext value MY_VAR2 secretString **** $ aio cloudmanager:set-environment-variables ENVIRONMENT_ID --variable MY_VAR1 \"plaintext value\" --secret MY_VAR2 \"some secret value\" See the aio-cli-plugin-cloudmanager on GitHub for more information on how to configure values using the Cloud Manager plugin for Adobe I/O CLI. Up to 200 variables per environment can be declared. Because the secret and environment-specific configuration values live outside of Git, and therefore, are not part of the formal Adobe Experience Manager as a Cloud Service deployment mechanisms, the customer should manage, govern, and integrate into the Adobe Experience Manager as a Cloud Service deployment process. As mentioned above, calling the API deploys the new variables and values to Cloud environments, similar to a typical customer code deployment pipeline. The author and publish services are restarted and reference the new values, typically taking a few minutes. The quality gates and tests that are run by Cloud Manager during a regular code deployment are not performed during this process. Typically, customers would call the API to set environment variables before deploying code that relies on them in Cloud Manager. In some situations, one might want to modify an existing variable after code has already been deployed. The API may not succeed when a pipeline is in use, either an AEM update or customer deployment, depending on what part of the end to end pipeline is being executed at that time. The error response will indicate that the request was not successful, although it will not indicate the specific reason. There may be scenarios where a scheduled customer code deployment relies on existing variables to have new values, which would not be appropriate with the current code. If this is a concern, it is recommended to make variable modifications in an additive way. To do that, create new variable names instead of just changing the value of old variables so old code never references the new value. Then when the new customer release looks stable, one can choose to remove the older values. Similarly, since a variable’s values are not versioned, a rollback of code could cause it to reference newer values that cause issues. The previously mentioned additive variable strategy would help here as well. This additive variable strategy is also useful for disaster recovery scenarios where if code from several days prior needed to be redeployed, the variable names and values it references will still be intact. This relies on a strategy where a customer waits a few days before removing those older variables, otherwise the older code would not have appropriate variables to reference."
    },
    {
        "link": "https://docs.osgi.org/specification/osgi.cmpn/8.1.0/service.war.html",
        "document": "The Java EE Servlet model has provided the backbone of web based applications written in Java. Given the popularity of the Servlet model, it is desirable to provide a seamless experience for deploying existing and new web applications to Servlet containers operating on the OSGi framework. Previously, the Http Service in the catalog of OSGi compendium services was the only model specified in OSGi to support the Servlet programming model. However, the Http Service, as defined in that specification, is focused on the run time, as well as manual construction of the servlet context, and thus does not actually support the standard Servlet packaging and deployment model based on the Web Application Archive, or WAR format. This specification defines the Web Application Bundle, which is a bundle that performs the same role as the WAR in Java EE. A WAB uses the OSGi life cycle and class/resource loading rules instead of the standard Java EE environment. WABs are normal bundles and can leverage the full set of features of the OSGi framework. Web applications can also be installed as traditional WARs through a manifest rewriting process. During the install, a WAR is transformed into a WAB. This specification was based on ideas developed in [5] PAX Web Extender. This Web Application Specification provides support for web applications written to the Servlet 2.5 specification, or later. Given that Java Server Pages, or JSPs, are an integral part of the Java EE web application framework, this specification also supports the JSP 2.1 specification or greater if present. This specification details how a web application packaged as a WAR may be installed into an OSGi framework, as well as how this application may interact with, and obtain, OSGi services.\n• Extender - Enable the configuration of components inside a bundle based on configuration data provided by the bundle developer.\n• Services - Enable the use of OSGi services within a Web Application.\n• Deployment - Define a mechanism to deploy Web Applications, both OSGi aware and non OSGi aware, in the OSGi environment.\n• WAR File Support - Transparently enhance the contents of a WAR's manifest during installation to add any headers necessary to deploy a WAR as an OSGi bundle.\n• Web Container - The implementation of this specification. Consists of a Web Extender, a Web URL Handler and a Servlet and Java Server Pages Web Runtime environment.\n• Web Application - A program that has web accessible content. A Web Application is defined by [2] Java EE Web Applications.\n• Web Application Archive (WAR) - The Java EE standard resource format layout of a JAR file that contains a deployable Web Application.\n• Web Application Bundle - A Web Application deployed as an OSGi bundle, also called a WAB.\n• Web Extender - An extender bundle that deploys the Web Application Bundle to the Web Runtime based on the Web Application Bundle's state.\n• Web URL Handler - A URL handler which transforms a Web Application Archive (WAR) to conform to the OSGi specifications during installation by installing the WAR through a special URL so that it becomes a Web Application Bundle.\n• Web Runtime - A Java Server Pages and Servlet environment, receiving the web requests and translating them to servlet calls, either from Web Application servlets or other classes.\n• Servlet - An object implementing the Servlet interface; this is for the request handler model in the Servlet Specification.\n• Servlet Context - The model representing the Web Application in the Servlet Specification.\n• Java Server Page (JSP) - A declarative, template based model for generating content through Servlets that is optionally supported by the Web Runtime.\n• Context Path - The URI path prefix of any content accessible in a Web Application. \n\n The package dependencies for the clients of this specification are listed in the following table. \n\n JSP is optional for the Web Runtime. The Web Application Specification is composed of a number of cooperating parts, which are implemented by a Web Container. A Web Container consists of:\n• Web Runtime - Provides support for Servlet and optionally for JSPs, and\n• Web URL Handler - Provides on-the-fly enhancements of non-OSGi aware Web ARchives (WAR) so that they can be installed as a WAB. WABs are standard OSGi bundles with additional headers in the manifest that serve as deployment instructions to the Web Extender. WABs can also contain the Java EE defined descriptor in the / directory. When the Web Extender detects that a WAB is ready the Web Extender deploys the WAB to the Web Runtime using information contained in the descriptor and the appropriate manifest headers. The Bundle Context of the WAB is made available as a Servlet Context attribute. From that point, the Web Runtime will use the information in the WAB to serve content to any requests. Both dynamic as well as static content can be provided. The Web URL Handler allows the deployment of an unmodified WAR as a WAB into the OSGi framework. This Web URL Handler provides a URL stream handler with the scheme. Installing a WAR with this scheme allows the Web URL Handler to interpose itself as a filter on the input stream of the contents of the WAR, transforming the contents of the WAR into a WAB. The Web URL Handler rewrites the manifest by adding necessary headers to turn the WAR into a valid WAB. Additional headers can be added to the manifest that serve as instructions to the Web Extender. After a WAB has been deployed to the Web Runtime, the Web Application can interact with the OSGi framework via the provided Bundle Context. The Servlet Context associated with this WAB follows the same life cycle as the WAB. That is, when the underlying Web Application Bundle is started, the Web Application is deployed to the Web Runtime. When the underlying Web Application Bundle is stopped because of a failure or other reason, the Web Application is undeployed from the Web Run-time.\n\nBundles are the deployment and management entities under OSGi. A Web Application Bundle (WAB) is deployed as an OSGi bundle in an OSGi framework, where each WAB provides a single Web Application. A Web Application can make use of the [3] Servlet 2.5 specification and [4] JSP 2.1 specification programming models, or later, to provide content for the web. A WAB is defined as a normal OSGi bundle that contains web accessible content, both static and dynamic. There are no restrictions on bundles. A Web Application can be packaged as a WAB during application development, or it can be transparently created at bundle install time from a standard Web Application aRchive (WAR) via transformation by the Web URL Handler, see Web URL Handler. A WAB is a valid OSGi bundle and as such must fully describe its dependencies and exports (if any). As Web Applications are modularized further into multiple bundles (and not deployed as WAR files only) it is possible that a WAB can have dependencies on other bundles. A WAB may be installed into the framework using the methods. Once installed, a WAB's life cycle is managed just like any other bundle in the framework. This life cycle is tracked by the Web Extender who will then deploy the Web Application to the Web Runtime when the WAB is ready and will undeploy it when the WAB is no longer ready. This state is depicted in Figure 128.2. \n\n A WAB is differentiated from non Web Application bundles through the specification of the additional manifest header: The Web-ContextPath header specifies the value of the Context Path of the Web Application. All web accessible content of the Web Application is available on the web server relative to this Context Path. For example, if the context path is , then the URL would be something like: . The Context Path must always begin with a solidus ( ). The Web Extender must not recognize a bundle as a Web Application unless the Web-ContextPath header is present in its manifest and the header value is a valid path for the bundle. A WAB can optionally contain a resource to specify additional configuration. This must be found with the Bundle method at the path: The method includes fragments, allowing the to be provided by a fragment. The Web Extender must fully support a descriptor that specifies Servlets, Filters, or Listeners whose classes are required by the WAB. A WAB's Web Application must be deployed while the WAB is ready. Deployed means that the Web Application is available for web requests. Once deployed, a WAB can serve its web content on the given Context Path. Ready is when the WAB:\n• Is in the state, or\n• Has a activation policy and is in the state. The Web Extender should ensure that serving static content from the WAB does not activate the WAB when it has a activation policy. To deploy the WAB, the Web Extender must initiate the deploying of the Web Application into a Web Runtime. This is outlined in the following steps:\n• Wait for the WAB to become ready. The following steps can take place asynchronously with the starting of the WAB.\n• Validate that the manifest header does not match the Context Path of any other currently deployed web application. If the Context Path value is already in use by another Web Application, then the Web Application must not be deployed, and the deployment fails, see Failure. The Web Extender should log the collision. If the prior Web Application with the same Context Path is undeployed later, this Web Application should be considered as a candidate, see Stopping the Web Application Bundle.\n• The Web Runtime processes deployment information by processing the descriptor, if present. The Web Container must perform the necessary initialization of Web Components in the WAB as described in the [3] Servlet 2.5 specification. This involves the following sub-steps in the given order: The Web Runtime is required to complete instantiation of listeners prior to the start of execution of the first request into the Web Application by the Web Runtime. Attribute changes to the Servlet Context and Http Session objects can occur concurrently. The Servlet Container is not required to synchronize the resulting notifications to attribute listener classes. Listener classes that maintain state are responsible for the integrity of the data and should handle this case explicitly. If event listeners or filters are used in the , then the Web Runtime will load the corresponding classes from the bundle activating the bundle if it was lazily started. Such a configuration will therefore not act lazily.\n• Publish the Servlet Context as a service with identifying service properties, see Publishing the Servlet Context.\n• Post an event to indicate that the web application is now available. See Events. If at any moment before the event is published the deployment of the WAB fails, then the WAB deployment fails, see Failure. Any validation failures must prevent the Web Application from being accessible via HTTP, and must result in a event being posted. See Events. The situation after the failure must be as if the WAB was never deployed. To help management agents with tracking the state of Web Applications, the Web Extender must register the Servlet Context of the WAB as a service, using the Bundle Context of the WAB. The Servlet Context service must be registered with the service properties listed in the following table. The symbolic name for the Web Application Bundle The version of the Web Application Bundle. If no Bundle-Version is specified in the manifest then this property must not be set. The Context Path from which the WAB's content will be served. \n\n A deployed WAB provides content on requests from the web. For certain access paths, this can serve content from the resources of the web application: this is called static content. A Web Runtime must use the Servlet Context resource access methods to service static content, the resource loading strategy for these methods is based on the method, see Resource Lookup. For confidentiality reasons, a Web Runtime must not return any static content for paths that start with one of the following prefixes: These protected directories are intended to shield code content used for dynamic content generation from accidentally being served over the web, which is a potential attack route. In the servlet specification, the / directory in the WAR is protected in such a way. However, this protection is not complete. A dependent JAR can actually be placed outside the WEB-INF directory that can then be served as static content. The same is true for a WAB. Though the protected directories must never be served over the web, there are no other checks required to verify that no content can be served that is also available from the Bundle class path. It is the responsibility of the author of the WAB to ensure that confidential information remains confidential by placing it in one of the protected directories. WAB bundles should be constructed in such a way that they do not accidentally expose code or confidential information. The simplest way to achieve this is to follow the WAR model where code is placed in the directory and this directory is placed on the Bundle's class path as the first entry. For example: Dynamic content is content that uses code to generate the content, for example a servlet. This code must be loaded from the bundle with the Bundle method, following all the Bundle class path rules. Unlike a WAR, a WAB is not constrained to package classes and code resources in the directory or dependent JARs in only. These entries can be packaged in any way that's valid for an OSGi bundle as long as such directories and JARs are part of bundle class path as set with the Bundle-ClassPath header and any attached fragments. JARs that are specified in the Bundle-ClassPath header are treated like JARs in the directory of the Servlet specification. Similarly, any directory that is part of the Bundle-ClassPath header is treated like directory of the Servlet specification. Like WARs, code content that is placed outside the protected directories can be served up to clients as static content. This example consists of a WAB with the following contents: The content of the embedded JARs and is: Assuming there are no special rules in place then the following lists specifies the result of a number of web requests for static content: /acme/index.html acme.wab:index.html /acme/favicon.ico acme.wab:favicon.ico /acme/WEB-INF/lib/foo.jar not found because protecteddirectory /acme/LIB/bar.jar acme.wab:LIB/bar.jar (code, but not protected) In this example, the tag classes in must be found (if JSP is supported) but the tag classes in must not because is not part of the bundle class path. A web application is stopped by stopping the corresponding WAB. In response to a WAB event, the Web Extender must undeploy the corresponding Web Application from the Servlet Container and clean up any resources. This undeploying must occur synchronously with the WAB's stopping event. This will involve the following steps:\n• An event is posted to signal that a Web Application will be removed. See Events.\n• The Web Runtime must stop serving content from the Web Application.\n• The Web Runtime must clean up any Web Application specific resources as per servlet 2.5 specification.\n• It is possible that there are one or more colliding WABs because they had the same Context Path as this stopped WAB. If such colliding WABs exists then the Web Extender must attempt to deploy the colliding WAB with the lowest bundle id. Any failure during undeploying should be logged but must not stop the cleaning up of resources and notification of (other) listeners as well as handling any collisions. A web application can be uninstalled by uninstalling the corresponding WAB. The WAB will be uninstalled from the OSGi framework. When the Web Extender is stopped all deployed WABs are undeployed as described in Stopping the Web Application Bundle. Although the WAB is undeployed it remains in the state. When the Web Extender leaves the state all WABs will have been undeployed.\n\nThe Web URL Handler acts as a filter on the Input Stream of an install operation. It receives the WAB or WAR and it then generates a JAR that conforms to the WAB specification by rewriting the manifest resource. This process is depicted in Figure 128.3. \n\n When the Web Container bundle is installed it must provide the scheme to the URL class. The Web URL Handler has two primary responsibilities:\n• WAB - If the source is already a bundle then only the Web-ContextPath can be set or overwritten.\n• WAR - If the source is a WAR (that is, it must not contain any OSGi defined headers) then convert the WAR into a WAB. The Web URL Handler can take parameters from the query arguments of the install URL, see URL Parameters. The URL handler must validate query parameters, and ensure that the manifest rewriting results in valid OSGi headers. Any validation failures must result in Bundle Exception being thrown and the bundle install must fail. Once a WAB is generated and installed, its life cycle is managed just like any other bundle in the framework. The Web URL Handler's scheme is defined to be: scheme ::= 'webbundle:' embedded '?' web-params embedded ::= <embedded URL according to RFC 1738> web-params ::= ( web-param ( '&' web-param )* )? web-param ::= <key> '=' <value> The < and as well as the must follow [6] Uniform Resource Locators, RFC 1738 for their escaping and character set rules.A Web URL must further follow all the rules of a URL. Whitespaces are not allowed between terms. An example for a URL: Any URL scheme understood by the framework can be embedded, such as an , or URL. Some forms of embedded URL also contain URL query parameters and this must be supported. The embedded URL most be encoded as a standard URL. That is, the control characters like colon ( ), solidus ( ), percent ( ), and ampersand ( ) must not be encoded. Thus the value returned from the method may contain a query part. Any implementation must take care to preserve both the query parameters for the embedded URL, and for the complete URL. A question mark must always follow the embedded URL to simplify this processing. The following example shows an HTTP URL with some query parameters: The object for a URL must return the following values for the given methods:\n• - The parameters for processing of the manifest. For the following example: All the parameters in the URL are optional except for the Web-ContextPath parameter. The parameter names are case insensitive, but their values must be treated as case sensitive. Table 128.3 describes the parameters that must be supported by any URL Stream handler. A Web URL Handler is allowed to support additional parameters. The desired symbolic name for the resulting WAB. The version of the resulting WAB. The value of this parameter must follow the OSGi versioning syntax. The desired bundle manifest version. Currently, the only valid value for this parameter is . A list of packages that the war file depends on. The Context Path from which the Servlet Container should serve content from the resulting WAB. This is the only valid parameter when the input JAR is already a bundle. This parameter must be specified. \n\n The Web URL Handler can set or modify the Web-ContextPath of a WAB if the input source is already a bundle. It must be considered as a bundle when any of the OSGi defined headers listed in Table 128.3 is present in the bundle. For WAB Modification, the Web URL Handler must only support the Web-ContextPath parameter and it must not modify any existing headers other than the Web-ContextPath. Any other parameter given must result in a Bundle Exception. The Web URL Handler is designed to support the transparent deployment of Java EE Web ARchives (WAR). Such WARs are ignorant of the requirements of the underlying OSGi framework that hosts the Web Runtime. These WARs are not proper OSGi bundles because they do not contain the necessary metadata in the manifest. For example, a WAR without a Bundle-ManifestVersion, Import-Package, and other headers cannot operate in an OSGi framework. The Web URL Handler implementation copies the contents of the embedded URL to the output and rewrites the manifest headers based on the given parameters. The result must be a WAB. Any parameters specified must be treated as manifest headers for the web. The following manifest headers must be set to the following values if not specified:\n• - Must be set to 2.\n• - Generated in an implementation specific way.\n• \n• All JARs from the directory in the WAR. The order of these embedded JARs is unspecified.\n• If these JARs declare dependencies in their manifest on other JARs in the bundle, then these jars must also be appended to the Bundle-ClassPath header. The process of detecting JAR dependencies must be performed recursively as indicated in the Servlet Specification.\n• - The Web-ContextPath must be specified as a parameter. This Context Path should start with a leading solidus ( ). The Web URL handler must add the preceding solidus it if it is not present. The Web URL Handler is responsible for managing the import dependencies of the WAR. Implementations are free to handle the import dependencies in an implementation defined way. They can augment the Import-Package header with byte-code analysis information, add a fixed set of clauses, and/or use the DynamicImport-Package header as last resort. Any other manifest headers defined as a parameter or WAR manifest header not described in this section must be copied to the WAB manifest by the Web URL Handler. Such an header must not be modified. When a signed WAR file is installed using the Web URL Handler, then the manifest rewriting process invalidates the signatures in the bundle. The OSGi specification requires fully signed bundles for security reasons, security resources in partially signed bundles are ignored. If the use of the signing metadata is required, the WAR must be converted to a WAB during development and then signed. In this case, the Web URL Handler cannot be used. If the Web URL Handler is presented with a signed WAR, the manifest name sections that contain the resource's check sums must be stripped out by the URL stream handler. Any signer files ( and their corresponding signature files) must also be removed.\n\nIn order to properly integrate in an OSGi environment, a Web Application can access the OSGi service registry for publishing its services, accessing services provided by other bundles, and listening to bundle and service events to track the life cycle of these artifacts. This requires access to the Bundle Context of the WAB. The Web Extender must make the Bundle Context of the corresponding WAB available to the Web Application via the Servlet Context attribute. A Servlet can obtain a Bundle Context as follows: Web Applications sometimes need to inter-operate with services provided by other component models, such as a Declarative Services or Blueprint. Per the Servlet specification, the Servlet Container owns the life cycle of a Servlet; the life cycle of the Servlet must be subordinate to the life cycle of the Servlet Context, which is only dependent on the life cycle of the WAB. Interactions between different bundles are facilitated by the OSGi service registry. This interaction can be managed in several ways:\n• A Servlet can obtain a Bundle Context from the Servlet Context for performing service registry operations.\n• Via the JNDI Specification and the JNDI namespace. The OSGi JNDI specification describes how OSGi services can be made available via the JNDI URL Context. It defines an namespace and leverages URL Context factories to facilitate JNDI integration with the OSGi service registry. Per this specification, it is not possible to make the Servlet life cycle dependent on the availability of specific services. Any synchronization and service dependency management must therefore be done by the Web Application itself. The and methods of the interface are used to access resources in the web application. For a WAB, these resources must be found according to the method, this method includes fragments. For the and method, if multiple resources are found, then the first one must be used. Since the and methods do not support wildcards while the method does it is necessary to escape the wildcard asterisk ( ) with prefixing it with a reverse solidus ( ). This implies that a reverse solidus must be escaped with an extra reverse solidus. For example, the path must be escaped to . The method must map to the Bundle method, its return type is a Set and can not handle multiples. However, the paths from the method are relative while the methods of the must be absolute. For example, assume the following manifest for a bundle: This WAB has an attached fragment with the following content: The method for uses the method to find a resource in the directory and the resource . Assuming the host bundle has no directory, the Web Runtime must serve the resource from the . The Web Application descriptor can specify the attribute on the element. This attribute defines whether the descriptor is complete, or whether the classes in the bundle should be examined for deployment annotations. If the attribute is set to , the Web Runtime must ignore any servlet annotations present in the class files of the Web Application. Otherwise, if the attribute is not specified, or is set to , the container should process the class files of the Web Application for annotations, if supported. A WAB can make use of the annotations defined by [7] JSR 250 Common Annotations for the Java Platform if supported by the Web Extender. Such a WAB must import the packages the annotations are contained in. A Web Extender that does not support the use of JSR 250 annotations must not process a WAB that imports the annotations package. Java Server Pages (JSP) is a rendering technology for template based web page construction. This specification supports [4] JSP 2.1 specification if available with the Web Runtime. The element in a descriptor is used to describe both types of Web Components. JSP components are defined implicitly in the descriptor through the use of an implicit extension mapping, or explicitly through the use of a element. A Web Runtime compiles a JSP page into a Servlet, either during the deployment phase, or at the time of request processing, and dispatches the request to an instance of such a dynamically created class. Often times, the compilation task is delegated to a separate JSP compiler that will be responsible for identifying the necessary tag libraries, and generating the corresponding Servlet. The container then proceeds to load the dynamically generated class, creates an instance and dispatches the servlet request to that instance. Supporting in-line compilation of a JSP inside a bundle will require that the Web Runtime maintains a private area where it can store such compiled classes. The Web Runtime can leverage its private bundle storage area. The Web Runtime can construct a special class loader to load generated JSP classes such that classes from the bundle class path are visible to newly compiled JSP classes. The JSP specification does not describe how JSP pages are dynamically compiled or reloaded. Various Web Runtime implementations handle the aspects in proprietary ways. This specification does not bring forward any explicit requirements for supporting dynamic aspects of JSP pages."
    },
    {
        "link": "https://docs.oracle.com/en/middleware/standalone/weblogic-server/14.1.1.0/wlprg/osgi.html",
        "document": "OSGi is a Java modularity system developed and maintained by the OSGi Alliance, of which Oracle is a member. The OSGi specifications and related Javadoc together describe a comprehensive operating environment for Java applications:\n• You can download the OSGi Service Platform Core Specification from .\n• The OSGi Javadoc is available from . As described on the OSGi Alliance Web page, \"The OSGi Alliance is a worldwide consortium of technology innovators that advances a proven and mature process to create open specifications that enable the modular assembly of software built with Java technology. Modularity reduces software complexity; OSGi is the best model to modularize Java..\" The OSGi Architecture Web page further describes the OSGi technology as \"...a set of specifications that define a dynamic component system for Java. These specifications enable a development model where applications are (dynamically) composed of many different (reusable) components. The OSGi specifications enable components to hide their implementations from other components while communicating through services, which are objects that are specifically shared between components. This surprisingly simple model has far reaching effects for almost any aspect of the software development process.\" OSGi offers you the following benefits:\n• Versioning of package wiring, for both implementors and users of interfaces.\n• The \"uses\" directive allows for intelligent wiring of class loaders and helps ensure a consistent class space.\n\nWebLogic Server allows you to configure and manage one or more instances of an OSGi framework. You can also create and deploy your own OSGi bundles. WebLogic Server allows you to add a list of OSGi frameworks (maintained via OsgiFrameWorkMBean MBeans) to the server configuration. After the OSGi framework has been booted, a bundle object for the framework is placed into the local server JNDI tree. Applications can then get this bundle from JNDI and thereafter use that as their entry point into the OSGi system. Applications can also deploy their own OSGi bundles. One specific OSGi bundle from the chosen framework instance can be used in the application classloader hierarchy. WebLogic Server allows you to:\n• Configure and manage one or more instances of an OSGi framework from the Weblogic Server Administration Console and WLST. WebLogic Server includes the Apache Felix implementation of the OSGi framework. See for information on Felix.\n• Create and deploy your own OSGi bundles. WebLogic Server includes an OSGi bundle containing the OSGi API. You can use this API to create your own OSGi bundles.\n• One specific OSGi bundle from the chosen framework instance can be used in the application classloader hierarchy.\n• Incorporate the OSGi services of your choice. These topics are described in the sections that follow.\n\nAfter the OSGi server has been booted, a bundle object is placed into the local server JNDI tree. Applications can therefore get this bundle from JNDI and thereafter use that as the entry point into the OSGi system. The is placed into the JNDI environment of the application. One specific OSGi bundle from the chosen framework instance can be used in the application classloader hierarchy. Example 18-8 shows how to access a bundle that you create from JNDI. Example 18-8 Accessing Your OSGi Bundle From JNDI public static final String BUNDLE_JNDI_NAME = \"java:app/osgi/Bundle\"; ... String bundleSymbolicName = null; Bundle bundle = null; OsgiInfo info = new OsgiInfo(); List<String> errorMessages = new ArrayList<String>(); try { Context initCtx = new InitialContext(); bundle = (Bundle) initCtx.lookup(Constants.BUNDLE_JNDI_NAME); } catch (NamingException e) { errorMessages.add(e.toString()); System.out.println(\"Failed to lookup bundle from JNDI due to \" + e); } if (bundle != null) { bundleSymbolicName = bundle.getSymbolicName() + \"_\" + bundle.getVersion(); info.setCurrentBundle(bundleSymbolicName); BundleContext bc = bundle.getBundleContext(); if (bc != null) { // Get the start level service: StartLevel startLevelSvc = null; ServiceReference startLevelSr = bc.getServiceReference(\"org.osgi.service.startlevel.StartLevel\"); if (startLevelSr != null) { startLevelSvc = (StartLevel) bc.getService(startLevelSr); } List<String> allInstalledBundles = new ArrayList<String>(); List<String> allActivatedBundles = new ArrayList<String>(); Map<String, List<String>> services = new HashMap<String, List<String>>(); Map<String, String> startLevels = new HashMap<String, String>(); for (Bundle b : bc.getBundles()) { // Collect all the installed and activated bundles: String bundleId = b.getSymbolicName() + \"_\" + b.getVersion(); allInstalledBundles.add(bundleId); if (b.getState() == Bundle.ACTIVE) { allActivatedBundles.add(bundleId); } // Collect the registered services: ServiceReference[] srs = b.getRegisteredServices(); if (srs != null) { List<String> list = new ArrayList<String>(); for (ServiceReference sr : srs) { list.add(sr + \"-->\" + bc.getService(sr)); } services.put(bundleId, list); } // Collect the start levels: if (startLevelSvc != null) { startLevels.put(bundleId, startLevelSvc.getBundleStartLevel(b) + \"\"); } } info.setAllInstalledBundles(allInstalledBundles); info.setAllActivatedBundles(allActivatedBundles); info.setRegisteredServices(services); info.setStartLevels(startLevels); // Query the work manager services: List<String> workManagers = new ArrayList<String>(); try { ServiceReference[] wmSrs = bc.getServiceReferences(WorkManager.class.getCanonicalName(), null); if (wmSrs != null) { for (ServiceReference sr : wmSrs) { WorkManager wm = (WorkManager) bc.getService(sr); workManagers.add(wm.getName()); } } } catch (InvalidSyntaxException e) { e.printStackTrace(System.out); } info.setWorkManagers(workManagers); // Query the data source services: List<String> dataSources = new ArrayList<String>(); try { ServiceReference[] dsSrs = bc.getServiceReferences(DataSource.class.getCanonicalName(), null); if (dsSrs != null) { for (ServiceReference sr : dsSrs) { dataSources.add(sr.getProperty(\"name\").toString()); } } } catch (InvalidSyntaxException e) { e.printStackTrace(System.out); } info.setDataSources(dataSources); } } String bundleFileName = null; try { BundleIntrospect introspection = new BundleIntrospect(); bundleFileName = introspection.whichBundleFile(); info.setCurrentBundleFileName(bundleFileName); } catch (Throwable e) { errorMessages.add(e.toString()); //e.printStackTrace(System.out); } info.setErrorMessages(errorMessages); return info; } }\n\nYou can use a filtering classloader to specify the use of alternate library versions that are deployed as OSGi bundles. To configure the to specify that a certain package is loaded from an application, add a descriptor element to , which details the list of packages to be loaded from the application. The following example specifies that and packages are loaded from the application, not the system classloader: Place packages in or in if the package is an OSGi bundle. You can either add OSGi bundle dependencies directly to or configure the property (see Table 18-1) in your OSGi framework instance to export the necessary packages that the application needs. For more information on filtering classloaders, see Using a Filtering ClassLoader."
    },
    {
        "link": "https://docs.spring.io/spring-osgi/docs/current/reference/html/web.html",
        "document": "This will help you to understand how osgi can work in a development / production environment. The programmer guide describes the sophisticated eclipse tooling in detail.\n\nA major feature introduced in the 1.1.0 release is support for web applications which enables easy deployment of web artifacts to OSGi.\n\nThe biggest problems in running web applications in OSGi involve resource and class loading; there is no notion of bundle space or imported packages in a web application. Each web container has its own class loading hierarchy and classpath assumption which can conflict with the OSGi space. Spring DM addresses these problems by bridging the web container and the OSGi space so loading is no longer a concern. Unique in its functionality, the web support in Spring DM integrates directly with the web container so the WAR processing is literally handled by the server, giving full access to its configuration and capabilities(non-blocking vs blocking IO, thread pool, specification support (Servlet 2.3, 2.4, 2.5) and so on). The entire syntax is supported (without any parsing on Spring DM behalf), as well as any custom configuration file particular to the target container. In short, everything that the target container supports is available to the OSGi WAR through Spring DM.\n\nThis document understand by web application an instance of a WAR: a WAR is a definition while a web application a runtime instance of a definition. This is similar to the difference between a class and an object: the class represents a (bytecode) definition while the object, the instance of a class. Just like with non-WAR bundles, Spring DM Web uses the extender pattern to detect and install WARs. However, one crucial difference from the standard Spring DM Extender is that Spring DM will only trigger the install and uninstall of the WAR - the actual web application creation and thread management is delegated to the web container in which the WAR is installed. That is, Spring DM Web only dictates when a WAR is deployed to and undeployed from a web container; it is up to the web container to create and manage the equivalent web application. bundles to detect started OSGi WAR bundles and to deploy them to one of the supported web containers. Note that the web extender consider a war a bundle that has trailing in its location or contains a entry. By default, Tomcat will be used but this can be changed to Jetty or to another custom server. When the war bundle is stopped, Spring DM will also stop and uninstall the web application associated with it. Different from traditional web development, the Servlet classes need to be explicitly imported as the OSGi class path always takes priority (see below). Since, when running a web application, it's the web container that does the bootstrapping and instantiation, there is no need to place the Spring .xml files under or use the Spring DM manifest entries. Simply bundle your files in the WAR and use your web framework (or s/ s) to bootstrap the Spring container. See Section 9.7, “Spring-MVC Integration” for Spring-MVC integration and/or Spring reference documentation for more information. These being said, the Spring Extender is still required as it performs namespace handlers discovery - without it, it would not be possible to use Spring namespaces (like , or even for that matter).\n\nThe servlet specification defines a number of rules and locations which special meaning inside a WAR. This section will explain how these are handled in an OSGi environment. When installing a WAR bundle, for static resources, Spring DM will only consider what is available in the bundle space - this means what is available in the bundle jar and its attached fragments. Conforming to the Servlet spec, resources under folder will be available through the API but not to remote clients connecting to the web application. In addition, any resource available in the classpath (imported packages, required bundles or dynamic imports) can be loaded and used by the application code but cannot be seen outside of it. The main difference from the traditional WAR deployment is that the Servlet packages need to be imported so they are available to the WAR bundle. To do that, add the following packages to the entry: Additionally, the servlet specification defines the classpath of a WAR, based on some predefined locations. To quickly recap, these are: In addition, each container implementation can provide common libraries that are appended to the war classpath. Since OSGi, with its class wiring, versioning, reloading, superseeds the WAR classpath, Spring DM will ignore the WAR predefined locations and will always use the OSGi classpath instead. This means that classes imported by a WAR bundle can be used even if they are not present under folder or inside a jar under . This also means that any class under will not be considered if it's not available in the WAR OSGi classpath. One of the easiest ways to support the pre-defined WAR locations, is to add them to the bundle classpath, by adding them to the bundle manifest: Make sure the default location ( ) is present and there are no whitespaces between the commas. Since the OSGi API doesn't provide a hook for bundles to be pre-processed, Spring DM cannot automate this process in a reliable way. However, we are working on finding a suitable solution. Note that there are tools (bnd) that can add these entries during packaging. Before creating entries for embedded libraries, consider whether they can be installed as OSGi bundles - doing so allows them to be shared with other WARs if needed and since OSGi allows versioning, it is perfectly okay to have multiple versions of the same library inside the same VM. For JSPs, Spring DM integrates with Tomcat Jasper 2 Engine which means JSP 1.2, 2.0 and 2.1 are supported. OSGified versions for Jasper (from Tomcat 5.5.x and 6.0.x distribution respectively) are available in the Spring DM OSGi repository. No imports on Jasper classes are required for the OSGi bundle. The JSP spec allows the creation of tag libraries to “define declarative, modular functionality that can be reused by any JSP page”. Also known as taglibs, these reusable components consist of Java classes (the tag implementation) and description files that indicate how the tags can be used. Spring DM extends the JSP convention, of placing the taglibs either packed as a jar under or unpacked under , by detecting any taglib defined in the bundle classpath (imported packages or required bundles). Spring DM will automatically look for any taglib file ( ) available in the bundle classpath and will make them available to the Jasper engine. However, while the tag definitions are automatically discovered, the tag classes are not - again, the OSGi classpath takes priority. This means that in order to use a tag, the war bundle would have to import the tag corresponding classes since otherwise, they are not seen by the bundle and the tag cannot be used. When dealing with libraries that export a lot of tags, one can use the header instead of for importing the tags: Using the manifest entry above, all the classes (and thus tag implementations) exported by the JSP Standard Tag Library (or JSTL in short), are seen by the war bundle and thus can be used inside the JSPs. Before using on a large scale, please read the OSGi specification (section 3.13) for an in-depth review of its implications. No matter what mechanism you decide to use for the war classpath, due to the OSGi capabilities, it is possible to create libraries that are shared between multiple WARs while having full control over the used packages. Each bundle can import only the packages (and the versions) needed not an entire library jar - in fact, packages from different bundles/jars can be selectively used to obtain the desired behaviour - a very powerful capability which should make web application deployment easier.\n\nJust like the core extender, the web extender can be configured by using OSGi fragments. Following a similar pattern, the web extender looks for all XMLs under folder in its bundle space and assembles them into an application context that is used internally as its configuration. To override a default setting of the web extender, look up the appropriate bean name from the table below, define it in a suitable manner and then attach it as a fragment to the , using: The following beans are currently recognized by the web extender: Installs OSGi bundles as web applications. The deployers takes care of locating the required web container and installing and uninstalling web applications. Installs OSGi WARs to Tomcat 5.5.x/6.0.x. The servers needs to be installed, started and published as OSGi services as explained here. Determines the context path associated with an OSGi bundle/WAR. The returned path is used by the war deployer to install the war application. Returns as context path of the war based on the manifest header or (if missing), the file name from the bundle location, falling back to the bundle name and bundle symbolic name respectively. If neither of these is present, the bundle object identity will be used. \n\n Note that to properly support wars, whether they are using Servlet 2.5 or not, the Spring DM web extender considers as WARs bundles that contains a extension. To change the Tomcat deployer to Jetty for example, one can create a configuration file with the following content: Pre-defined bean name used by the web extender Once the file is created, it should be bundled in an OSGi fragment attached to the Spring DM Web Extender bundle by adding the header: Now the fragment can be deployed alongside bundle to plug in Jetty. A pre-packed Jetty fragment is available in the Spring DM maven repository under artifactId (make sure to use version 1.0.1+).\n\nBy default, the out of the box deployers look up the needed services, at startup. As the services are considered mandatory, the deployers will wait for them and, in case they are not found, will throw an exception. In cases where the default timeout or service lookup filter is not be appropriate, one can customize the service used through a Spring DM reference: Spring's namespace declaration - see this blog entry for more information Make sure to add the packages on which your configuration depends to the fragment manifest (since the web extender bundle imports only the packages it needs: Spring DM web support's). For the example above, one must import Catalina 's package. Since the interface signature depends on the class from another package, its package needs to be imported as well - not doing so results in s:\n\nUnfortunately, at the moment most libraries used for web development are not OSGi bundles, which means they cannot be used inside the OSGi space unless they are embedded in other bundles. To address this problem, the Spring DM project has osgified most of the common libraries and made them available through a dedicated Maven repository (which can be found in the appendix). Please note that the current repository, for now, is provided as-is without any support. These being said, we hope you find it useful. Spring DM web support expects the web containers to be installed as OSGi services. Since neither the Tomcat nor the Jetty distribution do this, Spring DM offers two simple yet useful OSGi Activators for both containers at the Spring DM OSGi repository. Once installed, these will programmatically start the appropriate web container based on a default configuration (which can be customized and publish it as an OSGi service. While the activators are generic, they can be easily customized for advance usages or even replaced - it's up to each deployer to decide how the server instances are looked up. The activator binaries and sources can be found either in the Spring DM repository (see below) or under the folder inside the Spring DM ( ) distribution All entries in the repository belong to the group and have an termination to differentiate them from the original jars. Apache Tomcat version 5.5.x and 6.0.x are available as OSGi artifacts in the repository under artifactId. The jars require only commons-logging, JMX and Servlet/JSP libraries to be present. In addition to the Catalina artifacts, the repository contains also a Tomcat activator (that works with both 5.5.x and 6.0.x versions) named . The activator understands Tomcat XML configuration and contains a default, minimal setup that starts the server on , port . This behaviour can be customized by placing the desired configuration (which will override the default one) under location (following the Tomcat folder layout) in a fragment attached to the Tomcat activator. To attach fragments to the Tomcat activator, specify the following host name in the fragment manifest: Since Jetty is OSGi-ready by default, the official distribution can be installed without any transformation/processing on the OSGi platform. However, since there is no activator, Spring DM provides one, similar in functionality to the one available for Tomcat. The activator has as artifact id. Similar to the Tomcat case, a default configuration bundle (named ) is provided for starting a Jetty instance on , port . To change the defaults, place your Jetty configuration under location (either by updating the provided bundle by using a custom one). To attach fragments to the Jetty activator, specify the following host name in the fragment manifest: Just like the extender, each activator uses a default configuration which can be overridden by the user. For the latter case, one should use fragments (as mentioned above) to provide a customized configuration and to avoid modifying the distribution jar. The Servlet, Java Server Pages, Standard Taglib, Commons-EL and other web libraries are available as well in the Spring DM repository. When browsing use an S3 compatible application .\n\nSince 1.1, Spring DM integrates closely with Spring-MVC framework. This section details how Spring-MVC applications can be run into OSGi environments (it is assumed the reader is familiar with Spring-MVC concepts and APIs). In order to be properly used inside an OSGi platform, a Spring-MVC application needs to adapt to its new environment. Spring DM provides a dedicated, OSGi-aware, web application context (called ) that offers the same functionality and behaviour to its Spring-MVC brethren, . The application context is aware of the web application and thus is able to load resources from the OSGi space, import and export OSGi services and support the and component scanning across the bundles included in the classpath. To use this application context instead of the default one, use the parameters supported by Spring's and inside your web application : Name of the used by Spring's to determine the root web application context type Fully qualified name of the OSGi-aware web application context class Name of the used by Spring's to determine the web application context type With this configuration, deployed Spring-MVC bundles will be able to look up the existing and be aware of the OSGi environment. You still need to add the proper package imports to your Spring-MVC application - the WAR is still a bundle after all which means without the proper manifest entries, it will have an invalid class path and will not be able to work properly."
    },
    {
        "link": "https://docs.osgi.org/specification/osgi.cmpn/7.0.0/service.component.html",
        "document": "Most bundles will require access to other services from the service registry. The dynamics of the service registry require care and attention of the programmer because referenced services, once acquired, could be unregistered at any moment. The component model simplifies the handling of these service dependencies significantly. The services that are selected by a reference are called the target services. These are the services selected by the method where the first argument is the reference's interface and the second argument is the reference's target property, which must be a valid filter. A component configuration becomes satisfied when each specified reference is satisfied. A reference is satisfied if it specifies optional cardinality or when the number of target services is equal to or more than the minimum cardinality of the reference. An activated component configuration that becomes unsatisfied must be deactivated. During the activation of a component configuration, SCR must bind some or all of the target services of a reference to the component configuration. Any target service that is bound to the component configuration is called a bound service. See Bound Services. A component instance must be able to use the services that are referenced by the component configuration, that is, the bound services of the references. The following techniques are available for a component instance to acquire these bound services:\n• Method injection - SCR calls a method on the component instance when a service becomes bound, when a service becomes unbound, or when its properties are updated. These methods are the bind, updated, and unbind methods specified by the reference. Method injection is useful if the component needs to be notified of changes to the bound services for a dynamic reference.\n• Field injection - SCR modifies a field in the component instance when a service becomes bound, when a service becomes unbound, or when its properties are updated.\n• Constructor injection - When SCR activates a component instance, the component instance must be constructed and constructor injection occurs. Bound services and activation objects can be parameters to the constructor.\n• Lookup strategy - A component instance can use one of the methods of its ComponentContext to locate a bound service. These methods take the of the reference as a parameter. If the reference has a dynamic policy, it is important to not store returned service objects but look them up every time they are needed. A component may use multiple strategies to access the bound services of a reference. When using method injection, SCR must call the component instance at the appropriate time. SCR must call on the following events:\n• - The bind method, if specified, is called to bind a new service to the component that matches the selection criteria. If the is then the bind method of a replacement service can be called before its corresponding unbind method.\n• - The updated method, if specified, is called when the service properties of a bound services are modified and the resulting properties do not cause the service to become unbound because it is no longer selected by the target property.\n• - The unbind method, if specified, is called when SCR needs to unbind the service. Each event is associated with an event method. An event method can take one or more parameters. Each parameter must be of one of the following types:\n• - A Service Reference for the bound service. This Service Reference may later be passed to the locateService(String,ServiceReference) method to obtain the actual service object. This approach is useful when the service properties need to be examined before accessing the service object. It also allows for the delayed activation of bound services when using method injection.\n• - A Component Service Objects for the bound service. This Component Service Objects can be used to obtain the actual service object or objects. This approach is useful when the referenced service has prototype service scope and the component instance needs multiple service objects for the service.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must additionally implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is . This method will receive a Service Reference for the bound service.\n• The method takes a single parameter and the type of the parameter is ComponentServiceObjects. This method will receive a Component Service Objects for the bound service.\n• The method takes a single parameter and the type of the parameter is the type specified by the reference's attribute. This method will receive the bound service object.\n• The method takes a single parameter and the type of the parameter is assignable from the type specified by the reference's attribute. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. This method will receive the bound service object.\n• The method takes a single parameter and the type of the parameter is . This method will receive an unmodifiable Map containing the service properties of the bound service.\n• The method takes two or more parameters and the types of the parameters must be one of: the type specified by the reference's attribute, a type assignable from the type specified by the reference's attribute, , ComponentServiceObjects, or . If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. In the case where the type specified by the reference's attribute is , ComponentServiceObjects, or , the first parameter of that type will receive the bound service object. If selected event method has more than one parameter of that type, the remaining parameters of that type will receive a Service Reference for the bound service, a Service Objects for the bound service, or an unmodifiable Map containing the service properties of the bound service. When searching for an event method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If no suitable method is located, SCR must log an error message with the Log Service, if present, and there will be no bind, updated, or unbind notification. The bind and unbind methods must be called once for each bound service. This implies that if the reference has multiple cardinality, then the methods may be called multiple times. The updated method can be called multiple times per service. In the following examples, a component requires the Logger Factory service. The first example uses the lookup strategy. The reference is declared without any bind, updated, and unbind methods: The component implementation class must now lookup the service. This looks like: Alternatively, the component could use method injection and ask to be notified with the Logger Factory service by declaring bind, updated, and unbind methods. The component implementation class looks like: Event methods can be declared private in the component class but are only looked up in the inheritance chain when they are protected, public, or have default access. See Locating Component Methods and Fields. When using field injection, SCR must modify fields in the component instance at the appropriate time. SCR must modify the fields on the following events:\n• - The field is modified to bind a new service to the component that matches the selection criteria.\n• - For certain field types, the field is modified when the service properties of a bound services are modified and the resulting properties do not cause the service to become unbound because it is no longer selected by the target property.\n• - The field is modified when SCR needs to unbind the service. For a reference with unary cardinality, a field must be of one of the following types:\n• - The bound service object. The type of the field can be the actual service type or it can be a type that is assignable from the actual service type.\n• - A Service Reference for the bound service. This Service Reference may later be passed to the locateService(String,ServiceReference) method to obtain the actual service object. This approach is useful when the service properties need to be examined before accessing the service object. It also allows for the delayed activation of bound services when using field injection.\n• - A Component Service Objects for the bound service. This Component Service Objects can be used to obtain the actual service object or objects. This approach is useful when the referenced service has prototype service scope and the component instance needs multiple service objects for the service.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must additionally implement with the method comparing service property maps using the same ordering as based upon service ranking and service id.\n• - An unmodifiable Map.Entry whose key is an unmodifiable Map containing the service properties of the bound service, as above, and whose value is the bound service object. This Map.Entry must additionally implement with the method comparing the service property map key using the same ordering as based upon service ranking and service id. If the actual service type is one of , , , or , the field will be set to the service object rather than the object about the service. For a reference with multiple cardinality, a field must be a collection of one of the following types:\n• A subtype of - This type can only be used for dynamic references using the reference field option. The component instance must initialize the field to a collection object in its constructor. The type of objects set in the collection are specified by the attribute in the component description:\n• - The bound service object. This is the default field collection type.\n• - An unmodifiable Map containing the service properties of the bound service. This Map must implement , as above.\n• - An unmodifiable Map.Entry whose key is an unmodifiable Map containing the service properties of the bound service, as above, and whose value is the bound service object. This Map.Entry must implement , as above. Only instance fields of the field types above are supported. If a referenced field is declared with the modifier or has a type other than one of the above, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must locate a suitable field as specified in Locating Component Methods and Fields. If no suitable field is located, SCR must log an error message with the Log Service, if present, and no field will not be modified for the reference. Care must be taken by the component implementation regarding the field. SCR has no way to know if the component implementation itself may alter the field value. The component implementation should not alter the field value and allow SCR to manage it. SCR must treat the field as if the component implementation does not alter the field value so SCR may retain its own copy of the value set in the field. In the following examples, a component requires the Logger Factory service. The component implementation class looks like: Fields can be declared private in the component class but are only looked up in the inheritance chain when they are protected, public, or have default access. See Locating Component Methods and Fields. When using constructor injection, SCR must construct the component instance using the appropriate constructor passing activation objects and bound services as parameters. Since a component instance is only constructed once, constructor parameters for references must be for static references. A suitable constructor is selected using the following steps:\n• If the constructor is not public, then the constructor must not be considered.\n• If the constructor has a parameter count that does not match the value of the attribute in the element, then the constructor must not be considered. If the value of the attribute is 0, the default value, then the public no-parameter constructor must be used.\n• For the constructor parameters associated with a reference, that is, there is a reference with a attribute whose value matches the zero-based parameter number of the constructor parameter, if the parameter type is not one of the types supported for field injection for a static reference, then the constructor must not be considered. See Field Injection for information on types supported for field injection.\n• For the constructor parameters not associated with a reference, if the parameter type is not assignable from one of the activation object types, then the constructor must not be considered. See Activation Objects for information on activation object types.\n• If only a single constructor remains, this constructor must be used to construct the component instance.\n• If more than one constructor remains, this implies the constructor is overloaded and SCR may choose any of the remaining constructors to construct the component instance. When searching for the constructor to call, SCR must use reflection on the implementation class. If no suitable constructor is located, SCR must log an error message with the Log Service, if present, and the component configuration is not activated. If the constructor throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the component configuration is not activated. If the constructor parameter is associated with a reference having cardinality of and there is no bound service for the reference, then the value will be supplied as the constructor parameter. In the following examples, a component requires the Logger Factory service. The component implementation class looks like: A component implementation is always written with a certain cardinality for each reference in mind. The cardinality represents two important concepts:\n• Multiplicity - Does the component implementation assume a single service or does it explicitly handle multiple services? For example, when a component uses the Logger Factory service, it only needs to bind to one Logger Factory service to function correctly. Alternatively, when the Configuration Admin uses the Configuration Listener services it needs to bind to all target services present in the service registry to dispatch its events correctly.\n• Optionality - Can the component function without any bound service present? Some components can still perform useful tasks even when no service is available; other components must bind to at least one service before they can be useful. For example, the Configuration Admin in the previous example must still provide its functionality even if there are no Configuration Listener services present. Alternatively, an application that registers a Servlet with the Http Service has little to do when the Http Service is not present, it should therefore use a reference with a mandatory cardinality. The cardinality is expressed with the following syntax: The cardinality for a reference can be specified as one of four choices: The minimum cardinality is specified by the optionality part of the cardinality. This is either or . A minimum cardinality property can be used to raise the minimum cardinality of a reference from this initial value. For example, a cardinality in the component description can be raised into a cardinality at runtime by setting the minimum cardinality property for the reference to . This would typically be done by a deployer setting the minimum cardinality property in a configuration for the component. The minimum cardinality for a unary cardinality cannot exceed . See Minimum Cardinality Property for more information. A reference is satisfied if the number of target services is equal to or more than the minimum cardinality. The is irrelevant for the satisfaction of the reference. The only specifies if the component implementation is written to handle being bound to multiple services ( ) or requires SCR to select and bind to a single service ( ). When a satisfied component configuration is activated, there must be at most one bound service for each reference with a unary cardinality and at least as many bound services as the minimum cardinality for each reference. If the cardinality constraints cannot be maintained after a component configuration is activated, that is the reference becomes unsatisfied, the component configuration must be deactivated. If the reference has a unary cardinality and there is more than one target service for the reference, then the bound service must be the target service with the highest service ranking as specified by the property. If there are multiple target services with the same service ranking, then the bound service must be the target service with the highest service ranking and the lowest service id as specified by the property. In the following example, a component wants to register a resource with all Http Services that are available. Such a scenario has the cardinality of . The code must be prepared to handle multiple calls to the bind method for each Http Service in such a case. In this example, the code uses the method to register a directory for external access. A component implementation must be written to understand the service scope of referenced services. The reference scope defines whether the component expects the bundle to be exposed to a single service object for a bound service or to potentially multiple services objects. The following reference scopes are available:\n• bundle - For all references to a given bound service, all activated component instances within a bundle must use the same service object. That is, for a given bound service, all component instances within a bundle will be using the same service object. This is the default reference scope.\n• prototype - For all references to a given bound service, each activated component instance may use a single, distinct service object. That is, for a given bound service, each component instance may use a distinct service object but within a component instance all references to the bound service will use the same service object.\n• prototype_required - For all references to a given bound service, each activated component instance must use a single, distinct service object. That is, for a given bound service, each component instance will use a distinct service object but within a component instance all references to the bound service will use the same service object. For a bound service of a reference with bundle reference scope, SCR must get the service object from the OSGi Framework's service registry using the method on the component's Bundle Context. If the service object for a bound service has been obtained and the service becomes unbound, SCR must unget the service object using the method on the component's Bundle Context and discard all references to the service object. This ensures that the bundle will only be exposed to a single instance of the service object at any given time. For a bound service of a reference with prototype or prototype_required reference scope, SCR must use a Service Objects object obtained from the OSGi Framework's service registry using the component's Bundle Context to get any service objects. If service objects for a bound service have been obtained and the service becomes unbound, SCR must unget any unreleased service objects using the Service Objects object obtained from the OSGi Framework's service registry using the component's Bundle Context. This means that if a component instance used a Component Service Objects object to obtain service objects, SCR must track those service objects so that when the service becomes unbound, SCR can unget any unreleased service objects. Additionally, for a reference with prototype_required reference scope, only services registered with prototype service scope can be considered as target services. This ensures that each component instance can be exposed to a single, distinct instance of the service object. Using prototype_required reference scope effectively adds to the target property for the reference. A service that does not use prototype service scope cannot be used as a bound service for a reference with prototype_required reference scope since the service cannot provide a distinct service object for each component instance. Once all the references of a component are satisfied, a component configuration can be activated and therefore bound to target services. However, the dynamic nature of the OSGi service registry makes it likely that services are registered, modified and unregistered after target services are bound. These changes in the service registry could make one or more bound services no longer a target service thereby making obsolete any object references that the component has to these service objects. Components therefore must specify a policy how to handle these changes in the set of bound services. A policy-option can further refine how changes affect bound services. The static policy is the most simple policy and is the default policy. A reference with a static policy is called a static reference. A component instance never sees any of the dynamics of the static reference. The bind method is called and/or the field is set before the component instance is activated. Static references can also be used for parameters for constructor injection. Component configurations are deactivated before any bound service for the static reference becomes unavailable. If a target service is available to replace the bound service which became unavailable, the component configuration must be reactivated and the replacement service is bound to the new component instance. If the is then the registration of an additional target service for a reference must not result in deactivating and reactivating a component configuration. If the is then the component configuration must be reactivated when new applicable services become available. See Table 112.1 on page . If a static reference specifies an updated method and the bound service's properties change, SCR must call the updated method. The static policy can be very expensive if it depends on services that frequently unregister and re-register or if the cost of activating and deactivating a component configuration is high. Static policy is usually also not applicable if the cardinality specifies multiple bound services. The dynamic policy is slightly more complex since the component implementation must properly handle changes in the set of bound services that can occur on any thread at any time after the component instance is created. A reference with a dynamic policy is called a dynamic reference. With a dynamic reference, SCR can change the set of bound services without deactivating a component configuration. If the component uses method injection to access services, then the component instance will be notified of changes in the set of bound services by calls to the bind, updated, and unbind methods. If the is then a bound reference is not rebound even if a more suitable service becomes available for a 1..1 or 0..1 reference. If the is then the component must be unbound and rebound for that reference. See Table 112.1 on page . The previous example with the registering of a resource directory used a static policy. This implied that the component configurations are deactivated when there is a change in the bound set of Http Services. The code in the example can be seen to easily handle the dynamics of Http Services that come and go. The component description can therefore be updated to: The code is identical to the previous example. The reference policy option defines how eager the reference is to rebind when a new, potentially a higher ranking, target service becomes available. The reference policy option can have the following values:\n• - Minimize rebinding and reactivating. This is the default reference policy option.\n• - Maximize the use of the best service by deactivating static references or rebinding dynamic references. Table 112.1 defines the actions that are taken when a better target service becomes available. In this context, better is when the reference is not bound or when the new target service has a higher ranking than the bound service. Table 112.1 Action taken for policy-option when a new or higher ranking service becomes available Reactivate to bind the better target service. If no service is bound, bind to new target service. Otherwise, ignore new target service. If no service is bound, bind to better target service. Otherwise, unbind the bound service and bind the better target service. Reactivate to bind the better target service. Unbind the bound service, then bind the new service. \n\n For a reference using field injection, the reference field option defines how SCR must manage the field value. The reference field option can have the following values:\n• - SCR must set the field value. Any field value set by the constructor of the component instance is overwritten. This is the default reference field option.\n• - SCR must update the collection set in the field. This collection can be set by the constructor of the component instance. This reference field option can only be used for a dynamic reference with multiple cardinality. For a static reference, the replace option must be used. For a dynamic reference, the choice of reference field option is influenced by the cardinality of the reference. For unary cardinality, the replace option must be used. For multiple cardinality, either the replace or update option can be used. If the update option is used when not permitted, SCR must log an error message with the Log Service, if present, and the field must not be modified. If the field is declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified. For a static reference, SCR must set the field value before the component instance is activated and must not change the field while the component is active. This means there is a happens-before relationship between setting the field and activating the component instance, so the active component can safely read the field. For a dynamic reference, the field must be declared with the modifier so that field value changes made by SCR are visible to other threads. If the field is not declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified. For a reference with unary cardinality, SCR must set the field value with initial bound service, if any, before the component instance is activated. If the reference has optional cardinality and there is no bound service, SCR must set the field value to . If the reference is dynamic, when there is a new bound service or the service properties of the bound service are modified and the field holds service properties, SCR must replace the field value. If the reference has optional cardinality and there is no bound service, SCR must set the field value to . For a reference with multiple cardinality, the type of the field must be or . If the field has a different type, SCR must log an error message with the Log Service, if present, and the field must not be modified. Before the component instance is activated, SCR must set the field value with a new mutable collection that must contain the initial set of bound services sorted using the same ordering as based upon service ranking and service id. The collection may be empty if the reference has optional cardinality and there are no bound services. If the reference is dynamic, when there is a change in the set of bound services or the service properties of a bound service are modified and the collection holds service properties, SCR must replace the field value with a new mutable collection that must contain the updated set of bound services sorted using the same ordering as based upon service ranking and service id. The new collection may be empty if the reference has optional cardinality and there are no bound services. The update option can only be used for a dynamic reference with multiple cardinality. The component's constructor can set the field with its choice of collection implementation. In this case, the field can be declared with the modifier. The collection implementation used by the component should use identity rather than or to manage the elements of the collection. The collection implementation should also be thread-safe since SCR may update the collection from threads different than those used by the component instance. After constructing the component instance, if the field value is :\n• If the type of the field is or , SCR will set the field value to a new mutable empty collection or list object, respectively. If the field is declared with the modifier, SCR must log an error message with the Log Service, if present, and the field must not be modified.\n• Otherwise, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must not change the field value while the component is active and only update the contents of the collection. SCR must update the collection before the component instance is activated by calling for each bound service. When there is a change to the set of bound services:\n• SCR must call for an unbound service.\n• If the service properties of a bound service are modified and the collection holds service properties, SCR must call for the replacement element followed by for the old element. The collection may be empty if the reference has optional cardinality and there are no bound services. The target services for a reference are constrained by the reference's interface name and target property. By specifying a filter in the target property, the programmer and deployer can constrain the set of services that should be part of the target services. For example, a component wants to track all Component Factory services that have a factory identification of . The following component description shows how this can be done. The filter is manifested as a component property called the target property. The target property can also be set by and elements, see Property and Properties Elements. The deployer can also set the target property by establishing a configuration for the component which sets the value of the target property. This allows the deployer to override the target property in the component description. See Target Property for more information. It is possible for a set of component descriptions to create a circular dependency. For example, if component references a service provided by component and component references a service provided by component then a component configuration of one component cannot be satisfied without accessing a partially activated component instance of the other component. SCR must ensure that a component instance is never accessible to another component instance or as a service until it has been fully activated, that is it has returned from its method if it has one. Circular references must be detected by SCR when it attempts to satisfy component configurations and SCR must fail to satisfy the references involved in the cycle and log an error message with the Log Service, if present. However, if one of the references in the cycle has optional cardinality SCR must break the cycle. The reference with the optional cardinality can be satisfied and bound to zero target services. Therefore the cycle is broken and the other references may be satisfied. SCR provides special support for components having references to the Logger Factory from the Log Service specification. If the reference uses method, field or constructor injection, the referenced service is of type , and the type of the parameter or field to receive the service object is of type or , then SCR must obtain the proper type of Logger from the bound Logger Factory service and use the obtained Logger as the service object rather than the service object for the bound Logger Factory service. To obtain the Logger object to use as the service object, SCR must call the method passing the bundle declaring the component as the first argument, the fully qualified name of the component implementation class as the second argument, and the type of the parameter or field, or , as the third argument. For example, the following code will have the field set to a Logger object created by SCR from the bound Logger Factory service.\n\nA component must first be enabled before it can be used. A component cannot be enabled unless the component's bundle is started. See Starting Bundles in OSGi Core Release 7. All components in a bundle become disabled when the bundle is stopped. So the life cycle of a component is contained within the life cycle of its bundle. Every component can be enabled or disabled. The initial enabled state of a component is specified in the component description via the attribute of the element. See Component Element. Component configurations can be created, satisfied and activated only when the component is enabled. The enabled state of a component can be controlled with the Component Context enableComponent(String) and disableComponent(String) methods. The purpose of later enabling a component is to be able to decide programmatically when a component can become enabled. For example, an immediate component can perform some initialization work before other components in the bundle are enabled. The component descriptions of all other components in the bundle can be disabled by having set to in their component descriptions. After any necessary initialization work is complete, the immediate component can call to enable the remaining components. The and methods must return after changing the enabled state of the named component. Any actions that result from this, such as activating or deactivating a component configuration, must occur asynchronously to the method call. Therefore a component can disable itself. All components in a bundle can be enabled by passing a as the argument to . Component configurations can only be activated when the component configuration is satisfied. A component configuration becomes satisfied when the following conditions are all satisfied:\n• If the component description specifies , then a object for the component is present in the Configuration Admin service.\n• Using the component properties of the component configuration, all the component's references are satisfied. A reference is satisfied when the reference specifies optional cardinality or the number of target services is equal to or more than the minimum cardinality of the reference. Once any of the listed conditions are no longer true, the component configuration becomes unsatisfied. An activated component configuration that becomes unsatisfied must be deactivated. A component is an immediate component when it must be activated as soon as its dependencies are satisfied. Once the component configuration becomes unsatisfied, the component configuration must be deactivated. If an immediate component configuration is satisfied and specifies a service, SCR must register the component configuration as a service in the service registry and then activate the component configuration. The service properties for this registration consist of the component properties as defined in Service Properties. The state diagram is shown in Figure 112.2. \n\n A key attribute of a delayed component is the delaying of class loading and object creation. Therefore, the activation of a delayed component configuration does not occur until there is an actual request for a service object. A component is a delayed component when it specifies a service but it is not a factory component and does not have the attribute of the element set to . SCR must register a service after the component configuration becomes satisfied. The registration of this service must look to observers of the service registry as if the component's bundle actually registered this service. This makes it possible to register services without creating a class loader for the bundle and loading classes, thereby allowing reduction in initialization time and a delay in memory footprint. When SCR registers the service on behalf of a component configuration, it must avoid causing a class load to occur from the component's bundle. SCR can ensure this by registering a object with the Framework for that service. By registering a object, the actual service object is not needed until the is called to provide the service object. The service properties for this registration consist of the component properties as defined in Service Properties. The activation of a component configuration must be delayed until its service is requested. When the service is requested, if the service has the attribute set to , SCR must create and activate a unique component configuration for each bundle requesting the service. If the service has the attribute set to , SCR must create and activate a unique component configuration for each distinct request for the service. Otherwise, if the service has the attribute set to , SCR must activate a single component configuration which is used by all requests for the service. A component instance can determine the bundle it was activated for by calling the getUsingBundle() method on the Component Context. The activation of delayed components is depicted in a state diagram in Figure 112.3. Notice that multiple component configurations can be created from the state if a delayed component specifies a service set to a value other than . If the service has the attribute set to , SCR must deactivate a component configuration when it stops being used as a service object since the component configuration must not be reused as a service object. If the service has the attribute set to or , SCR must deactivate a component configuration when it stops being used as a service object after a delay since the component configuration may be reused as a service object in the near future. This allows SCR implementations to reclaim component configurations not in use while attempting to avoid deactivating a component configuration only to have to quickly activate a new component configuration for a new service request. The delay amount is implementation specific and may be zero. \n\n SCR must register a Component Factory service as soon as the component factory becomes satisfied. The component factory is satisfied when the following conditions are all satisfied:\n• Using the component properties specified by the component description, all the component's references are satisfied. A reference is satisfied when the reference specifies optional cardinality or there is at least one target service for the reference The component factory, however, does not use any of the target services and does not bind to them. Once any of the listed conditions are no longer true, the component factory becomes unsatisfied and the Component Factory service must be unregistered. Any component configurations activated via the component factory are unaffected by the unregistration of the Component Factory service, but may themselves become unsatisfied for the same reason. The Component Factory service must be registered under the name with the following service properties:\n• - The name of the component.\n• - The value of the attribute. The service properties of the Component Factory service must not include the component properties. New component configurations are created and activated when the method of the Component Factory service is called. If the component description specifies a service, the component configuration is registered as a service under the provided interfaces. The service properties for this registration consist of the component properties as defined in Service Properties. The service registration must take place before the component configuration is activated. Service unregistration must take place before the component configuration is deactivated. \n\n A Component Factory service has a single method: newInstance(Dictionary). This method must create, satisfy and activate a new component configuration and register its component instance as a service if the component description specifies a service. It must then return a ComponentInstance object. This ComponentInstance object can be used to get the component instance with the getInstance() method. SCR must attempt to satisfy the component configuration created by before activating it. If SCR is unable to satisfy the component configuration given the component properties and the Dictionary argument to , the method must throw a . The client of the Component Factory service can also deactivate a component configuration with the dispose() method on the ComponentInstance object. If the component configuration is already deactivated, or is being deactivated, then this method is ignored. Also, if the component configuration becomes unsatisfied for any reason, it must be deactivated by SCR. Once a component configuration created by the Component Factory has been deactivated, that component configuration will not be reactivated or used again. Activating a component configuration consists of the following steps:\n• Set the activation fields, if any. See Activation Objects.\n• Call the method, if any. See Activate Method. Calling the method signals the completion of activating the component instance. Component instances must never be reused. Each time a component configuration is activated, SCR must create a new component instance to use with the activated component configuration. A component instance must complete activation before it can be deactivated. Once the component configuration is deactivated or fails to activate due to an exception, SCR must unbind all the component's bound services and discard all references to the component instance associated with the activation. When a component configuration's reference is satisfied, there is a set of zero or more target services for that reference. When the component configuration is activated, a subset of the target services for each reference are bound to the component configuration. The subset is chosen by the cardinality of the reference. See Reference Cardinality. Obtaining the service object for a bound service may result in activating a component configuration of the bound service which could result in an exception. If the loss of the bound service due to the exception causes the reference's cardinality constraint to be violated, then activation of this component configuration will fail. Otherwise the bound service which failed to activate will be considered unbound. The Component Context can be made available to a component instance during activation, modification, and deactivation. It provides the interface to the execution context of the component, much like the Bundle Context provides a bundle the interface to the Framework. A Component Context should therefore be regarded as a capability and not shared with other components or bundles. Each distinct component instance receives a unique Component Context. Component Contexts are not reused and must be discarded when the component configuration is deactivated. A component can have an method, activation fields, and also receive activation objects via its constructor. The following activation object types are supported:\n• - The Component Context for the component configuration.\n• - The Bundle Context of the component's bundle.\n• - An unmodifiable Map containing the component properties.\n• A component property type - An instance of the component property type which allows type safe access to component properties defined by the component property type. See Component Property Types. For activation fields, only instance fields of the activation object types above are supported. If an activation field is declared with the modifier or has a type other than one of the above, SCR must log an error message with the Log Service, if present, and the field must not be modified. SCR must locate a suitable field as specified in Locating Component Methods and Fields. If no suitable field is located for an activation field name, SCR must log an error message with the Log Service, if present. When binding services, the references are processed in the order in which they are specified in the component description. That is, target services from the first specified reference are bound before services from the next specified reference. If the reference uses field injection, the field must be set. Then, if the reference uses method injection, the bind method must be called for each bound service of that reference. If a bind method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, but the activation of the component configuration does not fail. A component can have an method. The name of the method can be specified by the attribute. If the attribute is not specified, the default method name of is used. See Component Element. The activate method can take zero or more parameters. Each parameter must be assignable from one of the activation object types. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. When searching for the activate method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the component configuration is not activated. If an activate method is located, SCR must call this method to complete the activation of the component configuration. If the activate method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the component configuration is not activated. If an active component configuration has a dynamic reference with unary cardinality and the bound service is modified or unregistered and ceases to be a target service, or the is and a better target service becomes available then SCR must attempt to replace the bound service with a new bound service. If the reference uses field injection, the field must be set for the replacement bound service. Then, if the reference uses method injection, SCR must first bind the new bound service and then unbind the outgoing service. This reversed order allows the component to not have to handle the inevitable gap between the unbind and bind methods. However, this means that in the unbind method care must be taken to not overwrite the newly bound service. For example, the following code handles the associated concurrency issues and simplify handling the reverse order. If the dynamic reference falls below the minimum cardinality, the component configuration must be deactivated because the cardinality constraints will be violated. If a component configuration has a static reference and a bound service is modified or unregistered and ceases to be a target service, or the is and a better target service becomes available then SCR must deactivate the component configuration. Afterwards, SCR must attempt to activate the component configuration again if another target service can be used as a replacement for the outgoing service. If an active component is bound to a service that modifies its service properties then the component can be updated. If the reference uses field injection and the field holds the service properties, the field must be set for the updated bound service. Then, if the reference uses method injection and specifies an updated method, the updated method must be called. Modifying a component configuration can occur if the component description specifies the attribute and the component properties of the component configuration use a object from the Configuration Admin service and that object is modified without causing the component configuration to become unsatisfied. If this occurs, the component instance will be notified of the change in the component properties. If the attribute is not specified, then the component configuration will become unsatisfied if its component properties use a object and that Configuration object is modified in any way. Modifying a component configuration consists of the following steps:\n• Update the component context for the component configuration with the modified configuration properties.\n• Modify the bound services for the dynamic references if the set of target services changed due to changes in the target properties. See Bound Service Replacement.\n• If the component configuration is registered as a service, modify the service properties. A component instance must complete activation, or a previous modification, before it can be modified. See Configuration Changes for more information. The name of the modified method is specified by the attribute. See Component Element. The modified method can take zero or more parameters. Each parameter must be assignable from one of the activation object types. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types. If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the component configuration becomes unsatisfied and is deactivated as if the attribute was not specified. If a modified method is located, SCR must call this method to notify the component configuration of changes to the component properties. If the modified method throws an exception, SCR must log an error message containing the exception with the Log Service, if present and continue processing the modification. Deactivating a component configuration consists of the following steps:\n• Call the deactivate method, if present. See Deactivate Method.\n• Release all references to the component instance and component context. A component instance must complete activation or modification before it can be deactivated. A component configuration can be deactivated for a variety of reasons. The deactivation reason can be received by the deactivate method. The following reason values are defined: Once the component configuration is deactivated, SCR must discard all references to the component instance and component context associated with the activation. A component instance can have a deactivate method. The name of the deactivate method can be specified by the attribute. See Component Element. If the attribute is not specified, the default method name of is used. Activation fields must not be modified during deactivation. The deactivate method can take zero or more parameters. Each parameter must be assignable from one of the following types:\n• One of the activation object types.\n• or - The reason the component configuration is being deactivated. See Deactivation. A suitable method is selected using the following priority:\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is a component property type.\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes a single parameter and the type of the parameter is .\n• The method takes two or more parameters and the type of each parameter must be one of the activation object types, or . If multiple methods match this rule, this implies the method name is overloaded and SCR may choose any of the methods to call. When searching for the deactivate method to call, SCR must locate a suitable method as specified in Locating Component Methods and Fields. If the attribute is specified and no suitable method is located, SCR must log an error message with the Log Service, if present, and the deactivation of the component configuration will continue. If a deactivate method is located, SCR must call this method to commence the deactivation of the component configuration. If the deactivate method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the deactivation of the component configuration will continue. When a component configuration is deactivated, the bound services are unbound from the component configuration. When unbinding services, the references are processed in the reverse order in which they are specified in the component description. That is, target services from the last specified reference are unbound before services from the previous specified reference. If the reference uses method injection, the unbind method must be called for each bound service of that reference. If an unbind method throws an exception, SCR must log an error message containing the exception with the Log Service, if present, and the deactivation of the component configuration will continue. Then, if the reference uses field injection, the field must be set to . A component could declare a dependency on the Http Service to register some resources. The component implementation code looks like: This example is depicted in a sequence diagram in Figure 112.5 with the following scenario:\n• A bundle with the component is started. At that time there is a Log Service and a Http Service registered. \n\n\n\nA number of retention annotations have been provided to allow tools to construct the component description XML from the Java class files. The Component Annotations are intended to be used during build time to generate the component description XML. Component Property Types, which are user defined annotations, can be used to describe component properties in the component description XML and to access those component properties at runtime in a type safe manner. The Component Annotations provide a convenient way to create the component description XML during build time. Since annotations are placed in the source file and can use types, fields, and methods, they can significantly simplify the use of Declarative Services. The Component Annotations are build time annotations because one of the key aspects of Declarative Services is its laziness. SCR can easily read the component description XML from the bundle, preprocess it, and cache the results between framework invocations. This way it is unnecessary to load a class from the bundle when the bundle is started and/or scan the classes for annotations. Component Annotations are not recognized by SCR at runtime. The Component Annotations are not inherited, they can only be used on a given class, annotations on its super class hierarchy or interfaces are not taken into account. The primary annotation is the Component annotation. It indicates that a class is a component. Its defaults create the easiest to use component:\n• Its name is the class name\n• It registers all of the class's directly implemented interfaces as services\n• The instance will be shared by all bundles\n• It is immediate if it has no services, otherwise it is delayed\n• It has an optional configuration policy\n• The configuration PID is the class name For example, the following class registers a Speech service that can run on a Macintosh: The previous example would be processed at build time into a component description similar to the following XML: It is possible to add activate and deactivate methods on the component with the Activate and Deactivate annotations. If the component wants to be updated for changes in the configuration properties than it can also indicated the modified method with the Modified annotation. For example: The Activate annotation can also be used on a field or a constructor. When used on a field, the field will be set during activation of the component. When used on a constructor, the constructor will be used to construct the component instances. If a component has dependencies on other services then they can be referenced with the Reference annotation that can be applied to a bind method, a field, or a constructor parameter. For a bind method, the defaults for the Reference annotation are:\n• The name of the bind method or field is used for the name of the reference.\n• The requested service is the type of the first parameter of the bind method.\n• It will infer a default unset method and updated method based on the name of the bind method. For a field, the defaults for the Reference annotation are:\n• The name of the bind method or field is used for the name of the reference.\n• 1:1 cardinality if the field is not a collection. 0..n cardinality if the field is a collection.\n• Static reluctant policy if the field is not declared volatile. Dynamic reluctant policy if the field is declared volatile.\n• The requested service is the type of the field. For a constructor parameter, the defaults for the Reference annotation are:\n• The name of the parameter is used for the name of the reference.\n• 1:1 cardinality if the field is not a collection. 0..n cardinality if the field is a collection.\n• The requested service is the type of the field. Component properties can be defined and accessed through a user defined annotation type, called a component property type, containing the property names, property types and default values. A component property type allows properties to be defined and accessed in a type safe manner. Component property types can themselves be annotated with the ComponentPropertyType meta-annotation. The following example shows the definition of a component property type called which defines three properties where the name of the property is the name of the method, the type of the property is the return type of the method and the default value for the property is the default value of the method. Component property types can be used in two ways:\n• Component property types can be used to annotate the component implementation class, along side the Component annotation. The annotation usage can specify property values which can be different than the default values declared in the component property type. To be used in this way, the component property type must be annotated with the ComponentPropertyType meta-annotation so that, at build time, the annotation is recognized as a component property type.\n• Component property types can be used as parameter types in the component's constructor and life cycle methods, or as field types for activation fields. The component implementation can use objects of a component property type at runtime to access component property values in a type safe manner. To be used in this way, it is recommended the component property type be annotated with the ComponentPropertyType meta-annotation but it is not required. Both ways define property names, types and values for the component. The following example shows the component implementation annotated with the example component property type which specifies a property value for the component which is different than the default value. The example also shows the activate method taking the example component property type as a parameter type and the method implementation accesses component property values by invoking methods on the component property type object. @Component @Config(names=\"myapp\") public class MyComponent { @Activate void activate(Config config) { if (config.enabled()) { // do something } for (String name:config.names()) { // do something with each name } } } If a component implementation needs to access component properties which are not represented by a component property type, it can use a type of Map to receive the properties map in addition to component property types. For example: @Component public class MyComponent { @Activate void activate(Config config, Map<String, ?> allProperties) { if (config.enabled()) { // do something } if (allProperties.get(\"other.prop\") != null) { // do something } } } Component property types must be defined as annotation types. This is done for several reasons. First, the limitations on annotation type definitions make them well suited for component property types. The methods must have no parameters and the return types supported are limited to a set which is well suited for component properties. Second, annotation types support default values which is useful for defining the default value of a component property. Finally, as annotations, they can be used to annotate component implementation classes. At build time, the component property types must be processed to potentially generate elements in the component description. See Ordering of Generated Component Properties. At runtime, when SCR needs to provide a component instance an activation object whose type is a component property type, SCR must construct an instance of the component property type whose methods are backed by the values of the component properties for the component instance. This object can then be used to obtain the property values in a type safe manner. Each method of a configuration property type is mapped to a component property. The property name is derived from the method name. Certain common property name characters, such as full stop ( ) and hyphen-minus ( ) are not valid in Java identifiers. So the name of a method must be converted to its corresponding property name as follows:\n• A single dollar sign ( ) is removed unless it is followed by:\n• A low line ( ) and a dollar sign in which case the three consecutive characters ( ) are converted to a single hyphen-minus ( ).\n• Another dollar sign in which case the two consecutive dollar signs ( ) are converted to a single dollar sign.\n• A single low line ( ) is converted into a full stop ( ) unless is it followed by another low line in which case the two consecutive low lines ( ) are converted to a single low line.\n• All other characters are unchanged.\n• If the component property type declares a field whose value is a compile-time constant String, then the property name is prefixed with the value of the field. Table 112.11 contains some name mapping examples. \n\n However, if the component property type is a single-element annotation, see 9.7.3 in [7] The Java Language Specification, Java SE 8 Edition, then the property name for the method is derived from the name of the component property type rather than the name of the method. In this case, the simple name of the component property type, that is, the name of the class without any package name or outer class name, if the component property type is an inner class, must be converted to the property name as follows:\n• When a lower case character is followed by an upper case character, a full stop ( ) is inserted between them.\n• Each upper case character is converted to lower case.\n• All other characters are unchanged.\n• If the component property type declares a field whose value is a compile-time constant String, then the property name is prefixed with the value of the field. Table 112.12 contains some mapping examples for the method. \n\n If the component property type is a marker annotation, see 9.7.2 in [7] The Java Language Specification, Java SE 8 Edition, then the property name is derived from the name of the component property type, as is described above for single-element annotations, and the value of the property is . Marker annotations can be used to annotate component implementation classes to set a component property to the value . However, since marker annotations have no methods, they are of no use as parameter types in the component's constructor and life cycle methods, or as field types for activation fields. The property type can be directly derived from the type of the method. All types supported for annotation elements can be used except for annotation types. Method types of an annotation type or array thereof are not supported. A tool processing the component property types must ignore such methods. If the method type is or , then the property type must be or , respectively, whose values are fully qualified class names in the form returned by the method. If the method type is an enumeration type or an array thereof, then the property type must be or , respectively, whose values are the names of the enum constants in the form returned by the method. When a component property type is used as an activation object type, SCR must create an object that implements the component property type and maps the methods of the component property type to component properties. The name of the method is converted to the property name as described in Component Property Mapping. The property value may need to be coerced to the type of the method. In Table 112.13, the columns are source types, that is, the type of the component property value, and the rows are target types, that is, the method types. The property value is v; number is a primitive numerical type and Number is a wrapper numerical type. An invalid coercion is represented by . Such a coercion attempt must result in throwing a Component Exception when the component property type method is called. Any other coercion error, such as parsing a non-numerical string to a number or the inability to coerce a string into a Class or enum object, must be wrapped in a Component Exception and thrown when the component property type method is called. Table 112.13 Coercion From Property Value to Method Type If has no elements, ; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. If has no elements, 0; otherwise the first element of is coerced. If has no elements, 0; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. If has no elements, ; otherwise the first element of is coerced. A single element array is created and is coerced into the single element of the new array. An array the size of is created and each element of is coerced into the corresponding element of the new array. \n\n Component properties whose names do not map to component property type methods are ignored. If there is no corresponding component property for a component property type method, the component property type method must: Component property types for standard service properties are specified in the org.osgi.service.component.propertytypes package. The ServiceDescription component property type can be used to add the service property to a component. The ServiceRanking component property type can be used to add the service property to a component. The ServiceVendor component property type can be used to add the service property to a component. For example, using these component property types as annotations: will result in the following component properties: The ExportedService component property type can be used to specify service properties for remote services. The Component annotation contains two ways to define component properties via the property and properties elements. See Property and Properties Elements. If Component Annotations are used to describe the component, then any component property types used as the type of an activation object or used to annotate the component implementation class must also be processed since component property types can be used to define component property values as well. See Component Property Types. A tool processing the Component Annotations and the component property types must write the defined component properties into the generated component description in the following order.\n• Properties defined through component property types used as the type of an activation object. If any of the referenced component property types have methods with defaults, then the generated component description must include a element for each such method with the property name mapped from the method name, the property type mapped from the method type, and the property value set to the method's default value. See Component Property Mapping. The generated elements must be added to the component description by processing the component property types used as the type of an activation object in the following order:\n• The component property types used as parameters to the constructor.\n• The component property types used as activation fields. The fields are processed in lexicographical order, using , of the field names.\n• The component property types used as parameters to the activate method.\n• The component property types used as parameters to the modified method.\n• The component property types used as parameters to the deactivate method. If a method has more than one component property type parameter, the component property types are processed in the order of the method parameters. For component property type methods without a default value or with a default value of an empty array, a element must not be generated.\n• The generated component description must include a element for each such method with the property name mapped from the method name, the property type mapped from the method type, and the property value set to the method's value. See Component Property Mapping. The generated elements must be added to the component description by processing the component property types annotating the component implementation class in the order that the annotations appear in the component implementation's class file. However, the order of the and attributes in the class file is unspecified by [6] The Java Virtual Machine Specification, Java SE 8 Edition so care must be taken when using component property types of different that have method names in common. For component property type methods with a value of an empty array, a element must not be generated. This means that the properties defined through component property types are declared first in the generated component description, followed by all properties defined through the property element of the Component annotation and finally the properties entries defined through the properties element of the Component annotation. Since property values defined later in the component description override property values defined earlier in the component description, this means that property values defined in properties element of the Component annotation can override property values defined in property element of the Component annotation which can override values defined by values in the component property types.\n\nThis package is not used at runtime. Annotated classes are processed by tools to generate Component Descriptions which are used at runtime.\n• - Identify the annotated member as part of the activation of a Service Component.\n• - Identify the annotated method as the method of a Service Component.\n• - Identify the annotated method as the method of a Service Component.\n• - Identify the annotated member or parameter as a reference of a Service Component.\n• - This annotation can be used to require the Service Component Runtime to process Declarative Services components. Identify the annotated member as part of the activation of a Service Component. When this annotation is applied to a:\n• Method - The method is the method of the Component.\n• Constructor - The constructor will be used to construct the Component and can be called with activation objects and bound services as parameters.\n• Field - The field will contain an activation object of the Component. The field must be set after the constructor is called and before calling any other method on the fully constructed component instance. That is, there is a happens-before relationship between the field being set and calling any method on the fully constructed component instance such as the method. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The init, activate, and activation-fields attributes of the component element of a Component Description. The service collection type is used to indicate the collection holds the bound service objects. This is the default collection type. The reference collection type is used to indicate the collection holds Service References for the bound services. The serviceobjects collection type is used to indicate the collection holds Component Service Objects for the bound services. The properties collection type is used to indicate the collection holds unmodifiable Maps containing the service properties of the bound services. The Maps must implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. The tuple collection type is used to indicate the collection holds unmodifiable Map.Entries whose key is an unmodifiable Map containing the service properties of the bound service, as specified in PROPERTIES, and whose value is the bound service object. The Map.Entries must implement with the method comparing service property maps using the same ordering as based upon service ranking and service id. The annotated class is the implementation class of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The name of this Component. If not specified, the name of this Component is the fully qualified type name of the class being annotated. The name attribute of the component element of a Component Description. The types under which to register this Component as a service. If no service should be registered, the empty value must be specified. If not specified, the service types for this Component are all the directly implemented interfaces of the class being annotated. The factory identifier of this Component. Specifying a factory identifier makes this Component a Factory Component. If not specified, the default is that this Component is not a Factory Component. The factory attribute of the component element of a Component Description. Declares whether this Component uses the OSGi ServiceFactory concept and each bundle using this Component's service will receive a different component instance. This element is ignored when the scope() element does not have the default value. If , this Component uses bundle service scope. If or not specified, this Component uses singleton service scope. If the factory() element is specified or the immediate() element is specified with , this element can only be specified with . The scope attribute of the service element of a Component Description. Declares whether this Component is enabled when the bundle declaring it is started. If or not specified, this Component is enabled. If , this Component is disabled. The enabled attribute of the component element of a Component Description. Declares whether this Component must be immediately activated upon becoming satisfied or whether activation should be delayed. If , this Component must be immediately activated upon becoming satisfied. If , activation of this Component is delayed. If this property is specified, its value must be if the factory() property is also specified or must be if the service() property is specified with an empty value. If not specified, the default is if the factory() property is specified or the service() property is not specified or specified with a non-empty value and otherwise. The immediate attribute of the component element of a Component Description. Each property string is specified as . The type of the property value can be specified in the name as . The type must be one of the property types supported by the attribute of the element of a Component Description. To specify a property with multiple values, use multiple name, value pairs. For example, . Specifies the name of an entry in the bundle whose contents conform to a standard Java Properties File. The entry is read and processed to obtain the properties and their values. The XML name space of the Component Description for this Component. If not specified, the XML name space of the Component Description for this Component should be the lowest Declarative Services XML name space which supports all the specification features used by this Component. The XML name space specified for a Component Description. The configuration policy of this Component. Controls whether component configurations must be satisfied depending on the presence of a corresponding Configuration object in the OSGi Configuration Admin service. A corresponding configuration is a Configuration object where the PID equals the name of the component. If not specified, the configuration policy is based upon whether the component is also annotated with the Meta Type Designate annotation.\n• Not annotated with - The configuration policy is OPTIONAL.\n• Annotated with - The configuration policy is OPTIONAL.\n• Annotated with - The configuration policy is REQUIRE. The configuration-policy attribute of the component element of a Component Description. The configuration PIDs for the configuration of this Component. Each value specifies a configuration PID for this Component. If no value is specified, the name of this Component is used as the configuration PID of this Component. A special string ( ) can be used to specify the name of the component as a configuration PID. The NAME constant holds this special string. For example: Tools creating a Component Description from this annotation must replace the special string with the actual name of this Component. The configuration-pid attribute of the component element of a Component Description. The service scope for the service of this Component. If not specified (and the deprecated servicefactory() element is not specified), the singleton service scope is used. If the factory() element is specified or the immediate() element is specified with , this element can only be specified with the singleton service scope. The scope attribute of the service element of a Component Description. The lookup strategy references of this Component. To access references using the lookup strategy, Reference annotations are specified naming the reference and declaring the type of the referenced service. The referenced service can be accessed using one of the methods of . To access references using method injection, bind methods are annotated with Reference. To access references using field injection, fields are annotated with Reference. To access references using constructor injection, constructor parameters are annotated with Reference. Each factory property string is specified as . The type of the factory property value can be specified in the name as . The type must be one of the factory property types supported by the attribute of the element of a Component Description. To specify a factory property with multiple values, use multiple name, value pairs. For example, . If specified, the factory() element must also be specified to indicate the component is a Factory Component. Specifies the name of an entry in the bundle whose contents conform to a standard Java Properties File. The entry is read and processed to obtain the factory properties and their values. If specified, the factory() element must also be specified to indicate the component is a Factory Component. Special string representing the name of this Component. This string can be used in configurationPid() to specify the name of the component as a configuration PID. For example: Tools creating a Component Description from this annotation must replace the special string with the actual name of this Component. Component Property Types can be applied as annotations to the implementation class of the Component. They can also be used as activation objects which means they can be used as parameter types for the component's constructor and life cycle methods Activate, Deactivate, and Modified as well as activation fields. Component Property Types do not have to be annotated with this annotation to be used as parameter types but they must be annotated with this annotation to be used as annotations on the implementation class of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. Controls whether component configurations must be satisfied depending on the presence of a corresponding Configuration object in the OSGi Configuration Admin service. A corresponding configuration is a Configuration object where the PID is the name of the component. Use the corresponding Configuration object if present but allow the component to be satisfied even if the corresponding Configuration object is not present. There must be a corresponding Configuration object for the component configuration to become satisfied. Always allow the component configuration to be satisfied and do not use the corresponding Configuration object even if it is present. Identify the annotated method as the method of a Service Component. The annotated method is the deactivate method of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The deactivate attribute of the component element of a Component Description. The update field option is used to update the collection referenced by the field when there are changes to the bound services. This field option can only be used when the field reference has dynamic policy and multiple cardinality. The replace field option is used to replace the field value with a new value when there are changes to the bound services. Identify the annotated method as the method of a Service Component. The annotated method is the modified method of the Component. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. The modified attribute of the component element of a Component Description. Identify the annotated member or parameter as a reference of a Service Component. When the annotation is applied to a method, the method is the bind method of the reference. When the annotation is applied to a field, the field will contain the bound service(s) of the reference. When the annotation is applied to a parameter of a constructor, the parameter will contain the bound service(s) of the reference. This annotation is not processed at runtime by Service Component Runtime. It must be processed by tools and used to add a Component Description to the bundle. In the generated Component Description for a component, the references must be ordered in ascending lexicographical order (using ) of the reference names. The name of this reference. The name of this reference must be specified when using this annotation in the Component.reference() element since there is no annotated member from which the name can be determined. If not specified, the name of this reference is based upon how this annotation is used:\n• Annotated method - If the method name begins with , or , that prefix is removed to create the name of the reference. Otherwise, the name of the reference is the method name.\n• Annotated field - The name of the reference is the field name.\n• Annotated constructor parameter - The name of the reference is the parameter name. The name attribute of the reference element of a Component Description. The type of the service for this reference. The type of the service for this reference must be specified when using this annotation in the Component.reference() element since there is no annotated member from which the type of the service can be determined. If not specified, the type of the service for this reference is based upon how this annotation is used:\n• Annotated method - The type of the service is the type of the first parameter of the method.\n• Annotated field - The type of the service is based upon the type of the field being annotated and the cardinality of the reference. If the cardinality is either 0..n, or 1..n, the type of the field must be one of , , or a subtype of so the type of the service is the generic type of the collection. Otherwise, the type of the service is the type of the field.\n• Annotated constructor parameter - The type of the service is based upon the type of the parameter being annotated and the cardinality of the reference. If the cardinality is either 0..n, or 1..n, the type of the parameter must be one of , , or a subtype of so the type of the service is the generic type of the collection. Otherwise, the type of the service is the type of the parameter. The interface attribute of the reference element of a Component Description. The cardinality of this reference. If not specified, the cardinality of this reference is based upon how this annotation is used:\n• Annotated field - The cardinality is based on the type of the field. If the type is either , , or a subtype of , the cardinality is 0..n. Otherwise the cardinality is 1..1.\n• Annotated constructor parameter - The cardinality is based on the type of the parameter. If the type is either , , or a subtype of , the cardinality is 0..n. Otherwise the cardinality is 1..1. The cardinality attribute of the reference element of a Component Description. The policy for this reference. If not specified, the policy of this reference is based upon how this annotation is used:\n• Annotated field - The policy is based on the modifiers of the field. If the field is declared , the policy is ReferencePolicy.DYNAMIC. Otherwise the policy is STATIC.\n• Annotated constructor parameter - The policy is STATIC. STATIC policy must be used for constructor parameters. The policy attribute of the reference element of a Component Description. The target property for this reference. If not specified, no target property is set. The target attribute of the reference element of a Component Description. The policy option for this reference. If not specified, the RELUCTANT reference policy option is used. The policy-option attribute of the reference element of a Component Description. The reference scope for this reference. If not specified, the bundle reference scope is used. The scope attribute of the reference element of a Component Description. The name of the bind method for this reference. If specified and this reference annotates a method, the specified name must match the name of the annotated method. If not specified, the name of the bind method is based upon how this annotation is used:\n• Annotated method - The name of the annotated method is the name of the bind method.\n• Annotated field - There is no bind method name.\n• Annotated constructor parameter - There is no bind method name.\n• Component.reference() element - There is no bind method name. If there is a bind method name, the component must contain a method with that name. The bind attribute of the reference element of a Component Description. The name of the updated method for this reference. If not specified, the name of the updated method is based upon how this annotation is used:\n• Annotated method - The name of the updated method is created from the name of the annotated method. If the name of the annotated method begins with , or , that prefix is replaced with to create the name candidate for the updated method. Otherwise, is prefixed to the name of the annotated method to create the name candidate for the updated method. If the component type contains a method with the candidate name, the candidate name is used as the name of the updated method. To declare no updated method when the component type contains a method with the candidate name, the value must be used.\n• Annotated field - There is no updated method name.\n• Annotated constructor parameter - There is no updated method name.\n• Component.reference() element - There is no updated method name. If there is an updated method name, the component must contain a method with that name. The updated attribute of the reference element of a Component Description. The name of the unbind method for this reference. If not specified, the name of the unbind method is based upon how this annotation is used:\n• Annotated method - The name of the unbind method is created from the name of the annotated method. If the name of the annotated method begins with , or , that prefix is replaced with , or , respectively, to create the name candidate for the unbind method. Otherwise, is prefixed to the name of the annotated method to create the name candidate for the unbind method. If the component type contains a method with the candidate name, the candidate name is used as the name of the unbind method. To declare no unbind method when the component type contains a method with the candidate name, the value must be used.\n• Annotated field - There is no unbind method name.\n• Annotated constructor parameter - There is no unbind method name.\n• Component.reference() element - There is no unbind method name. If there is an unbind method name, the component must contain a method with that name. The unbind attribute of the reference element of a Component Description. The name of the field for this reference. If specified and this reference annotates a field, the specified name must match the name of the annotated field. If not specified, the name of the field is based upon how this annotation is used:\n• Annotated method - There is no field name.\n• Annotated field - The name of the annotated field is the name of the field.\n• Annotated constructor parameter - There is no field name.\n• Component.reference() element - There is no field name. If there is a field name, the component must contain a field with that name. The field attribute of the reference element of a Component Description. The field option for this reference. If not specified, the field option is based upon how this annotation is used:\n• Annotated method - There is no field option.\n• Annotated field - The field option is based upon the policy and cardinality of the reference and the modifiers of the field. If the policy is ReferencePolicy.DYNAMIC, the cardinality is 0..n or 1..n, and the field is declared , the field option is FieldOption.UPDATE. Otherwise, the field option is FieldOption.REPLACE.\n• Annotated constructor parameter - There is no field option.\n• Component.reference() element - There is no field option. The field-option attribute of the reference element of a Component Description. The zero-based parameter number of the constructor parameter for this reference. If specified and this reference annotates an constructor parameter, the specified value must match the zero-based parameter number of the annotated constructor parameter. If not specified, the parameter number is based upon how this annotation is used:\n• Annotated method - There is no parameter number.\n• Annotated field - There is no parameter number.\n• Annotated constructor parameter - The zero-based parameter number of the parameter.\n• Component.reference() element - There is no parameter number. If there is a parameter number, the component must declare a constructor that has a parameter having the zero-based parameter number. The parameter attribute of the reference element of a Component Description. , The init attribute of the component element of a Component Description. The collection type for this reference. If not specified, the collection type is based upon how this annotation is used:\n• Annotated method - There is no collection type.\n• Annotated field - The collection type is based upon the cardinality of the reference and the generic type of the field. If the cardinality is 0..n or 1..n, the collection type is inferred from the generic type of the list or collection. Otherwise, there is no collection type\n• Annotated constructor method parameter - The collection type is based upon the cardinality of the reference and the generic type of the parameter. If the cardinality is 0..n or 1..n, the collection type is inferred from the generic type of the list or collection. Otherwise, there is no collection type\n• Component.reference() element - There is no collection type. The field-collection-type attribute of the reference element of a Component Description. Specifies if the reference is optional and if the component implementation support a single bound service or multiple bound services. The reference is optional and unary. That is, the reference has a cardinality of . The reference is mandatory and unary. That is, the reference has a cardinality of . The reference is optional and multiple. That is, the reference has a cardinality of . The reference is mandatory and multiple. That is, the reference has a cardinality of . The static policy is the most simple policy and is the default policy. A component instance never sees any of the dynamics. Component configurations are deactivated before any bound service for a reference having a static policy becomes unavailable. If a target service is available to replace the bound service which became unavailable, the component configuration must be reactivated and bound to the replacement service. The dynamic policy is slightly more complex since the component implementation must properly handle changes in the set of bound services. With the dynamic policy, SCR can change the set of bound services without deactivating a component configuration. If the component uses method injection to access services, then the component instance will be notified of changes in the set of bound services by calls to the bind and unbind methods. The reluctant policy option is the default policy option for both static and dynamic reference policies. When a new target service for a reference becomes available, references having the reluctant policy option for the static policy or the dynamic policy with a unary cardinality will ignore the new target service. References having the dynamic policy with a multiple cardinality will bind the new target service. The greedy policy option is a valid policy option for both static and dynamic reference policies. When a new target service for a reference becomes available, references having the greedy policy option will bind the new target service. A single service object is used for all references to the service in this bundle. If the bound service has prototype service scope, then each instance of the component with this reference can receive a unique instance of the service. If the bound service does not have prototype service scope, then this reference scope behaves the same as BUNDLE. Bound services must have prototype service scope. Each instance of the component with this reference can receive a unique instance of the service. This annotation can be used to require the Service Component Runtime to process Declarative Services components. It can be used directly, or as a meta-annotation. When the component is registered as a service, it must be registered as a bundle scope service but only a single instance of the component must be used for all bundles using the service. When the component is registered as a service, it must be registered as a bundle scope service and an instance of the component must be created for each bundle using the service. When the component is registered as a service, it must be registered as a prototype scope service and an instance of the component must be created for each distinct request for the service. Default element value for annotation. This is used to distinguish the default value for an element and should not otherwise be used.\n\nBundles wishing to use this package must list the package in the Import-Package header of the bundle's manifest. This package has two types of users: the consumers that use the API in this package and the providers that implement the API in this package. Example import for consumers using the API in this package: Example import for providers implementing the API in this package:\n• - A representation of an actual instance of a declared component description parameterized by component properties. A representation of an actual instance of a declared component description parameterized by component properties. This is the normal operational state of a component configuration. The representation of the component configuration's component description. This means the component configuration is satisfied but that either:\n• the constructor threw an exception, or The failure information from the exception is available from failure. The failure information if the component configuration state is FAILED_ACTIVATION. This is the failure exception converted to a String using: This must be if the component configuration state is not FAILED_ACTIVATION. The id of the component configuration. The id is a non-persistent, unique value assigned at runtime. The id is also available as the component property. The value of this field is unspecified if the state of this component configuration is unsatisfied. The component properties for the component configuration. Any services declared by the component description are registered. Each SatisfiedReferenceDTO in the array represents a satisfied reference of the component configuration. The array must be empty if the component configuration has no satisfied references. The registered service of the component configuration. This must be non- if the component configuration is registered as a service. Otherwise it must be . The current state of the component configuration. This is one of UNSATISFIED_CONFIGURATION, UNSATISFIED_REFERENCE, SATISFIED, ACTIVE, or FAILED_ACTIVATION. The component configuration is unsatisfied due to a missing required configuration. The component configuration is unsatisfied due to an unsatisfied reference. Each UnsatisfiedReferenceDTO in the array represents an unsatisfied reference of the component configuration. The array must be empty if the component configuration has no unsatisfied references. The name of the activate method. This is declared in the attribute of the element. This must be if the component description does not declare an activate method name. These are declared in the attribute of the element. The array must be empty if the component description does not declare any activation fields. These are declared in the attribute of the element. This must contain the default configuration pid if the component description does not declare a configuration pid. This is declared in the attribute of the element. This must be the default configuration policy if the component description does not declare a configuration policy. The name of the deactivate method. This is declared in the attribute of the element. This must be if the component description does not declare a deactivate method name. This is declared in the attribute of the element. This is declared in the attribute of the element. This must be if the component description is not declared as a factory component. These are declared in the component description by the and elements. This must be if the component description is not declared as a factory component. This is declared in the attribute of the element. The fully qualified name of the implementation class. This is declared in the attribute of the element. This is declared in the attribute of the element. This must be if the component description does not declare an attribute. The name of the modified method. This is declared in the attribute of the element. This must be if the component description does not declare a modified method name. The name of the component. This is declared in the attribute of the element. This must be the default name if the component description does not declare a name. These are declared in the component description by the and elements as well as the attribute of the elements. These are declared in the elements. The array must be empty if the component description does not declare references to any services. This is declared in the attribute of the element. This must be if the component description does not declare any service interfaces. The fully qualified names of the service interfaces. These are declared in the attribute of the elements. The array must be empty if the component description does not declare any service interfaces. The name of the bind method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a bind method for the reference. The cardinality of the reference. This is declared in the attribute of the element. This must be the default cardinality if the component description does not declare a cardinality for the reference. The collection type for the reference. This is declared in the attribute of the element. This must be if the component description does not declare a collection type for the reference. The name of the field of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a field for the reference. The field option of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a field for the reference. The service interface of the reference. This is declared in the attribute of the element. The name of the reference. This is declared in the attribute of the element. This must be the default name if the component description does not declare a name for the reference. The zero-based parameter number of the constructor parameter for the reference. This is declared in the attribute of the element. This must be if the component description does not declare a parameter number for the reference. The policy of the reference. This is declared in the attribute of the element. This must be the default policy if the component description does not declare a policy for the reference. The policy option of the reference. This is declared in the attribute of the element. This must be the default policy option if the component description does not declare a policy option for the reference. The scope of the reference. This is declared in the attribute of the element. This must be the default scope if the component description does not declare a scope for the reference. The target of the reference. This is declared in the attribute of the element. This must be if the component description does not declare a target for the reference. The name of the unbind method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare an unbind method for the reference. The name of the updated method of the reference. This is declared in the attribute of the element. This must be if the component description does not declare an updated method for the reference. Each ServiceReferenceDTO in the array represents a service bound to the satisfied reference. The array must be empty if there are no bound services. The name of the declared reference. This is declared in the attribute of the element of the component description. The target property of the satisfied reference. This is the value of the component property whose name is the concatenation of the declared reference name and \".target\". This must be if no target property is set for the reference. The name of the declared reference. This is declared in the attribute of the element of the component description. The target property of the unsatisfied reference. This is the value of the component property whose name is the concatenation of the declared reference name and \".target\". This must be if no target property is set for the reference. Each ServiceReferenceDTO in the array represents a target service for the reference. The array must be empty if there are no target services. The upper bound on the number of target services in the array is the upper bound on the cardinality of the reference."
    },
    {
        "link": "https://docs.redhat.com/en/documentation/red_hat_fuse/7.0/html/deploying_into_apache_karaf/deploysimple",
        "document": "The Blueprint container is a dependency injection framework that simplifies interaction with the OSGi container. The Blueprint container supports a configuration-based approach to using the OSGi service registry—for example, providing standard XML elements to import and export OSGi services. Relative to the root of the bundle JAR file, the standard location for Blueprint configuration files is the following directory: Any files with the suffix, , under this directory are interpreted as Blueprint configuration files; in other words, any files that match the pattern, . In the context of a Maven project, ProjectDir, the standard location for Blueprint configuration files is the following directory: Blueprint configuration elements are associated with the following XML namespace: The root element for Blueprint configuration is , so a Blueprint XML configuration file normally has the following outline form: In the root element, there is no need to specify the location of the Blueprint schema using an attribute, because the schema location is already known to the Blueprint framework. Some aspects of Blueprint configuration are controlled by headers in the JAR’s manifest file, , as follows: If you need to place your Blueprint configuration files in a non-standard location (that is, somewhere other than ), you can specify a comma-separated list of alternative locations in the header in the manifest file—for example: Dependencies on an OSGi service are mandatory by default (although this can be changed by setting the attribute to on a element or a element). Declaring a dependency to be mandatory means that the bundle cannot function properly without that dependency and the dependency must be available at all times. Normally, while a Blueprint container is initializing, it passes through a grace period, during which time it attempts to resolve all mandatory dependencies. If the mandatory dependencies cannot be resolved in this time (the default timeout is 5 minutes), container initialization is aborted and the bundle is not started. The following settings can be appended to the manifest header to configure the grace period: If (the default), the grace period is enabled and the Blueprint container waits for mandatory dependencies to be resolved during initialization; if , the grace period is skipped and the container does not check whether the mandatory dependencies are resolved. Specifies the grace period timeout in milliseconds. The default is 300000 (5 minutes). For example, to enable a grace period of 10 seconds, you could define the following header in the manifest file: The value of the header is a semi-colon separated list, where the first item is the actual bundle symbolic name, the second item, , enables the grace period and the third item, , specifies a 10 second timeout. The Blueprint container enables you to instantiate Java classes using a element. You can create all of your main application objects this way. In particular, you can use the element to create a Java object that represents an OSGi service instance. The Blueprint element is defined in the Blueprint schema namespace, . The following example shows how to create a few different types of bean using Blueprint’s element: Where the class referenced by the last bean example could be defined as follows: For more details on defining Blueprint beans, consult the following references: This section describes how to configure Blueprint using properties held in a file which is outside the Camel context. Blueprint beans can be configured by using variables that can be substitued with properties from an external file. You need to declare the namespace and add the bean in your Blueprint xml. Use the bean to declare the location of your properties file to Blueprint. The specification of configuration options can be found at http://aries.apache.org/schemas/blueprint-ext/blueprint-ext.xsd.\n\nThis section describes how to export a Java object to the OSGi service registry, thus making it accessible as a service to other bundles in the OSGi container. To export a service to the OSGi service registry under a single interface name, define a element that references the relevant service bean, using the attribute, and specifies the published interface, using the attribute. For example, you could export an instance of the class under the interface name using the Blueprint configuration code shown in Example 10.1, “Sample Service Export with a Single Interface”. Where the attribute specifies the ID of the corresponding bean instance and the attribute specifies the name of the public Java interface under which the service is registered in the OSGi service registry. The classes and interfaces used in this example are shown in Example 10.2, “Sample Account Classes and Interfaces” To export a service to the OSGi service registry under multiple interface names, define a element that references the relevant service bean, using the attribute, and specifies the published interfaces, using the child element. For example, you could export an instance of the class under the list of public Java interfaces, and , using the following Blueprint configuration code: The attribute and the element cannot be used simultaneously in the same element. You must use either one or the other. If you want to export a service to the OSGi service registry under all of its implemented public Java interfaces, there is an easy way of accomplishing this using the attribute. For example, to export an instance of the class under all of its implemented public interfaces, use the following Blueprint configuration code: Where the value of the attribute indicates that Blueprint should register all of the public interfaces implemented by . The attribute can have the following valid values: Disables auto-export. This is the default. Registers the service under all of its implemented public Java interfaces. Registers the service under its own type (class) and under all super-types (super-classes), except for the class. Like the option, but including all of the implemented public Java interfaces as well. The OSGi service registry also allows you to associate service properties with a registered service. Clients of the service can then use the service properties to search for or filter services. To associate service properties with an exported service, add a child element that contains one or more elements (one element for each service property). For example, to associate the string property with a savings account service, you could use the following Blueprint configuration: Where the string property has the value, . It is possible to define service properties of type other than string: that is, primitive types, arrays, and collections are also supported. For details of how to define these types, see Controlling the Set of Advertised Properties. in the Spring Reference Guide. The element ought to belong to the Blueprint namespace. The use of the element in Spring’s implementation of Blueprint is non-standard. There are two service properties that might be set automatically when you export a service using the element, as follows:\n• —is always set to the of the service’s element, unless the bean is inlined (that is, the bean is defined as a child element of the element). Inlined beans are always anonymous.\n• —is automatically set, if the ranking attribute is non-zero. If a bundle looks up a service in the service registry and finds more than one matching service, you can use ranking to determine which of the services is returned. The rule is that, whenever a lookup matches multiple services, the service with the highest rank is returned. The service rank can be any non-negative integer, with being the default. You can specify the service ranking by setting the attribute on the element—for example: If you want to keep track of service registration and unregistration events, you can define a registration listener callback bean that receives registration and unregistration event notifications. To define a registration listener, add a child element to a element. For example, the following Blueprint configuration defines a listener bean, , which is referenced by a element, so that the listener bean receives callbacks whenever an service is registered or unregistered: Where the element’s attribute references the of the listener bean, the attribute specifies the name of the listener method that receives the registration callback, and attribute specifies the name of the listener method that receives the unregistration callback. The following Java code shows a sample definition of the class that receives notifications of registration and unregistration events: The method names, and , are specified by the and attributes respectively. The signatures of these methods must conform to the following syntax:\n• —any type T that is assignable from the service object’s type. In other words, any supertype class of the service class or any interface implemented by the service class. This argument contains the service instance, unless the service bean declares the to be , in which case this argument is (when the scope is , no service instance is available at registration time).\n• —must be of either type or type. This map contains the service properties associated with this service registration.\n\nThis section describes how to obtain and use references to OSGi services that have been exported to the OSGi service registry. You can use either the element or the element to import an OSGi service. The element is suitable for accessing stateless services, while the element is suitable for accessing stateful services. The following models for obtaining OSGi services references are supported: A reference manager instance is created by the Blueprint element. This element returns a single service reference and is the preferred approach for accessing stateless services. Figure 10.1, “Reference to Stateless Service” shows an overview of the model for accessing a stateless service using the reference manager. Beans in the client Blueprint container get injected with a proxy object (the provided object), which is backed by a service object (the backing service) from the OSGi service registry. This model explicitly takes advantage of the fact that stateless services are interchangeable, in the following ways:\n• If multiple services instances are found that match the criteria in the element, the reference manager can arbitrarily choose one of them as the backing instance (because they are interchangeable).\n• If the backing service disappears, the reference manager can immediately switch to using one of the other available services of the same type. Hence, there is no guarantee, from one method invocation to the next, that the proxy remains connected to the same backing service. The contract between the client and the backing service is thus stateless, and the client must not assume that it is always talking to the same service instance. If no matching service instances are available, the proxy will wait for a certain length of time before throwing the exception. The length of the timeout is configurable by setting the attribute on the element. A reference list manager instance is created by the Blueprint element. This element returns a list of service references and is the preferred approach for accessing stateful services. Figure 10.2, “List of References to Stateful Services” shows an overview of the model for accessing a stateful service using the reference list manager. Beans in the client Blueprint container get injected with a object (the provided object), which contains a list of proxy objects. Each proxy is backed by a unique service instance in the OSGi service registry. Unlike the stateless model, backing services are not considered to be interchangeable here. In fact, the lifecycle of each proxy in the list is tightly linked to the lifecycle of the corresponding backing service: when a service gets registered in the OSGi registry, a corresponding proxy is synchronously created and added to the proxy list; and when a service gets unregistered from the OSGi registry, the corresponding proxy is synchronously removed from the proxy list. The contract between a proxy and its backing service is thus stateful, and the client may assume when it invokes methods on a particular proxy, that it is always communicating with the same backing service. It could happen, however, that the backing service becomes unavailable, in which case the proxy becomes stale. Any attempt to invoke a method on a stale proxy will generate the exception. The simplest way to obtain a stateles service reference is by specifying the interface to match, using the attribute on the element. The service is deemed to match, if the attribute value is a super-type of the service or if the attribute value is a Java interface implemented by the service (the attribute can specify either a Java class or a Java interface). For example, to reference a stateless service (see Example 10.1, “Sample Service Export with a Single Interface”), define a element as follows: Where the element creates a reference manager bean with the ID, . To use the referenced service, inject the bean into one of your client classes, as shown. The bean property injected into the client class can be any type that is assignable from . For example, you could define the class as follows: The simplest way to obtain a stateful service reference is by specifying the interface to match, using the attribute on the element. The reference list manager then obtains a list of all the services, whose attribute value is either a super-type of the service or a Java interface implemented by the service (the attribute can specify either a Java class or a Java interface). For example, to reference a stateful service (see Example 10.1, “Sample Service Export with a Single Interface”), define a element as follows: Where the element creates a reference list manager bean with the ID, . To use the referenced service list, inject the bean reference into one of your client classes, as shown. By default, the bean property is a list of service objects (for example, ). You could define the client class as follows: Matching by interface and component name To match both the interface and the component name (bean ID) of a stateless service, specify both the attribute and the attribute on the element, as follows: To match both the interface and the component name (bean ID) of a stateful service, specify both the attribute and the attribute on the element, as follows: You can select services by matching service properties against a filter. The filter is specified using the attribute on the element or on the element. The value of the attribute must be an LDAP filter expression. For example, to define a filter that matches when the service property equals , you could use the following LDAP filter expression: To match two service property values, you can use conjunction, which combines expressions with a logical .For example, to require that the property is equal to and the property is equal to , you could use the following LDAP filter expression: For the complete syntax of LDAP filter expressions, see section 3.2.7 of the OSGi Core Specification. Filters can also be combined with the and settings, in which case all of the specified conditions are required to match. For example, to match a stateless service of type, with a service property equal to , you could define a element as follows: To match a stateful service of type, with a service property equal to , you could define a element as follows: Specifying whether mandatory or optional By default, a reference to an OSGi service is assumed to be mandatory (see Mandatory dependencies). It is possible to customize the dependency behavior of a element or a element by setting the attribute on the element. There are two possible values of the attribute:\n• (the default), means that the dependency be resolved during a normal Blueprint container initialization\n• , means that the dependency need be resolved during initialization. The following example of a element shows how to declare explicitly that the reference is a mandatory dependency: To cope with the dynamic nature of the OSGi environment—for example, if you have declared some of your service references to have availability—it is often useful to track when a backing service gets bound to the registry and when it gets unbound from the registry. To receive notifications of service binding and unbinding events, you can define a element as the child of either the element or the element. For example, the following Blueprint configuration shows how to define a reference listener as a child of the reference manager with the ID, : The preceding configuration registers an instance of type as a callback that listens for and events. Events are generated whenever the reference manager’s backing service binds or unbinds. The following example shows a sample implementation of the class: The method names, and , are specified by the and attributes respectively. Both of these callback methods take an argument.\n\nThis section explains how to generate, build, and deploy a simple OSGi service in the OSGi container. The service is a simple Hello World Java class and the OSGi configuration is defined using a Blueprint configuration file. In order to generate a project using the Maven Quickstart archetype, you must have the following prerequisites:\n• —Maven is a free, open source build tool from Apache. You can download the latest version from http://maven.apache.org/download.html (minimum is 2.0.9).\n• —whilst performing a build, Maven dynamically searches external repositories and downloads the required artifacts on the fly. In order for this to work, your build machine be connected to the Internet. The archetype creates a generic Maven project, which you can then customize for whatever purpose you like. To generate a Maven project with the coordinates, , enter the following command: The result of this command is a directory, , containing the files for the generated project. Be careful not to choose a group ID for your artifact that clashes with the group ID of an existing product! This could lead to clashes between your project’s packages and the packages from the existing product (because the group ID is typically used as the root of a project’s Java package names). You must customize the POM file in order to generate an OSGi bundle, as follows:\n• Follow the POM customization steps described in Section 3.1, “Generating a Bundle Project”.\n• None In the configuration of the Maven bundle plug-in, modify the bundle instructions to export the package, as follows: Create the sub-directory. In this directory, use your favorite text editor to create the file, , and add the code from Example 10.3, “The HelloWorldSvc Interface” to it. Create the sub-directory. In this directory, use your favorite text editor to create the file, , and add the code from Example 10.4, “The HelloWorldSvcImpl Class” to it. The Blueprint configuration file is an XML file stored under the directory on the class path. To add a Blueprint file to your project, first create the following sub-directories: Where the is the standard Maven location for all JAR resources. Resource files under this directory will automatically be packaged in the root scope of the generated bundle JAR. Example 10.5, “Blueprint File for Exporting a Service” shows a sample Blueprint file that creates a bean, using the element, and then exports the bean as an OSGi service, using the element. Under the directory, use your favorite text editor to create the file, , and add the XML code from Example 10.5, “Blueprint File for Exporting a Service”. To install and run the project, perform the following steps:\n• None Build the project—open a command prompt and change directory to . Use Maven to build the demonstration by entering the following command: If this command runs successfully, the directory should contain the bundle file, .\n• None Install and start the osgi-service bundle—at the Red Hat Fuse console, enter the following command: Where ProjectDir is the directory containing your Maven projects and the flag directs the container to start the bundle right away. For example, if your project directory is on a Windows machine, you would enter the following command: On Windows machines, be careful how you format the URL—for details of the syntax understood by the URL handler, see Section 12.1, “File URL Handler”.\n• None Check that the service has been created—to check that the bundle has started successfully, enter the following Red Hat Fuse console command: Somewhere in this listing, you should see a line for the bundle, for example:\n\nThis section explains how to generate, build, and deploy a simple OSGi client in the OSGi container. The client finds the simple Hello World service in the OSGi registry and invokes the method on it. In order to generate a project using the Maven Quickstart archetype, you must have the following prerequisites:\n• —Maven is a free, open source build tool from Apache. You can download the latest version from http://maven.apache.org/download.html (minimum is 2.0.9).\n• —whilst performing a build, Maven dynamically searches external repositories and downloads the required artifacts on the fly. In order for this to work, your build machine be connected to the Internet. The archetype creates a generic Maven project, which you can then customize for whatever purpose you like. To generate a Maven project with the coordinates, , enter the following command: The result of this command is a directory, , containing the files for the generated project. Be careful not to choose a group ID for your artifact that clashes with the group ID of an existing product! This could lead to clashes between your project’s packages and the packages from the existing product (because the group ID is typically used as the root of a project’s Java package names). You must customize the POM file in order to generate an OSGi bundle, as follows:\n• Follow the POM customization steps described in Section 3.1, “Generating a Bundle Project”.\n• None Because the client uses the Java interface, which is defined in the bundle, it is necessary to add a Maven dependency on the bundle. Assuming that the Maven coordinates of the bundle are , you should add the following dependency to the client’s POM file: To add a Blueprint file to your client project, first create the following sub-directories: Under the directory, use your favorite text editor to create the file, , and add the XML code from Example 10.6, “Blueprint File for Importing a Service”. Where the element creates a reference manager that finds a service of type in the OSGi registry. The element creates an instance of the class and injects the service reference as the bean property, . In addition, the attribute specifies that the method is called during the bean initialization phase (that is, after the service reference has been injected into the client bean). Under the directory, use your favorite text editor to create the file, , and add the Java code from Example 10.7, “The Client Class”. The class defines a getter and a setter method for the bean property, which enables it to receive the reference to the Hello World service by injection. The method is called during the bean initialization phase, after property injection, which means that it is normally possible to invoke the Hello World service within the scope of this method. To install and run the project, perform the following steps:\n• None Build the project—open a command prompt and change directory to . Use Maven to build the demonstration by entering the following command: If this command runs successfully, the directory should contain the bundle file, .\n• None Install and start the osgi-service bundle—at the Red Hat Fuse console, enter the following command: Where ProjectDir is the directory containing your Maven projects and the flag directs the container to start the bundle right away. For example, if your project directory is on a Windows machine, you would enter the following command: On Windows machines, be careful how you format the URL—for details of the syntax understood by the URL handler, see Section 12.1, “File URL Handler”.\n• None Client output—f the client bundle is started successfully, you should immediately see output like the following in the console:\n\nApache Camel provides a simple way to invoke OSGi services using the Bean language. This feature is automatically available whenever a Apache Camel application is deployed into an OSGi container and requires no special configuration. When a Apache Camel route is deployed into the OSGi container, the automatically sets up a registry chain for resolving bean instances: the registry chain consists of the OSGi registry, followed by the Blueprint registry. Now, if you try to reference a particular bean class or bean instance, the registry resolves the bean as follows:\n• Look up the bean in the OSGi registry first. If a class name is specified, try to match this with the interface or class of an OSGi service.\n• If no match is found in the OSGi registry, fall back on the Blueprint registry. Consider the OSGi service defined by the following Java interface, which defines the single method, : When defining the bundle that implements the OSGi service, you could use the following Blueprint configuration to export the service: Where it is assumed that the interface is implemented by the class (not shown). After you have deployed the bundle containing the OSGi service, you can invoke the service from a Apache Camel application using the Java DSL. In the Java DSL, you invoke the OSGi service through the Bean language, as follows: In the command, the first argument is the OSGi interface or class, which must match the interface exported from the OSGi service bundle. The second argument is the name of the bean method you want to invoke. For full details of the command syntax, see Apache Camel Development Guide Bean Integration . When you use this approach, the OSGi service is implicitly imported. It is not necessary to import the OSGi service explicitly in this case. In the XML DSL, you can also use the Bean language to invoke the OSGi service, but the syntax is slightly different. In the XML DSL, you invoke the OSGi service through the Bean language, using the element, as follows: When you use this approach, the OSGi service is implicitly imported. It is not necessary to import the OSGi service explicitly in this case."
    },
    {
        "link": "https://experienceleague.adobe.com/en/docs/experience-manager-learn/cloud-service/developing/osgi-services/configurations",
        "document": "Let’s take a look at how we can use OSGi configuration properties to provide configuration data to our OSGi service. We’ll be looking at two different ways that we can specify and read in OSGi configuration properties in our OSGi service. The first is a little bit more low-level and you probably won’t actually use that much in real life. However, it’s a good approach to know. So for this we’re going to start by looking at how we can pull out our list of activities and set them via OSGi configurations instead of directly hard coding them into our Java class. So let’s start by going up to our component annotation on our class that turns this class into an OSGi component and adding the property attribute. So this takes a list of strings and the strings are in the format of the OSGi property key, the equal sign, and then the corresponding value.\n\nSo since we’ll be defining a list of activities, we can make up a key, and of course this key should probably be semantic. So let’s just call it Activities, and we can set the value to be one of our values for the activity array. So let’s make this a little bit different from what we have currently just so we can see the changes in AEM. So let’s make this Hiking. And before we look at how we can add more values, let’s first take a look at how we can read this single value out based on this key here. We’re going to head back down to our activate method and the activate method has a number of valid method signatures, and one of these signatures takes a map of type string object.\n\nAnd this map is going to represent a map of all of the OSGi properties and their corresponding values. So we can read out our activities value of Hiking and set it to our activities field here. So we can say this activities is equal to, and what we could do is directly access the value through the map.\n\nHowever, this returns an object. So we would have to figure out how to coerce this into a string array. But luckily we have some helper utilities that do this job for us. So we can OSGi’s converters util to do this. So let’s go ahead and you do that. We’ll use as the standard converter provided by the library.\n\nWe’ll call convert and convert takes the object value, which we can get by calling properties.get with that OSGi property name, and then we can call to and provide it the class we would like the value to be coerced to, which is a string array. So now it’s going to essentially take the values it finds under the OSGi property key activities, and try to turn it into a string array, and then sets it to our activities field.\n\nSo in order to get the other activities in our activities list, all we need to do is create more key value pairs using the exact same key name. So we’ll say, and again, I’ll be changing this up just so we can see the values change when we execute it.\n\nAnd there we go. Now, all three values, Hiking, Jogging, and Walking will be associated with the activities OSGi property, and we’ll read them out as a string array, for use within our OSGi service. So one of the thing we can do is actually specify the type of value that we expect for an OSGi property, and this is done with a special syntax when defining the property name. So let’s make a OSGi configuration property that sets the seed for our random number generator. So let’s just call this random.seed and we can specify the type by putting a colon and then the type name. So in this case we’ll be setting an integer and the available types are all documented on the OSGi component annotations Java docs, so you can check those out.\n\nOtherwise it works exactly the same as before, equal sign and then the value. And again, we can always read this out using the same converters.\n\nAgain, we have to make sure that we pass in the actual object that represents the value. So in this case, it’s just random seed. We don’t have to put the colon integer as that is just a descriptor. The key itself has random.seed of course, and then here we can say to (Integer.class) and make sure properties.get, of course. So now we pulling out the value from the random seed OSGi property whose default value up here is set to 10 and we’ll send it to randomSeed, and then we can use that to initialize our random object. And of course we have to make this non final and we can get rid of this since we’re setting it with an activate, anyhow.\n\nSo now what we’ve done is we pulled out our list of activities as well as our randomSeed into OSGi configuration properties. So I’m going to go ahead and deploy this and we can check it out just to make sure it’s all working, and our activate method is in fact reading out the correct values. And after we’ve done that we’re going to come back and we’re going to address the elephant in the room as it were, which is: What we’ve done so far is taken a hard-coded list of activities, which we previously hard-coded in our activate method and all we’ve really done is hard-coded them up here in our component annotation. So you may be asking yourself, “Why did we do this and what did it by us?” It’s actually a little bit more code as well as more complexity. So we’re going to come back and take a look at how we can use OSGi configuration files and target these properties with different values based on run mode. But let’s really quickly jump back to AEM and make sure that our activate method is reading out our OSGi properties of Hiking, Jogging, and Walking. So back in AEM we have our test harness that invokes our getRandomActivity so we should start seeing these change when I refresh to our new three activities.\n\nSo there we go, Hiking, Jogging, and Walking. So this is absolutely pulling our values from our OSGi properties that we’ve defined up here.\n\nOkay. So in order to parameterize these outside of our Java class, we can define OSGi configuration files. So to do this, we’re going to head over to our UI config project and this project contains all our OSGi configurations. So we drill into this. You’ll see that archetype pre creates a bunch of config folders that are targeted by run mode as well.\n\nSo if you’re not familiar with this concept of run mode, AEM as a cloud service wIll start using different run modes depending on the environment, as well as the tier. So all AEM as a Cloud service. Author instances wIll start with the author run mode. Likewise, Ul AEM as a service, published tiers will start with a publish run mode. Likewise we can target just the production environment with prod or a state with stage.\n\nSo what we can do it is go into the appropriate folder that we want our configuration to be in. I’ll pick the config folder, which is considered the default global folder here, and what we can do is we can make new OSGi configurations. So these are very simple to make.\n\nAll you have to do is know the fully qualified class path to your OSGi service implementation you want to configure. So in this case we can just grab the package name up here, create a new one file. I’ll just paste the package name in, and then we just want to make sure that we put in this ActivitiesImpl, which is the class name for our OSGi service implementation. And then we post fix it with cfg.json so AEM knows that this is in fact in OSGi configuration in the Json format. In here we can define a Json object and this Json object is effectively simply going to model our OSGi properties and values. So we have two keys, activities and randomSeed. So let’s come back here and we can make a key, activities, and since this is Jason, we can actually use an array to model this so we can put in a couple of new activities here.\n\nSo again, I’m going to make these different from what we have set as the defaults effectively up here in properties, so we can see the difference and make sure that they’re actually pulling from our configuration.\n\nSo we’ll go back to Skateboarding, maybe some Surfing, and Skiing. Okay. And we can also set the random seed if we want to as well. And the syntax for this looks exactly the same as defining the key in the component annotation. So random.seed. We can specify the type by just simply post fixing the colon type to the key name, and we can set a key. And maybe we’ll set this to 32, make sure we put our comma there so it’s well formatted.\n\nAnd there we go. So now when we deploy our complete application, including our core bundle, as well as our UI config project, we’ll start using these values to drive our OSGi configurations.\n\nSo let’s go ahead and try that out.\n\nAnd let’s go ahead and refresh this page to see if it’s pulling the activities from our list of activities defined in our OSGi configuration file. So there we go. You start seeing Skiing, Surfing, and Skateboarding should be in there as well. And there we go. So you can see that our OSGi service is now being powered by values that we’ve defined in our OSGi configuration file rather than something that we have hard coded in our OSGi service implementation itself.\n\nSo coming back here, you probably have already guessed that when we define the properties and values in the component, they effectively act as default values that are used if no other OSGi configuration values are applicable for those keys. So I want to be clear that this doesn’t necessarily act as the canonical source for OSGi properties. In fact, if we wanted to, we could simply delete all of these and wholly rely on the OSGi properties we’ve defined here.\n\nThere is one caveat to that though, because if we go back down into our activate method, you can see that we are trying to coerce the value from our activities as well as randomSeed, and then turn it into the specified types.\n\nIf our OSGi configuration file neglected to specify one of these settings or both, when this code is evaluated, it would actually throw a null pointer exception because it would be trying to convert a null object into a string array and a null object into an integer class. It didn’t do that before because we had our properties essentially defaulted above. So a different way you can provide default values is through the same converter tool by setting default value, and you can provide anything you want in here. We could do something like this.\n\nOkay. So that should cover the basics of OSGi configurations and how we can use them in our OSGi services. Make sure to check out the video that builds on this, that shows you how you can designate an object class definition to model your OSGi configuration object. -"
    },
    {
        "link": "https://docs.osgi.org/specification/osgi.cmpn/7.0.0/util.xml.html",
        "document": "The Extensible Markup Language (XML) has become a popular method of describing data. As more bundles use XML to describe their data, a common XML Parser becomes necessary in an embedded environment in order to reduce the need for space. Not all XML Parsers are equivalent in function, however, and not all bundles have the same requirements on an XML parser. This problem was addressed in the Java API for XML Processing, see [4] JAXP for Java 2 Standard Edition and Enterprise Edition. This specification addresses how the classes defined in JAXP can be used in an OSGi framework. It defines how:\n• Implementations of XML parsers can become available to other bundles\n• A standard parser in a JAR can be transformed to a bundle\n• Simple - It should be easy to provide a SAX or DOM parser as well as easy to find a matching parser\n• Multiple - It should be possible to have multiple implementations of parsers available\n• Extendable - It is likely that parsers will be extended in the future with more functionality\n• XMLParserActivator - A utility class that registers a parser factory from declarative information in the Manifest file.\n• SAXParserFactory - A class that can create an instance of a class.\n• DocumentBuilderFactory - A class that can create an instance of a class.\n• SAXParser - A parser, instantiated by a object, that parses according to the SAX specifications.\n• DocumentBuilder - A parser, instantiated by a , that parses according to the DOM specifications. \n\n A bundle containing a SAX or DOM parser is started. This bundle registers a and/or a service object with the Framework. Service registration properties describe the features of the parsers to other bundles. A bundle that needs an XML parser will get a or service object from the Framework service registry. This object is then used to instantiate the requested parsers according to their specifications.\n\nXML has become very popular in the last few years because it allows the interchange of complex information between different parties. Though only a single XML standard exists, there are multiple APIs to XML parsers, primarily of two types:\n• The Simple API for XML (SAX1 and SAX2)\n• Based on the Document Object Model (DOM 1 and 2) Both standards, however, define an abstract API that can be implemented by different vendors. A given XML Parser implementation may support either or both of these parser types by implementing the and/or packages. In addition, parsers have characteristics such as whether they are validating or non-validating parsers and whether or not they are name-space aware. An application which uses a specific XML Parser must code to that specific parser and become coupled to that specific implementation. If the parser has implemented [4] JAXP, however, the application developer can code against SAX or DOM and let the runtime environment decide which parser implementation is used. JAXP uses the concept of a factory. A factory object is an object that abstracts the creation of another object. JAXP defines a and a class for this purpose. JAXP is implemented in the package and provides an abstraction layer between an application and a specific XML Parser implementation. Using JAXP, applications can choose to use any JAXP compliant parser without changing any code, simply by changing a System property which specifies the SAX- and DOM factory class names. In JAXP, the default factory is obtained with a static method in the or class. This method will inspect the associated System property and create a new instance of that class.\n\nThe current specification of JAXP has the limitation that only one of each type of parser factories can be registered. This specification specifies how multiple objects and objects can be made available to bundles simultaneously. Providers of parsers should register a JAXP factory object with the OSGi service registry under the factory class name. Service properties are used to describe whether the parser: With this functionality, bundles can query the OSGi service registry for parsers supporting the specific functionality that they require.\n\nIf an XML Parser supports JAXP, then it can be converted to an OSGi aware bundle by adding a class which registers an XML Parser Service. The utility class provides this function and can be added (copied, not referenced) to any XML Parser bundle, or it can be extended and customized if desired. Its functionality is based on the definition of the [5] JAR File specification, services directory. This specification defines a concept for service providers. A JAR file can contain an implementation of an abstractly defined service. The class (or classes) implementing the service are designated from a file in the directory. The name of this file is the same as the abstract service class. The content of the UTF-8 encoded file is a list of class names separated by new lines. White space is ignored and the number sign ( ) is the comment character. JAXP uses this service provider mechanism. It is therefore likely that vendors will place these service files in the directory. To support this mechanism, the XML Parser service provides a utility class that should be normally delivered with the OSGi framework implementation. This class is a Bundle Activator and must start when the bundle is started. This class is copied into the parser bundle, and not imported. The method of the utility class will look in the service provider directory for the files SAXFACTORYNAME ) or DOMFACTORYNAME ). The full path name is specified in the constants SAXCLASSFILE and DOMCLASSFILE respectively. If either of these files exist, the utility class will parse the contents according to the specification. A service provider file can contain multiple class names. Each name is read and a new instance is created. The following example shows the possible content of such a file: Both the and the provide methods that describe the features of the parsers they can create. The activator will use these methods to set the values of the properties, as defined in Properties, that describe the instances. To incorporate this bundle activator into a XML Parser Bundle, do the following:\n• If SAX parsing is supported, create a resource file containing the class names of the classes.\n• If DOM parsing is supported, create a file containing the fully qualified class names of the classes.\n• Create manifest file which imports the packages , , and .\n• Add a Bundle-Activator header to the manifest pointing to the , the sub-class that was created, or a fully custom one.\n• If the parsers support attributes, properties, or features that should be registered as properties so they can be searched, extend the class and override setSAXProperties(javax.xml.parsers.SAXParserFactory,Hashtable) and setDOMProperties(javax.xml.parsers.DocumentBuilderFactory,Hashtable).\n• Ensure that custom properties are put into the object. JAXP does not provide a way for to query the parser to find out what properties were added.\n• Bundles that extend the class must call the original methods via super to correctly initialize the XML Parser Service properties.\n• Compile this class into the bundle.\n• Ensure that the class is contained in the bundle.\n\nA single bundle should export the JAXP, SAX, and DOM APIs. The version of contained packages must be appropriately labeled. JAXP 1.1 or later is required which references SAX 2 and DOM 2. See [4] JAXP for the exact version dependencies. This specification is related to related packages as defined in the JAXP 1.1 document. The following table contains the expected minimum versions. \n\n The Xerces project from the Apache group, [6] Xerces 2 Java Parser, contains a number libraries that implement the necessary APIs. These libraries can be wrapped in a bundle to provide the relevant packages.\n\nA centralized XML parser is likely to see sensitive information from other bundles. Provisioning an XML parser should therefore be limited to trusted bundles. This security can be achieved by providing | to only trusted bundles. Using an XML parser is a common function, and | should not be restricted. The XML parser bundle will need for parsing of files because it is not known beforehand where those files will be located. This requirement further implies that the XML parser is a system bundle that must be fully trusted.\n\nBundles wishing to use this package must list the package in the Import-Package header of the bundle's manifest. Example import for consumers using the API in this package:\n• - A BundleActivator class that allows any JAXP compliant XML Parser to register itself as an OSGi parser service. A BundleActivator class that allows any JAXP compliant XML Parser to register itself as an OSGi parser service. Multiple JAXP compliant parsers can concurrently register by using this BundleActivator class. Bundles who wish to use an XML parser can then use the framework's service registry to locate available XML Parsers with the desired characteristics such as validating and namespace-aware. The services that this bundle activator enables a bundle to provide are: The algorithm to find the implementations of the abstract parsers is derived from the JAR file specifications, specifically the Services API. An XMLParserActivator assumes that it can find the class file names of the factory classes in the following files:\n• is a file contained in a jar available to the runtime which contains the implementation class name(s) of the SAXParserFactory.\n• is a file contained in a jar available to the runtime which contains the implementation class name(s) of the If either of the files does not exist, assumes that the parser does not support that parser type. attempts to instantiate both the and the . It registers each factory with the framework along with service properties:\n• PARSER_VALIDATING- indicates if this factory supports validating parsers. It's value is a .\n• PARSER_NAMESPACEAWARE- indicates if this factory supports namespace aware parsers It's value is a . Individual parser implementations may have additional features, properties, or attributes which could be used to select a parser with a filter. These can be added by extending this class and overriding the and methods. Fully qualified path name of DOM Parser Factory Class Name file Filename containing the DOM Parser Factory Class name. Also used as the basis for the registration property. Service property specifying if factory is configured to support namespace aware parsers. The value is of type . Service property specifying if factory is configured to support validating parsers. The value is of type . Fully qualified path name of SAX Parser Factory Class Name file Filename containing the SAX Parser Factory Class name. Also used as the basis for the registration property. The bundle using the service. The object for the service. A unique XML Parser Factory object is returned for each call to this method. The returned XML Parser Factory object will be configured for validating and namespace aware support as specified in the service properties of the specified ServiceRegistration object. This method can be overridden to configure additional features in the returned XML Parser Factory object. A new, configured XML Parser Factory object or null if a configuration error was encountered This method attempts to instantiate a validating parser and a namespace aware parser to determine if the parser can support those features. The appropriate properties are then set in the specified props object. This method can be overridden to add additional DOM2 features and properties. If you want to be able to filter searches of the OSGi service registry, this method must put a key, value pair into the properties object for each feature or property. For example, properties.put(\"http://www.acme.com/features/foo\", Boolean.TRUE); - the properties object for the service This method attempts to instantiate a validating parser and a namespace aware parser to determine if the parser can support those features. The appropriate properties are then set in the specified properties object. This method can be overridden to add additional SAX2 features and properties. If you want to be able to filter searches of the OSGi service registry, this method must put a key, value pair into the properties object for each feature or property. For example, properties.put(\"http://www.acme.com/features/foo\", Boolean.TRUE); The execution context of the bundle being started. Called when this bundle is started so the Framework can perform the bundle-specific activities necessary to start this bundle. This method can be used to register services or to allocate any resources that this bundle needs. This method must complete and return to its caller in a timely manner. This method attempts to register a SAX and DOM parser with the Framework's service registry. – If this method throws an exception, this bundle is marked as stopped and the Framework will remove this bundle's listeners, unregister all services registered by this bundle, and release all services used by this bundle. The execution context of the bundle being stopped. This method has nothing to do as all active service registrations will automatically get unregistered when the bundle stops. – If this method throws an exception, the bundle is still marked as stopped, and the Framework will remove the bundle's listeners, unregister all services registered by the bundle, and release all services used by the bundle. The object for the service. The XML Parser Factory object returned by a previous call to the method."
    },
    {
        "link": "https://vogella.com/tutorials/OSGi/article.html",
        "document": "OSGi uses the META-INF/MANIFEST.MF file (called the manifest file) from the standard Java specification to define its meta information. The Java specification defines that additional key/value pairs can be added to this file without affecting runtimes which do not understand these key/value combinations. Therefore, OSGi plug-ins can be used without restrictions in other Java environments. The following listing is an example for a manifest file containing OSGi metadata. The following table gives an overview of the OSGi meta-data used in the manifest file. The unique technical name of the plug-in. If this plug-in is providing an extension or an extension point it must be marked as Singleton. You do this by adding the following statement after the Bundle-SymbolicName identifier: Defines the plug-in version and must be incremented if a new version of the plug-in is published. Defines an optional activator class which implements the interface. An instance of this class is created when the plug-in gets activated. Its and methods are called whenever the plug-in is started or stopped. An OSGi activator can be used to configure the plug-in during startup. The execution of an activator may increase the startup time of the application, therefore this functionality should be avoided if possible. Specify which Java version is required to run the plug-in. If this requirement is not fulfilled, then the runtime does not load the plug-in. The OSGi specification deprecates but the Eclipse Plug-in development tooling still uses it, hence this is also used in this description. Setting this to lazy instructs the OSGi runtime that this plug-in should be activated if one of its classes and interfaces are used by other plug-ins. Must be in Equinox if the plug-in provides services. The Bundle-ClassPath specifies where to load classes from the bundle. The default is '.' which allows classes to be loaded from the root of the bundle. You can also add JAR files to it, these are called nested JAR files. The combination of and uniquely identifies a plug-in. Each plug-in has a unique name (id) which is defined via the property. By convention, this name uses the reverse domain name of the plug-in author. For example, if you own the \"example.com\" domain then the symbolic name would start with \"com.example\". Each plug-in defines its version number in the property. OSGi recommends to use the following schema for versions in the field identifier. If you change your plug-in code you increase the version according to the following rule set.\n• <major> is increased if changes are not backwards compatible.\n• <minor> is increased if public API has changed but all changes are backwards compatible.\n• <service> is increased if all changes are backwards compatible. For more information on this version scheme see the Version Numbering Wiki.\n\nServices enable functionality for other software components. A service interface in OSGi is defined in a plug-in by a standard Java class or an interface. Service implementations for a service interface are published to the OSGi service registry so that other plug-ins can access them. Multiple plug-ins can provide a service implementation for the service interface. Plug-ins can access the service implementation via the service interface. During the declaration of a service it is possible to specify key/values which can be used to configure the service. A service can be dynamically started and stopped, and plug-ins which use services must be able to handle this dynamic behavior. The plug-ins can register listeners to be informed if a service is started or stopped. To provide a service a plug-in needs to be in the life cycle status. OSGi provides several ways of defining, providing and consuming services. The following description focuses on the usage of declarative services. The OSGi declarative services (DS) allows you to define and consume service via meta-data. Tooling allows you to generate service metadata based on annotations in your source code, we cover this in the exercises for the Eclipse IDE. The following is an example of using an annotation to define an OSGi service. It provides a service implementation for the interface. The preferred way of defining OSGi services is using the annotations, as this is the simplest way possible. Alternatively, you can also define and register the service component definition manually via an XML file or use the OSGi API for starting, stopping and tracking services. This is covered later. The annotation is used to generate an XML file, which is read once the plug-in gets activated.\n• delayed component - service is not activated until requested, this means class and implementation loading is delayed until this time. This type must define a OSGi service\n• immediate component - service is activated as soon as its dependencies are satisfied, does not need to specify a service\n• factory component - creates and activates a new service an request, service is not re-used if it become unsatisfied or unregistered The following table gives a brief overview of the OSGi ds terminology, you can skip this table and return to it, in case you want to lookup a definition. A Java class inside a bundle that is declared via Component Description and managed by a service component runtime. The declaration of a Service Component, contained in an XML document or defined via annotations which are used to generate the XML document A Component Description that is parameterized with component properties. It is used to track the component dependencies and manages the Component Instance. The instance of the component implementation class. It is created when a Component Configuration is activated and discarded if the Component Configuration is deactivated. Sometimes you need to access information about the bundle, e.g., the bundle version or the bundle name. Access to the bundle and its bundleContext is performed via the and class. You can use the class from the OSGi framework to access the for a class. If you want to activate a service immediately after its dependencies are satisfied, the parameter to the annotation can be used. You need to ensure that the plug-in is started before any application plug-in which wants to consume a service. You can ensure this in your run configuration by setting the auto-start field to true and the start level lower than 4 (4 is the default value) for the plug-in The Eclipse RCP framework automatically starts the required plug-ins for using declarative OSGi service. It is not required to manually set a start level in your product configuration file. It is good practice to define a service via a plug-in which only contains the interface definition. Another plug-in would provide the implementation for this service. This allows you to change the implementation of the service via a different plug-in. A plug-in which provides a service must be in its life cycle status. Therefore, ensure that the Activate this plug-in when one of its classes is loaded flag is set on the MANIFEST.MF file. The DS annotation support in sets this flag automatically, if you use the default settings The above will set the Lazy Activation Policy setting via the Bundle-ActivationPolicy key in the manifest. This is necessary for the Eclipse runtime (Equinox), other OSGi runtimes will activate bundle always if their dependencies are fulfilled. This flag ensures that the bundle is activated (auto-started) as soon as one of its classes is accessed. OSGi Services have their own life cycle, the following states are possible: The initial enabled state of a component is specified via Component Description. All components are disabled when the bundle is stopped. It is possible to change the enabled state programmatically at runtime via ComponentContext. The component is not ready to be started. See satisfied for the necessary criteria. This status can also be reached again if a component becomes unsatisfied. A component is in this state when it is enabled and the required referenced services are available. If the is used and configuration-policy=required is specified, a configuration object also needs to be available to bring a component to satisfied state. A component is in REGISTERED state if it SATISFIED and not yet requested. Only applies for delayed components. The component was activated due to immediate activation or, in case of a Delayed Component, it was requested. If the bundle is started, an OSGi component called SCR checks if the bundle contains component descriptions. It does that by reading the MANIFEST.MF and searching for Service-Components. If it finds one it will start to process the componentDescription and create a component configuration. If the configuration is enabled, it checks for required references and configurations if necessary. If all of these conditions are met, the component can be activated. An Immediate Component will activate as soon as its requirements are fulfilled. In contrast, a Delayed Component moves to the REGISTERED state, and waits for the first request to its provided service. If a Component Configuration contains dynamic references, the references can rebind in ACTIVE state, otherwise it will be re-activated. If a Component Configuration becomes unsatisfied (e.g. a bound service becomes unavailable), the Component Configuration will be deactivated. Note that a Delayed Component will also be deactivated and gets back to REGISTERED state if no other bundle references it anymore.\n\nOSGi service can define dependencies to other services. You can use the annotation to define (so-called event) methods to bind to these services and to update them. You can also use it on fields. Called to bind a new service to the component. For static references this method is called before the activate method. For dynamic references this method can also be called while the component is active. Called when the configuration properties of a bound service are modified. Called when the SCR needs to unbind the service. For static references this method is called after the deactivate method. For dynamic references this method can also be called while the component is active. The bind event methods are typically prefixed with either bind, set or add. The unbind method should have the corresponding prefixes unbind, unset or remove, so they are automatically picked up by @Reference. T OSGi allows to define multiple service implementations. To define the importance of them, it is possible to define a ranking for a service. This is done via a service property, called . By default, the service ranking is zero, the higher the ranking the more important is the service. The ranking order is defined as follows: Sorted on descending ranking order (highest first) If the ranking numbers are equal, sorted on ascending service.id property (oldest first) You can specify these properties via the @ServiceRanking annotation or the value. Frameworks like the Eclipse dependency injection framework automatically inject the service with the highest service ranking. As OSGi service component can be configured via key-value pairs (properties). These are accessed via a . These properties can be defined via the following ways:\n• via argument of the ComponentFactory.newInstance method if a factory is used These configurations options are processed in the above order, so a Java properties file can override inline configuration. The first three options are demonstrated in a later exercise. You can add properties to a declarative service component via the @Component annotation property type element. The value of that annotation type element is an array of Strings, which need to be given as key-value pairs in the format <name>(:<type>)?=<value> where the type information is optional and defaults to String. Another way to configure you OSGi services is to use a Java Properties File that is located inside the bundle. It can be specified via the @Component annotation properties type element, where the value needs to be an entry path relative to the root of the bundle. The configuration admin service allows to configure properties of services. It uses the PID (Persistent IDentity) of the service, which default to the fully qualified class name. You can also configure it via the configurationPid type element of the @Component annotation. The property of the annotation allows to configure, if a configuration is optional, required for ignored.\n• ConfigurationPolicy.OPTIONAL - Use the corresponding configuration object if present. This is the default value.\n• ConfigurationPolicy.REQUIRE - Configuration object must be present for the service to satisfy its requirements\n• ConfigurationPolicy.IGNORE - Ignore any corresponding configuration object even if it is present. This means that the component properties can not be changed dynamically using the configuration admin. To be able to handle changes in the configuration, you can use a method annotated with . If you do not do this, the service is stopped and restarted with the new configuration.\n\n7.1. Access to the OSGi console for your Eclipse application If you specify the -console parameter in your run configuration, you can use a console / terminal to interact with the OSGi console. The OSGi console is like a command-line shell. In this console you can type a command to perform an OSGi action. This can be useful to analyze problems on the OSGi layer of your application. Use, for example, the command to get an overview of all bundles, their status and bundle-id. The following table is a reference of the most important OSGi commands. Lists the installed bundles and their status. Lists bundles and their status that have vogella within their name. Starts the bundle with the <bundle-id> ID. Stops the bundle with the <bundle-id> ID. Diagnoses a particular bundle. It lists all missing dependencies. Uninstalls the bundle with the <bundle-id> ID. Shows information about the bundle with the <bundle-id> ID, including the registered and used services. Shows all available services and their consumers. Filter is an optional LDAP filter, e.g., to see all services which provide a ManagedService implementation use the \"services (objectclass=*ManagedService)\" command. Add the to keep the OSGi console running, even if the application fails to start. This is useful for error analysis. The following plug-ins are necessary to use the OSGi console. The easiest way to add them to your Eclipse application is to add them directly via the runtime configuration. If you want to access your application via a Telnet client, you can add another parameter to the parameter. This specifies the port to which you can connect via the telnet protocol. To access such an application, use a Telnet client. For instance, on Linux, use the command: . In an OSGi console accessed via telnet, you can use tab completion and a history of the commands similar to the Bash shell under Linux. The specification of the port must be used, if you want to access the OSGi console via the Console view of the Eclipse IDE. Use only for this. You can also access the OSGi console of your running Eclipse IDE. In the Console View you find a menu entry with the tooltip Open Console. If you select Host OSGi Console, you will have access to your running OSGi instance. Please note that interfering with your running Eclipse IDE via the OSGi console, may put the Eclipse IDE into a bad state. The plug-in development tooling (PDE) must be installed in Eclipse. If you can create plug-ins using the wizard, PDE is installed.\n\nTo manage the plug-ins included in the OSGi runtime, you can use a product configuration file. While the product is coming from the Eclipse IDE and RCP development point of view and is not perfect for OSGi development, it can still be handy to have one place to configure your run configuration. This product can also be used for a Maven Tycho command line build. In this exercise, you create one product based on features. If you have already an existing launch configuration you can use that to popular the feature. Open the file and switch to the _Included Plug-ins` tag. Ensure the following framework plug-ins are included in your file: Also ensure that your plug-in is part of the feature. Create a new project named com.vogella.osgi.runtime of type General via the Menu File New Project General Project menu entry. Right-click on the com.vogella.osgi.runtime project and select New Other…​ Plug-in Development Product Configuration. Create a product configuration file called osgi-runtime.product inside the main folder of the project using basis settings. Press the Finish button. The file is created and opened in an editor. On the Overview tab ensure the following settings: Leave the product and application empty. Product and Application are used in RCP products, and therefore not needed for a headless OSGi command line application. Also set that the product is based on features. On the Contents tab, add your feature as content. Equinox does not automatically activate any bundle. Bundles are only activated if a class is directly requested from it. But the service component runtime is never required directly. So you need to configure that it is activated, otherwise, org.apache.felix.scr will never get activated. Tells Equinox to skip trying to start an Eclipse application. The OSGi framework will not be shut down after the Eclipse application has ended. You can find further information about these properties in the Equinox Framework QuickStart Guide and the Eclipse Platform Help. The above configuration is used for the exported application. You also have to configure the parameters for the start from the IDE. When adding the parameters in the Launching tab instead of the Configuration tab, the configurations are added to the eclipse.ini in the root folder, not to the config.ini in the configuration folder. When starting the application via the exported jar, the eclipse.ini in the root folder is not inspected. Click on the Run button to start your OSGi command line application. If the system shows an validation error, that the application is not maintained, you can ignore that."
    }
]