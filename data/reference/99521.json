[
    {
        "link": "https://stackoverflow.com/questions/57620799/react-hook-useeffect-is-called-conditionally",
        "document": "you can not call hooks conditionally because React relies on the order in which Hooks are called\n\nyou can refer rules of hooks from react official docs https://reactjs.org/docs/hooks-rules.html#explanation\n\nExplanation we can use multiple State or Effect Hooks in a single component:\n\nSo how does React know which state corresponds to which useState call? The answer is that React relies on the order in which Hooks are called. Our example works because the order of the Hook calls is the same on every render:\n\nAs long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the persistForm effect) inside a condition?\n\nThe name !== '' condition is true on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition false. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:\n\nReact wouldn’t know what to return for the second useState Hook call. React expected that the second Hook call in this component corresponds to the persistForm effect, just like during the previous render, but it doesn’t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.\n\nThis is why Hooks must be called on the top level of our components. If we want to run an effect conditionally, we can put that condition inside our Hook:\n\nNote that you don’t need to worry about this problem if you use the provided lint rule. But now you also know why Hooks work this way, and which issues the rule is preventing."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://stackoverflow.com/questions/67827350/calling-a-react-hook-conditionally",
        "document": "I was just thinking about this today. I believe that while it 'breaks the rules', there's nothing that React could do to tell the difference between the two.\n\nSo while it breaks the rules, if you have a good enough reason, understand the risks, then the 'rules' is just dogma.\n\nReact basically knows which useEffect hook is which, by counting invocations. Calling conditionally is bad, specifically because the amount of times gets called cannot change.\n\nYour example is conditional, but React can't detect it because in either condition you call it once.\n\nHowever, the example you mention seems like it doesn't need this. There's good reasons to do things the 'normal' way, because as you can see from other commenters here, it causes confusion and surprise, and we don't like surprise =)\n\nIf you are lazily loading in some functionality, just have your hook call the function when it is ready."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let’s see how we can do the same with the Hook.\n\nWe’ve already seen this example at the top of this page, but let’s take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! Let’s compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let’s say we have a module that lets us subscribe to a friend’s online status. Here’s how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet’s see how we could write this component with Hooks.\n\nYou might be thinking that we’d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe’ve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don’t return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe’ll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don’t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn’t suffer from this bug. (But we also didn’t make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That’s our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You’ve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes — and where they don’t, you might find the additional Hooks helpful.\n\nWe’re also starting to see how Hooks solve problems outlined in Motivation. We’ve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We’ve also seen how we can separate effects by their purpose, which is something we couldn’t do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React “match up” previous and next effects on every update? On the next page we will learn about the Rules of Hooks — they’re essential to making Hooks work."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/12ubp76/how_to_call_custom_hook_conditionally",
        "document": "I got this custom hook where I want it to run only when is true. Right now I get this error: \" React Hook \"useTimeout\" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function. \" I also get another error message: \" Cannot find name 'handleMouseEnter'. \" , since custom hook is wrapped inside of useEffect. How can I solve this issue?"
    },
    {
        "link": "https://react.dev/reference/react/useState",
        "document": "Suppose the is . This handler calls three times: However, after one click, will only be rather than ! This is because calling the function does not update the state variable in the already running code. So each call becomes . To solve this problem, you may pass an updater function to instead of the next state: Here, is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state. There are no other queued updates, so React will store as the current state in the end. By convention, it’s common to name the pending state argument for the first letter of the state variable name, like for . However, you may also call it like or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. You might hear a recommendation to always write code like if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary. In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” at the beginning of the event handler. However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders). If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\n\nReact saves the initial state once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to instead: Notice that you’re passing , which is the function itself, and not , which is the result of calling it. If you pass a function to , React will only call it during initialization. React may call your initializers twice in development to verify that they are pure.\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes. In most cases, you don’t need this:\n• If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the Hook can help.\n• If you want to reset the entire component tree’s state, pass a different to your component.\n• If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a function while your component is rendering. Here’s an example. This component displays the prop passed to it: Say you want to show whether the counter has increased or decreased since the last change. The prop doesn’t tell you this — you need to keep track of its previous value. Add the state variable to track it. Add another state variable called to hold whether the count has increased or decreased. Compare with , and if they’re not equal, update both and . Now you can show both the current count prop and how it has changed since the last render.\n\nNote that if you call a function while rendering, it must be inside a condition like , and there must be a call like inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the function of another component during rendering is an error. Finally, your call should still update state without mutation — this doesn’t mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the function during render, React will re-render that component immediately after your component exits with a statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early to restart rendering earlier. Calling the function does not change state in the running code: This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the function: React will ignore your update if the next state is equal to the previous state, as determined by an comparison. This usually happens when you change an object or an array in state directly: You mutated an existing object and passed it back to , so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them: I’m getting an error: “Too many re-renders” You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once: This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. I’m trying to set state to a function, but it gets called instead You can’t put a function into state like this: Because you’re passing a function, React assumes that is an initializer function, and that is an updater function, so it tries to call them and store the result. To actually store a function, you have to put before them in both cases. Then React will store the functions you pass."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-state.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe introduction page used this example to get familiar with Hooks:\n\nWe’ll start learning about Hooks by comparing this code to an equivalent class example.\n\nIf you used classes in React before, this code should look familiar:\n\nThe state starts as , and we increment when the user clicks a button by calling . We’ll use snippets from this class throughout the page.\n\nAs a reminder, function components in React look like this:\n\nYou might have previously known these as “stateless components”. We’re now introducing the ability to use React state from these, so we prefer the name “function components”.\n\nHooks don’t work inside classes. But you can use them instead of writing classes.\n\nOur new example starts by importing the Hook from React:\n\nWhat is a Hook? A Hook is a special function that lets you “hook into” React features. For example, is a Hook that lets you add React state to function components. We’ll learn other Hooks later.\n\nWhen would I use a Hook? If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We’re going to do that right now!\n\nIn a class, we initialize the state to by setting to in the constructor:\n\nIn a function component, we have no , so we can’t assign or read . Instead, we call the Hook directly inside our component:\n\nWhat does calling do? It declares a “state variable”. Our variable is called but we could call it anything else, like . This is a way to “preserve” some values between the function calls — is a new way to use the exact same capabilities that provides in a class. Normally, variables “disappear” when the function exits but state variables are preserved by React.\n\nWhat do we pass to as an argument? The only argument to the Hook is the initial state. Unlike with classes, the state doesn’t have to be an object. We can keep a number or a string if that’s all we need. In our example, we just want a number for how many times the user clicked, so pass as initial state for our variable. (If we wanted to store two different values in state, we would call twice.)\n\nWhat does return? It returns a pair of values: the current state and a function that updates it. This is why we write . This is similar to and in a class, except you get them in a pair. If you’re not familiar with the syntax we used, we’ll come back to it at the bottom of this page.\n\nNow that we know what the Hook does, our example should make more sense:\n\nWe declare a state variable called , and set it to . React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current , we can call .\n\nWhen we want to display the current count in a class, we read :\n\nIn a function, we can use directly:\n\nIn a class, we need to call to update the state:\n\nIn a function, we already have and as variables so we don’t need :\n\nLet’s now recap what we learned line by line and check our understanding.\n• Line 1: We import the Hook from React. It lets us keep local state in a function component.\n• Line 4: Inside the component, we declare a new state variable by calling the Hook. It returns a pair of values, to which we give names. We’re calling our variable because it holds the number of button clicks. We initialize it to zero by passing as the only argument. The second returned item is itself a function. It lets us update the so we’ll name it .\n• Line 9: When the user clicks, we call with a new value. React will then re-render the component, passing the new value to it.\n\nThis might seem like a lot to take in at first. Don’t rush it! If you’re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to “forget” how state works in classes, and look at this code with fresh eyes, it will make sense.\n\nTip: What Do Square Brackets Mean?\n\nYou might have noticed the square brackets when we declare a state variable:\n\nThe names on the left aren’t a part of the React API. You can name your own state variables:\n\nThis JavaScript syntax is called “array destructuring”. It means that we’re making two new variables and , where is set to the first value returned by , and is the second. It is equivalent to this code:\n\nWhen we declare a state variable with , it returns a pair — an array with two items. The first item is the current value, and the second is a function that lets us update it. Using and to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.\n\nDeclaring state variables as a pair of is also handy because it lets us give different names to different state variables if we want to use more than one:\n\nIn the above component, we have , , and as local variables, and we can update them individually:\n\nYou don’t have to use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike in a class, updating a state variable always replaces it instead of merging it.\n\nWe provide more recommendations on splitting independent state variables in the FAQ.\n\nOn this page we’ve learned about one of the Hooks provided by React, called . We’re also sometimes going to refer to it as the “State Hook”. It lets us add local state to React function components — which we did for the first time ever!\n\nWe also learned a little bit more about what Hooks are. Hooks are functions that let you “hook into” React features from function components. Their names always start with , and there are more Hooks we haven’t seen yet.\n\nNow let’s continue by learning the next Hook: . It lets you perform side effects in components, and is similar to lifecycle methods in classes."
    },
    {
        "link": "https://geeksforgeeks.org/reactjs-usestate-hook",
        "document": "The useState hook is an alternative to the useReducer hook that is preferred when we require the basic update. useState Hooks are used to add the state variables in the components. For using the useState hook we have to import it in the component.\n• state: It is the value of the current state.\n• setState: It is the function that is used to update the state.\n• initialState: It is the initial value of the state.\n\nA common example of using useReducer is managing the state of a counter with actions to increment and decrement the value.\n\nIn this example\n• setCount(count + 1): Updates the state by adding 1 to the current value.\n\nuseState is also useful for handling form input fields dynamically.\n\nIn this example\n• useState(”): Initializes name and age with an empty string.\n• onChange={(e): setName(e.target.value)}: Updates name state as the user types.\n• Manages Simple State Easily: useState is ideal for managing simple state updates, such as toggling values, counters, and form inputs.\n• Functional Updates for Previous State: When updating state based on the previous state, always use a function to ensure the correct value:\n• Asynchronously updates the State: State updates in React are asynchronous, meaning that setState does not immediately reflect changes. Instead, updates are batched for performance.\n• State Does Not Merge Automatically: Unlike this.setState in class components, useState does not merge objects automatically. You must spread the previous state manually\n• Can Hold Any Data Type: useState is not limited to primitive values; it can store objects, arrays, or even functions\n• Lazy Initialization for Performance: If initializing state is expensive, you can use a function to compute it only once\n• State Updates Can Be Bypassed If the Same Value is Provided: React skips re-renders if you update the state with the same value\n\nWhen to Use useState\n\nWe should use the useState Hook when:\n• None We component has state that changes over time.\n• None The state does not require complex updates or dependencies.\n\nuseState and useReducer Hooks both are used for managing the state in the React, but in the different ways:\n• Avoid Re-Rendering Issues: useState updates the state asynchronously, which may cause unnecessary re-renders. To optimize this we can use functional updates for dependent state changes.\n• Optimize Large Component States: For complex states, use useReducer instead of useState to prevent unnecessary re-renders and improve performance.\n\nWhat is the useState Hook in React?\n\nHow do I update the state using useState?\n\nDoes useState merge the state like setState in class components?\n\nCan useState accept a function as an initial state?\n\nWhy is my useState update not reflecting immediately?"
    },
    {
        "link": "https://react.dev/learn/managing-state",
        "document": "Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset. Read More Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs! For example, this form has a redundant state variable:\n\nThis might seem like a small change, but many bugs in React apps are fixed this way. Read Choosing the State Structure to learn how to design the state shape to avoid bugs. Read More Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.\n\nRead Sharing State Between Components to learn how to lift state up and keep components in sync. Read More When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:\n\nReact lets you override the default behavior, and force a component to reset its state by passing it a different , like . This tells React that if the recipient is different, it should be considered a different component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.\n\nRead Preserving and Resetting State to learn the lifetime of state and how to control it. Read More Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!\n\nRead Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function. Read More Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props. Here, the component determines its heading level by “asking” the closest for its level. Each tracks its own level by asking the parent and adding one to it. Every provides information to all components below it without passing props—it does that through context.\n\nRead Passing Data Deeply with Context to learn about using context as an alternative to passing props. Read More Scaling up with reducer and context Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state."
    },
    {
        "link": "https://hygraph.com/blog/usestate-react",
        "document": "React is a free, open-source JavaScript frontend library that we can use to build frontend applications. Before React v16.8 in 2019, developers always used class components for data management (with states) and other operations like lifecycle methods, and functional components were only to be used for rendering UI.\n\nSince the introduction of React Hooks in React v16.8, we can manage data via states in functional components and work with lifecycle methods. Over time, class components were outdated and deprecated in React. Functional components along with Hooks are the new standard way to write React components.\n\nWhenever an interaction happens, react components often need to change and show the latest data after an interaction. For instance, typing in a form should update the input field with whatever the user typed, clicking “next page” should change the page content, and clicking “Add contact” should add the new contact to the existing contact list.\n\nTo update the UI, components first need to “remember” these things: the current input value, the current page, and the current contact list. This kind of component-specific memory is called state.\n\nIn this code above, we have defined a local variable and an increment button, which tries to increment the count value by one every time it is clicked. However, if we try to run this code and click the increment button it doesn’t work as expected. This happens due to two reasons\n• The value of a local variable does not persist across renders, meaning that on every re-render count will be re-initialized to 0.\n• Local variables do not trigger re-renders, so when we click the Increment button, React would not detect a state change and would not re-render our component.\n\nWe need to have “state” here instead of the local variable to manage the memory of a component.\n• Allows us to obtain a state variable, this is a special variable that is capable of retaining data between renders.\n• Provides us with a setter function to update the state variable and hence trigger a re-render of our component.\n\nWe can import the useState hook from react. The useState() hook takes in the initial value of the state variable as an argument and provides us with the state variable and the setter function. The variable could be of any data type, such as string, number, object, array, and more.\n\nThis setter function can be called anything, but it is a general practice to use the variable name with a prefix of . For example - name, setName | count, setCount | and so on.\n\nTo fix our CounterExample component where we could not see the updates in the UI we can use the useState hook. Here’s how we can use it to fix the situation:\n\nGoing a step further, we should understand that the setter function will always have access to the value of the state variable in the current render. Let us take the example of the counter component we have built above. Try adding some logs before and after calling the setCount and hit the increment button:\n\nYou might have expected it to print 1 in the After Set Count, but it logged a 0 there as well.\n\nThis happens because in the entire execution context of the handleClick function, the value of count was initially 0 and the operations by setCount will take effect in the next render.\n\nNext, let us take a look at this function below:\n\nOkay, two questions arise here:\n• What do you think will be printed in the logs?\n• What will be the value of the count variable in the next render?\n\nFor 1, it will print 0 as the function will have access to the count value of the current render.\n\nFor 2, the value of count in the next render will be 1 and not 3, even though we called thrice.\n\nThis is what actually happens, we are just calling thrice.\n\nYou may run into a situation where you want to access the latest value of a state variable and update it in that case you can use updater functions as shown below:\n\nAs you can see, instead of passing a value to setCount we passed a function, this function gets the latest value of the variable as a parameter and returns an incremented value and this is how it will behave:\n\nAt times we need to store many things for a particular entity, for example - we can choose to have name, age, and hobby as state variables for a person.\n\nInstead of creating three different state variables, it would be better to create an object that stores the state of a person. We can combine name, age, and hobby properties into an object state and use it as shown in the template.\n\nSo far we have seen numbers, and strings as state variables, these JavaScript values are “immutable”, so if we replace them we can trigger a re-render.\n\nWhen we set the distance from to , the value itself doesn’t change. is still\n\nBut when we do something as shown below, we are the state, and the original object itself changes. This is known as a . This is not allowed and would not lead React to re-render our component.\n\nIt is important to remember that we cannot mutate a state variable of type objects/arrays. We always need to replace them entirely or use the spread operator.\n\nSimilarly, we can use arrays to store some data as shown\n\nWhen updating the array state, we must avoid methods like , , , , , , and as these methods mutate the original array. Instead, we should use options like , , , , and as these methods return an entirely new array.\n\nis a hook, so just like any other hook, we should only use the useState() hook at the top level of our component: We should not use it inside any function, loop, nested function, or conditions. This helps React preserve and call hooks in the same order each time a component renders.\n\nIn this guide, we have learned what state is and why it is important, we learned about the useState() hook from React which helps us to manage a component’s memory. We also learned about the lifecycle of a state variable and how the new state value is enforced after a component’s re-render. Finally, we checked how to use objects and arrays as state variables and wrapped up by going through a few caveats about using hooks."
    }
]