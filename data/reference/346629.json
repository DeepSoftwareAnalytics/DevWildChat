[
    {
        "link": "https://geeksforgeeks.org/g-fact-21-increment-and-decrement-operators-in-python",
        "document": "If you’re familiar with Python, you would have known Increment and Decrement operators ( both pre and post) are not allowed in it. Python is designed to be consistent and readable. One common error by a novice programmer in languages with ++ and — operators are mixing up the differences (both in precedence and in return value) between pre and post-increment/decrement operators. Simple increment and decrement operators aren’t needed as much as in other languages. In this article, we will see how to increment in Python as well as decrement in Python.\n\nIn Python, we can achieve incrementing by using Python ‘+=’ operator. This operator adds the value on the right to the variable on the left and assigns the result to the variable. In this section, we will see how use Increment Operator in Python.\n\nFor normal usage, instead of i++, if you are increasing the count, you can use\n\nIn this example, a variable is initialized with the value 5. The operator is then used to increment the variable by 1, and the result is displayed, showcasing a concise way to perform the increment operation in Python.\n\nWe do not have a specific decrement operator in Python (like in some other programming languages). However, you can achieve decrementing a variable using the operator. This operator subtracts the value on the right from the variable on the left and assigns the result to the variable.\n\nFor normal usage, instead of i–, if you are increasing the count, you can use\n\nDecrement and Increment Operator With for loop\n\nIn Python, instead, we write it like the below and the syntax is as follows:\n\nWe can adjust start and stop with help of Python decrement and increment operators.\n\nIn this example, the Python increment operator ( ) is demonstrated by incrementing the variable by one. Additionally, the function is utilized in a for loop to showcase both incrementing and decrementing loops, providing a Pythonic alternative to traditional increment and decrement operators found in some other programming languages."
    },
    {
        "link": "https://stackoverflow.com/questions/1485841/behaviour-of-increment-and-decrement-operators-in-python",
        "document": "Why does ++count run, but not change the value of the variable?\n\nHow do I use pre-increment/decrement operators ( ++ , -- ), just like in C++?\n\nis not an operator. It is two operators. The operator is the identity operator, which does nothing. (Clarification: the and unary operators only work on numbers, but I presume that you wouldn't expect a hypothetical operator to work on strings.) You have to use the slightly longer operator to do what you want to do: I suspect the and operators were left out for consistency and simplicity. I don't know the exact argument Guido van Rossum gave for the decision, but I can imagine a few arguments:\n• Simpler parsing. Technically, parsing is ambiguous, as it could be , , (two unary operators) just as easily as it could be , (one unary operator). It's not a significant syntactic ambiguity, but it does exist.\n• Simpler language. is nothing more than a synonym for . It was a shorthand invented because C compilers were stupid and didn't know how to optimize into the instruction most computers have. In this day of optimizing compilers and bytecode interpreted languages, adding operators to a language to allow programmers to optimize their code is usually frowned upon, especially in a language like Python that is designed to be consistent and readable.\n• Confusing side-effects. One common newbie error in languages with operators is mixing up the differences (both in precedence and in return value) between the pre- and post-increment/decrement operators, and Python likes to eliminate language \"gotcha\"-s. The precedence issues of pre-/post-increment in C are pretty hairy, and incredibly easy to mess up.\n\nPython does not have pre and post increment operators. In Python, integers are immutable. That is you can't change them. This is because the integer objects can be used under several names. Try this: a and b above are actually the same object. If you incremented a, you would also increment b. That's not what you want. So you have to reassign. Like this: Many C programmers who used python wanted an increment operator, but that operator would look like it incremented the object, while it actually reassigns it. Therefore the and operators where added, to be shorter than the , while being clearer and more flexible than , so most people will increment with: Which will reassign to . That is not an increment operator, because it does not increment , it reassigns it. In short: Python behaves differently here, because it is not C, and is not a low level wrapper around machine code, but a high-level dynamic language, where increments don't make sense, and also are not as necessary as in C, where you use them every time you have a loop, for example.\n\nWhile the others answers are correct in so far as they show what a mere usually does (namely, leave the number as it is, if it is one), they are incomplete in so far as they don't explain what happens. To be exact, evaluates to and to . I could imagine a VERY weird class structure (Children, don't do this at home!) like this:\n\nIn python 3.8+ you can do : You can do a lot of thinks with this. Or if you want write somthing with more sophisticated syntaxe (the goal is not optimization): >>> del a >>> while (a := (a if 'a' in locals() else 0) + 1) < 5: print(a) 1 2 3 4 It will return 0 even if 'a' doesn't exist without errors, and then will set it to 1\n\nPython does not have unary increment/decrement operators ( / ). Instead, to increment a value, use But be careful here. If you're coming from C, even this is different in python. Python doesn't have \"variables\" in the sense that C does, instead python uses names and objects, and in python s are immutable. What this means in python is: create an object of type having value and bind the name to it. The object is an instance of having value , and the name refers to it. The name and the object to which it refers are distinct. Since s are immutable, what happens here is as follows:\n• look up the object that refers to (it is an with id )\n• look up the value of object (it is )\n• add 1 to that value (1 + 1 = 2)\n• create a new object with value (it has object id )\n• rebind the name to this new object\n• Now refers to object and the original object ( ) is no longer refered to by the name . If there aren't any other names refering to the original object it will be garbage collected later.\n\nPython does not have these operators, but if you really need them you can write a function having the same functionality. def PreIncrement(name, local={}): #Equivalent to ++name if name in local: local[name]+=1 return local[name] globals()[name]+=1 return globals()[name] def PostIncrement(name, local={}): #Equivalent to name++ if name in local: local[name]+=1 return local[name]-1 globals()[name]+=1 return globals()[name]-1 x = 1 y = PreIncrement('x') #y and x are both 2 a = 1 b = PostIncrement('a') #b is 1 and a is 2 Inside a function you have to add locals() as a second argument if you want to change local variable, otherwise it will try to change global. x = 1 def test(): x = 10 y = PreIncrement('x') #y will be 2, local x will be still 10 and global x will be changed to 2 z = PreIncrement('x', locals()) #z will be 11, local x will be 11 and global x will be unaltered test() Also with these functions you can do: But in my opinion following approach is much clearer: def PreDecrement(name, local={}): #Equivalent to --name if name in local: local[name]-=1 return local[name] globals()[name]-=1 return globals()[name] def PostDecrement(name, local={}): #Equivalent to name-- if name in local: local[name]-=1 return local[name]+1 globals()[name]-=1 return globals()[name]+1 I used these functions in my module translating javascript to python.\n\nYeah, I missed ++ and -- functionality as well. A few million lines of c code engrained that kind of thinking in my old head, and rather than fight it... Here's a class I cobbled up that implements: pre- and post-increment, pre- and post-decrement, addition, subtraction, multiplication, division, results assignable as integer, printable, settable. You might use it like this: c = counter() # defaults to zero for listItem in myList: # imaginary task doSomething(c.postinc(),listItem) # passes c, but becomes c+1 ...already having c, you could do this... ...and for (re-)assignment into integer... c = counter(100) d = c + 223 # assignment as integer c = c + 223 # re-assignment as integer print type(c),c # <type 'int'> 323 ...while this will maintain c as type counter: And then there's this bit of unexpected (and thoroughly unwanted) behavior, c = counter(42) s = '%s: %d' % ('Expecting 42',c) # but getting non-numeric exception print s ...because inside that tuple, getitem() isn't what used, instead a reference to the object is passed to the formatting function. Sigh. So: c = counter(42) s = '%s: %d' % ('Expecting 42',c.v) # and getting 42. print s ...or, more verbosely, and explicitly what we actually wanted to happen, although counter-indicated in actual form by the verbosity (use instead)... c = counter(42) s = '%s: %d' % ('Expecting 42',c.__getitem__()) # and getting 42. print s"
    },
    {
        "link": "https://discuss.python.org/t/increment-decrement-can-we-have-inc-dec-functions-in-python-feature-request/21641?page=2",
        "document": "No. It is nothing like . I’ve already given code using Python syntax that shows how Pascal and work. Unfortunately you can’t run that code, because they are don’t work in Python, but you can surely follow the input and the expected result. x = 15 inc(x) # There is NO ASSIGNMENT HERE. assert x == 16 # But like magic, x has a new value! How??? We can’t write a full implementation of because Python doesn’t work that way, but we can almost simulate a partial implementation: def inc(name): # Only works with globals :-( g = globals() g[name] += 1 return None x = 15 inc('x') # We have to quote the name (use a string). assert x == 16 But this is a pale shadow of the Pascal :\n• the real does not need you to quote the variable name;\n• nor does it limit you to just globals;\n• it works with any namespace or variable scope;\n• and of course any variable, not just “x”. Pascal’s and are merely special cases of a more general technique which Pascal supports, but Python doesn’t: pass by reference. Of course we can get the same effect. We just have to use assignment: So we’re not really losing any functionality, we just have to write it a different way.\n\nI know you’re kidding around, but beware that in Python 3 is an arbitrary-precision integer which is usually built with 30-bit ‘digits’. Thus this code will fail on a digit boundary such as , and it will probably cause a segfault (access violation) when it tries to write beyond the allocated memory of . Anyway, in Pascal has nothing to do with modifying the numerical value of an integer object. Pascal is working with primitive integers, for which the values and rules for signed and unsigned integers are implemented in the instruction set architecture and hardware. Python doesn’t have primitive types, but the type is immutable to make it behave like a primitive. What prevents implementing from being implemented as a pure Python function is the lack of call by reference, such as the C++ function declaration . Python uses names in namespaces instead of integer addresses in an address space. Thus a variable reference in Python would be the combination of a variable name and its namespace. To support call by reference in general, a frame’s would need to be implemented as a custom mapping object that supports modifying a frame’s fast locals and cell objects. It’s a moot point, however, because it’s unlikely that Python would ever support call by reference given it already supports lexical closures. Using a closure is more limited in regards to function parameters, but the lexical context makes it easier to understand when reading and debugging code.\n\nEven if they are not alike per se, I struggle to conceive of a use case where can do something that an iterator cannot do already. Are you trolling? I’ve demonstrated what does at least twice, and the OP linked to documentation for it. It has nothing to do with iteration. Here is a use-case: you have a variable, . You want to increase the width of the line by one pixel, by incrementing the value of by 1. How do you do that with an iterator? Traditionally, in Python, we would just write , and that’s fine. If the variable is in a different namespace, we might prefer this: because it avoids needing to type out the fully resolved variable name, but that’s essentially just syntactic sugar to save some typing. Just because we might put inside a loop doesn’t mean that incrementing by 1 is related to iteration. We can put inside a loop too, doesn’t mean that there’s nothing import can do that an iterator can’t do.\n\nI think the Python equivalent for the Pascal and procedures would be object methods such as and . These methods can not work for immutable objects, of course, simply because immutable objects, by definition, cannot be changed. However you could create a mutable class that wraps an immutable object and achieves the behaviour you want. Something like this might work for integers class UserInt: def __init__(self, value=0, base=10): if isinstance(value, str): self._value = int(x, base) else: self._value = int(value) def __int__(self): return self._value def inc(self, increment=1): self._value +=int(increment) # __add__, etc. See emulating-numeric-types. You would have to use everywhere you were using to create objects of this type instead of objects of int type, for both literal values and non-literal values. You would have to duplicate this for each of the numeric types. Personally, I think it would be easier to adapt to using the C/C++ style increment and decrement operators. I recall transitioning from Fortran to Pascal to C to Python, with assembler, Pilot, Perl, SQL, Go, Rust along the way. It gets easier.\n\nPersonally, I think it would be easier to adapt to using the C/C++ style increment and decrement operators. I recall transitioning from Fortran to Pascal to C to Python, with assembler, Pilot, Perl, SQL, Go, Rust along the way. It gets easier. What you’re saying is: it’s easier to learn Python than to try to force Pascal idioms to work inside Python Personally, I found it minorly irksome that I couldn’t use in Python, but it turns out, there are actually not that many situations where post-incrementing is necessary. It would be kinda nice for some algorithms, but it’s far from crucial. Other forms of incrementing are even less important - a stand-alone statement or can be written as without much loss of clarity, and pre-incrementing isn’t really all that common."
    },
    {
        "link": "https://inventwithpython.com/blog/2018/05/21/pythons-fake-increment-and-decrement-operators",
        "document": "In Python, you can increase the value of a variable by or reduce it by using the augmented assignment operators. The code and increments and decrements the numeric values in by , respectively.\n\nOther languages such as C++ and Java have the and operators for incrementing and decrementing variables. (The name of C++ itself reflects this; the name is a tongue-in-cheek joke that indicates it's an enhanced form of the C language.) Code in C++ and Java could have or . Python wisely doesn't include these operators; they are notoriously susceptible to subtle bugs.\n\nHowever, it is perfectly legal to have the following Python code:\n\nThe first thing you notice is that the and \"operators\" in Python don't actually increment or decrement the value in . Rather, the leading is Python's unary negation operator. It allows you to have code like this:\n\nThis is a quite silly thing to do, and you won't ever see a unary negation operator used twice in real-world code. (Though if you did, it's probably because the programmer learned to program in another language has just written buggy Python code!) There is also a unary operator. It evaluates an integer value to the same sign as the original value, which is to say, it does absolutely nothing:\n\nBeing able to write (or ) seems just as silly as , so why does Python even have this unary operator? It exists only to complement the operator if you need to overload these operators for your own classes. (See the documentation for the special method.)\n\nThe and unary operators are only valid when in front of a Python value, not after it. While and might be legal code in C++ or Java, they produce syntax errors in Python:\n\nPython doesn't have increment and decrement operators, it's only a quirk of the langauge syntax that can make it seem like it does."
    },
    {
        "link": "https://runestone.academy/ns/books/published/fopp/SimplePythonData/UpdatingVariables.html",
        "document": "One of the most common forms of reassignment is an update where the new value of the variable depends on the old. For example,\n\nThis means get the current value of x, add one, and then update x with the new value. The new value of x is the old value of x plus 1. Although this assignment statement may look a bit strange, remember that executing assignment is a two-step process. First, evaluate the right-hand side expression. Second, let the variable name on the left-hand side refer to this new resulting object. The fact that appears on both sides does not matter. The semantics of the assignment statement makes sure that there is no confusion as to the result. The visualizer makes this very clear.\n\nIf you try to update a variable that doesn’t exist, you get an error because Python evaluates the expression on the right side of the assignment operator before it assigns the resulting value to the name on the left. Before you can update a variable, you have to initialize it, usually with a simple assignment. In the above example, was initialized to 6.\n\nUpdating a variable by adding something to it is called an increment; subtracting is called a decrement. Sometimes programmers talk about incrementing or decrementing without specifying by how much; when they do they usually mean by 1. Sometimes programmers also talk about bumping a variable, which means the same as incrementing it by 1.\n\nIncrementing and decrementing are such common operations that programming languages often include special syntax for it. In Python is used for incrementing, and for decrementing. In some other languages, there is even a special syntax and for incrementing or decrementing by 1. Python does not have such a special syntax. To increment x by 1 you have to write or .\n\nImagine that we wanted to not increment by one each time but instead add together the numbers one through ten, but only one at a time.\n\nAfter the initial statement, where we assign to 1, we can add the current value of and the next number that we want to add (2 all the way up to 10) and then finally reassign that that value to so that the variable is updated after each line in the code.\n\nThis will be tedious when we have many things to add together. Later you’ll read about an easier way to do this kind of task."
    },
    {
        "link": "https://realpython.com/python-operators-expressions",
        "document": "Python operators enable you to perform computations by combining objects and operators into expressions. Understanding Python operators is essential for manipulating data effectively.\n\nThis tutorial covers arithmetic, comparison, Boolean, identity, membership, bitwise, concatenation, and repetition operators, along with augmented assignment operators. You’ll also learn how to build expressions using these operators and explore operator precedence to understand the order of operations in complex expressions.\n\nBy the end of this tutorial, you’ll understand that:\n• Identity operators determine if two operands refer to the same object.\n• Membership operators check for the presence of a value in a container.\n\nThis tutorial provides a comprehensive guide to Python operators, empowering you to create efficient and effective expressions in your code. To get the most out of this tutorial, you should have a basic understanding of Python programming concepts, such as variables, assignments, and built-in data types.\n\nGetting Started With Operators and Expressions In programming, an operator is usually a symbol or combination of symbols that allows you to perform a specific operation. This operation can act on one or more operands. If the operation involves a single operand, then the operator is unary. If the operator involves two operands, then the operator is binary. For example, in Python, you can use the minus sign ( ) as a unary operator to declare a negative number. You can also use it to subtract two numbers: In this code snippet, the minus sign ( ) in the first example is a unary operator, and the number is the operand. In the second example, the same symbol is a binary operator, and the numbers and are its left and right operands. Programming languages typically have operators built in as part of their syntax. In many languages, including Python, you can also create your own operator or modify the behavior of existing ones, which is a powerful and advanced feature to have. In practice, operators provide a quick shortcut for you to manipulate data, perform mathematical calculations, compare values, run Boolean tests, assign values to variables, and more. In Python, an operator may be a symbol, a combination of symbols, or a keyword, depending on the type of operator that you’re dealing with. For example, you’ve already seen the subtraction operator, which is represented with a single minus sign ( ). The equality operator is a double equal sign ( ). So, it’s a combination of symbols: In this example, you use the Python equality operator ( ) to compare two numbers. As a result, you get , which is one of Python’s Boolean values. Speaking of Boolean values, the Boolean or logical operators in Python are keywords rather than signs, as you’ll learn in the section about Boolean operators and expressions. So, instead of the odd signs like , , and that many other programming languages use, Python uses , , and . Using keywords instead of odd signs is a really cool design decision that’s consistent with the fact that Python loves and encourages code’s readability. You’ll find several categories or groups of operators in Python. Here’s a quick list of those categories: All these types of operators take care of specific types of computations and data-processing tasks. You’ll learn more about these categories throughout this tutorial. However, before jumping into more practical discussions, you need to know that the most elementary goal of an operator is to be part of an expression. Operators by themselves don’t do much: As you can see in this code snippet, if you use an operator without the required operands, then you’ll get a syntax error. So, operators must be part of expressions, which you can build using Python objects as operands. So, what is an expression anyway? Python has simple and compound statements. A simple statement is a construct that occupies a single logical line, like an assignment statement. A compound statement is a construct that occupies multiple logical lines, such as a loop or a conditional statement. An expression is a simple statement that produces and returns a value. You’ll find operators in many expressions. Here are a few examples: In the first two examples, you use the addition and division operators to construct two arithmetic expressions whose operands are integer numbers. In the last example, you use the equality operator to create a comparison expression. In all cases, you get a specific value after executing the expression. Note that not all expressions use operators. For example, a bare function call is an expression that doesn’t require any operator: In the first example, you call the built-in function to get the absolute value of . Then, you compute to the power of using the built-in function. These function calls occupy a single logical line and return a value. So, they’re expressions. Finally, the call to the built-in function is another expression. This time, the function doesn’t return a fruitful value, but it still returns , which is the Python null type. So, the call is technically an expression. Note: All Python functions have a return value, either explicit or implicit. If you don’t provide an explicit statement when defining a function, then Python will automatically make the function return . Even though all expressions are statements, not all statements are expressions. For example, pure assignment statements don’t return any value, as you’ll learn in a moment. Therefore, they’re not expressions. The assignment operator is a special operator that doesn’t create an expression but a statement. Note: Since version 3.8, Python also has what it calls assignment expressions. These are special types of assignments that do return a value. You’ll learn more about this topic in the section The Walrus Operator and Assignment Expressions. Okay! That was a quick introduction to operators and expressions in Python. Now it’s time to dive deeper into the topic. To kick things off, you’ll start with the assignment operator and statements.\n\nThe Python comparison operators allow you to compare numerical values and any other objects that support them. The table below lists all the currently available comparison operators in Python:\n• if the value of is equal to the value of\n• otherwise\n• if isn’t equal to\n• otherwise\n• if is less than\n• otherwise Less than or equal to\n• if is less than or equal to\n• otherwise\n• if is greater than\n• otherwise Greater than or equal to\n• if is greater than or equal to\n• otherwise The comparison operators are all binary. This means that they require left and right operands. These operators always return a Boolean value ( or ) that depends on the truth value of the comparison at hand. Note that comparisons between objects of different data types often don’t make sense and sometimes aren’t allowed in Python. For example, you can compare a number and a string for equality with the operator. However, you’ll get as a result: The integer isn’t equal to the string . Therefore, you get as a result. You can also use the operator in the above expression, in which case you’ll get as a result. Non-equality comparisons between operands of different data types raise a exception: : '<' not supported between instances of 'int' and 'str' In this example, Python raises a exception because a less than comparison ( ) doesn’t make sense between an integer and a string. So, the operation isn’t allowed. It’s important to note that in the context of comparisons, integer and floating-point values are compatible, and you can compare them. You’ll typically use and find comparison operators in Boolean contexts like conditional statements and loops. They allow you to make decisions and define a program’s control flow. The comparison operators work on several types of operands, such as numbers, strings, tuples, and lists. In the following sections, you’ll explore the differences. Probably, the more straightforward comparisons in Python and in math are those involving integer numbers. They allow you to count real objects, which is a familiar day-to-day task. In fact, the non-negative integers are also called natural numbers. So, comparing this type of number is probably pretty intuitive, and doing so in Python is no exception. Consider the following examples that compare integer numbers: In the first set of examples, you define two variables, and , to run a few comparisons between them. The value of is less than the value of . So, every comparison expression returns the expected Boolean value. The second set of examples uses two values that are equal, and again, you get the expected results. Comparing floating-point numbers is a bit more complicated than comparing integers. The value stored in a object may not be precisely what you’d think it would be. For that reason, it’s bad practice to compare floating-point values for exact equality using the operator. Consider the example below: Yikes! The internal representation of this addition isn’t exactly equal to , as you can see in the final example. So, comparing to with the equality operator returns . To compare floating-point numbers for equality, you need to use a different approach. The preferred way to determine whether two floating-point values are equal is to determine whether they’re close to one another, given some tolerance. The module from the standard library provides a function conveniently called that will help you with comparison. The function takes two numbers and tests them for approximate equality: In this example, you use the function to compare and for approximate equality. This time, you get as a result because both numbers are close enough to be considered equal. For further details on using , check out the Find the Closeness of Numbers With Python section in The Python Module: Everything You Need to Know. You can also use the comparison operators to compare Python strings in your code. In this context, you need to be aware of how Python internally compares string objects. In practice, Python compares strings character by character using each character’s Unicode code point. Unicode is Python’s default character set. You can use the built-in function to learn the Unicode code point of any character in Python. Consider the following examples: The uppercase has a lower Unicode point than the lowercase . So, is less than . In the end, Python compares characters using integer numbers. So, the same rules that Python uses to compare integers apply to string comparison. When it comes to strings with several characters, Python runs the comparison character by character in a loop. The comparison uses lexicographical ordering, which means that Python compares the first item from each string. If their Unicode code points are different, this difference determines the comparison result. If the Unicode code points are equal, then Python compares the next two characters, and so on, until either string is exhausted: In this example, Python compares both operands character by character. When it reaches the end of the string, it compares and . Because the lowercase letter has a greater Unicode code point, the first version of the string is greater than the second. You can also compare strings of different lengths: In this example, Python runs a character-by-character comparison as usual. If it runs out of characters, then the shorter string is less than the longer one. This also means that the empty string is the smallest possible string. In your Python journey, you can also face the need to compare lists with other lists and tuples with other tuples. These data types also support the standard comparison operators. Like with strings, when you use a comparison operator to compare two lists or two tuples, Python runs an item-by-item comparison. Note that Python applies specific rules depending on the type of the contained items. Here are some examples that compare lists and tuples of integer values: In these examples, you compare lists and tuples of numbers using the standard comparison operators. When comparing these data types, Python runs an item-by-item comparison. For example, in the first expression above, Python compares the in the left operand and the in the right operand. Because they’re equal, Python continues comparing and to conclude that both lists are equal. The same thing happens in the second example, where you compare tuples containing the same data. It’s important to note that you can actually compare lists to tuples using the and operators. However, you can’t compare lists and tuples using the , , , and operators: : '>' not supported between instances of 'list' and 'tuple' : '<=' not supported between instances of 'list' and 'tuple' Python supports equality comparison between lists and tuples. However, it doesn’t support the rest of the comparison operators, as you can conclude from the final two examples. If you try to use them, then you get a telling you that the operation isn’t supported. You can also compare lists and tuples of different lengths: In the first two examples, you get as a result because is less than . That fact is sufficient for Python to solve the comparison. In the second pair of examples, you get . This result makes sense because the compared sequences don’t have the same length, so they can’t be equal. In the final pair of examples, Python compares with . They’re equal, so the comparison continues. Because there are no more values to compare in the right-hand operands, Python concludes that the left-hand operands are greater. As you can see, comparing lists and tuples can be tricky. It’s also an expensive operation that, in the worst case, requires traversing two entire sequences. Things get more complex and expensive when the contained items are also sequences. In those situations, Python will also have to compare items in a value-by-value manner, which adds cost to the operation.\n\nPython has three Boolean or logical operators: , , and . They define a set of operations denoted by the generic operators , , and . With these operators, you can create compound conditions. In the following sections, you’ll learn how the Python Boolean operators work. Especially, you’ll learn that some of them behave differently when you use them with Boolean values or with regular objects as operands. You’ll find many objects and expressions that are of Boolean type or , as Python calls this type. In other words, many objects evaluate to or , which are the Python Boolean values. For example, when you evaluate an expression using a comparison operator, the result of that expression is always of type: In this example, the expression returns a Boolean value, which you store in the variable. Now is of type, as you can see after calling the built-in function. You can also find Python built-in and custom functions that return a Boolean value. This type of function is known as a predicate function. The built-in , , , and functions are all good examples of this practice. Consider the following examples: In this code snippet, you first define a variable called using your old friend the assignment operator. Then you create another variable called . This variable holds a tuple of expressions. The first expression uses to check whether is an integer value. The second is a compound expression that combines the modulo ( ) and equality ( ) operators to create a condition that checks whether the input value is an even number. In this condition, the modulo operator returns the remainder of dividing by , and the equality operator compares the result with , returning or as the comparison’s result. Then you use the function to determine if all the conditions are true. In this example, because , the conditions are true, and returns . You can play with the value of if you’d like to experiment a bit. In the final two examples, you use the function. As its name suggests, this function allows you to determine whether an object is callable. Being callable means that you can call the object with a pair of parentheses and appropriate arguments, as you’d call any Python function. The variable isn’t callable, and the function returns , accordingly. In contrast, the function is callable, so returns . All the previous discussion is the basis for understanding how the Python logical operators work with Boolean operands. Logical expressions involving , , and are straightforward when the operands are Boolean. Here’s a summary. Note that and represent Boolean operands:\n• if both and are\n• otherwise\n• if either or is\n• otherwise\n• if is\n• if is This table summarizes the truth value of expressions that you can create using the logical operators with Boolean operands. There’s something to note in this summary. Unlike and , which are binary operators, the operator is unary, meaning that it operates on one operand. This operand must always be on the right side. Now it’s time to take a look at how the operators work in practice. Here are a few examples of using the operator with Boolean operands: In the first example, both operands return . Therefore, the expression returns as a result. In the second example, the left-hand operand is , but the right-hand operand is . Because of this, the operator returns . In the third example, the left-hand operand is . In this case, the operator immediately returns and never evaluates the condition. This behavior is called short-circuit evaluation. You’ll learn more about it in a moment. Note: Short-circuit evaluation is also called McCarthy evaluation in honor of computer scientist John McCarthy. In the final example, both conditions return . Again, returns as a result. However, because of the short-circuit evaluation, the right-hand expression isn’t evaluated. What about the operator? Here are a few examples that demonstrate how it works: In the first three examples, at least one of the conditions returns . In all cases, the operator returns . Note that if the left-hand operand is , then applies short-circuit evaluation and doesn’t evaluate the right-hand operand. This makes sense. If the left-hand operand is , then already knows the final result. Why would it need to continue the evaluation if the result won’t change? In the final example, both operands are , and this is the only situation where returns . It’s important to note that if the left-hand operand is , then has to evaluate the right-hand operand to arrive at a final conclusion. Finally, you have the operator, which negates the current truth value of an object or expression: If you place before an expression, then you get the inverse truth value. When the expression returns , you get . When the expression evaluates to , you get . There is a fundamental behavior distinction between and the other two Boolean operators. In a expression, you always get a Boolean value as a result. That’s not always the rule that governs and expressions, as you’ll learn in the Boolean Expressions Involving Other Types of Operands section. In practice, most Python objects and expressions aren’t Boolean. In other words, most objects and expressions don’t have a or value but a different type of value. However, you can use any Python object in a Boolean context, such as a conditional statement or a loop. In Python, all objects have a specific truth value. So, you can use the logical operators with all types of operands. Python has well-established rules to determine the truth value of an object when you use that object in a Boolean context or as an operand in an expression built with logical operators. Here’s what the documentation says about this topic: By default, an object is considered true unless its class defines either a method that returns or a method that returns zero, when called with the object. Here are most of the built-in objects considered false:\n• constants defined to be false: and .\n• zero of any numeric type: , , , , You can determine the truth value of an object by calling the built-in function with that object as an argument. If returns , then the object is truthy. If returns , then it’s falsy. For numeric values, you have that a zero value is falsy, while a non-zero value is truthy: Python considers the zero value of all numeric types falsy. All the other values are truthy, regardless of how close to zero they are. Note: Instead of a function, is a class. However, because Python developers typically use this class as a function, you’ll find that most people refer to it as a function rather than as a class. Additionally, the documentation lists this class on the built-in functions page. This is one of those cases where practicality beats purity. When it comes to evaluating strings, you have that an empty string is always falsy, while a non-empty string is truthy: Note that strings containing white spaces are also truthy in Python’s eyes. So, don’t confuse empty strings with whitespace strings. Finally, built-in container data types, such as lists, tuples, sets, and dictionaries, are falsy when they’re empty. Otherwise, Python considers them truthy objects: To determine the truth value of container data types, Python relies on the special method. This method provides support for the built-in function, which you can use to determine the number of items in a given container. In general, if returns , then Python considers the container a falsy object, which is consistent with the general rules you’ve just learned before. All the discussion about the truth value of Python objects in this section is key to understanding how the logical operators behave when they take arbitrary objects as operands. You can also use any objects, such as numbers or strings, as operands to , , and . You can even use combinations of a Boolean object and a regular one. In these situations, the result depends on the truth value of the operands. Note: Boolean expressions that combine two Boolean operands are a special case of a more general rule that allows you to use the logical operators with all kinds of operands. In every case, you’ll get one of the operands as a result. You’ve already learned how Python determines the truth value of objects. So, you’re ready to dive into creating expressions with logic operators and regular objects. To start off, below is a table that summarizes what you get when you use two objects, and , in an expression: It’s important to emphasize a subtle detail in the above table. When you use in an expression, you don’t always get or as a result. Instead, you get one of the operands. You only get or if the returned operand has either of these values. Here are some code examples that use integer values. Remember that in Python, the zero value of numeric types is falsy. The rest of the values are truthy: In the first expression, the left-hand operand ( ) is truthy. So, you get the right-hand operand ( ) as a result. In the second example, the left-hand operand ( ) is falsy, and you get it as a result. In this case, Python applies the short-circuit evaluation technique. It already knows that the whole expression is false because is falsy, so Python returns immediately without evaluating the right-hand operand. In the final expression, the left-hand operand ( ) is truthy. Therefore Python needs to evaluate the right-hand operand to make a conclusion. As a result, you get the right-hand operand, no matter what its truth value is. Note: To dive deeper into the operator, check out Using the “and” Boolean Operator in Python. When it comes to using the operator, you also get one of the operands as a result. This is what happens for two arbitrary objects, and : Again, the expression doesn’t evaluate to either or . Instead, it returns one of its operands, or . As you can conclude from the above table, if the left-hand operand is truthy, then you get it as a result. Otherwise, you get the second operand. Here are some examples that demonstrate this behavior: In the first example, the left-hand operand is truthy, and immediately returns it. In this case, Python doesn’t evaluate the second operand because it already knows the final result. In the second example, the left-hand operand is falsy, and Python has to evaluate the right-hand one to determine the result. In the last example, the left-hand operand is truthy, and that fact defines the result of the expression. There’s no need to evaluate the right-hand operand. An expression like is truthy if either or is truthy, and falsy if both and are falsy. This type of expression returns the first truthy operand that it finds. If both operands are falsy, then the expression returns the right-hand operand. To see this latter behavior in action, consider the following example: In this specific expression, both operands are falsy. So, the operator returns the right-hand operand, and the whole expression is falsy as a result. Note: To learn more about the operator, check out Using the “or” Boolean Operator in Python. Finally, you have the operator. You can also use this one with any object as an operand. Here’s what happens: The operator has a uniform behavior. It always returns a Boolean value. This behavior differs from its sibling operators, and . Here are some code examples: In the first example, the operand, , is truthy from Python’s point of view. So, the operator returns . In the second example, the operand is falsy, and returns . Note: To better understand the operator, check out Using the “not” Boolean Operator in Python. In summary, the Python operator negates the truth value of an object and always returns a Boolean value. This latter behavior differs from the behavior of its sibling operators and , which return operands rather than Boolean values. So far, you’ve seen expressions with only a single or operator and two operands. However, you can also create compound logical expressions with multiple logical operators and operands. To illustrate how to create a compound expression using , consider the following toy example: This expression returns the first truthy value. If all the preceding variables are falsy, then the expression returns the last value, . Note: In an expression like the one above, Python uses short-circuit evaluation. The operands are evaluated in order from left to right. As soon as one is found to be true, the entire expression is known to be true. At that point, Python stops evaluating operands. The value of the entire expression is that of the that terminates the evaluation. To help demonstrate short-circuit evaluation, suppose that you have an identity function, , that behaves as follows:\n• Displays the function and its argument on the screen\n• Returns the argument as its return value Here’s the code to define this function and also a few examples of how it works: The function displays its argument, which visually confirms whether you called the function. It also returns the argument as you passed it in the call. Because of this behavior, you can make the expression be truthy or falsy by specifying a value for that’s truthy or falsy, respectively. Now, consider the following compound logical expression: In this example, Python first evaluates , which returns . This value is falsy. The expression isn’t true yet, so the evaluation continues from left to right. The next operand, , returns . That value is also falsy, so the evaluation continues. Next up is . That evaluates to , which is truthy. At that point, Python stops the evaluation because it already knows that the entire expression is truthy. Consequently, Python returns as the value of the expression and never evaluates the remaining operands, and . You can confirm from the output that the and calls don’t occur. A similar behavior appears in an expression with multiple operators like the following one: This expression is truthy if all the operands are truthy. If at least one operand is falsy, then the expression is also falsy. In this example, short-circuit evaluation dictates that Python stops evaluating as soon as an operand happens to be falsy. At that point, the entire expression is known to be false. Once that’s the case, Python stops evaluating operands and returns the falsy operand that terminated the evaluation. Here are two examples that confirm the short-circuiting behavior: In both examples, the evaluation stops at the first falsy term— in the first case, in the second case—and neither the nor the call occurs. In the end, the expressions return and , respectively. If all the operands are truthy, then Python evaluates them all and returns the last (rightmost) one as the value of the expression: In the first example, all the operands are truthy. The expression is also truthy and returns the last operand. In the second example, all the operands are truthy except for the last one. The expression is falsy and returns the last operand. As you dig into Python, you’ll find that there are some common idiomatic patterns that exploit short-circuit evaluation for conciseness of expression, performance, and safety. For example, you can take advantage of this type of evaluation for: To illustrate the first point, suppose you have two variables, and , and you want to know whether the division of by results in a number greater than . In this case, you can run the following expression or condition: This code works. However, you need to account for the possibility that might be , in which case you’ll get an exception: In this example, the divisor is , which makes Python raise a exception. This exception breaks your code. You can skip this error with an expression like the following: When is , is false. Python’s short-circuit evaluation ensures that the evaluation stops at that point, which means that never runs, and the error never occurs. Using this technique, you can implement a function to determine whether an integer is divisible by another integer: In this function, if is , then isn’t defined. So, the numbers aren’t divisible. If is different from , then the result will depend on the remainder of the division. Selecting a default value when a specified value is falsy is another idiom that takes advantage of the short-circuit evaluation feature of Python’s logical operators. For example, say that you have a variable that’s supposed to contain a country’s name. At some point, this variable can end up holding an empty string. If that’s the case, then you’d like the variable to hold a default county name. You can also do this with the operator: If is non-empty, then it’s truthy. In this scenario, the expression will return the first truthy value, which is in the first expression. The evaluation stops, and you get as a result. On the other hand, if is an empty string, then it’s falsy. The evaluation continues to the next operand, , which is truthy. Finally, you get the default country as a result. Another interesting use case for short-circuit evaluation is to avoid costly operations while creating compound logical expressions. For example, if you have a costly operation that should only run if a given condition is false, then you can use like in the following snippet: In this construct, your function represents a costly operation. Because of short-circuit evaluation, this function will only run when is false, which means that your data isn’t clean. Another variation of this technique is when you want to run a costly operation if a given condition is true. In this case, you can use the operator: In this example, the operator evaluates . If this variable is true, then the evaluation continues, and the function runs. Otherwise, the evaluation stops, and never runs. Sometimes you have a compound expression that uses the operator to join comparison expressions. For example, say that you want to determine if a number is in a given interval. You can solve this problem with a compound expression like the following: In this example, you use the operator to join two comparison expressions that allow you to find out if is in the interval from to , both included. In Python, you can make this compound expression more concise by chaining the comparison operators together. For example, the following chained expression is equivalent to the previous compound one: This expression is more concise and readable than the original expression. You can quickly realize that this code is checking if the number is between and . Note that in most programming languages, this chained expression doesn’t make sense. In Python, it works like a charm. In other programming languages, this expression would probably start by evaluating , which is true. This true value would then be compared with , which doesn’t make much sense, so the expression fails. Python internally processes this type of expression as an equivalent expression, such as . That’s why you get the correct result in the example above.\n\nPython provides two operators, and , that allow you to determine whether two operands have the same identity. In other words, they let you check if the operands refer to the same object. Note that identity isn’t the same thing as equality. The latter aims to check whether two operands contain the same data. Note: To learn more about the difference between identity and equality, check out Python ‘!=’ Is Not ‘is not’: Comparing Objects in Python. Here’s a summary of Python’s identity operators. Note that and are variables that point to objects:\n• if and hold a reference to the same in-memory object\n• otherwise\n• if points to an object different from the object that points to\n• otherwise These two Python operators are keywords instead of odd symbols. This is part of Python’s goal of favoring readability in its syntax. Here’s an example of two variables, and , that refer to objects that are equal but not identical: In this example, and refer to objects whose value is . So, they’re equal. However, they don’t reference the same object. That’s why the operator returns . You can check an object’s identity using the built-in function: As you can conclude from the output, and don’t have the same identity. So, they’re different objects, and because of that, the expression returns . In other words, you get because you have two different instances of stored in your computer’s memory. When you make an assignment like , Python creates a second reference to the same object. Again, you can confirm that with the function or the operator: In this example, and hold references to the same object, the string . Therefore, the function returns the same identity when you call it with and . Similarly, the operator returns . Note: You should note that, on your computer, you’ll get a different identity number when you call in the example above. The key detail is that the identity number will be the same for and . Finally, the operator is the opposite of . So, you can use to determine if two names don’t refer to the same object: In the first example, because and point to different objects in your computer’s memory, the operator returns . In the second example, because and are references to the same object, the operator returns . Note: The syntax also works the same as . However, the former syntax looks odd and is difficult to read. That’s why Python recognizes as an operator and encourages its use for readability. Again, the operator highlights Python’s readability goals. In general, both identity operators allow you to write checks that read as plain English.\n\nUp to this point, you’ve coded sample expressions that mostly use one or two different types of operators. However, what if you need to create compound expressions that use several different types of operators, such as comparison, arithmetic, Boolean, and others? How does Python decide which operation runs first? Consider the following math expression: There might be ambiguity in this expression. Should Python perform the addition first and then multiply the result by ? Should Python run the multiplication first, and the addition second? Because the result is , you can conclude that Python has chosen the latter approach. If it had chosen the former, then the result would be . This follows a standard algebraic rule that you’ll find in virtually all programming languages. All operators that Python supports have a precedence compared to other operators. This precedence defines the order in which Python runs the operators in a compound expression. In an expression, Python runs the operators of highest precedence first. After obtaining those results, Python runs the operators of the next highest precedence. This process continues until the expression is fully evaluated. Any operators of equal precedence are performed in left-to-right order. Here’s the order of precedence of the Python operators that you’ve seen so far, from highest to lowest: Operators at the top of the table have the highest precedence, and those at the bottom of the table have the lowest precedence. Any operators in the same row of the table have equal precedence. Getting back to your initial example, Python runs the multiplication because the multiplication operator has a higher precedence than the addition one. In the example above, Python first raises to the power of , which equals . Then, it carries out the multiplications in order from left to right: and . You can override the default operator precedence using parentheses to group terms as you do in math. The subexpressions in parentheses will run before expressions that aren’t in parentheses. Here are some examples that show how a pair of parentheses can affect the result of an expression: In the first example, Python computes the expression first because it’s wrapped in parentheses. Then Python multiplies the result by , and the expression returns . This result is completely different from what you got at the beginning of this section. In the second example, Python evaluates first. Then it raises to the power of the resulting value. Finally, Python multiplies the result by , returning . There’s nothing wrong with making liberal use of parentheses, even when they aren’t necessary to change the order of evaluation. Sometimes it’s a good practice to use parentheses because they can improve your code’s readability and relieve the reader from having to recall operator precedence from memory. Consider the following example: Here the parentheses are unnecessary, as the comparison operators have higher precedence than . However, some might find the parenthesized version clearer than the version without parentheses: On the other hand, some developers might prefer this latter version of the expression. It’s a matter of personal preference. The point is that you can always use parentheses if you feel that they make your code more readable, even if they aren’t necessary to change the order of evaluation."
    },
    {
        "link": "https://geeksforgeeks.org/python-operators",
        "document": "In Python programming, Operators in general are used to perform operations on values and variables. These are standard symbols used for logical and arithmetic operations. In this article, we will look into different types of Python operators.\n• OPERATORS: These are the special symbols. Eg- + , * , /, etc.\n• OPERAND: It is the value on which the operator is applied.\n\nPython Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication and division.\n\nIn Python 3.x the result of division is a floating-point while in Python 2.x division of 2 integers was an integer. To obtain an integer result in Python 3.x floored (// integer) is used.\n\nExample of Arithmetic Operators in Python:\n\nNote: Refer to Differences between / and // for some interesting facts about these two Python operators.\n\nIn Python Comparison of Relational operators compares the values. It either returns True or False according to the condition.\n\nExample of Comparison Operators in Python\n\nLet’s see an example of Comparison Operators in Python.\n\nPython Logical operators perform Logical AND, Logical OR and Logical NOT operations. It is used to combine conditional statements.\n\nThe precedence of Logical Operators in Python is as follows:\n\nExample of Logical Operators in Python:\n\nPython Bitwise operators act on bits and perform bit-by-bit operations. These are used to operate on binary numbers.\n\nBitwise Operators in Python are as follows:\n\nExample of Bitwise Operators in Python:\n\nPython Assignment operators are used to assign values to the variables. This operator is used to assign the value of the right side of the expression to the left side operand.\n\nExample of Assignment Operators in Python:\n\nIn Python, is and is not are the identity operators both are used to check if two values are located on the same part of the memory. Two variables that are equal do not imply that they are identical.\n\nExample of Identity Operators in Python:\n\nIn Python, in and not in are the membership operators that are used to test whether a value or variable is in a sequence.\n\nin Python, Ternary operators also known as conditional expressions are operators that evaluate something based on a condition being true or false. It was added to Python in version 2.5.\n\nIt simply allows testing a condition in a single line replacing the multiline if-else making the code compact.\n\nPrecedence and Associativity of Operators in Python\n\nIn Python, Operator precedence and associativity determine the priorities of the operator.\n\nThis is used in an expression with more than one operator with different precedence to determine which operation to perform first.\n\nIf an expression contains two or more operators with the same precedence then Operator Associativity is used to determine. It can either be Left to Right or from Right to Left.\n\nTo try your knowledge of Python Operators, you can take out the quiz on Operators in Python.\n\nBelow are two Exercise Questions on Python Operators. We have covered arithmetic operators and comparison operators in these exercise questions. For more exercises on Python Operators visit the page mentioned below.\n• None Why are there no ++ and – Operator in Python\n• None How to do Math in Python 3 with Operators\n• None Difference between == and is Operator in Python\n\nExplore more Exercises: Practice Exercise on Operators in Python"
    },
    {
        "link": "https://realpython.com/python-variables",
        "document": "In Python, variables are symbolic names that refer to objects or values stored in your computer’s memory. They allow you to assign descriptive names to data, making it easier to manipulate and reuse values throughout your code. You create a Python variable by assigning a value using the syntax .\n\nBy the end of this tutorial, you’ll understand that:\n• Variables in Python are symbolic names pointing to objects or values in memory.\n• You define variables by assigning them a value using the assignment operator.\n• Python variables are dynamically typed, allowing type changes through reassignment.\n• Python variable names can include letters, digits, and underscores but can’t start with a digit. You should use snake case for multi-word names to improve readability.\n• Variables exist in different scopes (global, local, non-local, or built-in), which affects how you can access them.\n• You can have an unlimited number of variables in Python, limited only by computer memory.\n\nTo get the most out of this tutorial, you should be familiar with Python’s basic data types and have a general understanding of programming concepts like loops and functions.\n\nDon’t worry if you don’t have all this knowledge yet and you’re just getting started. You won’t need this knowledge to benefit from working through the early sections of this tutorial.\n\nGetting to Know Variables in Python In Python, variables are names associated with concrete objects or values stored in your computer’s memory. By associating a variable with a value, you can refer to the value using a descriptive name and reuse it as many times as needed in your code. Variables behave as if they were the value they refer to. To use variables in your code, you first need to learn how to create them, which is pretty straightforward in Python. The primary way to create a variable in Python is to assign it a value using the assignment operator and the following syntax: In this syntax, you have the variable’s name on the left, then the assignment ( ) operator, followed by the value you want to assign to the variable at hand. The value in this construct can be any Python object, including strings, numbers, lists, dictionaries, or even custom objects. Note: To learn more about assignments, check out Python’s Assignment Operator: Write Robust Assignments. Here are a few examples of variables: In this code, you’ve defined several variables by assigning values to names. The first five examples include variables that refer to different built-in types. The last example shows that variables can also refer to custom objects like an instance of your class. Apart from a variable’s value, it’s also important to consider the data type of the value. When you think about a variable’s type, you’re considering whether the variable refers to a string, integer, floating-point number, list, tuple, dictionary, custom object, or another data type. Python is a dynamically typed language, which means that variable types are determined and checked at runtime rather than during compilation. Because of this, you don’t need to specify a variable’s type when you’re creating the variable. Python will infer a variable’s type from the assigned object. Note: In Python, variables themselves don’t have data types. Instead, the objects that variables reference have types. For example, consider the following variables: In this example, refers to the value, so the type of is . Similarly, refers to the integer number , so its type is . Finally, refers to a list, so its type is . Note that you don’t have to explicitly tell Python which type each variable is. Python determines and sets the type by checking the type of the assigned value. Because Python is dynamically typed, you can make variables refer to objects of different data types in different moments just by reassigning the variable: Now, refers to a string, and refer to a set object. By assigning a value of a different type to an existing variable, you change the variable’s type.\n\nVariables are an essential concept in Python programming. They work as the building blocks for your programs. So far, you’ve learned the basics of creating variables. In this section, you’ll explore different ways to use variables in Python. You’ll start by using variables in expressions. Then, you’ll dive into counters and accumulators, which are essential for keeping track of values during iteration. You’ll also learn about other common use cases for variables, such as temporary variables, Boolean flags, loop variables, and data storage variables. In Python, an expression is a simple statement that Python can evaluate to produce and return a value. For example, consider the following expressions that compute the circumference of two different circles: Each of these expressions represents a specific computation. To build the expressions, you’ve used values and the multiplication operator ( ). Python evaluates each expression and returns the resulting value. Note: To dive deeper into expressions and operators, check out the Operators and Expressions in Python tutorial. The above expressions are sort of rigid. For each expression, you have to repeat the input values, which is an error-prone and repetitive task. Now consider the following examples: In this example, you first define variables to hold the input values. Then, you use those variables in the expressions. Note that when you build an expression using variables, Python replaces the variable by its value. As shown in the example, you can conveniently reuse the values in different expressions. Another important point to note is that now you have descriptive names to properly identify the values used in the expressions. To summarize, variables are great for reusing values in expressions and running computations with data that varies over time. In general, variables let you name or label objects so that you can reference and manipulate them later in the program. In the following sections, you’ll see use cases of variables in practice. A counter is an integer variable that allows you to count objects. Counters typically have an initial value of zero, which increments to reflect the number of times a given object appears. To illustrate, say that you need to count the objects that are strings in a given list of objects. In this situation, you can do something like the following: In this example, you create the variable by initializing it to . Then, you run a loop over a list of objects of different types. Inside the loop, you check whether the current object is a string using the built-in function. If the current object is a string, then you increment the counter by one. At the end of the loop, has a value of , reflecting the number of string objects in the input list. Note: The highlighted line in the above example uses the expression , which is a shortcut for . The operator is known as the augmented addition operator. You reuse the expression in each iteration of the loop to increment the value of , making it change over time. This dynamic updating is a key feature of variables. As the name variables suggests, they are designed to hold values that can vary over time. Accumulators are another common type of variable used in programming. An accumulator is a variable that you use to add consecutive values to form a total that you can use as an intermediate step in different calculations. A classic example of an accumulator is when you need to compute the sum of numeric values: In this example, the loop iterates over a list of numbers and accumulates each value in . You can also use accumulators as parts of larger computations, for example to calculate the mean of a list of numbers: Then, you take advantage of to compute the average using the built-in function. You could have used an object counter instead of . Similarly, Python comes with several accumulator functions that you can often use instead of explicit accumulators. For example, you can use instead of calculating as above. Temporary variables hold intermediate results that you need for a more elaborate computation. A classic use case for a temporary variable is when you need to swap values between variables: In this example, you use a temporary variable called to hold the value of so that you can swap values between and . Once you’ve done the swap, is no longer needed. Note: In Python, there’s a clean and elegant way to swap values between variables without using temporary variables. You’ll learn about this topic in the section on iterable unpacking. For a more elaborate example of using temporary variables, consider the following function that calculates the variance of a sample of numeric data: The expression that you use as the function’s return value is quite involved and challenging to understand. It’s also difficult to debug because you’re running multiple operations in a single expression. To make your code easier to understand and debug, you can take advantage of an incremental development approach that uses temporary variables for intermediate calculations: In this alternative implementation of , you calculate the variance in several steps. Each step is represented by a temporary variable with a meaningful name, making your code more readable. Boolean flags help you manage control flow and decision-making in your programs. As their name suggests, these variables can be either or . You can use them in conditionals, loops, and Boolean expressions. Suppose you need to perform two different actions alternatively in a loop. In this case, you can use a flag variable to toggle actions in every iteration: Every time this loop runs, the conditional checks the value of to decide which course of action to take. At the end of the loop, you change the value of using the operator. The next iteration will run the alternative action. Flags are also used as function arguments. Consider the following toy example: ! It's great to see you!\" Hello, Pythonista! It's great to see you! In this example, the argument is a Boolean variable that lets you decide which greeting message to display. You’ll find that a few Python built-in functions use flag arguments. The function is a good example: The function takes an iterable as an argument and returns a list of sorted objects. This function has a argument that is a flag and defaults to . If you set this argument to , then you get the objects sorted in reverse order. In practice, you’ll find that Boolean variables are often named using the or naming pattern: In this example, the variable is a flag that changes depending on the value of . Note that the naming pattern allows you to clearly communicate the variable’s purpose. However, this naming convention is just a common practice and not a requirement or something that Python reinforces. Loop variables help you process data during iteration in loops and sometimes in loops. In a loop, the variable takes the value of the current element in the input iterable each time you go through the loop: In this example, you iterate over a list of colors using a loop. The loop variable, , holds the current color in each iteration. This way, you can do something with the current item while you iterate over the data. Python’s loops can have multiple loop variables. For example, say that you want to map each color with its index. In this case, you can do something like the following: In this example, you use the built-in function to generate indices while you iterate over the input data. Note how this loop has two variables. To provide multiple loop variables, you use a comma-separated series of variables. You can also use variables to control loops. Here’s a toy example: In this example, the loop variable works as a counter that defines the number of iterations. Inside the loop, you use the augmented subtraction operator ( ) to update the variable’s value. Data storage variables allow you to work with containers of values, such as lists, tuples, dictionaries, or sets. For example, say that you’re writing a contact book application that uses a list of tuples to store the information of your contacts: This variable allows you to manipulate your data using a single and descriptive name. You can use the variables in a loop, for example: The first loop iterates over the items in the contact list and prints them as tuples. The second loop uses three loop variables to process every piece of data individually. Note that inside the loop, you can use the variables as needed. You don’t need to use all the variables or use them in the same order. However, when you have an unused variable, then you should name it using an underscore to point out that it’s a throwaway variable. So, you could rewrite the loop header to look like this: for name, phone, _ in contacts: . In this case, the underscore represents the email variable, which you aren’t using in the body of the loop.\n\nThe examples you’ve seen so far use short variable names. In practice, variable names should be descriptive to improve the code’s readability, so they can also be longer and include multiple words. In the following sections, you’ll learn about the rules to follow when creating valid variable names in Python. You’ll also learn best practices for naming variables and other naming-related practices. Variable names in Python can be any length and can consist of uppercase letters ( ) and lowercase letters ( ), digits ( ), and the underscore character ( ). The only restriction is that even though a variable name can contain digits, the first character of a variable name can’t be a digit. Note: Python currently has full Unicode support, and you can use many unicode characters in variable names. For example, the following variable names are valid: These variable names may be uncommon in Python code, but they’re completely valid. You can use them in code that performs scientific calculations when you want the code to reflect the notation used in the target discipline. All of the following are valid variable names: These variables follow the rules for creating valid variable names in Python. They also follow best naming practices, which you’ll learn about in the next section. The variable name below doesn’t follow the rules: The variable name in this example starts with a number, which isn’t allowed in Python. Therefore, you get a exception. It’s important to know that variables are case-sensitive. Lowercase and uppercase letters aren’t treated the same: In this example, Python interprets the names as different and independent variables. So, casing is something to consider when you’re creating variable names in Python. Nothing stops you from creating two different variables in the same program called and , or, for that matter, . However, this practice isn’t recommended because it can confuse people trying to read your code and even yourself after a while. In general, you should use lowercase letters when creating your variable names. The use of underscore characters is also significant. You’ll use an underscore to separate multiple words in a variable name: In these variable names, you use the underscore character as a separator for multiple words. This is a way to improve the readability of your code by substituting the space character with an underscore. To illustrate this, consider how your variables would look without the underscores: Even though these names are technically valid, they can be challenging to read and understand at a glance. The lack of separation makes it harder to grasp the meaning of each variable quickly, and they require more effort to interpret. Using underscores improves the clarity of your code and makes it more maintainable. You should always give a variable a descriptive name that clearly explains the variable’s purpose. Sometimes, you can find a single word to name a given variable: Variables always refer to concrete objects, so their names should be nouns. You should try to find specific names for your variables that uniquely identify the referred object. Names like , , or may be too generic. While these names can work for short examples, they’re not descriptive enough for production code. In general, you should avoid single-letter names: Single-letter names may be hard to decipher, making your code difficult to read, especially when you use them in expressions with other similar names. Of course, there are exceptions. For example, if you’re working with nested lists, then you can use single-letter names to identify indices: It’s common to use letters like , , and to represent indices, so you can use them in the right context. It’s also common to use , , and to represent point coordinates, so these are also okay to use. Using abbreviations to name variables is discouraged, in favor of using the complete name: It’s best practice to use a complete name instead an abbreviated name because it’s more readable and clear. However, sometimes abbreviations are okay when they’re widely accepted and used: In these examples, is a commonly used abbreviation for command and is commonly used for message. A classic example of a widely used abbreviation in Python is the name, which you should use to identify the current class object in a class method. Sometimes, you need multiple words to build a descriptive variable name. When using multi-word names, you can struggle to read them if there isn’t a distinguishable boundary between words: This variable name is difficult to read. You have to pay close attention to figuring out the words’ boundaries so that you can understand what the variable represents. The most common practices for multi-word variable names are the following:\n• Snake case: Lowercase words are separated by underscores. For example: .\n• Camel case: The second and subsequent words are capitalized to make word boundaries easier to see. For example: .\n• Pascal case: Similar to camel case, except the first word is also capitalized. For example: . The Style Guide for Python Code, also known as PEP 8, contains naming conventions that list suggested standards for names of different object types. Regarding variables, PEP 8 recommends using the snake case style. When you need multi-word names, it’s common to combine an adjective as a qualifier with a noun: In these examples, you create descriptive variable names by combining adjectives and nouns, which can dramatically improve your code’s readability. Another point to consider is to avoid multi-word names that start with , like , , and so on. The part doesn’t really add anything useful to the name. Flag variables are another good example of when to use a multi-word variable name: In these examples, you’ve used an underscore to separate the words, making their boundaries visible and quick to spot. When it comes to naming lists and dictionaries, you should use plural nouns in most situations: Using plural nouns in these examples makes it clear that the variable refers to a container that stores several objects of similar types. When naming tuples, you should consider that they’re commonly used to store objects of different types or meanings. So, it’s okay to use singular nouns: Although these tuples store multiple objects, they represent a single entity. The first tuple represents an RGB (red, green, blue) color, while the second represents a row in a database table or some other tabular data. A widely used naming convention for variables in Python is to use a leading underscore when you need to communicate that a given variable is what Python defines as non-public. A non-public variable is a variable that shouldn’t be used outside its defining module. These variables are for internal use only: In this module, you have a non-public variable called . Then, you have a couple of functions that work with this variable. However, the variable itself isn’t intended to be used outside the containing module. Python reserves a small set of words known as keywords that are part of the language’s syntax. To get the list of Python’s keywords, go ahead and run the following code: In most cases, you won’t be able to use these words as variable names without getting an error: This behavior is true for most keywords. If you need to use a name that coincides with a keyword, then you can follow PEP 8’s recommendation, which is to add a trailing underscore to the name: In this example, you’ve added an underscore character at the end of the keyword, which enables you to use it as a variable name. Even though this convention works, sometimes it’s more elegant to do something like the following: Now, your variable’s name is way more descriptive and specific, which improves your code’s readability. There are also soft keywords, which are keywords only in specific contexts. For example, the keyword is only considered a keyword in structural pattern matching. Because is a soft keyword, you can use it to name variables: In this example, you import the module to use regular expressions. This example only searches for a basic expression in a target text. The idea here is to show that can be used as a valid variable name even though it’s a keyword. Another practice that you should avoid is using built-in names to name your variables. To illustrate, say that you’re learning about Python lists and run the following code: In this example, you’ve used as the name for a object containing numeric values. This shadows the original object behind the name, which prevents you from using it in your code: Now, calling fails because you’ve overridden the built-in name in your code. So, you’re better off avoiding built-in names to define your variables. This practice can make your code fail in different ways. Note: For a complete list of built-in names, run the following code in an interactive session: The list of built-in names is quite long. To make sure that your variable name doesn’t shadow one of the names in this list, you can do something like . If this check returns , then it’s best to find a different name. Note that this recommendation is also valid for names that refer to objects defined in third-party libraries that you use in your code.\n\nWhen you start digging deeper into how Python variables work internally, you discover several interesting features worth studying. In the following sections, you’ll explore some of the core features of variables so that you can better understand them. What happens when you create a variable with an assignment? This is an important question in Python because the answer differs from what you’d find in many other programming languages. Python is an object-oriented programming language. Every piece of data in a Python program is an object of a specific type or class. Consider this code: When presented with the statement , Python does the following operations:\n• Gives it a value of\n• Displays it on the screen You can see that an integer object is created using the built-in function: A Python variable is a symbolic name that refers to or points to an object like . Once an object is assigned to a variable, you can refer to it by the variable’s name, but the data itself is still contained within the object. For example, consider the following variable definition: This assignment creates an integer object with a value of and makes the variable point to that object. The diagram below shows how this happens: In Python, variables don’t store objects. They point or refer to objects. Every time you create an object in Python, it’s assigned a unique number, which is then associated with the variable. The built-in function returns an object’s identifier or identity: In CPython, the standard Python distribution, an object’s identity coincides with its memory address. Therefore, CPython variables store memory addresses. Through these memory addresses, variables access the concrete objects stored in memory. You can create multiple variables that point to the same object. In other words, variables that hold the same memory address: In this example, Python doesn’t create a new object. It creates a new variable name or reference, , which points to the same object that points to: Next, suppose you do something like this: Now, Python creates a new integer object with the value , and becomes a reference to it: Finally, say that you run the following statement: Now, Python creates a string object with the value and makes a reference to that: Because of the and reassignments, you no longer have a reference to integer object . It’s orphaned, and you have no way to access it again. When the references to an object drop to zero, the object is no longer accessible. At that point, its lifetime is over. Python reclaims the allocated memory so it can be used for something else. In programming terminology, this process is known as garbage collection. In many programming languages, variables are statically typed, which means they’re initially declared to have a specific data type during their lifetime. Any value assigned to that variable during its lifetime must be of the specified data type. Python variables aren’t typed this way. In Python, you can assign values of different data types to a variable at different moments: In this example, you’re making the variable refer to or point to an object of another type. Because of this feature, Python is a dynamically typed language. It’s important to note that changes in a variable’s data type can lead to runtime errors. For example, if a variable’s data type changes unexpectedly, you may face type-related bugs or even get an exception: # Try to use .upper() again : In this example, the variable type changes during the code’s execution. When points to a string, you can use the method to convert the letters into uppercase. However, when the type changes to , the method isn’t available, and you get an exception. You can use type hints to add explicit type information to your variables. To do this, you can use the following Python syntax: The square brackets aren’t part of the syntax. They denote that the enclosed part is optional. Yes, you can declare a Python variable without assigning it a value: : name 'number' is not defined The variable declaration on the first line works and is valid Python syntax. However, this declaration doesn’t really create a new variable for you. That’s why when you try to access the variable, you get a exception. Even though isn’t defined, Python has recorded the type hint: When it comes to basic data types such as numbers and strings, type hints may look superfluous: If you’re familiar with Python’s built-in types, then you won’t need to add type hints to these variables because you’ll soon know that you have a string, integer, and floating-point value, respectively. So, in this situation, you’re okay to skip the type hint. Also, your static type checker or linter won’t complain. The story changes when you use collection types, such as lists, tuples, dictionaries, and sets. With these types, it makes sense to provide type hints for their contained data. To illustrate, say that you have the following dictionary of colors: In this case, it’d be great to have information about the data types of keys and values. You can provide that information using the following type hint: In this updated code, you’re explicitly communicating that your dictionary will store its keys and values as strings. Why is this type hint important? Say that in another part of your code, you have another dictionary defined as shown below: At some point, you might be working with both dictionaries and won’t have an unambiguous way to know which dictionary is needed. To work around the issue, you can add a type hint to the second dictionary as well: The type hint in this example is a bit more elaborate, but it clearly states that your dictionary will have string keys and tuples of three integers as values. It’s important to note that type-hinting variables that refer to container data types is especially useful when you initialize the variable with an empty container: In these examples, you have two empty lists. Because they have type hint information, you can quickly figure out the data type of the content. Now you know that the first list will contain strings, while the second list will hold tuples, each consisting of three items: a string, an integer, and another string value. Note that in this example, your static type checker or linter will explicitly complain about the type hint of your lists if you don’t provide any type information. Later in your code, you can append items to each list using the correct data type: First, you use the method to add new fruits as strings to the end of , and then you add new rows to the end of .\n\nIn Python, you’ll find a few alternative ways to create new variables. Sometimes, defining several variables simultaneously with the same initial value is convenient or needed. To do this, you can use a parallel assignment. In other situations, you may need to initialize several variables with values from a sequence data type, like a list or tuple. In this case, you can use a technique called iterable unpacking. You’ll also find situations where you need to retain the value that results from a given expression. In this case, you can use an assignment expression. In the following sections, you’ll learn about all these alternative or complementary ways to create Python variables. Python also allows you to run multiple assignments in a single line of code. This feature makes it possible to assign the same value to several variables simultaneously: The parallel assignment in this example initializes three different but related variables to simultaneously. This way of creating and initializing variables is more concise and less repetitive than the following: By using parallel assignments instead of dedicated assignments, you make your code more concise and less repetitive. Iterable unpacking is a cool Python feature also known as tuple unpacking. It consists of distributing the values in an iterable into a series of variables. In most cases, the number of variables will match the number of items in the iterable. However, you can also use the syntax to grab several items in a list. You can use iterable unpacking to create multiple variables at a time using an iterable of values. For example, say that you have some data about a person and want to create dedicated variables for each piece of data: If you didn’t know about iterable unpacking, then your first approach might be to distribute the data into different variables manually, as shown below: This code works. However, using indices to extract the data may lead to an error-prone and hard-to-read result. Instead of using this technique, you can take advantage of iterable unpacking and end up with the following code: Now, your code looks cleaner and more readable. So, when you find yourself creating variables from iterables using indices, consider using unpacking instead. A great use case for unpacking is when you need to swap the values between two variables: In the highlighted line, you swap the values of and without using a temporary variable, as you saw before. In this example, it’s important to note that the iterable to the right of the equal sign is a tuple of variables. Assignment expressions allow you to assign the result of an expression used in a conditional or a loop to a name in one step. For example, consider the following loop that takes input from the keyboard until you type the word : This loop works as expected. However, this code has the drawback that it unnecessarily repeats the call to . You can rewrite the loop using an assignment expression and end up with the following code: In the expression , you create a new variable called to hold a reference to the input data. This data is also returned as the expression’s result, which is finally compared to the word to finish the loop. So, assignment expressions are another way to create variables. To learn more about assignment expressions, check out The Walrus Operator: Python’s Assignment Expressions.\n\nThe concept of scope defines how variables and names are looked up in your code. It determines the visibility of a variable within your code. The scope of a variable depends on the place in your code where you create the variable. In Python, you may find up to four different scopes, which can be presented using the LEGB acronym. The letters in this acronym stand for local, enclosing, global, and built-in scopes. Note: To dive deeper into how scopes work in Python, check out the following tutorials:\n• Python Scope & the LEGB Rule: Resolving Names in Your Code In the following sections, you’ll learn the basics of variable scopes in Python and how this concept can affect the way you use your variables. Global variables are those that you create at the module level. These variables are visible within the containing module and in other modules that import them. So, for example, if you’re using the Python REPL, then the current global scope is defined in a module called . This module defines your current global scope. All the variables defined in this module are global, so you can use them at anytime during an interactive session run: In this code snippet, you define the variable and call the built-in function to check the list of names defined in your current global scope. At the end of the list, you’ll find the entry, which corresponds to your variable. Now, say that you use this same interactive session to run several pieces of code while you try out some cool features of Python. After all those examples, you need to use the variable again: You’ll notice that the variables will still be available for you. That’s because this variable is global to your code. You can also import variables defined outside your current module by using the statement. A typical example of this practice is when you have a module that defines a variable to hold some configuration parameters. You can import this variable into your global scope and use it as you’d use any other global variable. As a quick example, say that you have the following module: This file defines a dictionary that contains several configuration parameters for a hypothetical application. You can import this variable to your app’s global scope and use the settings parameters as needed: With the import in the first line, you’ve brought the variable into your current global scope. You can use the variable from any part of your code. Local variables are those that you define inside a function. These variables can help you store the results of intermediate computations under a descriptive name. They can make your code more readable and explicit. Consider the following example: : name 'integer' is not defined Local variables are only visible within their defining function. Once the function returns, the variables disappear. That’s why you can’t access in the global scope. Similarly, non-local variables are those that you create in a function that define inner functions. The variables local to the outer function are non-local to the inner functions. Non-local variables are useful when you’re creating closure functions and decorators. Note: To learn more about closures and decorators, you can check out the following tutorials: Here’s a toy example that illustrates how global, local, and non-local variables work and how to identify the different scopes in Python: In this example, you first create a global variable at the module level. Then, you define a function called . Inside this function, you have , which is local to but non-local to . In , you create another variable called , which is local to the function itself. Note: You can access global and non-local variables from within an inner function. However, to update a global or non-local variable from within an inner function, you need to explicitly use the and statements. The calls to are intended to show how you can access variables from different scopes inside a function. Hi from the 'local' scope! Hi from the 'nonlocal' scope! Hi from the 'global' scope! In summary, global variables are accessible from every place in your code. Local variables are visible in their defining function. Non-local variables are visible in their defining or enclosing function and in any inner function that lives in the enclosing function. You can create variables inside custom Python classes when using object-oriented programming tools. These variables are called attributes. In practice, you can have class and instance attributes. Class attributes are variables that you create at the class level, while instance attributes are variables that you attach to instances of a given class. These attributes are visible only from within the class or its instances. So, classes define a namespace, which is similar to the scope. Note: To dive deeper into object-oriented programming in Python, check out the following tutorials: To illustrate how class and instance attributes work, say that you need a class to represent your company’s employees. The class should keep information about the employee at hand, which you can store in instance attributes like , , and so on. The class should also keep a count of how many employees are currently in the company. To implement this feature, you can use a class attribute. Here’s a possible implementation of your class: In this class, you define a class attribute called and initialize it to . You’ll use this attribute as a counter to keep track of the number of instances. Class attributes like are common to the class and all its instances. Inside the initializer, , you define three instance attributes to hold the name, position, and salary of the employee. The last line of code in increments the counter by every time you create a new employee. To do this, you access the class attribute on the class object itself. Note: You can’t change the value of a class attribute using the object. For example, if you do something like instead of , then you create a new instance attribute that shadows the class attribute. You can alternatively access the class attribute with instead of . Finally, you have a method to display the employee’s profile according to their current information. This method shows that you need to use the argument to access instance attributes within a class. Here’s how you can use this class in your code: In this code, you first create two instances of by calling the class constructor with appropriate arguments. Then, you call the display method on both employees and get the corresponding information. Finally, you access the attribute on to get the current number of employees. It’s important to note that you can access instance attributes like or using the dot notation on the target instance: : type object 'Employee' has no attribute 'name' Instance attributes are specific to one instance, so you can’t access them through the class. In contrast, class attributes are common to the class and all its instances: To access a class attribute, you can either use an instance or the class itself. However, to change a class attribute directly, you need to use the class. Go ahead and give it a try with the following example: In this example, you try to update the attribute using an instance, . This action results in you attaching a new instance attribute to instead of updating the value of . To update the class attribute, you need to use the class itself. In Python, you can explicitly remove variables or, more generically, names from a given scope using the statement: : name 'city' is not defined In this code snippet, you first create a new variable called in your current global scope. Then, you use the statement to remove the variable from its containing scope. When you try to access the variable again, you get a exception. Note: In practice, you can use the statement in several ways to remove names from scopes and containers. To dive deeper into how this statement works, check out Python’s : Remove References From Scopes and Containers. You should know that while removes the reference to an object, it doesn’t necessarily free the memory immediately. Python’s garbage collector claims the memory once there are no more references to the object."
    },
    {
        "link": "https://stackoverflow.com/questions/47690708/and-or-operator-between-numbers-in-python",
        "document": "It returns the last value which is (if there is any True value).\n\nFor an python needs to check every value, so if they are all true then it returns the last one, if one of them is False, then it returns that value. If all of them are False it returns the first one because Python doesn't need to check the second one as well.\n\nFor an python checks first the first one until he gets True sometime, so if the first value is True it returns this value, if the first one is False but the second one is True, it returns the second one. If they are all False it returns the last one.\n\nThe values which are equivalent to False: ."
    },
    {
        "link": "https://w3schools.com/python/python_operators.asp",
        "document": "Operators are used to perform operations on variables and values.\n\nIn the example below, we use the operator to add together two values:\n\nPython divides the operators in the following groups:\n\nArithmetic operators are used with numeric values to perform common mathematical operations:\n\nAssignment operators are used to assign values to variables:\n\nComparison operators are used to compare two values:\n\nLogical operators are used to combine conditional statements:\n\nIdentity operators are used to compare the objects, not if they are equal, but if they are actually the same object, with the same memory location:\n\nMembership operators are used to test if a sequence is presented in an object:\n\nBitwise operators are used to compare (binary) numbers:\n\nOperator precedence describes the order in which operations are performed.\n\nThe precedence order is described in the table below, starting with the highest precedence at the top:\n\nIf two operators have the same precedence, the expression is evaluated from left to right."
    }
]