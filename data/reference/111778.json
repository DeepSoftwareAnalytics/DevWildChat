[
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://w3schools.com/python/python_ref_dictionary.asp",
        "document": "Python has a set of built-in methods that you can use on dictionaries.\n\nLearn more about dictionaries in our Python Dictionaries Tutorial."
    },
    {
        "link": "https://docs.python.org/2/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list; equivalent to . Extend the list by appending all the items in the given list; equivalent to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is x. It is an error if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.) Return the index in the list of the first item whose value is x. It is an error if there is no such item. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list, in place. An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: We can obtain the same result with: This is also equivalent to , but it’s more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the nested listcomp is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nThere is a way to remove an item from a list given its index instead of its value: the statement. This differs from the method which returns a value. The statement can also be used to remove slices from a list or clear the entire list (which we did earlier by assignment of an empty list to the slice). For example: can also be used to delete entire variables: Referencing the name hereafter is an error (at least until another value is assigned to it). We’ll find other uses for later.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires the list of variables on the left to have the same number of elements as the length of the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in either a or b # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as an unordered set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. The method of a dictionary object returns a list of all the keys used in the dictionary, in arbitrary order (if you want it sorted, just apply the function to it). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and check whether a value occurs (does not occur) in a sequence. The operators and compare whether two objects are really the same object; this only matters for mutable objects like lists. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment cannot occur inside expressions. C programmers may grumble about this, but it avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the ASCII ordering for individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types is legal. The outcome is deterministic but arbitrary: the types are ordered by their name. Thus, a list is always smaller than a string, a string is always smaller than a tuple, etc. Mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc."
    },
    {
        "link": "https://datacamp.com/tutorial/python-pop",
        "document": "Learn the art of writing your own functions in Python, as well as key concepts like scoping and error handling."
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://stackoverflow.com/questions/39734016/python-str-format-list-of-dictionaries",
        "document": "I am trying to develop a format that prints a certain way when iterating through a list of dictionaries.\n\nI have looked at several other questions that with a similar topic and know that you can't key in using a numerical value and format(). At least that's what I got from it.\n\nIn my case I am not using a numerical value so not sure why it isn't working. I think I know how to solve this using the other (%S) formatting method but trying to condense and make my code more pythonic.\n\nSo when I remove the .formate statement and leave the indexing arguments I get the correct values, but as soon as I try to format them I get the error.\n\nLooking for why this is happening and how to resolve it, thanks!"
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://python-course.eu/python-tutorial/dictionaries.php",
        "document": "In the preceding chapters, we delved into the fundamentals of lists, , including subtle intricacies. Now, as we progress through this chapter of our online Python course, we turn our attention to dictionaries, exploring their syntax, operators, and methods. Lists and dictionaries are indispensable components of Python programming, making Python a powerful and extremely useful programming language.\n\nLet's begin with a straightforward example to illustrate the concept of a dictionary:\n\nIn Python, a dictionary is a data structure that stores key-value pairs. Let's take a closer look at our example dictionary to explain the essential details:\n• The keys in our dictionary are strings and are positined in front of the colons. The keys of our example dictionary are 'name', 'age', 'city', and 'email'.\n• Each key is associated with a corresponding value separated by a colon : 'Anna Schmidt' is the value associated with the key 'name', 28 with 'age', 'Berlin' with 'city', and '[email protected]' with 'email'.\n• We call a key-value pair like 'name': 'Anna Schmidt' an item. So a dictionary contains an arbitrary sequence of pairs separated by commas.\n\nDictionaries are useful for organizing data in a way that allows quick and easy access based on specific keys.\n\nWe can also consider a dictionary like a digital information card about a person named Anna Schmidt from Berlin, Germany and keeps track of important details in a structured way.\n• 'name': This is where we keep Anna's full name, which is 'Anna Schmidt'.\n• 'age': Here we store Anna's age, which is 28 years old.\n• 'city': This tells us where Anna lives, which is in Berlin.\n• 'email': Anna's email address, which is '[email protected]', is stored here.\n\nIn the code snippet below, we demonstrate how to retrieve specific pieces of information from our dictionary, such as the 'name' or 'age', from the dictionary:\n\nNow, we'll illustrate how dictionaries can be modified because they are mutable. Let's consider a scenario where Anna relocates from Berlin to Freiburg, renowned as one of Germany's most picturesque cities, known for its favorable weather compared to other regions in the country.\n\nLike lists, they can be easily changed, can be shrunk and grown ad libitum at run time. They shrink and grow without the necessity of making copies. Dictionaries can be contained in lists and vice versa.\n\nLet's add Anna's gender and her favorite hobbies, which include reading, music, and programming (as she's a beginner in Python), to the existing dictionary:\n\nNow, we remove again the gender information from the dictionary:\n\nMore theoretically, we can say that dictionaries are the Python implementation of an abstract data type, known in computer science as an associative array. Associative arrays consist - like dictionaries of (key, value) pairs, such that each possible key appears at most once in the collection. Any key of the dictionary is associated (or mapped) to a value. The values of a dictionary can be any type of Python data. So, dictionaries are unordered key-value-pairs. Dictionaries are implemented as hash tables, and that is the reason why they are known as \"Hashes\" in the programming language Perl.\n\nDictionaries don't support the sequence operation of the sequence data types like strings, tuples and lists. Dictionaries belong to the built-in mapping type, but so far, they are the sole representative of this kind!\n\nAt the end of this chapter, we will demonstrate how a dictionary can be turned into one list, containing (key,value)-tuples or two lists, i.e. one with the keys and one with the values. This transformation can be done reversely as well.\n\nBut what's the difference between lists and dictionaries?\n\nA list is a sequence of objects where the order matters. You can access list elements directly by their position in this order. Similarly, dictionaries are also ordered, but unlike lists, you can't access elements by their position. We can also say that contrary to lists that the order of a dictionary is not important. The order of items in a dictionary is determined by the sequence in which they were added. If we print a dictionary, we can see this ordering.\n\nLet's demonstrate this with the following dictionary:\n\nWe will add now the German cities \"München\" (Munich) and \"Köln' (Cologne) to our dictionary:\n\nWe can see that the cities \"München\" (Munich) and \"Köln' (Cologne) had been added to the end of the dictionary as expected.\n\nIf you have worked for a while with Python, nearly inevitably the moment will come, when you want or have to convert lists into dictionaries or vice versa. It wouldn't be too hard to write a function doing this. But Python wouldn't be Python, if it didn't provide such functionalities. We can convert the previously defined dictionary into a list with the following expression:\n\nThis list holds the identical information as the dictionary city_population. However, retrieving this data differs significantly. What if you want to get the population of Amsterdam? It's extremely easy with the dictionary:\n\nIt's a lot more complicated in the list representation. We're limited to accessing indices rather than city names. Consequently, we must iterate over the list and inspect all the tuples to determine if the first entry corresponds to the city of Amsterdam.\n\nIn this aspect, the dictionary method outperforms the list approach by enabling swifter data access. In a dictionary, you can directly retrieve the population of a city using its name as the key, which is much quicker compared to searching through a list to find the population. Think of it like looking up a word in a dictionary versus flipping through the pages of a book to find it. The dictionary provides instant access, while the list requires more time to search through.\n\nThe efficiency of this algorithm depends on the size of the city_population_list. Since it iterates through the entire list linearly to find the population of a given city, the time complexity is O(n), where n is the number of cities in the list.\n\nFor a small number of cities, this approach is acceptable. However, as the number of cities grows larger, the linear search becomes less efficient, especially if the city being searched for is towards the end of the list or if the list contains a large number of cities.\n\nIn scenarios where performance is critical or when dealing with a large dataset, a more efficient approach would be to use a dictionary instead of a list, where the keys are the city names. This would allow constant-time (O(1)) lookups, providing faster access to population data.\n\nIf we apply the method items() to a dictionary, we don't get a list back, as it used to be the case in Python 2, but a so-called items view. The items view can be turned into a list by applying the list function. We have no information loss by turning a dictionary into an item view or an items list, i.e. it is possible to recreate the original dictionary from the view created by items().\n\nAccessing dictionary items via a method like items() provides a more efficient approach compared to creating lists directly due to several reasons:\n\n1) Lazy Evaluation: The items() method doesn't generate the entire list of key-value pairs upfront. Instead, it returns a view object that generates items on-the-fly as needed. This lazy evaluation saves memory and processing time, especially when dealing with large dictionaries where creating a complete list of items upfront may be resource-intensive.\n\n2) Memory Efficiency: Generating a list of items directly requires storing all key-value pairs in memory simultaneously, which can be inefficient for large dictionaries. In contrast, using items() provides a memory-efficient solution as it generates items dynamically without storing the entire list in memory at once.\n\n3) Time Complexity: While both approaches have similar time complexity for iterating over all items (O(n), where n is the number of items in the dictionary), using items() may provide better performance in certain scenarios. For example, if only a subset of items is needed, items() allows for efficient iteration over only the required items without iterating over the entire dictionary.\n\nOverall, using methods like items() for accessing dictionary items provides a more efficient and memory-friendly approach, especially for large dictionaries or scenarios where lazy evaluation and selective item retrieval are beneficial.\n\nThe keys() method returns a view object that displays a list of all keys in the dictionary. This allows you to iterate over or access the keys directly without needing to create a separate list of keys.\n\nWhile the keys() method is available in Python dictionaries, it's less commonly used because iterating over a dictionary directly implicitly iterates over its keys. Here's an example demonstrating this:\n\nWe can also iterate directly over the values of a dictionary:\n\nNow we will turn our attention to the art of cooking, but don't be afraid, this remains a python course and not a cooking course. We want to show you, how to turn lists into dictionaries, if these lists satisfy certain conditions. We have two lists, one containing the names of the largest German cities and the other one the corresponding areas:\n\nIn this example, we have two lists: containing the names of the five largest cities in Germany, and containing their respective areas in square kilometers. We use the function to combine these lists into a list of tuples, then we use the function to convert this list of tuples into a dictionary, where each city is paired with its respective area.\n\nTo gain further insight into the functionality of the zip function, explore our tutorial available at 'zip'.\n\nWhat is wrong with the following example:\n\nThe issue with this example is that we are converting items to a list using list(items) before iterating over it. Once you convert items to a list, it becomes exhausted, meaning it doesn't contain any more elements for iteration.\n\nSo, it's possible to create a dictionary incrementally by starting with an empty dictionary. We haven't mentioned so far, how to define an empty one. It can be done by using an empty pair of brackets. The following defines an empty dictionary called city:\n\nCloser Look at Keys and Values\n\nLooking at our first examples with the cities and their population, you might have gotten the wrong impression that the values in the dictionaries have to be different. The values can be the same, as you can see in the following example. In honour to the patron saint of Python \"Monty Python\", we'll have now some special food dictionaries. What's Python without \"bacon\", \"egg\" and \"spam\"?\n\nKeys of a dictionary are unique. In casse a keys is defined multiple times, the value of the last \"wins\":\n\nOur next example is a simple English-German dictionary:\n\nWhat about having another language dictionary, let's say German-French?\n\nNow it's even possible to translate from English to French, even though we don't have an English-French-dictionary. de_fr[en_de[\"red\"]] gives us the French word for \"red\", i.e. \"rouge\":\n\nWe can use arbitrary types as values in a dictionary, but there is a restriction for the keys. Only immutable data types can be used as keys, i.e. no lists or dictionaries can be used: If you use a mutable data type as a key, you get an error message:\n\nTuple as keys are okay, as you can see in the following example:\n\nNested dictionaries are dictionaries that contain other dictionaries as values. In Python, dictionaries can hold any data type as their values, including other dictionaries. This allows for the creation of hierarchical or nested data structures where each level of the dictionary can store its own set of key-value pairs.\n\nLet's improve our examples with the natural language dictionaries a bit. We create now a nested dictionary, i.e. a dictionary of dictionaries:\n\nThe following dictionary contains a mapping from latin characters to morsecode.\n\nThe numbers of characters contained in this dictionary can be determined by calling the len function:\n\nThe dictionary contains only upper case characters, so that \"a\" returns False, for example:\n\nNow, we will output a space character with three spaces in the morsecode encoding:\n\nLists can serve as stacks, with the pop() method used to extract an element from the stack. This functionality is straightforward for lists. However, considering dictionaries, does it make sense to have a pop() method? Unlike lists, dictionaries are not sequential data structures; they lack indexing. Consequently, the pop() method behaves differently with dictionaries.\n\nIn dictionaries, the pop() method is used to remove a specific key-value pair from the dictionary and return the corresponding value. Here's how it works:\n\n1) You specify the key of the item you want to remove as an argument to the pop() method. 2) The pop() method then searches for this key in the dictionary. 3) If the key is found, the corresponding key-value pair is removed from the dictionary, and the value associated with the key is returned. 4) If the key is not found, a KeyError is raised.\n\nHere's an example to illustrate:\n\nIf we try to find out the capital of France in the previous example, we raise a KeyError. To prevent these errors, there is an elegant way. The method pop() has an optional second parameter, which can be used as a default value, if key is not in the dictionary:\n\npopitem() is a method of dict, which doesn't take any parameter and removes and returns a (key,value) pair as a 2-tuple. If popitem() is applied on an empty dictionary, a KeyError will be raised.\n\nIf you try to access a key which doesn't exist, you will get an error message:\n\nTo prevent getting an exception we can check first, if the city is in:\n\nAnother method to access the values via the key consists in using the get() method. get() is not raising an error, if an index doesn't exist. In this case it will return None. It's also possible to set a default value, which will be returned, if an index doesn't exist:\n\nA dictionary can be copied with the method copy():\n\nThis copy is a shallow copy, not a deep copy. If a value is a complex data type like a list, for example, in-place changes in this object have effects on the copy as well:\n\nIf we check the output, we can see that the title of course2 has been changed not only in the dictionary training but in trainings2 as well.\n\nEverything works the way you expect it, if you assign a new value, i.e. a new object, to a key:\n\nIf you want to understand the reason for this behaviour, we recommend our chapter \"Shallow and Deep Copy\".\n\nThe content of a dictionary can be cleared with the method clear(). The dictionary is not deleted, but set to an empty dictionary:\n\nWhat about concatenating dictionaries, like we did with lists? There is someting similar for dictionaries: the update method update() merges the keys and values of one dictionary into another, overwriting values of the same key:\n\nNo method is needed to iterate over the keys of a dictionary:\n\nHowever, it's possible to use the method keys(), we will get the same result:\n\nThe method values() is a convenient way for iterating directly over the values:\n\nThe above loop is logically equivalent to the following one:\n\nWe said logically, because the second way is less efficient!\n\nIf you are familiar with the timeit possibility of ipython, you can measure the time used for the two alternatives:\n\nWrite a function dict_merge_sum that takes two dictionaries and as parameters. The values of both dictionaries are numerical. The function should return the merged sum dictionary of those dictionaries. If a key is both in and , the corresponding values will be added and included in the dictionary If is only contained in one of the dictionaries, the and the corresponding value will be included in\n\nGiven is the following simplified data of a supermarket:\n\nTo be ready for an imminent crisis you decide to buy everything. This isn't particularly social behavior, but for the sake of the task, let's imagine it. The question is how much will you have to pay?\n• Create a virtual supermarket. For every article there is a price per article and a quantity, i.e. the stock. (Hint: you can use the one from the previous exercise!)\n• Create shopping lists for customers. The shopping lists contain articles plus the quantity.\n• The customers fill their carts, one after the other. Check if enough goods are available! Create a receipt for each customer.\n\nGiven is the island of Vannoth\n\nCreate a dictionary, where we get for every city of Vannoth the distance to the capital city of Rogeburgh\n\nCreate a dictionary where you can get the distance between two arbitrary cities\n\nA salesperson takes the following route: Port Carol to Rogerburgh to Smithstad to Scottshire to Clarkhaven to Dixonshire to Port Carol. How many kilometres did the salesperson drive?\n\nTo solve this dictionary exercise it will be optimal, if you are familiar with 'for' or while loops in Python. We recommend to work through the corresponding chapters in our python course.\n\nWrite Pyhton code to create a dictionary with the city names as keys and the corresponding areas and population numbers as values.\n\nTo solve this exercise you have to be familiar with functions in Python, see our introduction on functions in our python course.\n\nCreate a Python program to manage a student gradebook using nested dictionaries. Follow these steps to implement the functionality:\n• Initialize an empty dictionary to serve as the gradebook.\n• Implement a function that takes the gradebook dictionary and a student name as input and adds an empty dictionary for the student's grades to the gradebook.\n• Implement a function that takes the gradebook dictionary, a student name, a subject name, and a grade as input. This function should add the grade for the specified subject to the grades dictionary of the specified student in the gradebook.\n• Implement a function that takes the gradebook dictionary and a student name as input and calculates the average grade for the specified student.\n• Implement a function that takes the gradebook dictionary as input and displays the contents of the gradebook, including student names, subjects, and grades, as well as the average grade for each student.\n\nUse the provided sample usage to demonstrate the functionality of your program.\n\nNote: You may assume that each student will have unique names, and subjects may have duplicate names but within the context of different students.\n\nAn example dictionary may look like this:\n\nSample usage looks like this:\n\nWe offer two solutions to this exercise:\n\nThe first one is only using things you will have learned, if you followed our Python course sequentially. The second solution uses techniques which will be covered later in our tutorial.\n\nAlternative solution to exercise 3, in which we create the chopping lists randomly:\n\n1 The city of Constance, also known as Konstanz in German, holds historical significance as it was the site of the Council of Constance from 1414 to 1418. This council played a crucial role in resolving the Papal Schism, which involved multiple claimants to the papacy. Additionally, Constance is located at the western end of Lake Constance (Bodensee), where Germany, Switzerland, and Austria meet, making it a picturesque and culturally rich destination.\n\n2 If you would like to learn more about how iterators work and how to use them, we recommend that you go through our Iterators and Generators chapter."
    },
    {
        "link": "https://stackoverflow.com/questions/72073198/python-output-list-of-dictionary-in-specific-format",
        "document": "Hello I am new to python this may be something small but I am finding it difficult on how to get output in a specific format.\n\nI have the following list of dict being returned\n\nBelow is the snippet from my script\n\nThe output of which is following\n\nWhereas I want an output like this\n\ni.e. \"account_number\" which are same then those vpcs should be appended instead of creating a new entry. Any help would be greatly appreciated thank you"
    },
    {
        "link": "https://geeksforgeeks.org/differences-and-applications-of-list-tuple-set-and-dictionary-in-python",
        "document": "Differences and Applications of List, Tuple, Set and Dictionary in Python\n\nPython provides us with several in-built data structures such as lists, tuples, sets, and dictionaries that store and organize the data efficiently. In this article, we will learn the difference between them and their applications in Python.\n\nThe following table shows the difference between various Python built-in data structures.\n\nA list is a non-homogeneous data structure that stores the elements in columns of a single row or multiple rows. A Tuple is a non-homogeneous data structure that stores elements in columns of a single row or multiple rows. The set data structure is non-homogeneous but stores the elements in a single row. A dictionary is also a non-homogeneous data structure that stores key-value pairs. The list can be represented by [ ] A tuple can be represented by ( ) The set can be represented by { } The dictionary can be represented by { } The Set will not allow duplicate elements The list can be nested among all A tuple can be nested among all The set can be nested among all The dictionary can be nested among all A list can be created using the list() function Tuple can be created using the tuple() function. A set can be created using the set() function A dictionary can be created using the dict() function. A list is mutable i.e we can make any changes in the list. A tuple is immutable i.e we can not make any changes in the tuple. A set is mutable i.e we can make any changes in the set, its elements are not duplicated. A dictionary is mutable, its Keys are not duplicated. Dictionary is ordered (Python 3.7 and above)\n\nPython Lists are just like dynamic-sized arrays, declared in other languages (vector in C++ and ArrayList in Java). Lists need not be homogeneous always which makes it the most powerful tool in Python.\n\nHere are five important applications of Python lists:\n• Application : Python lists are used to store and manipulate collections of data, whether homogeneous (e.g., all integers) or heterogeneous (e.g., a mix of integers, strings, and other types).\n• Example : A list can store a series of sensor readings, user inputs, or any other sequential data that can be modified, updated, or analyzed.\n• Application : Lists are commonly used to implement stacks ( : First-In, First-Out) due to their ability to add and remove elements from the end or beginning.\n• Example to push onto a stack and\n• Application : Lists are ideal for storing data that needs to be iterated over and processed, such as reading data from files, performing computations, or generating reports.\n• Example : Iterating through a list of numbers to calculate their sum.\n• Application : Lists in Python are dynamic arrays, meaning they can grow and shrink in size. This is useful in applications where the size of the dataset isn’t known in advance and needs to be adjusted dynamically.\n• Example : Collecting user inputs or dynamically generating a list of results based on computations.\n• Application : Lists are often used to store and manipulate strings, especially when dealing with text processing tasks such as tokenization, filtering, or transforming data.\n• Example : Splitting a sentence into words and performing operations on each word.\n\nA Tuple is a collection of Python objects separated by commas. In some ways, a tuple is similar to a list in terms of indexing, nested objects, and repetition but a tuple is immutable, unlike lists that are mutable.\n\nHere are five important applications of Python tuples:\n• Purpose : Tuples are immutable, meaning once created, they cannot be modified. This makes them ideal for storing data that should not change throughout the program, such as configuration settings, constants, or fixed data points.\n• Purpose : Because tuples are immutable, they can be used as keys in a dictionary. This is not possible with lists, as they are mutable and hence\n• Example : Using tuples to represent composite keys in a dictionary.\n• Purpose : Tuples can hold elements of different data types. This makes them useful for grouping together heterogeneous data that logically belongs together.\n• Example : Storing a person’s name, age, and email in a single tuple.\n\nA Python Set is an unordered collection data type that is iterable, mutable and has no duplicate elements. Python’s set class represents the mathematical notion of a set.\n\nHere are five important applications of Python sets:\n• Application : When you need to eliminate duplicate elements from a list, converting the list to a set is a quick and efficient way to do so.\n• Application : Sets are ideal for performing mathematical operations like union, intersection, and difference, which are useful in fields like data analysis, database management, and computational biology.\n• Application : Checking for the existence of an element in a collection is very efficient with sets due to their underlying hash table implementation. This makes sets a good choice for membership testing in scenarios like checking if an item is in a list of prohibited items.\n• Application : Sets are highly efficient for finding common elements between two or more collections. This is useful in scenarios like finding common interests, mutual friends, or common values between datasets.\n• Application : Sets are useful when dealing with multiple data sources where you need to ensure the uniqueness of the combined dataset or identify overlaps between different data sources.\n\nDictionary in Python is an ordered (since Py 3.7) [unordered (Py 3.6 & prior)] collection of data values, used to store data values like a map, which, unlike other Data Types that hold only a single value as an element, Dictionary holds key:value pair. Key-value is provided in the dictionary to make it more optimized.\n\nHere are five important applications of Python dictionaries:\n• Application : Dictionaries are often used to represent database records where each key-value pair corresponds to a column and its associated value. This makes it easy to access and manipulate data based on field names.\n• Application : Dictionaries can be used to count the frequency of elements in a list, string, or any iterable. The element itself serves as the key, and its frequency is the value.\n• Application : Dictionaries provide O(1) average time complexity for lookups, making them ideal for creating fast lookup tables. This can be used in applications like caching, memoization, or mapping operations.\n• Application : JSON data, which is commonly used for APIs and web services, maps directly to Python dictionaries. This allows for easy storage, access, and manipulation of JSON data.\n• Application : Dictionaries can be used to group data by certain keys, which is particularly useful in data analysis and aggregation tasks.\n\nDifferences and Applications of List, Tuple, Set and Dictionary in Python – FAQs\n\nWhat Are the Differences Between Lists, Tuples, Sets, and Dictionaries in Python?\n\nWhen Should You Use a List Over a Tuple in Python?\n\nHow Does a Set Differ from a List and Tuple in Python?\n\nWhat Are the Common Use Cases for Dictionaries in Python?\n\nHow Do List Comprehensions Work in Python?"
    }
]