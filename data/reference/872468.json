[
    {
        "link": "https://gnu.org/s/bash/manual/bash.html",
        "document": "This text is a brief description of the features that are present in the Bash shell (version 5.2, 19 September 2022). The Bash home page is http://www.gnu.org/software/bash/.\n\nThis is Edition 5.2, last updated 19 September 2022, of , for , Version 5.2.\n\nBash contains features that appear in other popular shells, and some features that only appear in Bash. Some of the shells that Bash has borrowed concepts from are the Bourne Shell ( ), the Korn Shell ( ), and the C-shell ( and its successor, ). The following menu breaks the features up into categories, noting which features were inspired by other shells and which are specific to Bash.\n\nThis manual is meant as a brief introduction to features found in Bash. The Bash manual page should be used as the definitive reference on shell behavior.\n\nNext: Indexes, Previous: Major Differences From The Bourne Shell, Up: Bash Features [Contents][Index] Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, or using a publicly available , and standard-conforming simple , PostScript or designed for human modification. Examples of transparent image formats include , and . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, or for which the and/or processing tools are not generally available, and the machine-generated , PostScript or produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing. ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page: Copyright (C) . Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled ``GNU Free Documentation License''. If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this: with the Invariant Sections being , with the Front-Cover Texts being , and with the Back-Cover Texts being . If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
    },
    {
        "link": "https://gnu.org/software/bash/manual/bashref.html",
        "document": "This text is a brief description of the features that are present in the Bash shell (version 5.2, 19 September 2022). The Bash home page is http://www.gnu.org/software/bash/.\n\nThis is Edition 5.2, last updated 19 September 2022, of , for , Version 5.2.\n\nBash contains features that appear in other popular shells, and some features that only appear in Bash. Some of the shells that Bash has borrowed concepts from are the Bourne Shell ( ), the Korn Shell ( ), and the C-shell ( and its successor, ). The following menu breaks the features up into categories, noting which features were inspired by other shells and which are specific to Bash.\n\nThis manual is meant as a brief introduction to features found in Bash. The Bash manual page should be used as the definitive reference on shell behavior.\n\nNext: Indexes, Previous: Major Differences From The Bourne Shell, Up: Bash Features [Contents][Index] Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, or using a publicly available , and standard-conforming simple , PostScript or designed for human modification. Examples of transparent image formats include , and . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, or for which the and/or processing tools are not generally available, and the machine-generated , PostScript or produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing. ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page: Copyright (C) . Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled ``GNU Free Documentation License''. If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this: with the Invariant Sections being , with the Front-Cover Texts being , and with the Back-Cover Texts being . If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
    },
    {
        "link": "https://devdocs.io/bash",
        "document": ""
    },
    {
        "link": "https://tldp.org/LDP/abs/abs-guide.pdf",
        "document": ""
    },
    {
        "link": "https://bu.edu/tech/files/2019/06/Intro-To-Scripting-with-Bash.pdf",
        "document": ""
    },
    {
        "link": "https://fio.readthedocs.io/en/latest/fio_doc.html",
        "document": "This section describes in details each parameter associated with a job. Some parameters take an option of a given type, such as an integer or a string. Anywhere a numeric value is required, an arithmetic expression may be used, provided it is surrounded by parentheses. Supported operators are: For time values in expressions, units are microseconds by default. This is different than for time values not in expressions (not enclosed in parentheses). The following types are used: Integer with possible time suffix. Without a unit value is interpreted as seconds unless otherwise specified. Accepts a suffix of ‘d’ for days, ‘h’ for hours, ‘m’ for minutes, ‘s’ for seconds, ‘ms’ (or ‘msec’) for milliseconds and ‘us’ (or ‘usec’) for microseconds. For example, use 10m for 10 minutes. Integer. A whole number value, which may contain an integer prefix and an integer suffix: The optional integer prefix specifies the number’s base. The default is decimal. 0x specifies hexadecimal. The optional integer suffix specifies the number’s units, and includes an optional unit prefix and an optional unit. For quantities of data, the default unit is bytes. For quantities of time, the default unit is seconds unless otherwise specified. With =1000, fio follows international standards for unit prefixes. To specify power-of-10 decimal values defined in the International System of Units (SI): To specify power-of-2 binary values defined in IEC 80000-13: With =1024 (the default), the unit prefixes are opposite from those specified in the SI and IEC 80000-13 standards to provide compatibility with old scripts. For example, 4k means 4096. For quantities of data, an optional unit of ‘B’ may be included (e.g., ‘kB’ is the same as ‘k’). The integer suffix is not case sensitive (e.g., m/mi mean mebi/mega, not milli). ‘b’ and ‘B’ both mean byte, not bit. To specify times (units are not case sensitive): If the option accepts an upper and lower range, use a colon ‘:’ or minus ‘-’ to separate such values. See irange. If the lower value specified happens to be larger than the upper value the two values are swapped. Boolean. Usually parsed as an integer, however only defined for true and false (1 and 0). Integer range with suffix. Allows value range to be given, such as 1024-4096. A colon may also be used as the separator, e.g. 1k:4k. If the option allows two sets of ranges, they can be specified with a ‘,’ or ‘/’ delimiter: 1k-4k/8k-32k. Also see int. With the above in mind, here follows the complete list of fio job parameters. Select the interpretation of unit prefixes in input parameters. Inputs comply with IEC 80000-13 and the International System of Units (SI). Use: See for more details on input parameters. Outputs always use correct prefixes. Most outputs include both side-by-side, like: If only one value is reported, then kb_base selects the one to use: ASCII name of the job. This may be used to override the name printed by fio for this job. Otherwise the job name is used. On the command line this parameter has the special purpose of also signaling the start of a new job. Text description of the job. Doesn’t do anything except dump this text description when this job is run. It’s not parsed. Run the specified number of iterations of this job. Used to repeat the same workload a given number of times. Defaults to 1. Create the specified number of clones of this job. Each clone of job is spawned as an independent thread or process. May be used to setup a larger number of threads/processes doing the same thing. Each thread is reported separately; to see statistics for all clones as a whole, use in conjunction with . See . Default: 1. Limit runtime. The test will run until it completes the configured I/O workload or until it has run for this specified amount of time, whichever occurs first. It can be quite hard to determine for how long a specified job will run, so this parameter is handy to cap the total runtime to a given time. When the unit is omitted, the value is interpreted in seconds. If set, fio will run for the duration of the specified even if the file(s) are completely read or written. It will simply loop over the same workload as many times as the allows. Delay the start of job for the specified amount of time. Can be a single value or a range. When given as a range, each thread will choose a value randomly from within the range. Value is in seconds if a unit is omitted. If set, fio will run the specified workload for this amount of time before logging any performance numbers. Useful for letting performance settle before logging results, thus minimizing the runtime required for stable results. Note that the is considered lead in time for a job, thus it will increase the total runtime if a special timeout or is specified. When the unit is omitted, the value is given in seconds. Use the given clocksource as the base of timing. The supported options are: cpu is the preferred clocksource if it is reliable, as it is very fast (and fio is heavy on time calls). Fio will automatically use this clocksource if it’s supported and considered reliable on the system it is running on, unless another clocksource is specifically set. For x86/x86-64 CPUs, this means supporting TSC Invariant. Enable all of the gettimeofday(2) reducing options ( , , ) plus reduce precision of the timeout somewhat to really shrink the gettimeofday(2) call count. With this option enabled, we only do about 0.4% of the gettimeofday(2) calls we would have done if all time keeping was enabled. Sometimes it’s cheaper to dedicate a single thread of execution to just getting the current time. Fio (and databases, for instance) are very intensive on gettimeofday(2) calls. With this option, you can set one CPU aside for doing nothing but logging current time to a shared memory location. Then the other threads/processes that run I/O workloads need only copy that segment, instead of entering the kernel with a gettimeofday(2) call. The CPU set aside for doing these time calls will be excluded from other uses. Fio will manually clear it from the CPU mask of other jobs. The clock_id passed to the call to used to record job_start in the output format. Default is 0, or CLOCK_REALTIME. Prefix filenames with this directory. Used to place files in a different location than . You can specify a number of directories by separating the names with a ‘:’ character. These directories will be assigned equally distributed to job clones created by as long as they are using generated filenames. If specific are set fio will use the first listed directory, and thereby matching the semantic (which generates a file for each clone if not specified, but lets all clones use the same file if set). See the option for information on how to escape “ ” characters within the directory path itself. Note: To control the directory fio will use for internal state files use . Fio normally makes up a based on the job name, thread number, and file number (see ). If you want to share files between threads in a job or several jobs with fixed file paths, specify a for each of them to override the default. If the ioengine is file based, you can specify a number of files by separating the names with a ‘:’ colon. So if you wanted a job to open and as the two working files, you would use . This also means that whenever this option is specified, is ignored. The size of regular files specified by this option will be divided by number of files unless an explicit size is specified by . Each colon in the wanted path must be escaped with a character. For instance, if the path is then you would use and if the path is then you would use . On Windows, disk devices are accessed as for the first device, for the second etc. Note: Windows and FreeBSD (refer to geom(4)) prevent write access to areas of the disk containing in-use data (e.g. filesystems). For HTTP and S3 access, specify a valid URL path or S3 key, respectively. A filename for path-style S3 includes a bucket name ( ) while a virtual-hosted-style S3 filename does not because its bucket name is specified in . The filename “ ” is a reserved name, meaning stdin or stdout. Which of the two depends on the read/write direction set. If sharing multiple files between jobs, it is usually necessary to have fio generate the exact names that you want. By default, fio will name a file based on the default file format specification of . With this option, that can be customized. Fio will recognize and replace the following keywords in this string: The name of the worker thread or process. IP of the fio process when using client/server mode. The incremental number of the worker thread or process. The incremental number of the file for that worker thread or process. To have dependent jobs share a set of files, this option can be set to have fio generate filenames that are shared between the two. For instance, if is specified, file number 4 for any job will be named . The default of will be used if no other format specifier is given. If you specify a path then the directories will be created up to the main directory for the file. So for example if you specify then the directories a/b/c will be created before the file setup part of the job. If you specify then the path will be relative that directory, otherwise it is treated as the absolute path. To avoid collisions between networked clients, fio defaults to prefixing any generated filenames (with a directory specified) with the source of the client connecting. To disable this behavior, set this option to 0. Recursively open any files below directory . This accepts only a single directory and unlike related options, colons appearing in the path must not be escaped. Fio defaults to not locking any files before it does I/O to them. If a file or file descriptor is shared, fio can serialize I/O to that file to make the end result consistent. This is usual for emulating real workloads that share files. The lock modes are: Only one thread or process may do I/O at a time, excluding all others. Read-write locking on the file. Many readers may access the file at the same time, but writes get exclusive access. Number of files to use for this job. Defaults to 1. The size of files will be divided by this unless explicit size is specified by . Files are created for each thread separately, and each file will have a file number within its name by default, as explained in section. Number of files to keep open at the same time. Defaults to the same as , can be set smaller to limit the number simultaneous opens. Defines how fio decides which file from a job to service next. The following types are defined: Round robin over opened files. This is the default. Finish one file before moving on to the next. Multiple files can still be open depending on . Use a Zipf distribution to decide what file to access. Use a Pareto distribution to decide what file to access. Use a Gaussian (normal) distribution to decide what file to access. For random, roundrobin, and sequential, a postfix can be appended to tell fio how many I/Os to issue before switching to a new file. For example, specifying would cause fio to issue 8 I/Os before selecting a new file at random. For the non-uniform distributions, a floating point postfix can be given to influence how the distribution is skewed. See for a description of how that would work. Attempt to switch the device hosting the file to the specified I/O scheduler before running. If true, serialize the file creation for the jobs. This may be handy to avoid interleaving of data files, which may greatly depend on the filesystem used and even the number of processors in the system. Default: true. fsync(2) the data file after creation. This is the default. If true, don’t pre-create files but allow the job’s open() to create a file when it’s time to do I/O. Default: false – pre-create all necessary files when the job starts. If true, fio will only run the setup phase of the job. If files need to be laid out or updated on disk, only that will be done – the actual job contents are not executed. Default: false. If true, fio is permitted to create files as part of its workload. If this option is false, then fio will error out if the files it needs to use don’t already exist. Default: true. If this isn’t set, fio will abort jobs that are destructive (e.g. that write) to what appears to be a mounted device or partition. This should help catch creating inadvertently destructive tests, not realizing that the test will destroy data on the mounted file system. Note that some platforms don’t allow writing against a mounted device regardless of this option. Default: false. If this is given, files will be pre-read into memory before starting the given I/O operation. This will also clear the flag, since it is pointless to pre-read and then drop the cache. This will only work for I/O engines that are seek-able, since they allow you to read the same data multiple times. Thus it will not work on non-seekable I/O engines (e.g. network, splice). Default: false. Unlink (delete) the job files when done. Not the default, as repeated runs of that job would then waste time recreating the file set again and again. Default: false. Unlink (delete) job files after each iteration or loop. Default: false. The , , and parameters are ignored. I/O happens in a single zone until bytes have been transferred. After that number of bytes has been transferred processing of the next zone starts. is ignored. Zoned block device mode. I/O happens sequentially in each zone, even if random I/O has been selected. Random I/O happens across all zones instead of being restricted to a single zone. The parameter is ignored. and must be identical. Trim is handled using a zone reset operation. Trim only considers non-empty sequential write required and sequential write preferred zones. Size of a single zone. See also and . For =strided, this is the number of bytes to transfer before skipping bytes. If this parameter is smaller than then only a fraction of each zone with bytes will be accessed. If this parameter is larger than then each zone will be accessed multiple times before skipping to the next zone. For =zbd, this is the size of a single zone. The parameter is ignored in this mode. For =zbd, this defines the capacity of a single zone, which is the accessible area starting from the zone start address. This parameter only applies when using =zbd in combination with regular block devices. If not specified it defaults to the zone size. If the target device is a zoned block device, the zone capacity is obtained from the device information and this option is ignored. For =strided, the number of bytes to skip after bytes of data have been transferred. This parameter must be zero for =zbd. This parameter applies to =zbd only. Zoned block devices are block devices that consist of multiple zones. Each zone has a type, e.g. conventional or sequential. A conventional zone can be written at any offset that is a multiple of the block size. Sequential zones must be written sequentially. The position at which a write must occur is called the write pointer. A zoned block device can be either drive managed, host managed or host aware. For host managed devices the host must ensure that writes happen sequentially. Fio recognizes host managed devices and serializes writes to sequential zones for these devices. If a read occurs in a sequential zone beyond the write pointer then the zoned block device will complete the read without reading any data from the storage medium. Since such reads lead to unrealistically high bandwidth and IOPS numbers fio only reads beyond the write pointer if explicitly told to do so. Default: false. When a zone of a zoned block device is partially written (i.e. not all sectors of the zone have been written), the zone is in one of three conditions: ‘implicit open’, ‘explicit open’ or ‘closed’. Zoned block devices may have a limit called ‘max_open_zones’ (same name as the parameter) on the total number of zones that can simultaneously be in the ‘implicit open’ or ‘explicit open’ conditions. Zoned block devices may have another limit called ‘max_active_zones’, on the total number of zones that can simultaneously be in the three conditions. The parameter limits the number of zones to which write commands are issued by all fio jobs, that is, limits the number of zones that will be in the conditions. When the device has the max_open_zones limit and does not have the max_active_zones limit, the parameter limits the number of zones in the two open conditions up to the limit. In this case, fio includes zones in the two open conditions to the write target zones at fio start. When the device has both the max_open_zones and the max_active_zones limits, the parameter limits the number of zones in the three conditions up to the limit. In this case, fio includes zones in the three conditions to the write target zones at fio start. This parameter is relevant only if the =zbd is used. The default value is always equal to the max_open_zones limit of the target zoned block device and a value higher than this limit cannot be specified by users unless the option is specified. When is specified or the target device does not have the max_open_zones limit, can specify 0 to disable any limit on the number of zones that can be simultaneously written to by all jobs. In the same manner as , limit the number of open zones per fio job, that is, the number of zones that a single job can simultaneously write to. A value of zero indicates no limit. Default: zero. If this option is used, fio will ignore the maximum number of open zones limit of the zoned block device in use, thus allowing the option value to be larger than the device reported limit. Default: false. A number between zero and one that indicates the ratio of written bytes in the zones with write pointers in the IO range to the size of the IO range. When current ratio is above this ratio, zones are reset periodically as specifies. If there are multiple jobs when using this option, the IO range for all write jobs has to be the same. A number between zero and one that indicates how often a zone reset should be issued if the zone reset threshold has been exceeded. A zone reset is submitted after each (1 / zone_reset_frequency) write requests. This and the previous parameter can be used to simulate garbage collection activity. If value is true, use non-buffered I/O. This is usually O_DIRECT. Note that OpenBSD and ZFS on Solaris don’t support direct I/O. On Windows the synchronous ioengines don’t support direct I/O. Default: false. If value is true, use buffered I/O. This is the opposite of the option. Defaults to true. Sequential trim+write sequences. Blocks will be trimmed first, then the same blocks will be written to. So if is specified, Fio will trim a total of 64K bytes and also write 64K bytes on the same trimmed blocks. This behaviour will be consistent with or other Fio options limiting the total bytes or number of I/O’s. Like trimwrite, but uses random offsets rather than sequential writes. Fio defaults to read if the option is not specified. For the mixed I/O types, the default is to split them 50/50. For certain types of I/O the result may still be skewed a bit, since the speed may be different. It is possible to specify the number of I/Os to do before getting a new offset by appending to the end of the string given. For a random read, it would look like for passing in an offset modifier with a value of 8. If the suffix is used with a sequential I/O pattern, then the <nr> value specified will be added to the generated offset for each I/O turning sequential I/O into sequential I/O with holes. For instance, using will skip 4k for every write. Also see the option. If an offset modifier is given by appending a number to the line, then this option controls how that number modifies the I/O offset being generated. Accepted values are: is only useful for random I/O, where fio would normally generate a new random offset for every I/O. If you append e.g. 8 to randread, i.e. you would get a new random offset for every 8 I/Os. The result would be a sequence of 8 sequential offsets with a random starting point. However this behavior may change if a sequential I/O reaches end of the file. As sequential I/O is already sequential, setting for that would not result in any difference. behaves in a similar fashion, except it sends the same offset 8 number of times before generating a new offset. The generated sequence of offsets will look like this: 4k, 8k, 12k, 16k, 20k, 24k, 28k, 32k, 92k, 96k, 100k, 104k, 108k, 112k, 116k, 120k, 48k, 52k … The generated sequence of offsets will look like this: 4k, 4k, 4k, 4k, 4k, 4k, 4k, 4k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 48k, 48k, 48k … Fio normally reports statistics on a per data direction basis, meaning that reads, writes, and trims are accounted and reported separately. This option determines whether fio reports the results normally, summed together, or as both options. Accepted values are: Statistics are summed per data direction and reported together. Statistics are reported normally, followed by the mixed statistics. Seed all random number generators in a predictable way so the pattern is repeatable across runs. Default: true. Seed the random number generators based on this seed value, to be able to control what sequence of output is being generated. If not set, the random sequence depends on the setting. Whether pre-allocation is performed when laying down files. Accepted values are: Use a platform’s native pre-allocation call but fall back to none behavior if it fails/is not implemented. Extend file to final size via ftruncate(2) instead of allocating. May not be available on all supported platforms. keep is only available on Linux. If using ZFS on Solaris this cannot be set to posix because ZFS doesn’t support pre-allocation. Default: native if any pre-allocation methods except truncate are available, none if not. Note that using truncate on Windows will interact surprisingly with non-sequential write patterns. When writing to a file that has been extended by setting the end-of-file information, Windows will backfill the unwritten portion of the file up to that offset with zeroes before issuing the new write. This means that a single small write to the end of an extended file will stall until the entire file has been filled with zeroes. Use posix_fadvise(2) or posix_fadvise(2) to advise the kernel on what I/O patterns are likely to be issued. Accepted values are: Backwards compatible hint for “advise with fio workload type”. This uses FADV_RANDOM for a random workload, and FADV_SEQUENTIAL for a sequential workload. Advise using FADV_NOREUSE. This may be a no-op on older Linux kernels. Since Linux 6.3, it provides a hint to the LRU algorithm. See the posix_fadvise(2) man page. Use fcntl(2) to advise the kernel what life time to expect from a write. Only supported on Linux, as of version 4.13. Accepted values are: No particular life time associated with this file. Data written to this file has a short life time. Data written to this file has a medium life time. Data written to this file has a long life time. Data written to this file has a very long life time. The values are all relative to each other, and no absolute meaning should be associated with them. Start I/O at the provided offset in the file, given as either a fixed size in bytes, zones or a percentage. If a percentage is given, the generated offset will be aligned to the minimum or to the value of if provided. Data before the given offset will not be touched. This effectively caps the file size at . Can be combined with to constrain the start and end range of the I/O workload. A percentage can be specified by a number between 1 and 100 followed by ‘%’, for example, to specify 20%. In ZBD mode, value can be set as number of zones using ‘z’. If set to non-zero value, the byte offset generated by a percentage is aligned upwards to this value. Defaults to 0 meaning that a percentage offset is aligned to the minimum block size. If this is provided, then the real offset becomes , where the thread number is a counter that starts at 0 and is incremented for each sub-job (i.e. when option is specified). This option is useful if there are several jobs which are intended to operate on a file in parallel disjoint segments, with even spacing between the starting points. Percentages can be used for this option. If a percentage is given, the generated offset will be aligned to the minimum or to the value of if provided. In ZBD mode, value can also be set as number of zones using ‘z’. Fio will normally perform I/Os until it has exhausted the size of the region set by , or if it exhaust the allocated time (or hits an error condition). With this setting, the range/size can be set independently of the number of I/Os to perform. When fio reaches this number, it will exit normally and report status. Note that this does not extend the amount of I/O that will be done, it will only stop fio if this condition is met before other end-of-job criteria. If writing to a file, issue an fsync(2) (or its equivalent) of the dirty data for every number of blocks given. For example, if you give 32 as a parameter, fio will sync the file after every 32 writes issued. If fio is using non-buffered I/O, we may not sync the file. The exception is the sg I/O engine, which synchronizes the disk cache anyway. Defaults to 0, which means fio does not periodically issue and wait for a sync to complete. Also see and . Like but uses fdatasync(2) to only sync data and not metadata blocks. In Windows, DragonFlyBSD or OSX there is no fdatasync(2) so this falls back to using fsync(2). Defaults to 0, which means fio does not periodically issue and wait for a data-only sync to complete. Use sync_file_range(2) for every number of write operations. Fio will track range of writes that have happened since the last sync_file_range(2) call. can currently be one or more of: So if you do , fio would use for every 8 writes. Also see the sync_file_range(2) man page. This option is Linux specific. If true, writes to a file will always overwrite existing data. If the file doesn’t already exist, it will be created before the write phase begins. If the file exists and is large enough for the specified write phase, nothing will be done. Default: false. If true, fsync(2) file contents when a write stage has completed. Default: false. If true, fio will fsync(2) a dirty file on close. This differs from in that it will happen on every file close, not just at the end of the job. Default: false. Percentage of a mixed workload that should be reads. Default: 50. Percentage of a mixed workload that should be writes. If both and is given and the values do not add up to 100%, the latter of the two will be used to override the first. This may interfere with a given rate setting, if fio is asked to limit reads or writes to a certain rate. If that is the case, then the distribution may be skewed. Default: 50. By default, fio will use a completely uniform random distribution when asked to perform random I/O. Sometimes it is useful to skew the distribution in specific ways, ensuring that some parts of the data is more hot than others. fio includes the following distribution models: When using a zipf or pareto distribution, an input value is also needed to define the access pattern. For zipf, this is the . For pareto, it’s the . Fio includes a test program, fio-genzipf, that can be used visualize what the given input values will yield in terms of hit rates. If you wanted to use zipf with a of 1.2, you would use as the option. If a non-uniform model is used, fio will disable use of the random map. For the normal distribution, a normal (Gaussian) deviation is supplied as a value between 0 and 100. The second, optional float is allowed for pareto, zipf and normal distributions. It allows one to set base of distribution in non-default place, giving more control over most probable outcome. This value is in range [0-1] which maps linearly to range of possible random values. Defaults are: random for pareto and zipf, and 0.5 for normal. If you wanted to use zipf with a of 1.2 centered on 1/4 of allowed value range, you would use . For a zoned distribution, fio supports specifying percentages of I/O access that should fall within what range of the file or device. For example, given a criteria of:\n• None 60% of accesses should be to the first 10%\n• None 30% of accesses should be to the next 20%\n• None 8% of accesses should be to the next 30%\n• None 2% of accesses should be to the next 40% we can define that through zoning of the random accesses. For the above example, the user would do: A zoned_abs distribution works exactly like the zoned, except that it takes absolute sizes. For example, let’s say you wanted to define access according to the following criteria:\n• None 60% of accesses should be to the first 20G\n• None 30% of accesses should be to the next 100G\n• None 10% of accesses should be to the next 500G we can define an absolute zoning distribution with: For both zoned and zoned_abs, fio supports defining up to 256 separate zones. Similarly to how works for setting ranges and percentages of block sizes. Like , it’s possible to specify separate zones for reads, writes, and trims. If just one set is given, it’ll apply to all of them. This goes for both zoned zoned_abs distributions. For a random workload, set how big a percentage should be random. This defaults to 100%, in which case the workload is fully random. It can be set from anywhere from 0 to 100. Setting it to 0 would make the workload fully sequential. Any setting in between will result in a random mix of sequential and random I/O, at the given percentages. Comma-separated values may be specified for reads, writes, and trims as described in . Normally fio will cover every block of the file when doing random I/O. If this option is given, fio will just get a new random offset without looking at past I/O history. This means that some blocks may not be read or written, and that some blocks may be read/written more than once. If this option is used with and multiple blocksizes (via ), only intact blocks are verified, i.e., partially-overwritten blocks are ignored. With an async I/O engine and an I/O depth > 1, it is possible for the same block to be overwritten, which can cause verification errors. Either do not use norandommap in this case, or also use the lfsr random generator. See . If fio runs with the random block map enabled and it fails to allocate the map, if this option is set it will continue without a random block map. As coverage will not be as complete as with random maps, this option is disabled by default. Fio supports the following engines for generating I/O offsets for random I/O: tausworthe is a strong random number generator, but it requires tracking on the side if we want to ensure that blocks are only read or written once. lfsr guarantees that we never generate the same offset twice, and it’s also less computationally expensive. It’s not a true random generator, however, though for I/O purposes it’s typically good enough. lfsr only works with single block sizes, not with workloads that use multiple block sizes. If used with such a workload, fio may read or write some blocks multiple times. The default value is tausworthe, unless the required space exceeds 2^32 blocks. If it does, then tausworthe64 is selected automatically. The block size in bytes used for I/O units. Default: 4096. A single value applies to reads, writes, and trims. Comma-separated values may be specified for reads, writes, and trims. A value not terminated in a comma applies to subsequent types. means 8k for reads, 32k for writes and trims. means 8k for reads, 32k for writes, and default for trims. means default for reads, 8k for writes and trims. means default for reads, 8k for writes, and default for trims. A range of block sizes in bytes for I/O units. The issued I/O unit will always be a multiple of the minimum size, unless is set. Comma-separated ranges may be specified for reads, writes, and trims as described in . Example: also the ‘:’ delimiter . Sometimes you want even finer grained control of the block sizes issued, not just an even split between them. This option allows you to weight various block sizes, so that you are able to define a specific amount of block sizes issued. The format for this option is: for as many block sizes as needed. So if you want to define a workload that has 50% 64k blocks, 10% 4k blocks, and 40% 32k blocks, you would write: Ordering does not matter. If the percentage is left blank, fio will fill in the remaining values evenly. So a bssplit option like this one: would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up to 100, if bssplit is given a range that adds up to more, it will error out. Comma-separated values may be specified for reads, writes, and trims as described in . If you want a workload that has 50% 2k reads and 50% 4k reads, while having 90% 4k writes and 10% 8k writes, you would specify: Fio supports defining up to 64 different weights for each data direction. If set, fio will issue I/O units with any size within , not just multiples of the minimum size. This typically won’t work with direct I/O, as that normally requires sector alignment. If this option is set, fio will use the normal read,write blocksize settings as sequential,random blocksize settings instead. Any random read or write will use the WRITE blocksize settings, and any sequential read or write will use the READ blocksize settings. Boundary to which fio will align random I/O units. Default: . Minimum alignment is typically 512b for using direct I/O, though it usually depends on the hardware block size. This option is mutually exclusive with using a random map for files, so it will turn off that option. Comma-separated values may be specified for reads, writes, and trims as described in . Initialize buffers with all zeros. Default: fill buffers with random data. If this option is given, fio will refill the I/O buffers on every submit. Only makes sense if isn’t specified, naturally. Defaults to being unset i.e., the buffer is only filled at init time and the data in it is reused when possible but if any of , or are enabled then is also automatically enabled. If is too costly and the target is using data deduplication, then setting this option will slightly modify the I/O buffer contents to defeat normal de-dupe attempts. This is not enough to defeat more clever block compression attempts, but it will stop naive dedupe of blocks. Default: true. If this is set, then fio will attempt to provide I/O buffer content (on WRITEs) that compresses to the specified level. Fio does this by providing a mix of random data followed by fixed pattern data. The fixed pattern is either zeros, or the pattern specified by . If the option is used, it might skew the compression ratio slightly. Setting to a value other than 100 will also enable in order to reduce the likelihood that adjacent blocks are so similar that they over compress when seen together. See for how to set a finer or coarser granularity for the random/fixed data region. Defaults to unset i.e., buffer data will not adhere to any compression level. This setting allows fio to manage how big the random/fixed data region is when using . When is set to some non-zero value smaller than the block size, fio can repeat the random/fixed region throughout the I/O buffer at the specified interval (which particularly useful when bigger block sizes are used for a job). When set to 0, fio will use a chunk size that matches the block size resulting in a single random/fixed region within the I/O buffer. Defaults to 512. When the unit is omitted, the value is interpreted in bytes. If set, fio will fill the I/O buffers with this pattern or with the contents of a file. If not set, the contents of I/O buffers are defined by the other options related to buffer contents. The setting can be any pattern of bytes, and can be prefixed with 0x for hex values. It may also be a string, where the string must then be wrapped with . Or it may also be a filename, where the filename must be wrapped with in which case the file is opened and read. Note that not all the file contents will be read if that would cause the buffers to overflow. So, for example: Also you can combine everything together in any order: If set, fio will generate this percentage of identical buffers when writing. These buffers will be naturally dedupable. The contents of the buffers depend on what other buffer compression settings have been set. It’s possible to have the individual buffers either fully compressible, or not at all – this option only controls the distribution of unique buffers. Setting this option will also enable to prevent every buffer being identical. If is given, then this option controls how fio generates the dedupe buffers. is the default option for fio. Dedupe buffers are generated by repeating previous unique write. is a more realistic workload. With , should be provided. Given that, fio will use the initial unique write buffers as its working set. Upon deciding to dedupe, fio will randomly choose a buffer from the working set. Note that by using the dedupe percentage will converge to the desired over time while maintains the desired percentage throughout the job. If is set to , then this controls the percentage of size of the file or device used as the buffers fio will choose to generate the dedupe buffers from Note that size needs to be explicitly provided and only 1 file per job is supported This controls whether the deduplication buffers will be shared amongst all jobs that have this option set. The buffers are spread evenly between participating jobs. Invalidate the buffer/page cache parts of the files to be used prior to starting I/O if the platform and file type support it. Defaults to true. This will be ignored if is also specified for the same job. Whether, and what type, of synchronous I/O to use for writes. The allowed values are: Do not use synchronous IO, the default. Use synchronous file IO. For the majority of I/O engines, this means using O_SYNC. Use synchronous data IO. For the majority of I/O engines, this means using O_DSYNC. Fio can use various types of memory as the I/O unit buffer. The allowed values are: Use memory from malloc(3) as the buffers. Default memory type. Use shared memory as the buffers. Allocated through shmget(2). Same as shm, but use huge pages as backing. Use mmap(2) to allocate buffers. May either be anonymous memory, or can be file backed if a filename is given after the option. The format is . Use a memory mapped huge file as the buffer backing. Append filename after mmaphuge, ala . Same as mmap, but use a MMAP_SHARED mapping. Use GPU memory as the buffers for GPUDirect RDMA benchmark. The must be . The area allocated is a function of the maximum allowed bs size for the job, multiplied by the I/O depth given. Note that for shmhuge and mmaphuge to work, the system must have free huge pages allocated. This can normally be checked and set by reading/writing on a Linux system. Fio assumes a huge page is 2 or 4MiB in size depending on the platform. So to calculate the number of huge pages you need for a given job file, add up the I/O depth of all jobs (normally one unless is used) and multiply by the maximum bs set. Then divide that number by the huge page size. You can see the size of the huge pages in . If no huge pages are allocated by having a non-zero number in , using mmaphuge or shmhuge will fail. Also see . mmaphuge also needs to have hugetlbfs mounted and the file location should point there. So if it’s mounted in , you would use . This indicates the memory alignment of the I/O memory buffers. Note that the given alignment is applied to the first I/O unit buffer, if using the alignment of the following buffers are given by the used. In other words, if using a that is a multiple of the page sized in the system, all buffers will be aligned to this value. If using a that is not page aligned, the alignment of subsequent I/O memory buffers is the sum of the and used. Defines the size of a huge page. Must at least be equal to the system setting, see and . Defaults to 2 or 4MiB depending on the platform. Should probably always be a multiple of megabytes, so using is the preferred way to set this to avoid setting a non-pow-2 bad value. Pin the specified amount of memory with mlock(2). Can be used to simulate a smaller amount of memory. The amount specified is per worker. The total size of file I/O for each thread of this job. Fio will run until this many bytes has been transferred, unless runtime is altered by other means such as (1) , (2) (3) , (4) gaps/holes while doing I/O’s such as , or (5) sequential I/O reaching end of the file which is possible when is less than 100. Fio will divide this size between the available files determined by options such as , , unless is specified by the job. If the result of division happens to be 0, the size is set to the physical size of the given files or devices if they exist. If this option is not specified, fio will use the full size of the given files or devices. If the files do not exist, size must be given. It is also possible to give size as a percentage between 1 and 100. If is given, fio will use 20% of the full size of the given files or devices. In ZBD mode, value can also be set as number of zones using ‘z’. Can be combined with to constrain the start and end range that I/O will be done within. Normally fio operates within the region set by , which means that the option sets both the region and size of I/O to be performed. Sometimes that is not what you want. With this option, it is possible to define just the amount of I/O that fio should do. For instance, if is set to 20GiB and is set to 5GiB, fio will perform I/O within the first 20GiB but exit when 5GiB have been done. The opposite is also possible – if is set to 20GiB, and is set to 40GiB, then fio will do 40GiB of I/O within the 0..20GiB region. Individual file sizes. May be a range, in which case fio will select sizes for files at random within the given range. If not given, each created file is the same size. This option overrides in terms of file size, i.e. if is specified then becomes merely the default for and has no effect at all if is set explicitly. Perform I/O after the end of the file. Normally fio will operate within the size of a file. If this option is set, then fio will append to the file instead. This has identical behavior to setting to the size of a file. This option is ignored on non-regular files. Sets size to something really large and waits for ENOSPC (no space left on device) or EDQUOT (disk quota exceeded) as the terminating condition. Only makes sense with sequential write. For a read workload, the mount point will be filled first then I/O started on the result. This option doesn’t make sense if operating on a raw device node, since the size of that is already known by the file system. Additionally, writing beyond end-of-device will not return ENOSPC there. I/O engines define how the job issues I/O to the file. The following types are defined: Basic read(2) or write(2) I/O. lseek(2) is used to position the I/O location. See and for syncing write I/Os. Basic pread(2) or pwrite(2) I/O. Default on all supported operating systems except for Windows. Basic readv(2) or writev(2) I/O. Will emulate queuing by coalescing adjacent I/Os into a single submission. Fast Linux native asynchronous I/O. Supports async IO for both direct and buffered IO. This engine defines engine specific options. Fast Linux native asynchronous I/O for pass through commands. This engine defines engine specific options. Linux native asynchronous I/O. Note that Linux may only support queued behavior with non-buffered I/O (set or ). This engine defines engine specific options. File is memory mapped with mmap(2) and data copied to/from using memcpy(3). splice(2) is used to transfer the data and vmsplice(2) to transfer data from user space to the kernel. SCSI generic sg v3 I/O. May either be synchronous using the SG_IO ioctl, or if the target is an sg character device we use read(2) and write(2) for asynchronous I/O. Requires option to specify either block or character devices. This engine supports trim operations. The sg engine includes engine specific options. Read, write, trim and ZBC/ZAC operations to a zoned block device using libzbc library. The target can be either an SG character device or a block device file. Doesn’t transfer any data, just pretends to. This is mainly used to exercise fio itself and for debugging/testing purposes. Transfer over the network to given . Depending on the used, the , , and options are used to specify what sort of connection to make, while the option determines which protocol will be used. This engine defines engine specific options. Like net, but uses splice(2) and vmsplice(2) to map data and send/receive. This engine defines engine specific options. Doesn’t transfer any data, but burns CPU cycles according to the , and options. Setting =85 will cause that job to do nothing but burn 85% of the CPU. In case of SMP machines, use =<nr_of_cpu> to get desired CPU usage, as the cpuload only loads a single CPU at the desired rate. A job never finishes unless there is at least one non-cpuio job. Setting =qsort replace the default noop instructions loop by a qsort algorithm to consume more energy. The RDMA I/O engine supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the InfiniBand, RoCE and iWARP protocols. This engine defines engine specific options. I/O engine that does regular fallocate to simulate data transfer as fio ioengine. I/O engine that sends ftruncate(2) operations in response to write (DDIR_WRITE) events. Each ftruncate issued sets the file’s size to the current block offset. is ignored. I/O engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate defragment activity in request to DDIR_WRITE event. I/O engine supporting direct access to Ceph Reliable Autonomic Distributed Object Store (RADOS) via librados. This ioengine defines engine specific options. I/O engine supporting direct access to Ceph Rados Block Devices (RBD) via librbd without the need to use the kernel rbd driver. This ioengine defines engine specific options. I/O engine supporting GET/PUT requests over HTTP(S) with libcurl to a WebDAV or S3 endpoint. This ioengine defines engine specific options. This engine only supports direct IO of iodepth=1; you need to scale this via numjobs. blocksize defines the size of the objects to be created. Using GlusterFS libgfapi sync interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options. Using GlusterFS libgfapi async interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options. Read and write through Hadoop (HDFS). The option is used to specify host,port of the hdfs name-node to connect. This engine interprets offsets a little differently. In HDFS, files once created cannot be modified so random writes are not possible. To imitate this the libhdfs engine expects a bunch of small files to be created over HDFS and will randomly pick a file from them based on the offset generated by fio backend (see the example job file to create such files, use option). Please note, it may be necessary to set environment variables to work with HDFS/libhdfs properly. Each job uses its own connection to HDFS. Read, write and erase an MTD character device (e.g., ). Discards are treated as erases. Depending on the underlying device type, the I/O may have to go in a certain pattern, e.g., on NAND, writing sequentially to erase blocks and discarding before overwriting. The mode works well for this constraint. Read and write using device DAX to a persistent memory device (e.g., /dev/dax0.0) through the PMDK libpmem library. Prefix to specify loading an external I/O engine object file. Append the engine filename, e.g. to load ioengine in . The path can be either absolute or relative. See for details of writing an external I/O engine. Read and write using mmap I/O to a file on a filesystem mounted with DAX on a persistent memory device through the PMDK libpmem library. Synchronous read and write using DDN’s Infinite Memory Engine (IME). This engine is very basic and issues calls to IME whenever an IO is queued. Synchronous read and write using DDN’s Infinite Memory Engine (IME). This engine uses iovecs and will try to stack as much IOs as possible (if the IOs are “contiguous” and the IO depth is not exceeded) before issuing a call to IME. Asynchronous read and write using DDN’s Infinite Memory Engine (IME). This engine will try to stack as much IOs as possible by creating requests for IME. FIO will then decide when to commit these requests. I/O engine supporting libcufile synchronous access to nvidia-fs and a GPUDirect Storage-supported filesystem. This engine performs I/O without transferring buffers between user-space and the kernel, unless is set or is . must not be . This ioengine defines engine specific options. I/O engine supporting asynchronous read and write operations to the DAOS File System (DFS) via libdfs. I/O engine supporting asynchronous read and write operations to NFS filesystems from userspace via libnfs. This is useful for achieving higher concurrency and thus throughput than is possible via kernel NFS. Execute 3rd party tools. Could be used to perform monitoring during jobs runtime. I/O engine using the xNVMe C API, for NVMe devices. The xnvme engine provides flexibility to access GNU/Linux Kernel NVMe driver via libaio, IOCTLs, io_uring, the SPDK NVMe driver, or your own custom NVMe driver. The xnvme engine includes engine specific options. (See https://xnvme.io). Use the libblkio library (https://gitlab.com/libblkio/libblkio). The specific driver to use must be set using . If / is not specified, memory allocation is delegated to libblkio (and so is guaranteed to work with the selected driver). One libblkio instance is used per process, so all jobs setting option will share a single instance (with one queue per thread) and must specify compatible options. Note that some drivers don’t allow several instances to access the same device or file simultaneously, but allow it for threads. File/directory operation engines define how the job operates file or directory. The following types are defined: Simply create the files and do no I/O to them. You still need to set so that all the accounting still occurs, but no actual I/O will be done other than creating the file. Example job file: filecreate-ioengine.fio. Simply do stat() and do no I/O to the file. You need to set ‘filesize’ and ‘nrfiles’, so that files will be created. This engine is to measure file lookup and meta data access. Example job file: filestat-ioengine.fio. Simply delete the files by unlink() and do no I/O to them. You need to set ‘filesize’ and ‘nrfiles’, so that the files will be created. This engine is to measure file delete. Example job file: filedelete-ioengine.fio. Simply create the directories and do no I/O to them. You still need to set so that all the accounting still occurs, but no actual I/O will be done other than creating the directories. Example job file: dircreate-ioengine.fio. Simply do stat() and do no I/O to the directories. You need to set ‘filesize’ and ‘nrfiles’, so that directories will be created. This engine is to measure directory lookup and meta data access. Example job file: dirstat-ioengine.fio. Simply delete the directories by rmdir() and do no I/O to them. You need to set ‘filesize’ and ‘nrfiles’, so that the directories will be created. This engine is to measure directory delete. Example job file: dirdelete-ioengine.fio. For file and directory operation engines, there is no I/O throughput, then the statistics data in report have different meanings. The meaningful output indexes are: ‘iops’ and ‘clat’. ‘bw’ is meaningless. Refer to section: “Interpreting the output” for more details. In addition, there are some parameters which are only valid when a specific is in use. These are used identically to normal parameters, with the caveat that when used on the command line, they must come after the that defines them is selected. Set the percentage of I/O that will be issued with the highest priority. Default: 0. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. For this option to be effective, NCQ priority must be supported and enabled, and the option must be set. fio must also be run as the root user. Unlike slat/clat/lat stats, which can be tracked and reported independently, per priority stats only track and report a single type of latency. By default, completion latency (clat) will be reported, if is set, total latency (lat) will be reported. Set the I/O priority class to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to the highest priority class. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See ionice(1). See also the option. Set the I/O priority hint to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to 0 (no hint). A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See also the option. Set the I/O priority value to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to 0. Linux limits us to a positive value between 0 and 7, with 0 being the highest. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See ionice(1). Refer to an appropriate manpage for other operating systems since meaning of priority may differ. See also the option. To get a finer control over I/O priority, this option allows specifying the percentage of IOs that must have a priority set depending on the block size of the IO. This option is useful only when used together with the option, that is, multiple different block sizes are used for reads and writes. The first accepted format for this option is the same as the format of the option: In this case, each entry will use the priority class, priority hint and priority level defined by the options , and respectively. The second accepted format for this option is: In this case, the priority class and priority level is defined inside each entry. In comparison with the first accepted format, the second accepted format does not restrict all entries to have the same priority class and priority level. The third accepted format for this option is: This is an extension of the second accepted format that allows one to also specify a priority hint. For all formats, only the read and write data directions are supported, values for trim IOs are ignored. This option is mutually exclusive with the option. If fio is asked to do direct IO, then Linux will map pages for each IO call, and release them when IO is done. If this option is set, the pages are pre-mapped before IO is started. This eliminates the need to map and release for each IO. This is more efficient, and reduces the IO latency as well. With this option, fio will use non-vectored read/write commands, where address must contain the address directly. Default is -1. Normal operation for io_uring is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner. With this option set to N, then every N request fio will ask sqe to be issued in an async manner. Default is 0. With this option, fio registers the set of files being used with the kernel. This avoids the overhead of managing file counts in the kernel, making the submission and completion part more lightweight. Required for the below option. Normally fio will submit IO by issuing a system call to notify the kernel of available items in the SQ ring. If this option is set, the act of submitting IO will be done by a polling thread in the kernel. This frees up cycles for fio, at the cost of using more CPU in the system. As submission is just the time it takes to fill in the sqe entries and any syscall required to wake up the idle kernel thread, fio will not report submission latencies. When is set, this option provides a way to define which CPU should be used for the polling thread. Specifies the type of uring passthrough command to be used. Supported value is nvme. Default is nvme. If this option is set, fio will attempt to use polled IO completions. Normal IO completions generate interrupts to signal the completion of IO, polled completions do not. Hence they are require active reaping by the application. The benefits are more efficient IO for high IOPS scenarios, and lower latencies for low queue depth IO. Use poll queues. This is incompatible with and . Set RWF_HIPRI on I/O, indicating to the kernel that it’s of higher priority than normal. If this option is set, fio will attempt to use polled IO completions. This will have a similar effect as (io_uring)hipri. Only SCSI READ and WRITE commands will have the SGV4_FLAG_HIPRI set (not UNMAP (trim) nor VERIFY). Older versions of the Linux sg driver that do not support hipri will simply ignore this flag and do normal IO. The Linux SCSI Low Level Driver (LLD) that “owns” the device also needs to support hipri (also known as iopoll and mq_poll). The MegaRAID driver is an example of a SCSI LLD. Default: clear (0) which does normal (interrupted based) IO. Normally, with the libaio engine in use, fio will use the io_getevents(2) system call to reap newly returned events. With this flag turned on, the AIO ring will be read directly from user-space to reap events. The reaping mode is only enabled when polling for a minimum of 0 events (e.g. when ). When hipri is set this determines the probability of a pvsync2 I/O being high priority. The default is 100%. By default if a request cannot be executed immediately (e.g. resource starvation, waiting on locks) it is queued and the initiating process will be blocked until the required resource becomes free. This option sets the RWF_NOWAIT flag (supported from the 4.14 Linux kernel) and the call will return instantly with EAGAIN or a partial result rather than waiting. It is useful to also use ignore_error=EAGAIN when using this option. Note: glibc 2.27, 2.28 have a bug in syscall wrappers preadv2, pwritev2. They return EOPNOTSUP instead of EAGAIN. For cached I/O, using this option usually means a request operates only with cached data. Currently the RWF_NOWAIT flag does not supported for cached write. For direct I/O, requests will only succeed if cache invalidation isn’t required, file blocks are fully allocated and the disk request could be issued immediately. This option means that writes are issued with torn-write protection, meaning that for a power fail or kernel crash, all or none of the data from the write will be stored, but never a mix of old and new data. Torn-write protection is also known as atomic writes. This option sets the RWF_ATOMIC flag (supported from the 6.11 Linux kernel) on a per-IO basis. Writes with RWF_ATOMIC set will be rejected by the kernel when the file does not support torn-write protection. To learn a file’s torn-write limits, issue statx with STATX_WRITE_ATOMIC. Specifies the data placement directive type to use for write commands. The following types are supported: Do not use a data placement directive. This is the default. Use Flexible Data Placement directives for write commands. This is equivalent to specifying =1. Defines how fio decides which placement ID to use next. The following types are defined: Round robin over available placement IDs. This is the default. Choose a placement ID (index) based on the scheme file defined by the option . The available placement ID (indices) are defined by the option or except for the case of scheme. Select which Placement ID Indices (FDP) or Placement IDs (streams) this job is allowed to use for writes. This option accepts a comma-separated list of values or ranges (e.g., 1,2-4,5,6-8). For FDP by default, the job will cycle through all available Placement IDs, so use this option to be selective. The values specified here are array indices for the list of placement IDs returned by the nvme-cli command . If you want fio to use FDP placement identifiers only at indices 0, 2 and 5, set . For streams this should be a list of Stream IDs. Defines which placement ID (index) to be selected based on offset(LBA) range. The file should contains one or more scheme entries in the following format: Each line, a scheme entry, contains start offset, end offset, and placement ID (index) separated by comma(,). If the write offset is within the range of a certain scheme entry(start offset ≤ offset < end offset), the corresponding placement ID (index) will be selected. If the write offset belongs to multiple scheme entries, the first matched scheme entry will be applied. If the offset is not within any range of scheme entry, dspec field will be set to 0, default RUH. (Caution: In case of multiple devices in a job, all devices of the job will be affected by the scheme. If this option is specified, the option or will be ignored.) Size in bytes for separate metadata buffer per IO. For io_uring_cmd these buffers are allocated using malloc regardless of what is set for . Default: 0. Action to take when nvme namespace is formatted with protection information. If this is set to 1 and namespace is formatted with metadata size equal to protection information size, fio won’t use separate metadata buffer or extended logical block. If this is set to 1 and namespace is formatted with metadata size greater than protection information size, fio will not generate or verify the protection information portion of metadata for write or read case respectively. If this is set to 0, fio generates protection information for write case and verifies for read case. Default: 1. For 16 bit CRC generation fio will use isa-l if available otherwise it will use the default slower generator. (see: https://github.com/intel/isa-l) Controls the protection information check. This can take one or more of these values. Default: none. Specifies logical block application tag value, if namespace is formatted to use end to end protection information. Default: 0x1234. Specifies logical block application tag mask value, if namespace is formatted to use end to end protection information. Default: 0xffff. For trim command this will be the number of ranges to trim per I/O request. The number of logical blocks per range is determined by the option which should be a multiple of logical block size. This cannot be used with read or write. Note that setting this option > 1, will not be able to log all the offsets. Default: 1. Attempt to use the specified percentage of CPU cycles. This is a mandatory option when using cpuio I/O engine. Split the load into cycles of the given time. In microseconds. Specify how to stress the CPU. It can take these two values: This is the default where the CPU executes noop instructions. Replace the default noop instructions loop with a qsort algorithm to consume more energy. Detect when I/O threads are done, then exit. The hostname or IP address of a HDFS cluster namenode to contact. The listening port of the HFDS cluster namenode. The TCP or UDP port to bind to or connect to. If this is used with to spawn multiple instances of the same job type, then this will be the starting port number since fio will use a range of ports. The port to use for RDMA-CM communication. This should be the same value on the client and the server side. The hostname or IP address to use for TCP, UDP or RDMA-CM based I/O. If the job is a TCP listener or UDP reader, the hostname is not used and must be omitted unless it is a valid UDP multicast address. The IP address of the network interface used to send or receive UDP multicast. The network protocol to use. Accepted values are: When the protocol is TCP, UDP or VSOCK, the port must also be given, as well as the hostname if the job is a TCP or VSOCK listener or UDP reader. For unix sockets, the normal option should be used and the port is invalid. When the protocol is VSOCK, the is the CID of the remote VM. For TCP network connections, tell fio to listen for incoming connections rather than initiating an outgoing connection. The must be omitted if this option is used. Normally a network writer will just continue writing data, and a network reader will just consume packages. If is set, a writer will send its normal payload to the reader, then wait for the reader to send the same payload back. This allows fio to measure network latencies. The submission and completion latencies then measure local time spent sending or receiving, and the completion latency measures how long it took for the other end to receive and send back. For UDP multicast traffic should only be set for a single reader when multiple readers are listening to the same address. Set the desired socket buffer size for the connection. File will be used as a block donor (swap extents between files). Allocate space immediately inside defragment event, and free right after event. Specifies the name of the Ceph cluster. Specifies the name of the RBD. Specifies the username (without the ‘client.’ prefix) used to access the Ceph cluster. If the clustername is specified, the clientname shall be the full type.id string. If no type. prefix is given, fio will add ‘client.’ by default. Specifies the configuration path of ceph cluster, so conf file does not have to be /etc/ceph/ceph.conf. Poll store instead of waiting for completion. Usually this provides better throughput at cost of higher(up to 100%) CPU utilization. During initialization, touch (create if do not exist) all objects (files). Touching all objects affects ceph caches and likely impacts test results. Enabled by default. Specifies the name of the Ceph pool containing RBD or RADOS data. Specify the label or UUID of the DAOS pool to connect to. Specify the label or UUID of the DAOS container to open. Specify a different chunk size (in bytes) for the dfs file. Use DAOS container’s chunk size by default. The size of the chunk to use for each file. Specify a different object class for the dfs file. Use DAOS container’s object class by default. libhdfs will create chunk in this HDFS directory. The RDMA verb to use on this side of the RDMA ioengine connection. Valid values are write, read, send and recv. These correspond to the equivalent RDMA verbs (e.g. write = rdma_write etc.). Note that this only needs to be specified on the client side of the connection. See the examples folder. The name to use to bind the local RDMA-CM connection to a local RDMA device. This could be a hostname or an IPv4 or IPv6 address. On the server side this will be passed into the rdma_bind_addr() function and on the client site it will be used in the rdma_resolve_add() function. This can be useful when multiple paths exist between the client and the server or in certain loopback configurations. Specify stat system call type to measure lookup/getattr performance. Default is stat for stat(2). With readfua option set to 1, read operations include the force unit access (fua) flag. Default is 0. With writefua option set to 1, write operations include the force unit access (fua) flag. Default is 0. Specifies the type of write operation. Defaults to ‘write’. Specifies the type of command to be used in the verification phase. Defaults to ‘read’. Specify the type of write commands to issue. This option can take ten values: This is the default where write opcodes are issued as usual. Issue WRITE AND VERIFY commands. The BYTCHK bit is set to 0. This directs the device to carry out a medium verification with no data comparison. The writefua option is ignored with this selection. This option is deprecated. Use write_and_verify instead. Issue WRITE SAME commands. This transfers a single block to the device and writes this same block of data to a contiguous sequence of LBAs beginning at the specified offset. fio’s block size parameter specifies the amount of data written with each command. However, the amount of data actually transferred to the device is equal to the device’s block (sector) size. For a device with 512 byte sectors, blocksize=8k will write 16 sectors with each command. fio will still generate 8k of data for each command but only the first 512 bytes will be used and transferred to the device. The writefua option is ignored with this selection. This option is deprecated. Use write_same instead. Issue WRITE SAME(16) commands as above but with the No Data Output Buffer (NDOB) bit set. No data will be transferred to the device with this bit set. Data written will be a pre-determined pattern such as all zeroes. Issue WRITE STREAM(16) commands. Use the stream_id option to specify the stream identifier. Issue VERIFY commands with BYTCHK set to 00. This directs the device to carry out a medium verification with no data comparison. Issue VERIFY commands with BYTCHK set to 01. This directs the device to compare the data on the device with the data transferred to the device. Issue VERIFY commands with BYTCHK set to 11. This transfers a single block to the device and compares the contents of this block with the data on the device beginning at the specified offset. fio’s block size parameter specifies the total amount of data compared with this command. However, only one block (sector) worth of data is transferred to the device. This is similar to the WRITE SAME command except that data is compared instead of written. Set the stream identifier for WRITE STREAM commands. If this is set to 0 (which is not a valid stream identifier) fio will open a stream and then close it when done. Default is 0. Hostname to connect to. HTTP port 80 is used automatically when the value of the https parameter is off, and HTTPS port 443 if it is on. A virtual-hosted-style S3 hostname starts with a bucket name, while a path-style S3 hostname does not. See https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html for detailed examples. Default is localhost (path-style S3 hostname) Enable HTTPS instead of http. on enables HTTPS; insecure will enable HTTPS, but disable SSL peer verification (use with caution!). Default is off Which HTTP access mode to use: webdav, swift, or s3. Default is webdav The encryption customer algorithm in SSE server side. Default is AES256 Which storage class to access. User-customizable settings. Default is STANDARD The Swift auth token. See the example configuration file on how to retrieve this. Enable verbose requests from libcurl. Useful for debugging. 1 turns on verbose logging from libcurl, 2 additionally enables HTTP IO tracing. Default is 0 Specify the NBD URI of the server to test. The string is a standard NBD URI (see https://github.com/NetworkBlockDevice/nbd/tree/master/doc). Example URIs: nbd://localhost:10809 nbd+unix:///?socket=/tmp/socket nbds://tlshost/exportname Specify the GPU IDs to use with CUDA. This is a colon-separated list of int. GPUs are assigned to workers roundrobin. Default is 0. Specify the type of I/O to use with CUDA. Default is cufile. Use libcufile and nvidia-fs. This option performs I/O directly between a GPUDirect Storage filesystem and GPU buffers, avoiding use of a bounce buffer. If is set, cudaMemcpy is used to copy verificaton data between RAM and GPU. Verification data is copied from RAM to GPU before a write and from GPU to RAM after a read. must be 1. Use POSIX to perform I/O with a RAM buffer, and use cudaMemcpy to transfer data between RAM and the GPUs. Data is copied from GPU to RAM before a write and copied from RAM to GPU after a read. does not affect use of cudaMemcpy. URL in libnfs format, eg nfs://<server|ipv4|ipv6>/path[?arg=val[&arg=val]*] Refer to the libnfs README for more details. Specify the program to execute. Specify arguments to pass to program. Some special variables can be expanded to pass fio’s job details to the program. Replaced by the duration of the job in seconds. Replaced by the name of the job. Specify the time between the SIGTERM and SIGKILL signals. Default is 1 second. If set, stdout and stderr streams are redirected to files named from the job name. Default is true. Select the xnvme async command interface. This can take these values. This is default and use to emulate asynchronous I/O by using a single thread to create a queue pair on top of a synchronous I/O interface using the NVMe driver IOCTL. Emulate an asynchronous I/O interface with a pool of userspace threads on top of a synchronous I/O interface using the NVMe driver IOCTL. By default four threads are used. Linux native asynchronous I/O interface which supports both direct and buffered I/O. Fast Linux native asynchronous I/O interface for NVMe pass through commands. This only works with NVMe character device (/dev/ngXnY). Use the posix asynchronous I/O interface to perform one or more I/O operations asynchronously. Use the user-space VFIO-based backend, implemented using libvfn instead of SPDK. Do not transfer any data; just pretend to. This is mainly used for introspective performance evaluation. Select the xnvme synchronous command interface. This can take these values. This is default and uses Linux NVMe Driver ioctl() for synchronous I/O. This supports regular as well as vectored pread() and pwrite() commands. This is the same as psync except that it also supports zone management commands using Linux block layer IOCTLs. Select the xnvme admin command interface. This can take these values. This is default and uses linux NVMe Driver ioctl() for admin commands. Use Linux Block Layer ioctl() and sysfs for admin commands. Sets the subsystem NQN for fabrics. This is for xNVMe to utilize a fabrics target with multiple systems. Select the xnvme memory backend. This can take these values. This is the default posix memory backend for linux NVMe driver. Use hugepages, instead of existing posix memory backend. The memory backend uses hugetlbfs. This require users to allocate hugepages, mount hugetlbfs and set an environment variable for XNVME_HUGETLB_PATH. Uses libvfn’s memory allocator. This also specifies the use of libvfn backend instead of SPDK. If this option is set. xnvme will use vectored read/write commands. The libblkio driver to use. Different drivers access devices through different underlying interfaces. Available drivers depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#drivers Sets the value of the driver-specific “path” property before connecting the libblkio instance, which identifies the target device or file on which to perform I/O. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers A colon-separated list of additional libblkio properties to be set after creating but before connecting the libblkio instance. Each property must have the format . Colons can be escaped as . These are set after the engine sets any other properties, so those can be overridden. Available properties depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#properties Sets the value of the driver-specific “num-entries” property before starting the libblkio instance. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers Sets the value of the driver-specific “queue-size” property before starting the libblkio instance. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers A colon-separated list of additional libblkio properties to be set after connecting but before starting the libblkio instance. Each property must have the format . Colons can be escaped as . These are set after the engine sets any other properties, so those can be overridden. Available properties depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#properties Submit trims as “write zeroes” requests instead of discard requests. How to wait for completions: Use a blocking call to on the completion eventfd. Use a busy loop with a non-blocking call to . Enable the queue’s completion eventfd even when unused. This may impact performance. The default is to enable it only if . Number of I/O units to keep in flight against the file. Note that increasing iodepth beyond 1 will not affect synchronous ioengines (except for small degrees when is in use). Even async engines may impose OS restrictions causing the desired depth not to be achieved. This may happen on Linux when using libaio and not setting =1, since buffered I/O is not async on that OS. Keep an eye on the I/O depth distribution in the fio output to verify that the achieved depth is as expected. Default: 1. This defines how many pieces of I/O to submit at once. It defaults to 1 which means that we submit each I/O as soon as it is available, but can be raised to submit bigger batches of I/O at the time. If it is set to 0 the value will be used. This defines how many pieces of I/O to retrieve at once. It defaults to 1 which means that we’ll ask for a minimum of 1 I/O in the retrieval process from the kernel. The I/O retrieval will go on until we hit the limit set by . If this variable is set to 0, then fio will always check for completed events before queuing more I/O. This helps reduce I/O latency, at the cost of more retrieval system calls. This defines maximum pieces of I/O to retrieve at once. This variable should be used along with =int variable, specifying the range of min and max amount of I/O which should be retrieved. By default it is equal to the value. which means that we will retrieve at least 1 I/O and up to the whole submitted queue depth. If none of I/O has been completed yet, we will wait. which means that we can retrieve up to the whole submitted queue depth, but if none of I/O has been completed yet, we will NOT wait and immediately exit the system call. In this example we simply do polling. The low water mark indicating when to start filling the queue again. Defaults to the same as , meaning that fio will attempt to keep the queue full at all times. If is set to e.g. 16 and iodepth_low is set to 4, then after fio has filled the queue of 16 requests, it will let the depth drain down to 4 before starting to fill it again. Serialize in-flight I/Os that might otherwise cause or suffer from data races. When two or more I/Os are submitted simultaneously, there is no guarantee that the I/Os will be processed or completed in the submitted order. Further, if two or more of those I/Os are writes, any overlapping region between them can become indeterminate/undefined on certain storage. These issues can cause verification to fail erratically when at least one of the racing I/Os is changing data and the overlapping region has a non-zero size. Setting tells fio to avoid provoking this behavior by explicitly serializing in-flight I/Os that have a non-zero overlap. Note that setting this option can reduce both performance and the achieved. This option only applies to I/Os issued for a single job except when it is enabled along with =offload. In offload mode, fio will check for overlap among all I/Os submitted by offload jobs with enabled. This option controls how fio submits the I/O to the I/O engine. The default is , which means that the fio job threads submit and reap I/O directly. If set to , the job threads will offload I/O submission to a dedicated pool of I/O threads. This requires some coordination and thus has a bit of extra overhead, especially for lower queue depth I/O where it can increase latencies. The benefit is that fio can manage submission rates independently of the device completion rates. This avoids skewed latency reporting if I/O gets backed up on the device side (the coordinated omission problem). Note that this option cannot reliably be used with async IO engines. Stall the job for the specified number of cycles after an I/O has completed before issuing the next. May be used to simulate processing being done by an application. This is not taken into account for the time to be waited on for . Might not have any effect on some platforms, this can be checked by trying a setting a high enough amount of thinkcycles. Stall the job for the specified period of time after an I/O has completed before issuing the next. May be used to simulate processing being done by an application. When the unit is omitted, the value is interpreted in microseconds. See , and . Only valid if is set - pretend to spend CPU time doing something with the data received, before falling back to sleeping for the rest of the period specified by . When the unit is omitted, the value is interpreted in microseconds. Only valid if is set - control how many blocks to issue, before waiting usecs. If not set, defaults to 1 which will make fio wait usecs after every block. This effectively makes any queue depth setting redundant, since no more than 1 I/O will be queued before we have to complete it and do our . In other words, this setting effectively caps the queue depth if the latter is larger. Only valid if is set - control how triggers. The default is , which triggers thinktime when fio completes blocks. If this is set to , then the trigger happens at the issue side. Only valid if is set - control interval by time. The stall is repeated after IOs are executed for . For example, repeat 10-second cycle with IOs for 9 seconds and stall for 1 second. When the unit is omitted, is interpreted as a number of seconds. If this option is used together with , the stall is repeated after or after IOs, whichever happens first. Cap the bandwidth used by this job. The number is in bytes/sec, the normal suffix rules apply. Comma-separated values may be specified for reads, writes, and trims as described in . For example, using would limit reads to 1MiB/sec and writes to 500KiB/sec. Capping only reads or writes can be done with or where the former will only limit writes (to 500KiB/sec) and the latter will only limit reads. Tell fio to do whatever it can to maintain at least this bandwidth. Failing to meet this requirement will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in . Cap the bandwidth to this number of IOPS. Basically the same as , just specified independently of bandwidth. If the job is given a block size range instead of a fixed value, the smallest block size is used as the metric. Comma-separated values may be specified for reads, writes, and trims as described in . If fio doesn’t meet this rate of I/O, it will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in . This option controls how fio manages rated I/O submissions. The default is , which submits I/O in a linear fashion with fixed delays between I/Os that gets adjusted based on I/O completion rates. If this is set to , fio will submit I/O based on a more real world random request flow, known as the Poisson process (https://en.wikipedia.org/wiki/Poisson_point_process). The lambda will be 10^6 / IOPS for the given workload. By default, fio will attempt to catch up to the specified rate setting, if any kind of thinktime setting was used. If this option is set, then fio will ignore the thinktime and continue doing IO at the specified rate, instead of entering a catch-up mode after thinktime is done. Average bandwidth for and over this number of milliseconds. Defaults to 1000. If set, fio will attempt to find the max performance point that the given workload will run at while maintaining a latency below this target. When the unit is omitted, the value is interpreted in microseconds. See and . Used with to specify the sample window that the job is run at varying queue depths to test the performance. When the unit is omitted, the value is interpreted in microseconds. The percentage of I/Os that must fall within the criteria specified by and . If not set, this defaults to 100.0, meaning that all I/Os must be equal or below to the value set by . Used with . If false (default), fio will find the highest queue depth that meets and exit. If true, fio will continue running and try to meet by adjusting queue depth. If set, fio will exit the job with an ETIMEDOUT error if it exceeds this maximum latency. When the unit is omitted, the value is interpreted in microseconds. Comma-separated values may be specified for reads, writes, and trims as described in . Write the issued I/O patterns to the specified file. See . Specify a separate file for each job, otherwise the iologs will be interspersed and the file may be corrupt. This file will be opened in append mode. Open an iolog with the specified filename and replay the I/O patterns it contains. This can be used to store a workload and replay it sometime later. The iolog given may also be a blktrace binary file, which allows fio to replay a workload captured by blktrace. See blktrace(8) for how to capture such logging data. For blktrace replay, the file needs to be turned into a blkparse binary data file first ( ). You can specify a number of files by separating the names with a ‘:’ character. See the option for information on how to escape ‘:’ characters within the file names. These files will be sequentially assigned to job clones created by . ‘-’ is a reserved name, meaning read from stdin, notably if is set to ‘-’ which means stdin as well, then this flag can’t be set to ‘-‘. Determines how iolog is read. If false(default) entire will be read at once. If selected true, input from iolog will be read gradually. Useful when iolog is very large, or it is generated. When specified, rather than replaying the logs passed to , the logs go through a merge phase which aggregates them into a single blktrace. The resulting file is then passed on as the parameter. The intention here is to make the order of events consistent. This limits the influence of the scheduler compared to replaying multiple blktraces via concurrent jobs. This is a percentage based option that is index paired with the list of files passed to . When merging is performed, scale the time of each event by the corresponding amount. For example, runs the first trace in halftime and the second trace in realtime. This knob is separately tunable from which scales the trace during runtime and does not change the output of the merge unlike this option. This is a whole number option that is index paired with the list of files passed to . When merging is performed, run each trace for the specified number of iterations. For example, runs the first trace for two iterations and the second trace for one iteration. When replaying I/O with the default behavior is to attempt to respect the timestamps within the log and replay them with the appropriate delay between IOPS. By setting this variable fio will not respect the timestamps and attempt to replay them as fast as possible while still respecting ordering. The result is the same I/O pattern to a given device, but different timings. When replaying I/O with , fio will honor the original timing in the trace. With this option, it’s possible to scale the time. It’s a percentage option, if set to 50 it means run at 50% the original IO rate in the trace. If set to 200, run at twice the original IO rate. Defaults to 100. While replaying I/O patterns using the default behavior is to replay the IOPS onto the major/minor device that each IOP was recorded from. This is sometimes undesirable because on a different machine those major/minor numbers can map to a different device. Changing hardware on the same system can also result in a different major/minor mapping. causes all I/Os to be replayed onto the single specified device regardless of the device it was recorded from. i.e. = would cause all I/O in the blktrace or iolog to be replayed onto . This means multiple devices will be replayed onto a single device, if the trace contains multiple devices. If you want multiple devices to be replayed concurrently to multiple redirected devices you must blkparse your trace into separate traces and replay them with independent fio invocations. Unfortunately this also breaks the strict time ordering between multiple device accesses. Force alignment of the byte offsets in a trace to this value. The value must be a power of 2. Scale byte offsets down by this factor when replaying traces. Should most likely use as well. Sometimes it’s useful to skip certain IO types in a replay trace. This could be, for instance, eliminating the writes in the trace. Or not replaying the trims/discards, if you are redirecting to a device that doesn’t support them. This option takes a comma separated list of read, write, trim, sync. Fio defaults to creating jobs by using fork, however if this option is given, fio will create jobs by using POSIX Threads’ function pthread_create(3) to create threads instead. If set, the current job won’t be started until all workers of the specified waitee job are done. operates on the job name basis, so there are a few limitations. First, the waitee must be defined prior to the waiter job (meaning no forward references). Second, if a job is being referenced as a waitee, it must have a unique name (no duplicate waitees). Run the job with the given nice value. See man nice(2). On Windows, values less than -15 set the process class to “High”; -1 through -15 set “Above Normal”; 1 through 15 “Below Normal”; and above 15 “Idle” priority class. Set the I/O priority value of this job. Linux limits us to a positive value between 0 and 7, with 0 being the highest. See man ionice(1). Refer to an appropriate manpage for other operating systems since meaning of priority may differ. For per-command priority setting, see I/O engine specific and options. Set the I/O priority class. See man ionice(1). For per-command priority setting, see I/O engine specific and options. Set the I/O priority hint. This is only applicable to platforms that support I/O priority classes and to devices with features controlled through priority hints, e.g. block devices supporting command duration limits, or CDL. CDL is a way to indicate the desired maximum latency of I/Os so that the device can optimize its internal command scheduling according to the latency limits indicated by the user. For per-I/O priority hint setting, see the I/O engine specific option. Controls the same options as , but accepts a textual specification of the permitted CPUs instead and CPUs are indexed from 0. So to use CPUs 0 and 5 you would specify . This option also allows a range of CPUs to be specified – say you wanted a binding to CPUs 0, 5, and 8 to 15, you would set . On Windows, when is unset only CPUs from fio’s current processor group will be used and affinity settings are inherited from the system. An fio build configured to target Windows 7 makes options that set CPUs processor group aware and values will set both the processor group and a CPU from within that group. For example, on a system where processor group 0 has 40 CPUs and processor group 1 has 32 CPUs, values between 0 and 39 will bind CPUs from processor group 0 and values between 40 and 71 will bind CPUs from processor group 1. When using all CPUs specified by a single option must be from the same processor group. For Windows fio builds not built for Windows 7, CPUs will only be selected from (and be relative to) whatever processor group fio happens to be running in and CPUs from other processor groups cannot be used. Set the policy of how fio distributes the CPUs specified by or . Two policies are supported: All jobs will share the CPU set specified. Each job will get a unique CPU from the CPU set. shared is the default behavior, if the option isn’t specified. If split is specified, then fio will assign one cpu per job. If not enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs in the set. Set the CPU affinity of this job. The parameter given is a bit mask of allowed CPUs the job may run on. So if you want the allowed CPUs to be 1 and 5, you would pass the decimal value of (1 << 1 | 1 << 5), or 34. See man sched_setaffinity(2). This may not work on all supported operating systems or kernel versions. This option doesn’t work well for a higher CPU count than what you can store in an integer mask, so it can only control cpus 1-32. For boxes with larger CPU counts, use . Set this job running on specified NUMA nodes’ CPUs. The arguments allow comma delimited list of cpu numbers, A-B ranges, or . Note, to enable NUMA options support, fio must be built on a system with libnuma-dev(el) installed. Set this job’s memory policy and corresponding NUMA nodes. Format of the arguments: is one of the following memory policies: , , , or . For and memory policies, no node needs to be specified. For , only one node is allowed. For and the may be as follows: a comma delimited list of numbers, A-B ranges, or . Add job to this control group. If it doesn’t exist, it will be created. The system must have a mounted cgroup blkio mount point for this to work. If your system doesn’t have it mounted, you can do so with: Set the weight of the cgroup to this value. See the documentation that comes with the kernel, allowed values are in the range of 100..1000. Normally fio will delete the cgroups it has created after the job completion. To override this behavior and to leave cgroups around after the job completion, set . This can be useful if one wants to inspect various cgroup files after job completion. Default: false. The ID of the flow. If not specified, it defaults to being a global flow. See . Weight in token-based flow control. If this value is used, then fio regulates the activity between two or more jobs sharing the same flow_id. Fio attempts to keep each job activity proportional to other jobs’ activities in the same flow_id group, with respect to requested weight per job. That is, if one job has flow=3’, another job has `flow=2’ and another with `flow=1 , then there will be a roughly 3:2:1 ratio in how much one runs vs the others. The period of time, in microseconds, to wait after the flow counter has exceeded its proportion before retrying operations. Wait for preceding jobs in the job file to exit, before starting this one. Can be used to insert serialization points in the job file. A stone wall also implies starting a new reporting group, see . By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting will instead make fio terminate all jobs in the same group, as soon as one job of that group finishes. By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting will instead make fio terminate all jobs in the same group. The option allows one to control which jobs get terminated when is enabled. The default is and does not change the behaviour of . The setting terminates all jobs. The setting terminates all currently running jobs across all groups and continues execution with the next stonewalled group. Before running this job, issue the command specified through system(3). Output is redirected in a file called . After the job completes, issue the command specified though system(3). Output is redirected in a file called . Instead of running as the invoking user, set the user ID to this value before the thread/process does any work. Do not perform specified workload, only verify data still matches previous invocation of this workload. This option allows one to check data multiple times at a later date without overwriting it. This option makes sense only for workloads that write data, and does not support workloads with the option set. Run the verify phase after a write phase. Only valid if is set. Default: true. If writing to a file, fio can verify the file contents after each iteration of the job. Each verification method also implies verification of special header, which is written to the beginning of each block. This header also includes meta information, like offset of the block, block number, timestamp when block was written, etc. can be combined with option. The allowed values are: Use an md5 sum of the data area and store it in the header of each block. Use an experimental crc64 sum of the data area and store it in the header of each block. Use a crc32c sum of the data area and store it in the header of each block. This will automatically use hardware acceleration (e.g. SSE4.2 on an x86 or CRC crypto extensions on ARM64) but will fall back to software crc32c if none is found. Generally the fastest checksum fio supports when hardware accelerated. Use a crc32 sum of the data area and store it in the header of each block. Use a crc16 sum of the data area and store it in the header of each block. Use a crc7 sum of the data area and store it in the header of each block. Use xxhash as the checksum function. Generally the fastest software checksum that fio supports. Use sha512 as the checksum function. Use sha256 as the checksum function. Use optimized sha1 as the checksum function. Use optimized sha3-224 as the checksum function. Use optimized sha3-256 as the checksum function. Use optimized sha3-384 as the checksum function. Use optimized sha3-512 as the checksum function. This option is deprecated, since now meta information is included in generic verification header and meta verification happens by default. For detailed information see the description of the setting. This option is kept because of compatibility’s sake with old configurations. Do not use it. Verify a strict pattern. Normally fio includes a header with some basic information and checksumming, but if this option is set, only the specific pattern set with is verified. Only pretend to verify. Useful for testing internals with =null, not for much else. This option can be used for repeated burn-in tests of a system to make sure that the written data is also correctly read back. If the data direction given is a read or random read, fio will assume that it should verify a previously written file. If the data direction includes any form of write, the verify will be of the newly written data. To avoid false verification errors, do not use the norandommap option when verifying data with async I/O engines and I/O depths > 1. Or use the norandommap and the lfsr random generator together to avoid writing to the same offset with multiple outstanding I/Os. Swap the verification header with data somewhere else in the block before writing. It is swapped back before verifying. Write the verification header at a finer granularity than the . It will be written for chunks the size of . should divide this evenly. If set, fio will fill the I/O buffers with this pattern. Fio defaults to filling with totally random bytes, but sometimes it’s interesting to fill with a known pattern for I/O verification purposes. Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time (it can be either a decimal or a hex number). The if larger than a 32-bit quantity has to be a hex number that starts with either “0x” or “0X”. Use with . Also, supports %o format, which means that for each block offset will be written and then verified back, e.g.: Or use combination of everything: Normally fio will keep checking the entire contents before quitting on a block verification failure. If this option is set, fio will exit the job on the first observed failure. Default: false. If set, dump the contents of both the original data block and the data block we read off disk to files. This allows later analysis to inspect just what kind of data corruption occurred. Off by default. Fio will normally verify I/O inline from the submitting thread. This option takes an integer describing how many async offload threads to create for I/O verification instead, causing fio to offload the duty of verifying I/O contents to one or more separate threads. If using this offload option, even sync I/O engines can benefit from using an setting higher than 1, as it allows them to have I/O in flight while verifies are running. Defaults to 0 async threads, i.e. verification is not asynchronous. Tell fio to set the given CPU affinity on the async I/O verification threads. See for the format used. Fio will normally verify the written contents of a job that utilizes verify once that job has completed. In other words, everything is written then everything is read back and verified. You may want to verify continually instead for a variety of reasons. Fio stores the meta data associated with an I/O block in memory, so for large verify workloads, quite a bit of memory would be used up holding this meta data. If this option is enabled, fio will write only N blocks before verifying these blocks. Control how many blocks fio will verify if is set. If not set, will default to the value of (meaning the entire queue is read back and verified). If is less than then not all blocks will be verified, if is larger than , some blocks will be verified more than once. When a job exits during the write phase of a verify workload, save its current state. This allows fio to replay up until that point, if the verify state is loaded for the verify read phase. The format of the filename is, roughly: <type> is “local” for a local run, “sock” for a client/server socket connection, and “ip” (192.168.0.1, for instance) for a networked client/server connection. Defaults to true. If a verify termination trigger was used, fio stores the current write state of each thread. This can be used at verification time so that fio knows how far it should verify. Without this information, fio will run a full verification pass, according to the settings in the job file used. Default false. Enable experimental verification. Standard verify records I/O metadata for later use during the verification phase. Experimental verify instead resets the file after the write phase and then replays I/Os for the verification phase. Verify the header write sequence number. In a scenario with multiple jobs, verification of the write sequence number may fail. Disabling this option will mean that write sequence number checking is skipped. Doing that can be useful for testing atomic writes, as it means that checksum verification can still be attempted. For when is enabled, checksum verification is expected to succeed (while write sequence checking can still fail). Defaults to true. Verify that trim/discarded blocks are returned as zeros. Trim after this number of blocks are written. Define the criterion and limit for assessing steady state performance. The first parameter designates the criterion whereas the second parameter sets the threshold. When the criterion falls below the threshold for the specified duration, the job will stop. For example, will direct fio to terminate the job when the least squares regression slope falls below 0.1% of the mean IOPS. If is enabled this will apply to all jobs in the group. Below is the list of available steady state assessment criteria. All assessments are carried out using only data from the rolling collection window. Threshold limits can be expressed as a fixed value or as a percentage of the mean in the collection window. When using this feature, most jobs should include the and options or the option so that fio does not stop running after it has covered the full size of the specified file(s) or device(s). Collect IOPS data. Stop the job if all individual IOPS measurements are within the specified limit of the mean IOPS (e.g., means that all individual IOPS values must be within 2 of the mean, whereas means that all individual IOPS values must be within 0.2% of the mean IOPS to terminate the job). Collect IOPS data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit. Collect bandwidth data. Stop the job if all individual bandwidth measurements are within the specified limit of the mean bandwidth. Collect bandwidth data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit. A rolling window of this duration will be used to judge whether steady state has been reached. Data will be collected every . The default is 0 which disables steady state detection. When the unit is omitted, the value is interpreted in seconds. Allow the job to run for the specified duration before beginning data collection for checking the steady state job termination criterion. The default is 0. When the unit is omitted, the value is interpreted in seconds. The values during the rolling window will be collected with a period of this value. If is 30s and is 300s, 10 measurements will be taken. Default is 1s but that might not converge, especially for slower devices, so set this accordingly. When the unit is omitted, the value is interpreted in seconds. If set to true, fio generates bw/clat/iops logs with per job unique filenames. If set to false, jobs with identical names will share a log filename. Note that when this option is set to false log files will be opened in append mode and if log files already exist the previous contents will not be overwritten. Default: true. It may sometimes be interesting to display statistics for groups of jobs as a whole instead of for each individual job. This is especially true if is used; looking at individual thread/process output quickly becomes unwieldy. To see the final report per-group instead of per-job, use . Jobs in a file will be part of the same reporting group, unless if separated by a , or by using . NOTE: When is used along with output, there are certain per-job properties which can be different between jobs but do not have a natural group-level equivalent. Examples include , , , , , and . For these properties, the values for the first job are recorded for the group. Also, options like and should be consistent among the jobs in a reporting group. Having options like these vary across the jobs in a reporting group is an unsupported configuration. Start a new reporting group. See: . If not given, all jobs in a file will be part of the same reporting group, unless separated by a . By default, fio collects and shows final output results for all jobs that run. If this option is set to 0, then fio will ignore it in the final stat output. If given, write a bandwidth log for this job. Can be used to store data of the bandwidth of the jobs in their lifetime. If no str argument is given, the default filename of is used. Even when the argument is given, fio will still append the type of log. So if one specifies: The actual log name will be where is the index of the job ( , where is the number of jobs). If is false, then the filename will not include the job index. The included fio_generate_plots script uses gnuplot to turn these text files into nice graphs. See Log File Formats for how data is structured within the file. Same as , except this option creates I/O submission (e.g., ), completion (e.g., ), and total (e.g., ) latency files instead. See for details about the filename format and Log File Formats for how data is structured within the files. Same as but writes an I/O completion latency histogram file (e.g., ) instead. Note that this file will be empty unless has also been set. See for details about the filename format and Log File Formats for how data is structured within the file. Same as , but writes an IOPS file (e.g. ) instead. Because fio defaults to individual I/O logging, the value entry in the IOPS log will be 1 unless windowed logging (see ) has been enabled. See for details about the filename format and Log File Formats for how data is structured within the file. By default, fio will log an entry in the iops, latency, or bw log for every I/O that completes. The initial number of I/O log entries is 1024. When the log entries are all used, new log entries are dynamically allocated. This dynamic log entry allocation may negatively impact time-related statistics such as I/O tail latencies (e.g. 99.9th percentile completion latency). This option allows specifying a larger initial number of log entries to avoid run-time allocations of new log entries, resulting in more precise time-related I/O statistics. Also see . Defaults to 1024. By default, fio will log an entry in the iops, latency, or bw log for every I/O that completes. When writing to the disk log, that can quickly grow to a very large size. Setting this option directs fio to instead record an average over the specified duration for each log entry, reducing the resolution of the log. When the job completes, fio will flush any accumulated latency log data, so the final log interval may not match the value specified by this option and there may even be duplicate timestamps. See as well. Defaults to 0, logging entries for each I/O. Also see Log File Formats. Same as , but logs entries for completion latency histograms. Computing latency percentiles from averages of intervals using is inaccurate. Setting this option makes fio log histogram entries over the specified period of time, reducing log sizes for high IOPS devices while retaining percentile accuracy. See and as well. Defaults to 0, meaning histogram logging is disabled. Integer ranging from 0 to 6, defining the coarseness of the resolution of the histogram logs enabled with . For each increment in coarseness, fio outputs half as many bins. Defaults to 0, for which histogram logs contain 1216 latency bins. See and Log File Formats. If is set, fio by default logs the average over that window. This option determines whether fio logs the average, maximum or both the values over the window. This only affects the latency logging, as both average and maximum values for iops or bw log will be same. Accepted values are: Log average value over the window. The default. Log maximum value in the window. Log both average and maximum value over the window. If this is set, the iolog options will include the byte offset for the I/O entry as well as the other data values. Defaults to 0 meaning that offsets are not present in logs. Also see Log File Formats. If this is set, the Command priority field in Log File Formats shows the priority value and the IO priority class of the command. Otherwise, the field shows if the command has the highest RT priority class or not. Also see Log File Formats. If this is set, the iolog options will include the command issue time for the I/O entry as well as the other data values. Defaults to 0 meaning that command issue times are not present in logs. Also see Log File Formats. This option shall be set together with and . If this is set, fio will compress the I/O logs as it goes, to keep the memory footprint lower. When a log reaches the specified size, that chunk is removed and compressed in the background. Given that I/O logs are fairly highly compressible, this yields a nice memory savings for longer runs. The downside is that the compression will consume some background CPU cycles, so it may impact the run. This, however, is also true if the logging ends up consuming most of the system memory. So pick your poison. The I/O logs are saved normally at the end of a run, by decompressing the chunks and storing them in the specified log file. This feature depends on the availability of zlib. Define the set of CPUs that are allowed to handle online log compression for the I/O jobs. This can provide better isolation between performance sensitive jobs, and background compression work. See for the format used. If set, fio will store the log files in a compressed format. They can be decompressed with fio, using the command line parameter. The files will be stored with a suffix. If set, fio will log timestamps based on the epoch used by the clock specified in the log_alternate_epoch_clock_id option, to the log files produced by enabling write_type_log for each log type, instead of the default zero-based timestamps. Specifies the clock_id to be used by clock_gettime to obtain the alternate epoch if log_alternate_epoch is true. Otherwise has no effect. Default value is 0, or CLOCK_REALTIME. If set, record errors in trim block-sized units from writes and trims and output a histogram of how many trims it took to get to errors, and what kind of error was encountered. Average the calculated bandwidth over the given time. Value is specified in milliseconds. If the job also does bandwidth logging through , then the minimum of this option and will be used. Default: 500ms. Average the calculated IOPS over the given time. Value is specified in milliseconds. If the job also does IOPS logging through , then the minimum of this option and will be used. Default: 500ms. Generate disk utilization statistics, if the platform supports it. Default: true. Disable measurements of total latency numbers. Useful only for cutting back the number of calls to gettimeofday(2), as that does impact performance at really high IOPS rates. Note that to really get rid of a large amount of these calls, this option must be used with and as well. Report submission latency percentiles. Submission latency is not recorded for synchronous ioengines. Report total latency percentiles. Total latency is the sum of submission latency and completion latency. Overwrite the default list of percentiles for latencies and the block error histogram. Each number is a floating point number in the range (0,100], and the maximum length of the list is 20. Use to separate the numbers. For example, will cause fio to report the latency durations below which 99.5% and 99.9% of the observed latencies fell, respectively. If using of , set the significant figures to this value. Higher values will yield more precise IOPS and throughput units, while lower values will round. Requires a minimum value of 1 and a maximum value of 10. Defaults to 4. When one job finishes in error, terminate the rest. The default is to wait for each job to finish. Normally fio will exit the job on the first observed failure. If this option is set, fio will continue the job when there is a ‘non-fatal error’ (EIO or EILSEQ) until the runtime is exceeded or the I/O size specified is completed. If this option is used, there are two more stats that are appended, the total error count and the first error. The error field given in the stats is the first error that was hit during the run. Note: a write error from the device may go unnoticed by fio when using buffered IO, as the write() (or similar) system call merely dirties the kernel pages, unless or is used. Device IO errors occur when the dirty data is actually written out to disk. If fully sync writes aren’t desirable, or can be used as well. This is specific to writes, as reads are always synchronous. Exit on any I/O or verify errors. Continue on read errors, exit on all others. Continue on write errors, exit on all others. Continue on any I/O error, exit on all others. Continue on verify errors, exit on all others. Sometimes you want to ignore some errors during test in that case you can specify error list for each error type, instead of only being able to ignore the default ‘non-fatal error’ using . errors for given error type is separated with ‘:’. Error may be symbol (‘ENOSPC’, ‘ENOMEM’) or integer. Example: This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from WRITE. This option works by overriding with the list of errors for each error type if any. If set dump every error even if it is non fatal, true by default. If disabled only fatal error will be dumped.\n\nFio spits out a lot of output. While running, fio will display the status of the jobs created. An example of that would be: The characters inside the first set of square brackets denote the current status of each thread. The first character is the first job defined in the job file, and so forth. The possible values (in typical life cycle order) are: Thread exited, not reaped by main thread yet. Fio will condense the thread string as not to take up more space on the command line than needed. For instance, if you have 10 readers and 10 writers running, the output would look like this: Note that the status string is displayed in order, so it’s possible to tell which of the jobs are currently doing what. In the example above this means that jobs 1–10 are readers and 11–20 are writers. The other values are fairly self explanatory – number of threads currently running and doing I/O, the number of currently open files (f=), the estimated completion percentage, the rate of I/O since last check (read speed listed first, then write speed and optionally trim speed) in terms of bandwidth and IOPS, and time to completion for the current running group. It’s impossible to estimate runtime of the following groups (if any). When fio is done (or interrupted by ), it will show the data for each thread, group of threads, and disks in that order. For each overall thread (or group) the output looks like: The job name (or first job’s name when using ) is printed, along with the group id, count of jobs being aggregated, last error id seen (which is 0 when there are no errors), pid/tid of that thread and the time the job/group completed. Below are the I/O statistics for each data direction performed (showing writes in the example above). In the order listed, they denote: The string before the colon shows the I/O direction the statistics are for. IOPS is the average I/Os performed per second. BW is the average bandwidth rate shown as: value in power of 2 format (value in power of 10 format). The last two values show: (total I/O performed in power of 2 format / runtime of that thread). Submission latency (min being the minimum, max being the maximum, avg being the average, stdev being the standard deviation). This is the time from when fio initialized the I/O to submission. For synchronous ioengines this includes the time up until just before the ioengine’s queue function is called. For asynchronous ioengines this includes the time up through the completion of the ioengine’s queue function (and commit function if it is defined). For sync I/O this row is not displayed as the slat is negligible. This value can be in nanoseconds, microseconds or milliseconds — fio will choose the most appropriate base and print that (in the example above nanoseconds was the best scale). Note: in mode latencies are always expressed in microseconds. Completion latency. Same names as slat, this denotes the time from submission to completion of the I/O pieces. For sync I/O, this represents the time from when the I/O was submitted to the operating system to when it was completed. For asynchronous ioengines this is the time from when the ioengine’s queue (and commit if available) functions were completed to when the I/O’s completion was reaped by fio. For file and directory operation engines, clat denotes the time to complete one file or directory operation. filestat engine: the time cost to look up an existing file dircreate engine: the time cost to create a new directory dirstat engine: the time cost to look up an existing directory Total latency. Same names as slat and clat, this denotes the time from when fio created the I/O unit to completion of the I/O operation. It is the sum of submission and completion latency. Bandwidth statistics based on measurements from discrete intervals. Fio continuously monitors bytes transferred and I/O operations completed. By default fio calculates bandwidth in each half-second interval (see ) and reports descriptive statistics for the measurements here. Same names as the xlat stats, but also includes the number of samples taken (samples) and an approximate percentage of total aggregate bandwidth this thread received in its group (per). This last value is only really useful if the threads in this group are on the same disk, since they are then competing for disk access. For file and directory operation engines, bw is meaningless. IOPS statistics based on measurements from discrete intervals. For details see the description for bw above. See to control the duration of the intervals. Same values reported here as for bw except for percentage. For file and directory operation engines, iops is the most fundamental index to denote the performance. It means how many files or directories can be operated per second. filecreate engine:number of files can be created per second filestat engine: number of files can be looked up per second filedelete engine:number of files can be deleted per second dircreate engine: number of directories can be created per second dirstat engine: number of directories can be looked up per second dirdelete engine: number of directories can be deleted per second The distribution of I/O completion latencies. This is the time from when I/O leaves fio and when it gets completed. Unlike the separate read/write/trim sections above, the data here and in the remaining sections apply to all I/Os for the reporting group. 250=0.04% means that 0.04% of the I/Os completed in under 250us. 500=64.11% means that 64.11% of the I/Os required 250 to 499us for completion. CPU usage. User and system time, along with the number of context switches this thread went through, usage of system and user time, and finally the number of major and minor page faults. The CPU utilization numbers are averages for the jobs in that reporting group, while the context and fault counters are summed. The distribution of I/O depths over the job lifetime. The numbers are divided into powers of 2 and each entry covers depths from that value up to those that are lower than the next entry – e.g., 16= covers depths from 16 to 31. Note that the range covered by a depth distribution entry can be different to the range covered by the equivalent submit/complete distribution entry. How many pieces of I/O were submitting in a single submit call. Each entry denotes that amount and below, until the previous entry – e.g., 16=100% means that we submitted anywhere between 9 to 16 I/Os per submit call. Note that the range covered by a submit distribution entry can be different to the range covered by the equivalent depth distribution entry. Like the above submit number, but for completions instead. The number of read/write/trim requests issued, and how many of them were short or dropped. These values are for and related options. When these options are engaged, this section describes the I/O depth required to meet the specified latency target. After each client has been listed, the group statistics are printed. They will look like this: For each data direction it prints: Aggregate bandwidth of threads in this group followed by the minimum and maximum bandwidth of all the threads in this group. Values outside of brackets are power-of-2 format and those within are the equivalent value in a power-of-10 format. Aggregate I/O performed of all threads in this group. The format is the same as bw. The smallest and longest runtimes of the threads in this group. And finally, the disk statistics are printed. This is Linux specific. They will look like this: Each value is printed for both reads and writes, with reads first. The numbers denote: Number of I/Os performed by all groups. Amount of data transferred in units of 512 bytes for all groups. Number of merges performed by the I/O scheduler. Number of ticks we kept the disk busy. The disk utilization. A value of 100% means we kept the disk busy constantly, 50% would be a disk idling half of the time. It is also possible to get fio to dump the current output while it is running, without terminating the job. To do that, send fio the USR1 signal. You can also get regularly timed dumps by using the parameter, or by creating a file in named . If fio sees this file, it will unlink it and dump the current output status."
    },
    {
        "link": "https://fio.readthedocs.io/en/master/fio_doc.html",
        "document": "This section describes in details each parameter associated with a job. Some parameters take an option of a given type, such as an integer or a string. Anywhere a numeric value is required, an arithmetic expression may be used, provided it is surrounded by parentheses. Supported operators are: For time values in expressions, units are microseconds by default. This is different than for time values not in expressions (not enclosed in parentheses). The following types are used: Integer with possible time suffix. Without a unit value is interpreted as seconds unless otherwise specified. Accepts a suffix of ‘d’ for days, ‘h’ for hours, ‘m’ for minutes, ‘s’ for seconds, ‘ms’ (or ‘msec’) for milliseconds and ‘us’ (or ‘usec’) for microseconds. For example, use 10m for 10 minutes. Integer. A whole number value, which may contain an integer prefix and an integer suffix: The optional integer prefix specifies the number’s base. The default is decimal. 0x specifies hexadecimal. The optional integer suffix specifies the number’s units, and includes an optional unit prefix and an optional unit. For quantities of data, the default unit is bytes. For quantities of time, the default unit is seconds unless otherwise specified. With =1000, fio follows international standards for unit prefixes. To specify power-of-10 decimal values defined in the International System of Units (SI): To specify power-of-2 binary values defined in IEC 80000-13: With =1024 (the default), the unit prefixes are opposite from those specified in the SI and IEC 80000-13 standards to provide compatibility with old scripts. For example, 4k means 4096. For quantities of data, an optional unit of ‘B’ may be included (e.g., ‘kB’ is the same as ‘k’). The integer suffix is not case sensitive (e.g., m/mi mean mebi/mega, not milli). ‘b’ and ‘B’ both mean byte, not bit. To specify times (units are not case sensitive): If the option accepts an upper and lower range, use a colon ‘:’ or minus ‘-’ to separate such values. See irange. If the lower value specified happens to be larger than the upper value the two values are swapped. Boolean. Usually parsed as an integer, however only defined for true and false (1 and 0). Integer range with suffix. Allows value range to be given, such as 1024-4096. A colon may also be used as the separator, e.g. 1k:4k. If the option allows two sets of ranges, they can be specified with a ‘,’ or ‘/’ delimiter: 1k-4k/8k-32k. Also see int. With the above in mind, here follows the complete list of fio job parameters. Select the interpretation of unit prefixes in input parameters. Inputs comply with IEC 80000-13 and the International System of Units (SI). Use: See for more details on input parameters. Outputs always use correct prefixes. Most outputs include both side-by-side, like: If only one value is reported, then kb_base selects the one to use: ASCII name of the job. This may be used to override the name printed by fio for this job. Otherwise the job name is used. On the command line this parameter has the special purpose of also signaling the start of a new job. Text description of the job. Doesn’t do anything except dump this text description when this job is run. It’s not parsed. Run the specified number of iterations of this job. Used to repeat the same workload a given number of times. Defaults to 1. Create the specified number of clones of this job. Each clone of job is spawned as an independent thread or process. May be used to setup a larger number of threads/processes doing the same thing. Each thread is reported separately; to see statistics for all clones as a whole, use in conjunction with . See . Default: 1. Limit runtime. The test will run until it completes the configured I/O workload or until it has run for this specified amount of time, whichever occurs first. It can be quite hard to determine for how long a specified job will run, so this parameter is handy to cap the total runtime to a given time. When the unit is omitted, the value is interpreted in seconds. If set, fio will run for the duration of the specified even if the file(s) are completely read or written. It will simply loop over the same workload as many times as the allows. Delay the start of job for the specified amount of time. Can be a single value or a range. When given as a range, each thread will choose a value randomly from within the range. Value is in seconds if a unit is omitted. If set, fio will run the specified workload for this amount of time before logging any performance numbers. Useful for letting performance settle before logging results, thus minimizing the runtime required for stable results. Note that the is considered lead in time for a job, thus it will increase the total runtime if a special timeout or is specified. When the unit is omitted, the value is given in seconds. Use the given clocksource as the base of timing. The supported options are: cpu is the preferred clocksource if it is reliable, as it is very fast (and fio is heavy on time calls). Fio will automatically use this clocksource if it’s supported and considered reliable on the system it is running on, unless another clocksource is specifically set. For x86/x86-64 CPUs, this means supporting TSC Invariant. Enable all of the gettimeofday(2) reducing options ( , , ) plus reduce precision of the timeout somewhat to really shrink the gettimeofday(2) call count. With this option enabled, we only do about 0.4% of the gettimeofday(2) calls we would have done if all time keeping was enabled. Sometimes it’s cheaper to dedicate a single thread of execution to just getting the current time. Fio (and databases, for instance) are very intensive on gettimeofday(2) calls. With this option, you can set one CPU aside for doing nothing but logging current time to a shared memory location. Then the other threads/processes that run I/O workloads need only copy that segment, instead of entering the kernel with a gettimeofday(2) call. The CPU set aside for doing these time calls will be excluded from other uses. Fio will manually clear it from the CPU mask of other jobs. The clock_id passed to the call to used to record job_start in the output format. Default is 0, or CLOCK_REALTIME. Prefix filenames with this directory. Used to place files in a different location than . You can specify a number of directories by separating the names with a ‘:’ character. These directories will be assigned equally distributed to job clones created by as long as they are using generated filenames. If specific are set fio will use the first listed directory, and thereby matching the semantic (which generates a file for each clone if not specified, but lets all clones use the same file if set). See the option for information on how to escape “ ” characters within the directory path itself. Note: To control the directory fio will use for internal state files use . Fio normally makes up a based on the job name, thread number, and file number (see ). If you want to share files between threads in a job or several jobs with fixed file paths, specify a for each of them to override the default. If the ioengine is file based, you can specify a number of files by separating the names with a ‘:’ colon. So if you wanted a job to open and as the two working files, you would use . This also means that whenever this option is specified, is ignored. The size of regular files specified by this option will be divided by number of files unless an explicit size is specified by . Each colon in the wanted path must be escaped with a character. For instance, if the path is then you would use and if the path is then you would use . On Windows, disk devices are accessed as for the first device, for the second etc. Note: Windows and FreeBSD (refer to geom(4)) prevent write access to areas of the disk containing in-use data (e.g. filesystems). For HTTP and S3 access, specify a valid URL path or S3 key, respectively. A filename for path-style S3 includes a bucket name ( ) while a virtual-hosted-style S3 filename does not because its bucket name is specified in . The filename “ ” is a reserved name, meaning stdin or stdout. Which of the two depends on the read/write direction set. If sharing multiple files between jobs, it is usually necessary to have fio generate the exact names that you want. By default, fio will name a file based on the default file format specification of . With this option, that can be customized. Fio will recognize and replace the following keywords in this string: The name of the worker thread or process. IP of the fio process when using client/server mode. The incremental number of the worker thread or process. The incremental number of the file for that worker thread or process. To have dependent jobs share a set of files, this option can be set to have fio generate filenames that are shared between the two. For instance, if is specified, file number 4 for any job will be named . The default of will be used if no other format specifier is given. If you specify a path then the directories will be created up to the main directory for the file. So for example if you specify then the directories a/b/c will be created before the file setup part of the job. If you specify then the path will be relative that directory, otherwise it is treated as the absolute path. To avoid collisions between networked clients, fio defaults to prefixing any generated filenames (with a directory specified) with the source of the client connecting. To disable this behavior, set this option to 0. Recursively open any files below directory . This accepts only a single directory and unlike related options, colons appearing in the path must not be escaped. Fio defaults to not locking any files before it does I/O to them. If a file or file descriptor is shared, fio can serialize I/O to that file to make the end result consistent. This is usual for emulating real workloads that share files. The lock modes are: Only one thread or process may do I/O at a time, excluding all others. Read-write locking on the file. Many readers may access the file at the same time, but writes get exclusive access. Number of files to use for this job. Defaults to 1. The size of files will be divided by this unless explicit size is specified by . Files are created for each thread separately, and each file will have a file number within its name by default, as explained in section. Number of files to keep open at the same time. Defaults to the same as , can be set smaller to limit the number simultaneous opens. Defines how fio decides which file from a job to service next. The following types are defined: Round robin over opened files. This is the default. Finish one file before moving on to the next. Multiple files can still be open depending on . Use a Zipf distribution to decide what file to access. Use a Pareto distribution to decide what file to access. Use a Gaussian (normal) distribution to decide what file to access. For random, roundrobin, and sequential, a postfix can be appended to tell fio how many I/Os to issue before switching to a new file. For example, specifying would cause fio to issue 8 I/Os before selecting a new file at random. For the non-uniform distributions, a floating point postfix can be given to influence how the distribution is skewed. See for a description of how that would work. Attempt to switch the device hosting the file to the specified I/O scheduler before running. If true, serialize the file creation for the jobs. This may be handy to avoid interleaving of data files, which may greatly depend on the filesystem used and even the number of processors in the system. Default: true. fsync(2) the data file after creation. This is the default. If true, don’t pre-create files but allow the job’s open() to create a file when it’s time to do I/O. Default: false – pre-create all necessary files when the job starts. If true, fio will only run the setup phase of the job. If files need to be laid out or updated on disk, only that will be done – the actual job contents are not executed. Default: false. If true, fio is permitted to create files as part of its workload. If this option is false, then fio will error out if the files it needs to use don’t already exist. Default: true. If this isn’t set, fio will abort jobs that are destructive (e.g. that write) to what appears to be a mounted device or partition. This should help catch creating inadvertently destructive tests, not realizing that the test will destroy data on the mounted file system. Note that some platforms don’t allow writing against a mounted device regardless of this option. Default: false. If this is given, files will be pre-read into memory before starting the given I/O operation. This will also clear the flag, since it is pointless to pre-read and then drop the cache. This will only work for I/O engines that are seek-able, since they allow you to read the same data multiple times. Thus it will not work on non-seekable I/O engines (e.g. network, splice). Default: false. Unlink (delete) the job files when done. Not the default, as repeated runs of that job would then waste time recreating the file set again and again. Default: false. Unlink (delete) job files after each iteration or loop. Default: false. The , , and parameters are ignored. I/O happens in a single zone until bytes have been transferred. After that number of bytes has been transferred processing of the next zone starts. is ignored. Zoned block device mode. I/O happens sequentially in each zone, even if random I/O has been selected. Random I/O happens across all zones instead of being restricted to a single zone. The parameter is ignored. and must be identical. Trim is handled using a zone reset operation. Trim only considers non-empty sequential write required and sequential write preferred zones. Size of a single zone. See also and . For =strided, this is the number of bytes to transfer before skipping bytes. If this parameter is smaller than then only a fraction of each zone with bytes will be accessed. If this parameter is larger than then each zone will be accessed multiple times before skipping to the next zone. For =zbd, this is the size of a single zone. The parameter is ignored in this mode. For =zbd, this defines the capacity of a single zone, which is the accessible area starting from the zone start address. This parameter only applies when using =zbd in combination with regular block devices. If not specified it defaults to the zone size. If the target device is a zoned block device, the zone capacity is obtained from the device information and this option is ignored. For =strided, the number of bytes to skip after bytes of data have been transferred. This parameter must be zero for =zbd. This parameter applies to =zbd only. Zoned block devices are block devices that consist of multiple zones. Each zone has a type, e.g. conventional or sequential. A conventional zone can be written at any offset that is a multiple of the block size. Sequential zones must be written sequentially. The position at which a write must occur is called the write pointer. A zoned block device can be either drive managed, host managed or host aware. For host managed devices the host must ensure that writes happen sequentially. Fio recognizes host managed devices and serializes writes to sequential zones for these devices. If a read occurs in a sequential zone beyond the write pointer then the zoned block device will complete the read without reading any data from the storage medium. Since such reads lead to unrealistically high bandwidth and IOPS numbers fio only reads beyond the write pointer if explicitly told to do so. Default: false. When a zone of a zoned block device is partially written (i.e. not all sectors of the zone have been written), the zone is in one of three conditions: ‘implicit open’, ‘explicit open’ or ‘closed’. Zoned block devices may have a limit called ‘max_open_zones’ (same name as the parameter) on the total number of zones that can simultaneously be in the ‘implicit open’ or ‘explicit open’ conditions. Zoned block devices may have another limit called ‘max_active_zones’, on the total number of zones that can simultaneously be in the three conditions. The parameter limits the number of zones to which write commands are issued by all fio jobs, that is, limits the number of zones that will be in the conditions. When the device has the max_open_zones limit and does not have the max_active_zones limit, the parameter limits the number of zones in the two open conditions up to the limit. In this case, fio includes zones in the two open conditions to the write target zones at fio start. When the device has both the max_open_zones and the max_active_zones limits, the parameter limits the number of zones in the three conditions up to the limit. In this case, fio includes zones in the three conditions to the write target zones at fio start. This parameter is relevant only if the =zbd is used. The default value is always equal to the max_open_zones limit of the target zoned block device and a value higher than this limit cannot be specified by users unless the option is specified. When is specified or the target device does not have the max_open_zones limit, can specify 0 to disable any limit on the number of zones that can be simultaneously written to by all jobs. In the same manner as , limit the number of open zones per fio job, that is, the number of zones that a single job can simultaneously write to. A value of zero indicates no limit. Default: zero. If this option is used, fio will ignore the maximum number of open zones limit of the zoned block device in use, thus allowing the option value to be larger than the device reported limit. Default: false. A number between zero and one that indicates the ratio of written bytes in the zones with write pointers in the IO range to the size of the IO range. When current ratio is above this ratio, zones are reset periodically as specifies. If there are multiple jobs when using this option, the IO range for all write jobs has to be the same. A number between zero and one that indicates how often a zone reset should be issued if the zone reset threshold has been exceeded. A zone reset is submitted after each (1 / zone_reset_frequency) write requests. This and the previous parameter can be used to simulate garbage collection activity. If value is true, use non-buffered I/O. This is usually O_DIRECT. Note that OpenBSD and ZFS on Solaris don’t support direct I/O. On Windows the synchronous ioengines don’t support direct I/O. Default: false. If value is true, use buffered I/O. This is the opposite of the option. Defaults to true. Sequential trim+write sequences. Blocks will be trimmed first, then the same blocks will be written to. So if is specified, Fio will trim a total of 64K bytes and also write 64K bytes on the same trimmed blocks. This behaviour will be consistent with or other Fio options limiting the total bytes or number of I/O’s. Like trimwrite, but uses random offsets rather than sequential writes. Fio defaults to read if the option is not specified. For the mixed I/O types, the default is to split them 50/50. For certain types of I/O the result may still be skewed a bit, since the speed may be different. It is possible to specify the number of I/Os to do before getting a new offset by appending to the end of the string given. For a random read, it would look like for passing in an offset modifier with a value of 8. If the suffix is used with a sequential I/O pattern, then the <nr> value specified will be added to the generated offset for each I/O turning sequential I/O into sequential I/O with holes. For instance, using will skip 4k for every write. Also see the option. If an offset modifier is given by appending a number to the line, then this option controls how that number modifies the I/O offset being generated. Accepted values are: is only useful for random I/O, where fio would normally generate a new random offset for every I/O. If you append e.g. 8 to randread, i.e. you would get a new random offset for every 8 I/Os. The result would be a sequence of 8 sequential offsets with a random starting point. However this behavior may change if a sequential I/O reaches end of the file. As sequential I/O is already sequential, setting for that would not result in any difference. behaves in a similar fashion, except it sends the same offset 8 number of times before generating a new offset. The generated sequence of offsets will look like this: 4k, 8k, 12k, 16k, 20k, 24k, 28k, 32k, 92k, 96k, 100k, 104k, 108k, 112k, 116k, 120k, 48k, 52k … The generated sequence of offsets will look like this: 4k, 4k, 4k, 4k, 4k, 4k, 4k, 4k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 48k, 48k, 48k … Fio normally reports statistics on a per data direction basis, meaning that reads, writes, and trims are accounted and reported separately. This option determines whether fio reports the results normally, summed together, or as both options. Accepted values are: Statistics are summed per data direction and reported together. Statistics are reported normally, followed by the mixed statistics. Seed all random number generators in a predictable way so the pattern is repeatable across runs. Default: true. Seed the random number generators based on this seed value, to be able to control what sequence of output is being generated. If not set, the random sequence depends on the setting. Whether pre-allocation is performed when laying down files. Accepted values are: Use a platform’s native pre-allocation call but fall back to none behavior if it fails/is not implemented. Extend file to final size via ftruncate(2) instead of allocating. May not be available on all supported platforms. keep is only available on Linux. If using ZFS on Solaris this cannot be set to posix because ZFS doesn’t support pre-allocation. Default: native if any pre-allocation methods except truncate are available, none if not. Note that using truncate on Windows will interact surprisingly with non-sequential write patterns. When writing to a file that has been extended by setting the end-of-file information, Windows will backfill the unwritten portion of the file up to that offset with zeroes before issuing the new write. This means that a single small write to the end of an extended file will stall until the entire file has been filled with zeroes. Use posix_fadvise(2) or posix_fadvise(2) to advise the kernel on what I/O patterns are likely to be issued. Accepted values are: Backwards compatible hint for “advise with fio workload type”. This uses FADV_RANDOM for a random workload, and FADV_SEQUENTIAL for a sequential workload. Advise using FADV_NOREUSE. This may be a no-op on older Linux kernels. Since Linux 6.3, it provides a hint to the LRU algorithm. See the posix_fadvise(2) man page. Use fcntl(2) to advise the kernel what life time to expect from a write. Only supported on Linux, as of version 4.13. Accepted values are: No particular life time associated with this file. Data written to this file has a short life time. Data written to this file has a medium life time. Data written to this file has a long life time. Data written to this file has a very long life time. The values are all relative to each other, and no absolute meaning should be associated with them. Start I/O at the provided offset in the file, given as either a fixed size in bytes, zones or a percentage. If a percentage is given, the generated offset will be aligned to the minimum or to the value of if provided. Data before the given offset will not be touched. This effectively caps the file size at . Can be combined with to constrain the start and end range of the I/O workload. A percentage can be specified by a number between 1 and 100 followed by ‘%’, for example, to specify 20%. In ZBD mode, value can be set as number of zones using ‘z’. If set to non-zero value, the byte offset generated by a percentage is aligned upwards to this value. Defaults to 0 meaning that a percentage offset is aligned to the minimum block size. If this is provided, then the real offset becomes , where the thread number is a counter that starts at 0 and is incremented for each sub-job (i.e. when option is specified). This option is useful if there are several jobs which are intended to operate on a file in parallel disjoint segments, with even spacing between the starting points. Percentages can be used for this option. If a percentage is given, the generated offset will be aligned to the minimum or to the value of if provided. In ZBD mode, value can also be set as number of zones using ‘z’. Fio will normally perform I/Os until it has exhausted the size of the region set by , or if it exhaust the allocated time (or hits an error condition). With this setting, the range/size can be set independently of the number of I/Os to perform. When fio reaches this number, it will exit normally and report status. Note that this does not extend the amount of I/O that will be done, it will only stop fio if this condition is met before other end-of-job criteria. If writing to a file, issue an fsync(2) (or its equivalent) of the dirty data for every number of blocks given. For example, if you give 32 as a parameter, fio will sync the file after every 32 writes issued. If fio is using non-buffered I/O, we may not sync the file. The exception is the sg I/O engine, which synchronizes the disk cache anyway. Defaults to 0, which means fio does not periodically issue and wait for a sync to complete. Also see and . Like but uses fdatasync(2) to only sync data and not metadata blocks. In Windows, DragonFlyBSD or OSX there is no fdatasync(2) so this falls back to using fsync(2). Defaults to 0, which means fio does not periodically issue and wait for a data-only sync to complete. Use sync_file_range(2) for every number of write operations. Fio will track range of writes that have happened since the last sync_file_range(2) call. can currently be one or more of: So if you do , fio would use for every 8 writes. Also see the sync_file_range(2) man page. This option is Linux specific. If true, writes to a file will always overwrite existing data. If the file doesn’t already exist, it will be created before the write phase begins. If the file exists and is large enough for the specified write phase, nothing will be done. Default: false. If true, fsync(2) file contents when a write stage has completed. Default: false. If true, fio will fsync(2) a dirty file on close. This differs from in that it will happen on every file close, not just at the end of the job. Default: false. Percentage of a mixed workload that should be reads. Default: 50. Percentage of a mixed workload that should be writes. If both and is given and the values do not add up to 100%, the latter of the two will be used to override the first. This may interfere with a given rate setting, if fio is asked to limit reads or writes to a certain rate. If that is the case, then the distribution may be skewed. Default: 50. By default, fio will use a completely uniform random distribution when asked to perform random I/O. Sometimes it is useful to skew the distribution in specific ways, ensuring that some parts of the data is more hot than others. fio includes the following distribution models: When using a zipf or pareto distribution, an input value is also needed to define the access pattern. For zipf, this is the . For pareto, it’s the . Fio includes a test program, fio-genzipf, that can be used visualize what the given input values will yield in terms of hit rates. If you wanted to use zipf with a of 1.2, you would use as the option. If a non-uniform model is used, fio will disable use of the random map. For the normal distribution, a normal (Gaussian) deviation is supplied as a value between 0 and 100. The second, optional float is allowed for pareto, zipf and normal distributions. It allows one to set base of distribution in non-default place, giving more control over most probable outcome. This value is in range [0-1] which maps linearly to range of possible random values. Defaults are: random for pareto and zipf, and 0.5 for normal. If you wanted to use zipf with a of 1.2 centered on 1/4 of allowed value range, you would use . For a zoned distribution, fio supports specifying percentages of I/O access that should fall within what range of the file or device. For example, given a criteria of:\n• None 60% of accesses should be to the first 10%\n• None 30% of accesses should be to the next 20%\n• None 8% of accesses should be to the next 30%\n• None 2% of accesses should be to the next 40% we can define that through zoning of the random accesses. For the above example, the user would do: A zoned_abs distribution works exactly like the zoned, except that it takes absolute sizes. For example, let’s say you wanted to define access according to the following criteria:\n• None 60% of accesses should be to the first 20G\n• None 30% of accesses should be to the next 100G\n• None 10% of accesses should be to the next 500G we can define an absolute zoning distribution with: For both zoned and zoned_abs, fio supports defining up to 256 separate zones. Similarly to how works for setting ranges and percentages of block sizes. Like , it’s possible to specify separate zones for reads, writes, and trims. If just one set is given, it’ll apply to all of them. This goes for both zoned zoned_abs distributions. For a random workload, set how big a percentage should be random. This defaults to 100%, in which case the workload is fully random. It can be set from anywhere from 0 to 100. Setting it to 0 would make the workload fully sequential. Any setting in between will result in a random mix of sequential and random I/O, at the given percentages. Comma-separated values may be specified for reads, writes, and trims as described in . Normally fio will cover every block of the file when doing random I/O. If this option is given, fio will just get a new random offset without looking at past I/O history. This means that some blocks may not be read or written, and that some blocks may be read/written more than once. If this option is used with and multiple blocksizes (via ), only intact blocks are verified, i.e., partially-overwritten blocks are ignored. With an async I/O engine and an I/O depth > 1, it is possible for the same block to be overwritten, which can cause verification errors. Either do not use norandommap in this case, or also use the lfsr random generator. See . If fio runs with the random block map enabled and it fails to allocate the map, if this option is set it will continue without a random block map. As coverage will not be as complete as with random maps, this option is disabled by default. Fio supports the following engines for generating I/O offsets for random I/O: tausworthe is a strong random number generator, but it requires tracking on the side if we want to ensure that blocks are only read or written once. lfsr guarantees that we never generate the same offset twice, and it’s also less computationally expensive. It’s not a true random generator, however, though for I/O purposes it’s typically good enough. lfsr only works with single block sizes, not with workloads that use multiple block sizes. If used with such a workload, fio may read or write some blocks multiple times. The default value is tausworthe, unless the required space exceeds 2^32 blocks. If it does, then tausworthe64 is selected automatically. The block size in bytes used for I/O units. Default: 4096. A single value applies to reads, writes, and trims. Comma-separated values may be specified for reads, writes, and trims. A value not terminated in a comma applies to subsequent types. means 8k for reads, 32k for writes and trims. means 8k for reads, 32k for writes, and default for trims. means default for reads, 8k for writes and trims. means default for reads, 8k for writes, and default for trims. A range of block sizes in bytes for I/O units. The issued I/O unit will always be a multiple of the minimum size, unless is set. Comma-separated ranges may be specified for reads, writes, and trims as described in . Example: also the ‘:’ delimiter . Sometimes you want even finer grained control of the block sizes issued, not just an even split between them. This option allows you to weight various block sizes, so that you are able to define a specific amount of block sizes issued. The format for this option is: for as many block sizes as needed. So if you want to define a workload that has 50% 64k blocks, 10% 4k blocks, and 40% 32k blocks, you would write: Ordering does not matter. If the percentage is left blank, fio will fill in the remaining values evenly. So a bssplit option like this one: would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up to 100, if bssplit is given a range that adds up to more, it will error out. Comma-separated values may be specified for reads, writes, and trims as described in . If you want a workload that has 50% 2k reads and 50% 4k reads, while having 90% 4k writes and 10% 8k writes, you would specify: Fio supports defining up to 64 different weights for each data direction. If set, fio will issue I/O units with any size within , not just multiples of the minimum size. This typically won’t work with direct I/O, as that normally requires sector alignment. If this option is set, fio will use the normal read,write blocksize settings as sequential,random blocksize settings instead. Any random read or write will use the WRITE blocksize settings, and any sequential read or write will use the READ blocksize settings. Boundary to which fio will align random I/O units. Default: . Minimum alignment is typically 512b for using direct I/O, though it usually depends on the hardware block size. This option is mutually exclusive with using a random map for files, so it will turn off that option. Comma-separated values may be specified for reads, writes, and trims as described in . Initialize buffers with all zeros. Default: fill buffers with random data. If this option is given, fio will refill the I/O buffers on every submit. Only makes sense if isn’t specified, naturally. Defaults to being unset i.e., the buffer is only filled at init time and the data in it is reused when possible but if any of , or are enabled then is also automatically enabled. If is too costly and the target is using data deduplication, then setting this option will slightly modify the I/O buffer contents to defeat normal de-dupe attempts. This is not enough to defeat more clever block compression attempts, but it will stop naive dedupe of blocks. Default: true. If this is set, then fio will attempt to provide I/O buffer content (on WRITEs) that compresses to the specified level. Fio does this by providing a mix of random data followed by fixed pattern data. The fixed pattern is either zeros, or the pattern specified by . If the option is used, it might skew the compression ratio slightly. Setting to a value other than 100 will also enable in order to reduce the likelihood that adjacent blocks are so similar that they over compress when seen together. See for how to set a finer or coarser granularity for the random/fixed data region. Defaults to unset i.e., buffer data will not adhere to any compression level. This setting allows fio to manage how big the random/fixed data region is when using . When is set to some non-zero value smaller than the block size, fio can repeat the random/fixed region throughout the I/O buffer at the specified interval (which particularly useful when bigger block sizes are used for a job). When set to 0, fio will use a chunk size that matches the block size resulting in a single random/fixed region within the I/O buffer. Defaults to 512. When the unit is omitted, the value is interpreted in bytes. If set, fio will fill the I/O buffers with this pattern or with the contents of a file. If not set, the contents of I/O buffers are defined by the other options related to buffer contents. The setting can be any pattern of bytes, and can be prefixed with 0x for hex values. It may also be a string, where the string must then be wrapped with . Or it may also be a filename, where the filename must be wrapped with in which case the file is opened and read. Note that not all the file contents will be read if that would cause the buffers to overflow. So, for example: Also you can combine everything together in any order: If set, fio will generate this percentage of identical buffers when writing. These buffers will be naturally dedupable. The contents of the buffers depend on what other buffer compression settings have been set. It’s possible to have the individual buffers either fully compressible, or not at all – this option only controls the distribution of unique buffers. Setting this option will also enable to prevent every buffer being identical. If is given, then this option controls how fio generates the dedupe buffers. is the default option for fio. Dedupe buffers are generated by repeating previous unique write. is a more realistic workload. With , should be provided. Given that, fio will use the initial unique write buffers as its working set. Upon deciding to dedupe, fio will randomly choose a buffer from the working set. Note that by using the dedupe percentage will converge to the desired over time while maintains the desired percentage throughout the job. If is set to , then this controls the percentage of size of the file or device used as the buffers fio will choose to generate the dedupe buffers from Note that size needs to be explicitly provided and only 1 file per job is supported This controls whether the deduplication buffers will be shared amongst all jobs that have this option set. The buffers are spread evenly between participating jobs. Invalidate the buffer/page cache parts of the files to be used prior to starting I/O if the platform and file type support it. Defaults to true. This will be ignored if is also specified for the same job. Whether, and what type, of synchronous I/O to use for writes. The allowed values are: Do not use synchronous IO, the default. Use synchronous file IO. For the majority of I/O engines, this means using O_SYNC. Use synchronous data IO. For the majority of I/O engines, this means using O_DSYNC. Fio can use various types of memory as the I/O unit buffer. The allowed values are: Use memory from malloc(3) as the buffers. Default memory type. Use shared memory as the buffers. Allocated through shmget(2). Same as shm, but use huge pages as backing. Use mmap(2) to allocate buffers. May either be anonymous memory, or can be file backed if a filename is given after the option. The format is . Use a memory mapped huge file as the buffer backing. Append filename after mmaphuge, ala . Same as mmap, but use a MMAP_SHARED mapping. Use GPU memory as the buffers for GPUDirect RDMA benchmark. The must be . The area allocated is a function of the maximum allowed bs size for the job, multiplied by the I/O depth given. Note that for shmhuge and mmaphuge to work, the system must have free huge pages allocated. This can normally be checked and set by reading/writing on a Linux system. Fio assumes a huge page is 2 or 4MiB in size depending on the platform. So to calculate the number of huge pages you need for a given job file, add up the I/O depth of all jobs (normally one unless is used) and multiply by the maximum bs set. Then divide that number by the huge page size. You can see the size of the huge pages in . If no huge pages are allocated by having a non-zero number in , using mmaphuge or shmhuge will fail. Also see . mmaphuge also needs to have hugetlbfs mounted and the file location should point there. So if it’s mounted in , you would use . This indicates the memory alignment of the I/O memory buffers. Note that the given alignment is applied to the first I/O unit buffer, if using the alignment of the following buffers are given by the used. In other words, if using a that is a multiple of the page sized in the system, all buffers will be aligned to this value. If using a that is not page aligned, the alignment of subsequent I/O memory buffers is the sum of the and used. Defines the size of a huge page. Must at least be equal to the system setting, see and . Defaults to 2 or 4MiB depending on the platform. Should probably always be a multiple of megabytes, so using is the preferred way to set this to avoid setting a non-pow-2 bad value. Pin the specified amount of memory with mlock(2). Can be used to simulate a smaller amount of memory. The amount specified is per worker. The total size of file I/O for each thread of this job. Fio will run until this many bytes has been transferred, unless runtime is altered by other means such as (1) , (2) (3) , (4) gaps/holes while doing I/O’s such as , or (5) sequential I/O reaching end of the file which is possible when is less than 100. Fio will divide this size between the available files determined by options such as , , unless is specified by the job. If the result of division happens to be 0, the size is set to the physical size of the given files or devices if they exist. If this option is not specified, fio will use the full size of the given files or devices. If the files do not exist, size must be given. It is also possible to give size as a percentage between 1 and 100. If is given, fio will use 20% of the full size of the given files or devices. In ZBD mode, value can also be set as number of zones using ‘z’. Can be combined with to constrain the start and end range that I/O will be done within. Normally fio operates within the region set by , which means that the option sets both the region and size of I/O to be performed. Sometimes that is not what you want. With this option, it is possible to define just the amount of I/O that fio should do. For instance, if is set to 20GiB and is set to 5GiB, fio will perform I/O within the first 20GiB but exit when 5GiB have been done. The opposite is also possible – if is set to 20GiB, and is set to 40GiB, then fio will do 40GiB of I/O within the 0..20GiB region. Individual file sizes. May be a range, in which case fio will select sizes for files at random within the given range. If not given, each created file is the same size. This option overrides in terms of file size, i.e. if is specified then becomes merely the default for and has no effect at all if is set explicitly. Perform I/O after the end of the file. Normally fio will operate within the size of a file. If this option is set, then fio will append to the file instead. This has identical behavior to setting to the size of a file. This option is ignored on non-regular files. Sets size to something really large and waits for ENOSPC (no space left on device) or EDQUOT (disk quota exceeded) as the terminating condition. Only makes sense with sequential write. For a read workload, the mount point will be filled first then I/O started on the result. This option doesn’t make sense if operating on a raw device node, since the size of that is already known by the file system. Additionally, writing beyond end-of-device will not return ENOSPC there. I/O engines define how the job issues I/O to the file. The following types are defined: Basic read(2) or write(2) I/O. lseek(2) is used to position the I/O location. See and for syncing write I/Os. Basic pread(2) or pwrite(2) I/O. Default on all supported operating systems except for Windows. Basic readv(2) or writev(2) I/O. Will emulate queuing by coalescing adjacent I/Os into a single submission. Fast Linux native asynchronous I/O. Supports async IO for both direct and buffered IO. This engine defines engine specific options. Fast Linux native asynchronous I/O for pass through commands. This engine defines engine specific options. Linux native asynchronous I/O. Note that Linux may only support queued behavior with non-buffered I/O (set or ). This engine defines engine specific options. File is memory mapped with mmap(2) and data copied to/from using memcpy(3). splice(2) is used to transfer the data and vmsplice(2) to transfer data from user space to the kernel. SCSI generic sg v3 I/O. May either be synchronous using the SG_IO ioctl, or if the target is an sg character device we use read(2) and write(2) for asynchronous I/O. Requires option to specify either block or character devices. This engine supports trim operations. The sg engine includes engine specific options. Read, write, trim and ZBC/ZAC operations to a zoned block device using libzbc library. The target can be either an SG character device or a block device file. Doesn’t transfer any data, just pretends to. This is mainly used to exercise fio itself and for debugging/testing purposes. Transfer over the network to given . Depending on the used, the , , and options are used to specify what sort of connection to make, while the option determines which protocol will be used. This engine defines engine specific options. Like net, but uses splice(2) and vmsplice(2) to map data and send/receive. This engine defines engine specific options. Doesn’t transfer any data, but burns CPU cycles according to the , and options. Setting =85 will cause that job to do nothing but burn 85% of the CPU. In case of SMP machines, use =<nr_of_cpu> to get desired CPU usage, as the cpuload only loads a single CPU at the desired rate. A job never finishes unless there is at least one non-cpuio job. Setting =qsort replace the default noop instructions loop by a qsort algorithm to consume more energy. The RDMA I/O engine supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the InfiniBand, RoCE and iWARP protocols. This engine defines engine specific options. I/O engine that does regular fallocate to simulate data transfer as fio ioengine. I/O engine that sends ftruncate(2) operations in response to write (DDIR_WRITE) events. Each ftruncate issued sets the file’s size to the current block offset. is ignored. I/O engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate defragment activity in request to DDIR_WRITE event. I/O engine supporting direct access to Ceph Reliable Autonomic Distributed Object Store (RADOS) via librados. This ioengine defines engine specific options. I/O engine supporting direct access to Ceph Rados Block Devices (RBD) via librbd without the need to use the kernel rbd driver. This ioengine defines engine specific options. I/O engine supporting GET/PUT requests over HTTP(S) with libcurl to a WebDAV or S3 endpoint. This ioengine defines engine specific options. This engine only supports direct IO of iodepth=1; you need to scale this via numjobs. blocksize defines the size of the objects to be created. Using GlusterFS libgfapi sync interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options. Using GlusterFS libgfapi async interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options. Read and write through Hadoop (HDFS). The option is used to specify host,port of the hdfs name-node to connect. This engine interprets offsets a little differently. In HDFS, files once created cannot be modified so random writes are not possible. To imitate this the libhdfs engine expects a bunch of small files to be created over HDFS and will randomly pick a file from them based on the offset generated by fio backend (see the example job file to create such files, use option). Please note, it may be necessary to set environment variables to work with HDFS/libhdfs properly. Each job uses its own connection to HDFS. Read, write and erase an MTD character device (e.g., ). Discards are treated as erases. Depending on the underlying device type, the I/O may have to go in a certain pattern, e.g., on NAND, writing sequentially to erase blocks and discarding before overwriting. The mode works well for this constraint. Read and write using device DAX to a persistent memory device (e.g., /dev/dax0.0) through the PMDK libpmem library. Prefix to specify loading an external I/O engine object file. Append the engine filename, e.g. to load ioengine in . The path can be either absolute or relative. See for details of writing an external I/O engine. Read and write using mmap I/O to a file on a filesystem mounted with DAX on a persistent memory device through the PMDK libpmem library. Synchronous read and write using DDN’s Infinite Memory Engine (IME). This engine is very basic and issues calls to IME whenever an IO is queued. Synchronous read and write using DDN’s Infinite Memory Engine (IME). This engine uses iovecs and will try to stack as much IOs as possible (if the IOs are “contiguous” and the IO depth is not exceeded) before issuing a call to IME. Asynchronous read and write using DDN’s Infinite Memory Engine (IME). This engine will try to stack as much IOs as possible by creating requests for IME. FIO will then decide when to commit these requests. I/O engine supporting libcufile synchronous access to nvidia-fs and a GPUDirect Storage-supported filesystem. This engine performs I/O without transferring buffers between user-space and the kernel, unless is set or is . must not be . This ioengine defines engine specific options. I/O engine supporting asynchronous read and write operations to the DAOS File System (DFS) via libdfs. I/O engine supporting asynchronous read and write operations to NFS filesystems from userspace via libnfs. This is useful for achieving higher concurrency and thus throughput than is possible via kernel NFS. Execute 3rd party tools. Could be used to perform monitoring during jobs runtime. I/O engine using the xNVMe C API, for NVMe devices. The xnvme engine provides flexibility to access GNU/Linux Kernel NVMe driver via libaio, IOCTLs, io_uring, the SPDK NVMe driver, or your own custom NVMe driver. The xnvme engine includes engine specific options. (See https://xnvme.io). Use the libblkio library (https://gitlab.com/libblkio/libblkio). The specific driver to use must be set using . If / is not specified, memory allocation is delegated to libblkio (and so is guaranteed to work with the selected driver). One libblkio instance is used per process, so all jobs setting option will share a single instance (with one queue per thread) and must specify compatible options. Note that some drivers don’t allow several instances to access the same device or file simultaneously, but allow it for threads. File/directory operation engines define how the job operates file or directory. The following types are defined: Simply create the files and do no I/O to them. You still need to set so that all the accounting still occurs, but no actual I/O will be done other than creating the file. Example job file: filecreate-ioengine.fio. Simply do stat() and do no I/O to the file. You need to set ‘filesize’ and ‘nrfiles’, so that files will be created. This engine is to measure file lookup and meta data access. Example job file: filestat-ioengine.fio. Simply delete the files by unlink() and do no I/O to them. You need to set ‘filesize’ and ‘nrfiles’, so that the files will be created. This engine is to measure file delete. Example job file: filedelete-ioengine.fio. Simply create the directories and do no I/O to them. You still need to set so that all the accounting still occurs, but no actual I/O will be done other than creating the directories. Example job file: dircreate-ioengine.fio. Simply do stat() and do no I/O to the directories. You need to set ‘filesize’ and ‘nrfiles’, so that directories will be created. This engine is to measure directory lookup and meta data access. Example job file: dirstat-ioengine.fio. Simply delete the directories by rmdir() and do no I/O to them. You need to set ‘filesize’ and ‘nrfiles’, so that the directories will be created. This engine is to measure directory delete. Example job file: dirdelete-ioengine.fio. For file and directory operation engines, there is no I/O throughput, then the statistics data in report have different meanings. The meaningful output indexes are: ‘iops’ and ‘clat’. ‘bw’ is meaningless. Refer to section: “Interpreting the output” for more details. In addition, there are some parameters which are only valid when a specific is in use. These are used identically to normal parameters, with the caveat that when used on the command line, they must come after the that defines them is selected. Set the percentage of I/O that will be issued with the highest priority. Default: 0. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. For this option to be effective, NCQ priority must be supported and enabled, and the option must be set. fio must also be run as the root user. Unlike slat/clat/lat stats, which can be tracked and reported independently, per priority stats only track and report a single type of latency. By default, completion latency (clat) will be reported, if is set, total latency (lat) will be reported. Set the I/O priority class to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to the highest priority class. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See ionice(1). See also the option. Set the I/O priority hint to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to 0 (no hint). A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See also the option. Set the I/O priority value to use for I/Os that must be issued with a priority when or is set. If not specified when or is set, this defaults to 0. Linux limits us to a positive value between 0 and 7, with 0 being the highest. A single value applies to reads and writes. Comma-separated values may be specified for reads and writes. See ionice(1). Refer to an appropriate manpage for other operating systems since meaning of priority may differ. See also the option. To get a finer control over I/O priority, this option allows specifying the percentage of IOs that must have a priority set depending on the block size of the IO. This option is useful only when used together with the option, that is, multiple different block sizes are used for reads and writes. The first accepted format for this option is the same as the format of the option: In this case, each entry will use the priority class, priority hint and priority level defined by the options , and respectively. The second accepted format for this option is: In this case, the priority class and priority level is defined inside each entry. In comparison with the first accepted format, the second accepted format does not restrict all entries to have the same priority class and priority level. The third accepted format for this option is: This is an extension of the second accepted format that allows one to also specify a priority hint. For all formats, only the read and write data directions are supported, values for trim IOs are ignored. This option is mutually exclusive with the option. If fio is asked to do direct IO, then Linux will map pages for each IO call, and release them when IO is done. If this option is set, the pages are pre-mapped before IO is started. This eliminates the need to map and release for each IO. This is more efficient, and reduces the IO latency as well. With this option, fio will use non-vectored read/write commands, where address must contain the address directly. Default is -1. Normal operation for io_uring is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner. With this option set to N, then every N request fio will ask sqe to be issued in an async manner. Default is 0. With this option, fio registers the set of files being used with the kernel. This avoids the overhead of managing file counts in the kernel, making the submission and completion part more lightweight. Required for the below option. Normally fio will submit IO by issuing a system call to notify the kernel of available items in the SQ ring. If this option is set, the act of submitting IO will be done by a polling thread in the kernel. This frees up cycles for fio, at the cost of using more CPU in the system. As submission is just the time it takes to fill in the sqe entries and any syscall required to wake up the idle kernel thread, fio will not report submission latencies. When is set, this option provides a way to define which CPU should be used for the polling thread. Specifies the type of uring passthrough command to be used. Supported value is nvme. Default is nvme. If this option is set, fio will attempt to use polled IO completions. Normal IO completions generate interrupts to signal the completion of IO, polled completions do not. Hence they are require active reaping by the application. The benefits are more efficient IO for high IOPS scenarios, and lower latencies for low queue depth IO. Use poll queues. This is incompatible with and . Set RWF_HIPRI on I/O, indicating to the kernel that it’s of higher priority than normal. If this option is set, fio will attempt to use polled IO completions. This will have a similar effect as (io_uring)hipri. Only SCSI READ and WRITE commands will have the SGV4_FLAG_HIPRI set (not UNMAP (trim) nor VERIFY). Older versions of the Linux sg driver that do not support hipri will simply ignore this flag and do normal IO. The Linux SCSI Low Level Driver (LLD) that “owns” the device also needs to support hipri (also known as iopoll and mq_poll). The MegaRAID driver is an example of a SCSI LLD. Default: clear (0) which does normal (interrupted based) IO. Normally, with the libaio engine in use, fio will use the io_getevents(2) system call to reap newly returned events. With this flag turned on, the AIO ring will be read directly from user-space to reap events. The reaping mode is only enabled when polling for a minimum of 0 events (e.g. when ). When hipri is set this determines the probability of a pvsync2 I/O being high priority. The default is 100%. By default if a request cannot be executed immediately (e.g. resource starvation, waiting on locks) it is queued and the initiating process will be blocked until the required resource becomes free. This option sets the RWF_NOWAIT flag (supported from the 4.14 Linux kernel) and the call will return instantly with EAGAIN or a partial result rather than waiting. It is useful to also use ignore_error=EAGAIN when using this option. Note: glibc 2.27, 2.28 have a bug in syscall wrappers preadv2, pwritev2. They return EOPNOTSUP instead of EAGAIN. For cached I/O, using this option usually means a request operates only with cached data. Currently the RWF_NOWAIT flag does not supported for cached write. For direct I/O, requests will only succeed if cache invalidation isn’t required, file blocks are fully allocated and the disk request could be issued immediately. This option means that writes are issued with torn-write protection, meaning that for a power fail or kernel crash, all or none of the data from the write will be stored, but never a mix of old and new data. Torn-write protection is also known as atomic writes. This option sets the RWF_ATOMIC flag (supported from the 6.11 Linux kernel) on a per-IO basis. Writes with RWF_ATOMIC set will be rejected by the kernel when the file does not support torn-write protection. To learn a file’s torn-write limits, issue statx with STATX_WRITE_ATOMIC. Specifies the data placement directive type to use for write commands. The following types are supported: Do not use a data placement directive. This is the default. Use Flexible Data Placement directives for write commands. This is equivalent to specifying =1. Defines how fio decides which placement ID to use next. The following types are defined: Round robin over available placement IDs. This is the default. Choose a placement ID (index) based on the scheme file defined by the option . The available placement ID (indices) are defined by the option or except for the case of scheme. Select which Placement ID Indices (FDP) or Placement IDs (streams) this job is allowed to use for writes. This option accepts a comma-separated list of values or ranges (e.g., 1,2-4,5,6-8). For FDP by default, the job will cycle through all available Placement IDs, so use this option to be selective. The values specified here are array indices for the list of placement IDs returned by the nvme-cli command . If you want fio to use FDP placement identifiers only at indices 0, 2 and 5, set . For streams this should be a list of Stream IDs. Defines which placement ID (index) to be selected based on offset(LBA) range. The file should contains one or more scheme entries in the following format: Each line, a scheme entry, contains start offset, end offset, and placement ID (index) separated by comma(,). If the write offset is within the range of a certain scheme entry(start offset ≤ offset < end offset), the corresponding placement ID (index) will be selected. If the write offset belongs to multiple scheme entries, the first matched scheme entry will be applied. If the offset is not within any range of scheme entry, dspec field will be set to 0, default RUH. (Caution: In case of multiple devices in a job, all devices of the job will be affected by the scheme. If this option is specified, the option or will be ignored.) Size in bytes for separate metadata buffer per IO. For io_uring_cmd these buffers are allocated using malloc regardless of what is set for . Default: 0. Action to take when nvme namespace is formatted with protection information. If this is set to 1 and namespace is formatted with metadata size equal to protection information size, fio won’t use separate metadata buffer or extended logical block. If this is set to 1 and namespace is formatted with metadata size greater than protection information size, fio will not generate or verify the protection information portion of metadata for write or read case respectively. If this is set to 0, fio generates protection information for write case and verifies for read case. Default: 1. For 16 bit CRC generation fio will use isa-l if available otherwise it will use the default slower generator. (see: https://github.com/intel/isa-l) Controls the protection information check. This can take one or more of these values. Default: none. Specifies logical block application tag value, if namespace is formatted to use end to end protection information. Default: 0x1234. Specifies logical block application tag mask value, if namespace is formatted to use end to end protection information. Default: 0xffff. For trim command this will be the number of ranges to trim per I/O request. The number of logical blocks per range is determined by the option which should be a multiple of logical block size. This cannot be used with read or write. Note that setting this option > 1, will not be able to log all the offsets. Default: 1. Attempt to use the specified percentage of CPU cycles. This is a mandatory option when using cpuio I/O engine. Split the load into cycles of the given time. In microseconds. Specify how to stress the CPU. It can take these two values: This is the default where the CPU executes noop instructions. Replace the default noop instructions loop with a qsort algorithm to consume more energy. Detect when I/O threads are done, then exit. The hostname or IP address of a HDFS cluster namenode to contact. The listening port of the HFDS cluster namenode. The TCP or UDP port to bind to or connect to. If this is used with to spawn multiple instances of the same job type, then this will be the starting port number since fio will use a range of ports. The port to use for RDMA-CM communication. This should be the same value on the client and the server side. The hostname or IP address to use for TCP, UDP or RDMA-CM based I/O. If the job is a TCP listener or UDP reader, the hostname is not used and must be omitted unless it is a valid UDP multicast address. The IP address of the network interface used to send or receive UDP multicast. The network protocol to use. Accepted values are: When the protocol is TCP, UDP or VSOCK, the port must also be given, as well as the hostname if the job is a TCP or VSOCK listener or UDP reader. For unix sockets, the normal option should be used and the port is invalid. When the protocol is VSOCK, the is the CID of the remote VM. For TCP network connections, tell fio to listen for incoming connections rather than initiating an outgoing connection. The must be omitted if this option is used. Normally a network writer will just continue writing data, and a network reader will just consume packages. If is set, a writer will send its normal payload to the reader, then wait for the reader to send the same payload back. This allows fio to measure network latencies. The submission and completion latencies then measure local time spent sending or receiving, and the completion latency measures how long it took for the other end to receive and send back. For UDP multicast traffic should only be set for a single reader when multiple readers are listening to the same address. Set the desired socket buffer size for the connection. File will be used as a block donor (swap extents between files). Allocate space immediately inside defragment event, and free right after event. Specifies the name of the Ceph cluster. Specifies the name of the RBD. Specifies the username (without the ‘client.’ prefix) used to access the Ceph cluster. If the clustername is specified, the clientname shall be the full type.id string. If no type. prefix is given, fio will add ‘client.’ by default. Specifies the configuration path of ceph cluster, so conf file does not have to be /etc/ceph/ceph.conf. Poll store instead of waiting for completion. Usually this provides better throughput at cost of higher(up to 100%) CPU utilization. During initialization, touch (create if do not exist) all objects (files). Touching all objects affects ceph caches and likely impacts test results. Enabled by default. Specifies the name of the Ceph pool containing RBD or RADOS data. Specify the label or UUID of the DAOS pool to connect to. Specify the label or UUID of the DAOS container to open. Specify a different chunk size (in bytes) for the dfs file. Use DAOS container’s chunk size by default. The size of the chunk to use for each file. Specify a different object class for the dfs file. Use DAOS container’s object class by default. libhdfs will create chunk in this HDFS directory. The RDMA verb to use on this side of the RDMA ioengine connection. Valid values are write, read, send and recv. These correspond to the equivalent RDMA verbs (e.g. write = rdma_write etc.). Note that this only needs to be specified on the client side of the connection. See the examples folder. The name to use to bind the local RDMA-CM connection to a local RDMA device. This could be a hostname or an IPv4 or IPv6 address. On the server side this will be passed into the rdma_bind_addr() function and on the client site it will be used in the rdma_resolve_add() function. This can be useful when multiple paths exist between the client and the server or in certain loopback configurations. Specify stat system call type to measure lookup/getattr performance. Default is stat for stat(2). With readfua option set to 1, read operations include the force unit access (fua) flag. Default is 0. With writefua option set to 1, write operations include the force unit access (fua) flag. Default is 0. Specifies the type of write operation. Defaults to ‘write’. Specifies the type of command to be used in the verification phase. Defaults to ‘read’. Specify the type of write commands to issue. This option can take ten values: This is the default where write opcodes are issued as usual. Issue WRITE AND VERIFY commands. The BYTCHK bit is set to 0. This directs the device to carry out a medium verification with no data comparison. The writefua option is ignored with this selection. This option is deprecated. Use write_and_verify instead. Issue WRITE SAME commands. This transfers a single block to the device and writes this same block of data to a contiguous sequence of LBAs beginning at the specified offset. fio’s block size parameter specifies the amount of data written with each command. However, the amount of data actually transferred to the device is equal to the device’s block (sector) size. For a device with 512 byte sectors, blocksize=8k will write 16 sectors with each command. fio will still generate 8k of data for each command but only the first 512 bytes will be used and transferred to the device. The writefua option is ignored with this selection. This option is deprecated. Use write_same instead. Issue WRITE SAME(16) commands as above but with the No Data Output Buffer (NDOB) bit set. No data will be transferred to the device with this bit set. Data written will be a pre-determined pattern such as all zeroes. Issue WRITE STREAM(16) commands. Use the stream_id option to specify the stream identifier. Issue VERIFY commands with BYTCHK set to 00. This directs the device to carry out a medium verification with no data comparison. Issue VERIFY commands with BYTCHK set to 01. This directs the device to compare the data on the device with the data transferred to the device. Issue VERIFY commands with BYTCHK set to 11. This transfers a single block to the device and compares the contents of this block with the data on the device beginning at the specified offset. fio’s block size parameter specifies the total amount of data compared with this command. However, only one block (sector) worth of data is transferred to the device. This is similar to the WRITE SAME command except that data is compared instead of written. Set the stream identifier for WRITE STREAM commands. If this is set to 0 (which is not a valid stream identifier) fio will open a stream and then close it when done. Default is 0. Hostname to connect to. HTTP port 80 is used automatically when the value of the https parameter is off, and HTTPS port 443 if it is on. A virtual-hosted-style S3 hostname starts with a bucket name, while a path-style S3 hostname does not. See https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html for detailed examples. Default is localhost (path-style S3 hostname) Enable HTTPS instead of http. on enables HTTPS; insecure will enable HTTPS, but disable SSL peer verification (use with caution!). Default is off Which HTTP access mode to use: webdav, swift, or s3. Default is webdav The encryption customer algorithm in SSE server side. Default is AES256 Which storage class to access. User-customizable settings. Default is STANDARD The Swift auth token. See the example configuration file on how to retrieve this. Enable verbose requests from libcurl. Useful for debugging. 1 turns on verbose logging from libcurl, 2 additionally enables HTTP IO tracing. Default is 0 Specify the NBD URI of the server to test. The string is a standard NBD URI (see https://github.com/NetworkBlockDevice/nbd/tree/master/doc). Example URIs: nbd://localhost:10809 nbd+unix:///?socket=/tmp/socket nbds://tlshost/exportname Specify the GPU IDs to use with CUDA. This is a colon-separated list of int. GPUs are assigned to workers roundrobin. Default is 0. Specify the type of I/O to use with CUDA. Default is cufile. Use libcufile and nvidia-fs. This option performs I/O directly between a GPUDirect Storage filesystem and GPU buffers, avoiding use of a bounce buffer. If is set, cudaMemcpy is used to copy verificaton data between RAM and GPU. Verification data is copied from RAM to GPU before a write and from GPU to RAM after a read. must be 1. Use POSIX to perform I/O with a RAM buffer, and use cudaMemcpy to transfer data between RAM and the GPUs. Data is copied from GPU to RAM before a write and copied from RAM to GPU after a read. does not affect use of cudaMemcpy. URL in libnfs format, eg nfs://<server|ipv4|ipv6>/path[?arg=val[&arg=val]*] Refer to the libnfs README for more details. Specify the program to execute. Specify arguments to pass to program. Some special variables can be expanded to pass fio’s job details to the program. Replaced by the duration of the job in seconds. Replaced by the name of the job. Specify the time between the SIGTERM and SIGKILL signals. Default is 1 second. If set, stdout and stderr streams are redirected to files named from the job name. Default is true. Select the xnvme async command interface. This can take these values. This is default and use to emulate asynchronous I/O by using a single thread to create a queue pair on top of a synchronous I/O interface using the NVMe driver IOCTL. Emulate an asynchronous I/O interface with a pool of userspace threads on top of a synchronous I/O interface using the NVMe driver IOCTL. By default four threads are used. Linux native asynchronous I/O interface which supports both direct and buffered I/O. Fast Linux native asynchronous I/O interface for NVMe pass through commands. This only works with NVMe character device (/dev/ngXnY). Use the posix asynchronous I/O interface to perform one or more I/O operations asynchronously. Use the user-space VFIO-based backend, implemented using libvfn instead of SPDK. Do not transfer any data; just pretend to. This is mainly used for introspective performance evaluation. Select the xnvme synchronous command interface. This can take these values. This is default and uses Linux NVMe Driver ioctl() for synchronous I/O. This supports regular as well as vectored pread() and pwrite() commands. This is the same as psync except that it also supports zone management commands using Linux block layer IOCTLs. Select the xnvme admin command interface. This can take these values. This is default and uses linux NVMe Driver ioctl() for admin commands. Use Linux Block Layer ioctl() and sysfs for admin commands. Sets the subsystem NQN for fabrics. This is for xNVMe to utilize a fabrics target with multiple systems. Select the xnvme memory backend. This can take these values. This is the default posix memory backend for linux NVMe driver. Use hugepages, instead of existing posix memory backend. The memory backend uses hugetlbfs. This require users to allocate hugepages, mount hugetlbfs and set an environment variable for XNVME_HUGETLB_PATH. Uses libvfn’s memory allocator. This also specifies the use of libvfn backend instead of SPDK. If this option is set. xnvme will use vectored read/write commands. The libblkio driver to use. Different drivers access devices through different underlying interfaces. Available drivers depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#drivers Sets the value of the driver-specific “path” property before connecting the libblkio instance, which identifies the target device or file on which to perform I/O. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers A colon-separated list of additional libblkio properties to be set after creating but before connecting the libblkio instance. Each property must have the format . Colons can be escaped as . These are set after the engine sets any other properties, so those can be overridden. Available properties depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#properties Sets the value of the driver-specific “num-entries” property before starting the libblkio instance. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers Sets the value of the driver-specific “queue-size” property before starting the libblkio instance. Its exact semantics are driver-dependent and not all drivers may support it; see https://libblkio.gitlab.io/libblkio/blkio.html#drivers A colon-separated list of additional libblkio properties to be set after connecting but before starting the libblkio instance. Each property must have the format . Colons can be escaped as . These are set after the engine sets any other properties, so those can be overridden. Available properties depend on the libblkio version in use and are listed at https://libblkio.gitlab.io/libblkio/blkio.html#properties Submit trims as “write zeroes” requests instead of discard requests. How to wait for completions: Use a blocking call to on the completion eventfd. Use a busy loop with a non-blocking call to . Enable the queue’s completion eventfd even when unused. This may impact performance. The default is to enable it only if . Number of I/O units to keep in flight against the file. Note that increasing iodepth beyond 1 will not affect synchronous ioengines (except for small degrees when is in use). Even async engines may impose OS restrictions causing the desired depth not to be achieved. This may happen on Linux when using libaio and not setting =1, since buffered I/O is not async on that OS. Keep an eye on the I/O depth distribution in the fio output to verify that the achieved depth is as expected. Default: 1. This defines how many pieces of I/O to submit at once. It defaults to 1 which means that we submit each I/O as soon as it is available, but can be raised to submit bigger batches of I/O at the time. If it is set to 0 the value will be used. This defines how many pieces of I/O to retrieve at once. It defaults to 1 which means that we’ll ask for a minimum of 1 I/O in the retrieval process from the kernel. The I/O retrieval will go on until we hit the limit set by . If this variable is set to 0, then fio will always check for completed events before queuing more I/O. This helps reduce I/O latency, at the cost of more retrieval system calls. This defines maximum pieces of I/O to retrieve at once. This variable should be used along with =int variable, specifying the range of min and max amount of I/O which should be retrieved. By default it is equal to the value. which means that we will retrieve at least 1 I/O and up to the whole submitted queue depth. If none of I/O has been completed yet, we will wait. which means that we can retrieve up to the whole submitted queue depth, but if none of I/O has been completed yet, we will NOT wait and immediately exit the system call. In this example we simply do polling. The low water mark indicating when to start filling the queue again. Defaults to the same as , meaning that fio will attempt to keep the queue full at all times. If is set to e.g. 16 and iodepth_low is set to 4, then after fio has filled the queue of 16 requests, it will let the depth drain down to 4 before starting to fill it again. Serialize in-flight I/Os that might otherwise cause or suffer from data races. When two or more I/Os are submitted simultaneously, there is no guarantee that the I/Os will be processed or completed in the submitted order. Further, if two or more of those I/Os are writes, any overlapping region between them can become indeterminate/undefined on certain storage. These issues can cause verification to fail erratically when at least one of the racing I/Os is changing data and the overlapping region has a non-zero size. Setting tells fio to avoid provoking this behavior by explicitly serializing in-flight I/Os that have a non-zero overlap. Note that setting this option can reduce both performance and the achieved. This option only applies to I/Os issued for a single job except when it is enabled along with =offload. In offload mode, fio will check for overlap among all I/Os submitted by offload jobs with enabled. This option controls how fio submits the I/O to the I/O engine. The default is , which means that the fio job threads submit and reap I/O directly. If set to , the job threads will offload I/O submission to a dedicated pool of I/O threads. This requires some coordination and thus has a bit of extra overhead, especially for lower queue depth I/O where it can increase latencies. The benefit is that fio can manage submission rates independently of the device completion rates. This avoids skewed latency reporting if I/O gets backed up on the device side (the coordinated omission problem). Note that this option cannot reliably be used with async IO engines. Stall the job for the specified number of cycles after an I/O has completed before issuing the next. May be used to simulate processing being done by an application. This is not taken into account for the time to be waited on for . Might not have any effect on some platforms, this can be checked by trying a setting a high enough amount of thinkcycles. Stall the job for the specified period of time after an I/O has completed before issuing the next. May be used to simulate processing being done by an application. When the unit is omitted, the value is interpreted in microseconds. See , and . Only valid if is set - pretend to spend CPU time doing something with the data received, before falling back to sleeping for the rest of the period specified by . When the unit is omitted, the value is interpreted in microseconds. Only valid if is set - control how many blocks to issue, before waiting usecs. If not set, defaults to 1 which will make fio wait usecs after every block. This effectively makes any queue depth setting redundant, since no more than 1 I/O will be queued before we have to complete it and do our . In other words, this setting effectively caps the queue depth if the latter is larger. Only valid if is set - control how triggers. The default is , which triggers thinktime when fio completes blocks. If this is set to , then the trigger happens at the issue side. Only valid if is set - control interval by time. The stall is repeated after IOs are executed for . For example, repeat 10-second cycle with IOs for 9 seconds and stall for 1 second. When the unit is omitted, is interpreted as a number of seconds. If this option is used together with , the stall is repeated after or after IOs, whichever happens first. Cap the bandwidth used by this job. The number is in bytes/sec, the normal suffix rules apply. Comma-separated values may be specified for reads, writes, and trims as described in . For example, using would limit reads to 1MiB/sec and writes to 500KiB/sec. Capping only reads or writes can be done with or where the former will only limit writes (to 500KiB/sec) and the latter will only limit reads. Tell fio to do whatever it can to maintain at least this bandwidth. Failing to meet this requirement will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in . Cap the bandwidth to this number of IOPS. Basically the same as , just specified independently of bandwidth. If the job is given a block size range instead of a fixed value, the smallest block size is used as the metric. Comma-separated values may be specified for reads, writes, and trims as described in . If fio doesn’t meet this rate of I/O, it will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in . This option controls how fio manages rated I/O submissions. The default is , which submits I/O in a linear fashion with fixed delays between I/Os that gets adjusted based on I/O completion rates. If this is set to , fio will submit I/O based on a more real world random request flow, known as the Poisson process (https://en.wikipedia.org/wiki/Poisson_point_process). The lambda will be 10^6 / IOPS for the given workload. By default, fio will attempt to catch up to the specified rate setting, if any kind of thinktime setting was used. If this option is set, then fio will ignore the thinktime and continue doing IO at the specified rate, instead of entering a catch-up mode after thinktime is done. Average bandwidth for and over this number of milliseconds. Defaults to 1000. If set, fio will attempt to find the max performance point that the given workload will run at while maintaining a latency below this target. When the unit is omitted, the value is interpreted in microseconds. See and . Used with to specify the sample window that the job is run at varying queue depths to test the performance. When the unit is omitted, the value is interpreted in microseconds. The percentage of I/Os that must fall within the criteria specified by and . If not set, this defaults to 100.0, meaning that all I/Os must be equal or below to the value set by . Used with . If false (default), fio will find the highest queue depth that meets and exit. If true, fio will continue running and try to meet by adjusting queue depth. If set, fio will exit the job with an ETIMEDOUT error if it exceeds this maximum latency. When the unit is omitted, the value is interpreted in microseconds. Comma-separated values may be specified for reads, writes, and trims as described in . Write the issued I/O patterns to the specified file. See . Specify a separate file for each job, otherwise the iologs will be interspersed and the file may be corrupt. This file will be opened in append mode. Open an iolog with the specified filename and replay the I/O patterns it contains. This can be used to store a workload and replay it sometime later. The iolog given may also be a blktrace binary file, which allows fio to replay a workload captured by blktrace. See blktrace(8) for how to capture such logging data. For blktrace replay, the file needs to be turned into a blkparse binary data file first ( ). You can specify a number of files by separating the names with a ‘:’ character. See the option for information on how to escape ‘:’ characters within the file names. These files will be sequentially assigned to job clones created by . ‘-’ is a reserved name, meaning read from stdin, notably if is set to ‘-’ which means stdin as well, then this flag can’t be set to ‘-‘. Determines how iolog is read. If false(default) entire will be read at once. If selected true, input from iolog will be read gradually. Useful when iolog is very large, or it is generated. When specified, rather than replaying the logs passed to , the logs go through a merge phase which aggregates them into a single blktrace. The resulting file is then passed on as the parameter. The intention here is to make the order of events consistent. This limits the influence of the scheduler compared to replaying multiple blktraces via concurrent jobs. This is a percentage based option that is index paired with the list of files passed to . When merging is performed, scale the time of each event by the corresponding amount. For example, runs the first trace in halftime and the second trace in realtime. This knob is separately tunable from which scales the trace during runtime and does not change the output of the merge unlike this option. This is a whole number option that is index paired with the list of files passed to . When merging is performed, run each trace for the specified number of iterations. For example, runs the first trace for two iterations and the second trace for one iteration. When replaying I/O with the default behavior is to attempt to respect the timestamps within the log and replay them with the appropriate delay between IOPS. By setting this variable fio will not respect the timestamps and attempt to replay them as fast as possible while still respecting ordering. The result is the same I/O pattern to a given device, but different timings. When replaying I/O with , fio will honor the original timing in the trace. With this option, it’s possible to scale the time. It’s a percentage option, if set to 50 it means run at 50% the original IO rate in the trace. If set to 200, run at twice the original IO rate. Defaults to 100. While replaying I/O patterns using the default behavior is to replay the IOPS onto the major/minor device that each IOP was recorded from. This is sometimes undesirable because on a different machine those major/minor numbers can map to a different device. Changing hardware on the same system can also result in a different major/minor mapping. causes all I/Os to be replayed onto the single specified device regardless of the device it was recorded from. i.e. = would cause all I/O in the blktrace or iolog to be replayed onto . This means multiple devices will be replayed onto a single device, if the trace contains multiple devices. If you want multiple devices to be replayed concurrently to multiple redirected devices you must blkparse your trace into separate traces and replay them with independent fio invocations. Unfortunately this also breaks the strict time ordering between multiple device accesses. Force alignment of the byte offsets in a trace to this value. The value must be a power of 2. Scale byte offsets down by this factor when replaying traces. Should most likely use as well. Sometimes it’s useful to skip certain IO types in a replay trace. This could be, for instance, eliminating the writes in the trace. Or not replaying the trims/discards, if you are redirecting to a device that doesn’t support them. This option takes a comma separated list of read, write, trim, sync. Fio defaults to creating jobs by using fork, however if this option is given, fio will create jobs by using POSIX Threads’ function pthread_create(3) to create threads instead. If set, the current job won’t be started until all workers of the specified waitee job are done. operates on the job name basis, so there are a few limitations. First, the waitee must be defined prior to the waiter job (meaning no forward references). Second, if a job is being referenced as a waitee, it must have a unique name (no duplicate waitees). Run the job with the given nice value. See man nice(2). On Windows, values less than -15 set the process class to “High”; -1 through -15 set “Above Normal”; 1 through 15 “Below Normal”; and above 15 “Idle” priority class. Set the I/O priority value of this job. Linux limits us to a positive value between 0 and 7, with 0 being the highest. See man ionice(1). Refer to an appropriate manpage for other operating systems since meaning of priority may differ. For per-command priority setting, see I/O engine specific and options. Set the I/O priority class. See man ionice(1). For per-command priority setting, see I/O engine specific and options. Set the I/O priority hint. This is only applicable to platforms that support I/O priority classes and to devices with features controlled through priority hints, e.g. block devices supporting command duration limits, or CDL. CDL is a way to indicate the desired maximum latency of I/Os so that the device can optimize its internal command scheduling according to the latency limits indicated by the user. For per-I/O priority hint setting, see the I/O engine specific option. Controls the same options as , but accepts a textual specification of the permitted CPUs instead and CPUs are indexed from 0. So to use CPUs 0 and 5 you would specify . This option also allows a range of CPUs to be specified – say you wanted a binding to CPUs 0, 5, and 8 to 15, you would set . On Windows, when is unset only CPUs from fio’s current processor group will be used and affinity settings are inherited from the system. An fio build configured to target Windows 7 makes options that set CPUs processor group aware and values will set both the processor group and a CPU from within that group. For example, on a system where processor group 0 has 40 CPUs and processor group 1 has 32 CPUs, values between 0 and 39 will bind CPUs from processor group 0 and values between 40 and 71 will bind CPUs from processor group 1. When using all CPUs specified by a single option must be from the same processor group. For Windows fio builds not built for Windows 7, CPUs will only be selected from (and be relative to) whatever processor group fio happens to be running in and CPUs from other processor groups cannot be used. Set the policy of how fio distributes the CPUs specified by or . Two policies are supported: All jobs will share the CPU set specified. Each job will get a unique CPU from the CPU set. shared is the default behavior, if the option isn’t specified. If split is specified, then fio will assign one cpu per job. If not enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs in the set. Set the CPU affinity of this job. The parameter given is a bit mask of allowed CPUs the job may run on. So if you want the allowed CPUs to be 1 and 5, you would pass the decimal value of (1 << 1 | 1 << 5), or 34. See man sched_setaffinity(2). This may not work on all supported operating systems or kernel versions. This option doesn’t work well for a higher CPU count than what you can store in an integer mask, so it can only control cpus 1-32. For boxes with larger CPU counts, use . Set this job running on specified NUMA nodes’ CPUs. The arguments allow comma delimited list of cpu numbers, A-B ranges, or . Note, to enable NUMA options support, fio must be built on a system with libnuma-dev(el) installed. Set this job’s memory policy and corresponding NUMA nodes. Format of the arguments: is one of the following memory policies: , , , or . For and memory policies, no node needs to be specified. For , only one node is allowed. For and the may be as follows: a comma delimited list of numbers, A-B ranges, or . Add job to this control group. If it doesn’t exist, it will be created. The system must have a mounted cgroup blkio mount point for this to work. If your system doesn’t have it mounted, you can do so with: Set the weight of the cgroup to this value. See the documentation that comes with the kernel, allowed values are in the range of 100..1000. Normally fio will delete the cgroups it has created after the job completion. To override this behavior and to leave cgroups around after the job completion, set . This can be useful if one wants to inspect various cgroup files after job completion. Default: false. The ID of the flow. If not specified, it defaults to being a global flow. See . Weight in token-based flow control. If this value is used, then fio regulates the activity between two or more jobs sharing the same flow_id. Fio attempts to keep each job activity proportional to other jobs’ activities in the same flow_id group, with respect to requested weight per job. That is, if one job has flow=3’, another job has `flow=2’ and another with `flow=1 , then there will be a roughly 3:2:1 ratio in how much one runs vs the others. The period of time, in microseconds, to wait after the flow counter has exceeded its proportion before retrying operations. Wait for preceding jobs in the job file to exit, before starting this one. Can be used to insert serialization points in the job file. A stone wall also implies starting a new reporting group, see . By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting will instead make fio terminate all jobs in the same group, as soon as one job of that group finishes. By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting will instead make fio terminate all jobs in the same group. The option allows one to control which jobs get terminated when is enabled. The default is and does not change the behaviour of . The setting terminates all jobs. The setting terminates all currently running jobs across all groups and continues execution with the next stonewalled group. Before running this job, issue the command specified through system(3). Output is redirected in a file called . After the job completes, issue the command specified though system(3). Output is redirected in a file called . Instead of running as the invoking user, set the user ID to this value before the thread/process does any work. Do not perform specified workload, only verify data still matches previous invocation of this workload. This option allows one to check data multiple times at a later date without overwriting it. This option makes sense only for workloads that write data, and does not support workloads with the option set. Run the verify phase after a write phase. Only valid if is set. Default: true. If writing to a file, fio can verify the file contents after each iteration of the job. Each verification method also implies verification of special header, which is written to the beginning of each block. This header also includes meta information, like offset of the block, block number, timestamp when block was written, etc. can be combined with option. The allowed values are: Use an md5 sum of the data area and store it in the header of each block. Use an experimental crc64 sum of the data area and store it in the header of each block. Use a crc32c sum of the data area and store it in the header of each block. This will automatically use hardware acceleration (e.g. SSE4.2 on an x86 or CRC crypto extensions on ARM64) but will fall back to software crc32c if none is found. Generally the fastest checksum fio supports when hardware accelerated. Use a crc32 sum of the data area and store it in the header of each block. Use a crc16 sum of the data area and store it in the header of each block. Use a crc7 sum of the data area and store it in the header of each block. Use xxhash as the checksum function. Generally the fastest software checksum that fio supports. Use sha512 as the checksum function. Use sha256 as the checksum function. Use optimized sha1 as the checksum function. Use optimized sha3-224 as the checksum function. Use optimized sha3-256 as the checksum function. Use optimized sha3-384 as the checksum function. Use optimized sha3-512 as the checksum function. This option is deprecated, since now meta information is included in generic verification header and meta verification happens by default. For detailed information see the description of the setting. This option is kept because of compatibility’s sake with old configurations. Do not use it. Verify a strict pattern. Normally fio includes a header with some basic information and checksumming, but if this option is set, only the specific pattern set with is verified. Only pretend to verify. Useful for testing internals with =null, not for much else. This option can be used for repeated burn-in tests of a system to make sure that the written data is also correctly read back. If the data direction given is a read or random read, fio will assume that it should verify a previously written file. If the data direction includes any form of write, the verify will be of the newly written data. To avoid false verification errors, do not use the norandommap option when verifying data with async I/O engines and I/O depths > 1. Or use the norandommap and the lfsr random generator together to avoid writing to the same offset with multiple outstanding I/Os. Swap the verification header with data somewhere else in the block before writing. It is swapped back before verifying. Write the verification header at a finer granularity than the . It will be written for chunks the size of . should divide this evenly. If set, fio will fill the I/O buffers with this pattern. Fio defaults to filling with totally random bytes, but sometimes it’s interesting to fill with a known pattern for I/O verification purposes. Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time (it can be either a decimal or a hex number). The if larger than a 32-bit quantity has to be a hex number that starts with either “0x” or “0X”. Use with . Also, supports %o format, which means that for each block offset will be written and then verified back, e.g.: Or use combination of everything: Normally fio will keep checking the entire contents before quitting on a block verification failure. If this option is set, fio will exit the job on the first observed failure. Default: false. If set, dump the contents of both the original data block and the data block we read off disk to files. This allows later analysis to inspect just what kind of data corruption occurred. Off by default. Fio will normally verify I/O inline from the submitting thread. This option takes an integer describing how many async offload threads to create for I/O verification instead, causing fio to offload the duty of verifying I/O contents to one or more separate threads. If using this offload option, even sync I/O engines can benefit from using an setting higher than 1, as it allows them to have I/O in flight while verifies are running. Defaults to 0 async threads, i.e. verification is not asynchronous. Tell fio to set the given CPU affinity on the async I/O verification threads. See for the format used. Fio will normally verify the written contents of a job that utilizes verify once that job has completed. In other words, everything is written then everything is read back and verified. You may want to verify continually instead for a variety of reasons. Fio stores the meta data associated with an I/O block in memory, so for large verify workloads, quite a bit of memory would be used up holding this meta data. If this option is enabled, fio will write only N blocks before verifying these blocks. Control how many blocks fio will verify if is set. If not set, will default to the value of (meaning the entire queue is read back and verified). If is less than then not all blocks will be verified, if is larger than , some blocks will be verified more than once. When a job exits during the write phase of a verify workload, save its current state. This allows fio to replay up until that point, if the verify state is loaded for the verify read phase. The format of the filename is, roughly: <type> is “local” for a local run, “sock” for a client/server socket connection, and “ip” (192.168.0.1, for instance) for a networked client/server connection. Defaults to true. If a verify termination trigger was used, fio stores the current write state of each thread. This can be used at verification time so that fio knows how far it should verify. Without this information, fio will run a full verification pass, according to the settings in the job file used. Default false. Enable experimental verification. Standard verify records I/O metadata for later use during the verification phase. Experimental verify instead resets the file after the write phase and then replays I/Os for the verification phase. Verify the header write sequence number. In a scenario with multiple jobs, verification of the write sequence number may fail. Disabling this option will mean that write sequence number checking is skipped. Doing that can be useful for testing atomic writes, as it means that checksum verification can still be attempted. For when is enabled, checksum verification is expected to succeed (while write sequence checking can still fail). Defaults to true. Verify that trim/discarded blocks are returned as zeros. Trim after this number of blocks are written. Define the criterion and limit for assessing steady state performance. The first parameter designates the criterion whereas the second parameter sets the threshold. When the criterion falls below the threshold for the specified duration, the job will stop. For example, will direct fio to terminate the job when the least squares regression slope falls below 0.1% of the mean IOPS. If is enabled this will apply to all jobs in the group. Below is the list of available steady state assessment criteria. All assessments are carried out using only data from the rolling collection window. Threshold limits can be expressed as a fixed value or as a percentage of the mean in the collection window. When using this feature, most jobs should include the and options or the option so that fio does not stop running after it has covered the full size of the specified file(s) or device(s). Collect IOPS data. Stop the job if all individual IOPS measurements are within the specified limit of the mean IOPS (e.g., means that all individual IOPS values must be within 2 of the mean, whereas means that all individual IOPS values must be within 0.2% of the mean IOPS to terminate the job). Collect IOPS data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit. Collect bandwidth data. Stop the job if all individual bandwidth measurements are within the specified limit of the mean bandwidth. Collect bandwidth data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit. A rolling window of this duration will be used to judge whether steady state has been reached. Data will be collected every . The default is 0 which disables steady state detection. When the unit is omitted, the value is interpreted in seconds. Allow the job to run for the specified duration before beginning data collection for checking the steady state job termination criterion. The default is 0. When the unit is omitted, the value is interpreted in seconds. The values during the rolling window will be collected with a period of this value. If is 30s and is 300s, 10 measurements will be taken. Default is 1s but that might not converge, especially for slower devices, so set this accordingly. When the unit is omitted, the value is interpreted in seconds. If set to true, fio generates bw/clat/iops logs with per job unique filenames. If set to false, jobs with identical names will share a log filename. Note that when this option is set to false log files will be opened in append mode and if log files already exist the previous contents will not be overwritten. Default: true. It may sometimes be interesting to display statistics for groups of jobs as a whole instead of for each individual job. This is especially true if is used; looking at individual thread/process output quickly becomes unwieldy. To see the final report per-group instead of per-job, use . Jobs in a file will be part of the same reporting group, unless if separated by a , or by using . NOTE: When is used along with output, there are certain per-job properties which can be different between jobs but do not have a natural group-level equivalent. Examples include , , , , , and . For these properties, the values for the first job are recorded for the group. Also, options like and should be consistent among the jobs in a reporting group. Having options like these vary across the jobs in a reporting group is an unsupported configuration. Start a new reporting group. See: . If not given, all jobs in a file will be part of the same reporting group, unless separated by a . By default, fio collects and shows final output results for all jobs that run. If this option is set to 0, then fio will ignore it in the final stat output. If given, write a bandwidth log for this job. Can be used to store data of the bandwidth of the jobs in their lifetime. If no str argument is given, the default filename of is used. Even when the argument is given, fio will still append the type of log. So if one specifies: The actual log name will be where is the index of the job ( , where is the number of jobs). If is false, then the filename will not include the job index. The included fio_generate_plots script uses gnuplot to turn these text files into nice graphs. See Log File Formats for how data is structured within the file. Same as , except this option creates I/O submission (e.g., ), completion (e.g., ), and total (e.g., ) latency files instead. See for details about the filename format and Log File Formats for how data is structured within the files. Same as but writes an I/O completion latency histogram file (e.g., ) instead. Note that this file will be empty unless has also been set. See for details about the filename format and Log File Formats for how data is structured within the file. Same as , but writes an IOPS file (e.g. ) instead. Because fio defaults to individual I/O logging, the value entry in the IOPS log will be 1 unless windowed logging (see ) has been enabled. See for details about the filename format and Log File Formats for how data is structured within the file. By default, fio will log an entry in the iops, latency, or bw log for every I/O that completes. The initial number of I/O log entries is 1024. When the log entries are all used, new log entries are dynamically allocated. This dynamic log entry allocation may negatively impact time-related statistics such as I/O tail latencies (e.g. 99.9th percentile completion latency). This option allows specifying a larger initial number of log entries to avoid run-time allocations of new log entries, resulting in more precise time-related I/O statistics. Also see . Defaults to 1024. By default, fio will log an entry in the iops, latency, or bw log for every I/O that completes. When writing to the disk log, that can quickly grow to a very large size. Setting this option directs fio to instead record an average over the specified duration for each log entry, reducing the resolution of the log. When the job completes, fio will flush any accumulated latency log data, so the final log interval may not match the value specified by this option and there may even be duplicate timestamps. See as well. Defaults to 0, logging entries for each I/O. Also see Log File Formats. Same as , but logs entries for completion latency histograms. Computing latency percentiles from averages of intervals using is inaccurate. Setting this option makes fio log histogram entries over the specified period of time, reducing log sizes for high IOPS devices while retaining percentile accuracy. See and as well. Defaults to 0, meaning histogram logging is disabled. Integer ranging from 0 to 6, defining the coarseness of the resolution of the histogram logs enabled with . For each increment in coarseness, fio outputs half as many bins. Defaults to 0, for which histogram logs contain 1216 latency bins. See and Log File Formats. If is set, fio by default logs the average over that window. This option determines whether fio logs the average, maximum or both the values over the window. This only affects the latency logging, as both average and maximum values for iops or bw log will be same. Accepted values are: Log average value over the window. The default. Log maximum value in the window. Log both average and maximum value over the window. If this is set, the iolog options will include the byte offset for the I/O entry as well as the other data values. Defaults to 0 meaning that offsets are not present in logs. Also see Log File Formats. If this is set, the Command priority field in Log File Formats shows the priority value and the IO priority class of the command. Otherwise, the field shows if the command has the highest RT priority class or not. Also see Log File Formats. If this is set, the iolog options will include the command issue time for the I/O entry as well as the other data values. Defaults to 0 meaning that command issue times are not present in logs. Also see Log File Formats. This option shall be set together with and . If this is set, fio will compress the I/O logs as it goes, to keep the memory footprint lower. When a log reaches the specified size, that chunk is removed and compressed in the background. Given that I/O logs are fairly highly compressible, this yields a nice memory savings for longer runs. The downside is that the compression will consume some background CPU cycles, so it may impact the run. This, however, is also true if the logging ends up consuming most of the system memory. So pick your poison. The I/O logs are saved normally at the end of a run, by decompressing the chunks and storing them in the specified log file. This feature depends on the availability of zlib. Define the set of CPUs that are allowed to handle online log compression for the I/O jobs. This can provide better isolation between performance sensitive jobs, and background compression work. See for the format used. If set, fio will store the log files in a compressed format. They can be decompressed with fio, using the command line parameter. The files will be stored with a suffix. If set, fio will log timestamps based on the epoch used by the clock specified in the log_alternate_epoch_clock_id option, to the log files produced by enabling write_type_log for each log type, instead of the default zero-based timestamps. Specifies the clock_id to be used by clock_gettime to obtain the alternate epoch if log_alternate_epoch is true. Otherwise has no effect. Default value is 0, or CLOCK_REALTIME. If set, record errors in trim block-sized units from writes and trims and output a histogram of how many trims it took to get to errors, and what kind of error was encountered. Average the calculated bandwidth over the given time. Value is specified in milliseconds. If the job also does bandwidth logging through , then the minimum of this option and will be used. Default: 500ms. Average the calculated IOPS over the given time. Value is specified in milliseconds. If the job also does IOPS logging through , then the minimum of this option and will be used. Default: 500ms. Generate disk utilization statistics, if the platform supports it. Default: true. Disable measurements of total latency numbers. Useful only for cutting back the number of calls to gettimeofday(2), as that does impact performance at really high IOPS rates. Note that to really get rid of a large amount of these calls, this option must be used with and as well. Report submission latency percentiles. Submission latency is not recorded for synchronous ioengines. Report total latency percentiles. Total latency is the sum of submission latency and completion latency. Overwrite the default list of percentiles for latencies and the block error histogram. Each number is a floating point number in the range (0,100], and the maximum length of the list is 20. Use to separate the numbers. For example, will cause fio to report the latency durations below which 99.5% and 99.9% of the observed latencies fell, respectively. If using of , set the significant figures to this value. Higher values will yield more precise IOPS and throughput units, while lower values will round. Requires a minimum value of 1 and a maximum value of 10. Defaults to 4. When one job finishes in error, terminate the rest. The default is to wait for each job to finish. Normally fio will exit the job on the first observed failure. If this option is set, fio will continue the job when there is a ‘non-fatal error’ (EIO or EILSEQ) until the runtime is exceeded or the I/O size specified is completed. If this option is used, there are two more stats that are appended, the total error count and the first error. The error field given in the stats is the first error that was hit during the run. Note: a write error from the device may go unnoticed by fio when using buffered IO, as the write() (or similar) system call merely dirties the kernel pages, unless or is used. Device IO errors occur when the dirty data is actually written out to disk. If fully sync writes aren’t desirable, or can be used as well. This is specific to writes, as reads are always synchronous. Exit on any I/O or verify errors. Continue on read errors, exit on all others. Continue on write errors, exit on all others. Continue on any I/O error, exit on all others. Continue on verify errors, exit on all others. Sometimes you want to ignore some errors during test in that case you can specify error list for each error type, instead of only being able to ignore the default ‘non-fatal error’ using . errors for given error type is separated with ‘:’. Error may be symbol (‘ENOSPC’, ‘ENOMEM’) or integer. Example: This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from WRITE. This option works by overriding with the list of errors for each error type if any. If set dump every error even if it is non fatal, true by default. If disabled only fatal error will be dumped.\n\nFio spits out a lot of output. While running, fio will display the status of the jobs created. An example of that would be: The characters inside the first set of square brackets denote the current status of each thread. The first character is the first job defined in the job file, and so forth. The possible values (in typical life cycle order) are: Thread exited, not reaped by main thread yet. Fio will condense the thread string as not to take up more space on the command line than needed. For instance, if you have 10 readers and 10 writers running, the output would look like this: Note that the status string is displayed in order, so it’s possible to tell which of the jobs are currently doing what. In the example above this means that jobs 1–10 are readers and 11–20 are writers. The other values are fairly self explanatory – number of threads currently running and doing I/O, the number of currently open files (f=), the estimated completion percentage, the rate of I/O since last check (read speed listed first, then write speed and optionally trim speed) in terms of bandwidth and IOPS, and time to completion for the current running group. It’s impossible to estimate runtime of the following groups (if any). When fio is done (or interrupted by ), it will show the data for each thread, group of threads, and disks in that order. For each overall thread (or group) the output looks like: The job name (or first job’s name when using ) is printed, along with the group id, count of jobs being aggregated, last error id seen (which is 0 when there are no errors), pid/tid of that thread and the time the job/group completed. Below are the I/O statistics for each data direction performed (showing writes in the example above). In the order listed, they denote: The string before the colon shows the I/O direction the statistics are for. IOPS is the average I/Os performed per second. BW is the average bandwidth rate shown as: value in power of 2 format (value in power of 10 format). The last two values show: (total I/O performed in power of 2 format / runtime of that thread). Submission latency (min being the minimum, max being the maximum, avg being the average, stdev being the standard deviation). This is the time from when fio initialized the I/O to submission. For synchronous ioengines this includes the time up until just before the ioengine’s queue function is called. For asynchronous ioengines this includes the time up through the completion of the ioengine’s queue function (and commit function if it is defined). For sync I/O this row is not displayed as the slat is negligible. This value can be in nanoseconds, microseconds or milliseconds — fio will choose the most appropriate base and print that (in the example above nanoseconds was the best scale). Note: in mode latencies are always expressed in microseconds. Completion latency. Same names as slat, this denotes the time from submission to completion of the I/O pieces. For sync I/O, this represents the time from when the I/O was submitted to the operating system to when it was completed. For asynchronous ioengines this is the time from when the ioengine’s queue (and commit if available) functions were completed to when the I/O’s completion was reaped by fio. For file and directory operation engines, clat denotes the time to complete one file or directory operation. filestat engine: the time cost to look up an existing file dircreate engine: the time cost to create a new directory dirstat engine: the time cost to look up an existing directory Total latency. Same names as slat and clat, this denotes the time from when fio created the I/O unit to completion of the I/O operation. It is the sum of submission and completion latency. Bandwidth statistics based on measurements from discrete intervals. Fio continuously monitors bytes transferred and I/O operations completed. By default fio calculates bandwidth in each half-second interval (see ) and reports descriptive statistics for the measurements here. Same names as the xlat stats, but also includes the number of samples taken (samples) and an approximate percentage of total aggregate bandwidth this thread received in its group (per). This last value is only really useful if the threads in this group are on the same disk, since they are then competing for disk access. For file and directory operation engines, bw is meaningless. IOPS statistics based on measurements from discrete intervals. For details see the description for bw above. See to control the duration of the intervals. Same values reported here as for bw except for percentage. For file and directory operation engines, iops is the most fundamental index to denote the performance. It means how many files or directories can be operated per second. filecreate engine:number of files can be created per second filestat engine: number of files can be looked up per second filedelete engine:number of files can be deleted per second dircreate engine: number of directories can be created per second dirstat engine: number of directories can be looked up per second dirdelete engine: number of directories can be deleted per second The distribution of I/O completion latencies. This is the time from when I/O leaves fio and when it gets completed. Unlike the separate read/write/trim sections above, the data here and in the remaining sections apply to all I/Os for the reporting group. 250=0.04% means that 0.04% of the I/Os completed in under 250us. 500=64.11% means that 64.11% of the I/Os required 250 to 499us for completion. CPU usage. User and system time, along with the number of context switches this thread went through, usage of system and user time, and finally the number of major and minor page faults. The CPU utilization numbers are averages for the jobs in that reporting group, while the context and fault counters are summed. The distribution of I/O depths over the job lifetime. The numbers are divided into powers of 2 and each entry covers depths from that value up to those that are lower than the next entry – e.g., 16= covers depths from 16 to 31. Note that the range covered by a depth distribution entry can be different to the range covered by the equivalent submit/complete distribution entry. How many pieces of I/O were submitting in a single submit call. Each entry denotes that amount and below, until the previous entry – e.g., 16=100% means that we submitted anywhere between 9 to 16 I/Os per submit call. Note that the range covered by a submit distribution entry can be different to the range covered by the equivalent depth distribution entry. Like the above submit number, but for completions instead. The number of read/write/trim requests issued, and how many of them were short or dropped. These values are for and related options. When these options are engaged, this section describes the I/O depth required to meet the specified latency target. After each client has been listed, the group statistics are printed. They will look like this: For each data direction it prints: Aggregate bandwidth of threads in this group followed by the minimum and maximum bandwidth of all the threads in this group. Values outside of brackets are power-of-2 format and those within are the equivalent value in a power-of-10 format. Aggregate I/O performed of all threads in this group. The format is the same as bw. The smallest and longest runtimes of the threads in this group. And finally, the disk statistics are printed. This is Linux specific. They will look like this: Each value is printed for both reads and writes, with reads first. The numbers denote: Number of I/Os performed by all groups. Amount of data transferred in units of 512 bytes for all groups. Number of merges performed by the I/O scheduler. Number of ticks we kept the disk busy. The disk utilization. A value of 100% means we kept the disk busy constantly, 50% would be a disk idling half of the time. It is also possible to get fio to dump the current output while it is running, without terminating the job. To do that, send fio the USR1 signal. You can also get regularly timed dumps by using the parameter, or by creating a file in named . If fio sees this file, it will unlink it and dump the current output status."
    },
    {
        "link": "https://microsoft.github.io/VirtualClient/docs/workloads/fio",
        "document": "FIO, or flexible I/O, is a third party tool that simulates a given I/O workload. It allows us to quickly define and run workloads, and reports a variety of metrics about each run. This allows us to compare results under different conditions, such as different hardware and firmware configurations, with workloads that reflect production workloads.\n\nThe workload enables the ability to test various I/O scenarios that represent real-life usage patterns on computer systems. For example, it enables testing sequential read and write operations as well as random read and write operations. It also enables the ability to test single-threaded vs. multi-threaded I/O operations as well as the ability to control I/O queue depths and whether hardware caches should be used.\n\nThe FIO workload measures disk I/O performance focusing on throughput, bandwidth, latencies and data integrity/reliability.\n\nThe following metrics are examples of those captured by the Virtual Client when running the FIO workload. This set of metrics will be captured for each one of the distinct scenarios that are part of the profile (e.g. Random Write 4k block size, Random Read 4k block size). It is a lot of data!!\n• How fast are your disks?"
    },
    {
        "link": "https://buildmedia.readthedocs.org/media/pdf/fio/latest/fio.pdf",
        "document": ""
    },
    {
        "link": "https://github.com/axboe/fio",
        "document": "Fio was originally written to save me the hassle of writing special test case programs when I wanted to test a specific workload, either for performance reasons or to find/reproduce a bug. The process of writing such a test app can be tiresome, especially if you have to do it often. Hence I needed a tool that would be able to simulate a given I/O workload without resorting to writing a tailored test case again and again.\n\nA test work load is difficult to define, though. There can be any number of processes or threads involved, and they can each be using their own way of generating I/O. You could have someone dirtying large amounts of memory in a memory mapped file, or maybe several threads issuing reads using asynchronous I/O. fio needed to be flexible enough to simulate both of these cases, and many more.\n\nFio spawns a number of threads or processes doing a particular type of I/O action as specified by the user. fio takes a number of global parameters, each inherited by the thread unless otherwise parameters given to them overriding that setting is given. The typical use of fio is to write a job file matching the I/O load one wants to simulate.\n\nFio resides in a git repo, the canonical place is:\n\nSnapshots are frequently generated and :file:`fio-git-*.tar.gz` include the git meta data as well. Other tarballs are archives of official fio releases. Snapshots can download from:\n\nThere are also two official mirrors. Both of these are automatically synced with the main repository, when changes are pushed. If the main repo is down for some reason, either one of these is safe to use as a backup:\n\nThe fio project mailing list is meant for anything related to fio including general discussion, bug reporting, questions, and development. For bug reporting, see REPORTING-BUGS.\n\nAn automated mail detailing recent commits is automatically sent to the list at most daily. The list address is fio@vger.kernel.org, subscribe by sending an email to fio+subscribe@vger.kernel.org or visit https://subspace.kernel.org/vger.kernel.org.html.\n\nArchives can be found here:\n\nand archives for the old list can be found here:\n\nFio was written by Jens Axboe <axboe@kernel.dk> to enable flexible testing of the Linux I/O subsystem and schedulers. He got tired of writing specific test applications to simulate a given workload, and found that the existing I/O benchmark/test tools out there weren't flexible enough to do what he wanted.\n\nFio is maintained by Jens Axboe <axboe@kernel.dk and Vincent Fu <vincentfu@gmail.com> - however, for reporting bugs please use the fio reflector or the GitHub page rather than email any of them directly. By using the public resources, others will be able to learn from the responses too. Chances are also good that other members will be able to help with your inquiry as well.\n\nNote that GNU make is required. On BSDs it's available from devel/gmake within ports directory; on Solaris it's in the SUNWgmake package. On platforms where GNU make isn't the default, type instead of .\n\nConfigure will print the enabled options. Note that on Linux based platforms, the libaio development packages must be installed to use the libaio engine. Depending on the distro, it is usually called libaio-devel or libaio-dev.\n\nFor gfio, gtk 2.18 (or newer), associated glib threads, and cairo are required to be installed. gfio isn't built automatically and can be enabled with a option to configure.\n\nConfigure will attempt to determine the target platform automatically.\n\nIt's possible to build fio for ESX as well, use the switch to configure.\n\nThe minimum versions of Windows for building/running fio are Windows 7/Windows Server 2008 R2. On Windows, Cygwin (https://www.cygwin.com/) is required in order to build fio. To create an MSI installer package install WiX from https://wixtoolset.org and run :file:`dobuild.cmd` from the :file:`os/windows` directory.\n\nHow to compile fio on 64-bit Windows:\n\nTo build fio for 32-bit Windows, ensure the -i686 versions of the previously mentioned -x86_64 packages are installed and run before .\n\nIt's recommended that once built or installed, fio be run in a Command Prompt or other 'native' console such as console2, since there are known to be display and signal issues when running it under a Cygwin shell (see mintty/mintty#56 and https://github.com/mintty/mintty/wiki/Tips#inputoutput-interaction-with-alien-programs for details).\n\nFio uses Sphinx to generate documentation from the reStructuredText files. To build HTML formatted documentation run and direct your browser to :file:`./doc/output/html/index.html`. To build manual page run and then . To see what other output formats are supported run .\n\nFio works on (at least) Linux, Solaris, AIX, HP-UX, OSX, NetBSD, OpenBSD, Windows, FreeBSD, and DragonFly. Some features and/or options may only be available on some of the platforms, typically because those features only apply to that platform (like the solarisaio engine, or the splice engine on Linux).\n\nSome features are not available on FreeBSD/Solaris even if they could be implemented, I'd be happy to take patches for that. An example of that is disk utility statistics and (I think) huge page support, support for that does exist in FreeBSD/Solaris.\n\nFio uses pthread mutexes for signaling and locking and some platforms do not support process shared pthread mutexes. As a result, on such platforms only threads are supported. This could be fixed with sysv ipc locking or other locking alternatives.\n\nOther *BSD platforms are untested, but fio should work there almost out of the box. Since I don't do test runs or even compiles on those platforms, your mileage may vary. Sending me patches for other platforms is greatly appreciated. There's a lot of value in having the same test/benchmark tool available on all platforms.\n\nNote that POSIX aio is not enabled by default on AIX. Messages like these:\n\nindicate one needs to enable POSIX aio. Run the following commands as root:\n\nPOSIX aio should work now. To make the change permanent:\n\nRunning fio is normally the easiest part - you just give it the job file (or job files) as parameters:\n\nand it will start doing what the jobfile tells it to do. You can give more than one job file on the command line, fio will serialize the running of those files. Internally that is the same as using the :option:`stonewall` parameter described in the parameter section.\n\nIf the job file contains only one job, you may as well just give the parameters on the command line. The command line parameters are identical to the job parameters, with a few extra that control global parameters. For example, for the job file parameter :option:`iodepth=2 <iodepth>`, the mirror command line option would be :option:`--iodepth 2 <iodepth>` or :option:`--iodepth=2 <iodepth>`. You can also use the command line for giving more than one job entry. For each :option:`--name <name>` option that fio sees, it will start a new job with that name. Command line entries following a :option:`--name <name>` entry will apply to that job, until there are no more entries or a new :option:`--name <name>` entry is seen. This is similar to the job file options, where each option applies to the current job until a new [] job entry is seen.\n\nfio does not need to run as root, except if the files or devices specified in the job section requires that. Some other options may also be restricted, such as memory locking, I/O scheduler switching, and decreasing the nice value.\n\nIf jobfile is specified as , the job file will be read from standard input."
    }
]