[
    {
        "link": "https://stackoverflow.com/questions/54334202/how-to-execute-a-stored-procedure-against-linked-server",
        "document": "We currently execute a stored procedure against a linked server using:\n\nAnd this works fine; querying through a linked server works fine.\n\nThere is apparently a little known, seldom used, feature known as remote access. Microsoft has very little to say about what this feature is, except to say here:\n\nThis configuration option is an obscure SQL Server to SQL Server communication feature that is deprecated, and you probably shouldn't be using it. This feature will be removed in the next version of Microsoft SQL Server. Do not use this feature in new development work, and modify applications that currently use this feature as soon as possible. Use sp_addlinkedserver instead. The remote access option only applies to servers that are added by using sp_addserver, and is included for backward compatibility.\n\nAnd from the SQL Server 2000 Books Online:\n\nWe only ever added linked servers, and have never used this \"remote access\" feature, and have never added a server using .\n\nWe're all good. Right?\n\nExcept turning off remote access breaks everything\n\nAn auditor has mentioned that we should turn off the remote access feature:\n• it's a security checkbox on their clipboard\n• it's hardly ever used\n• and we don't use it\n\nShould be fine, right?\n\nMicrosoft documents how to turn off this hardly used feature:\n\nExcept when we do: everything goes to hell:\n\nJust to be absolutely sure I'm using a linked server, I:\n\nI can confirm that the server is a linked server (and is not a \"remote\" server) using:\n\nOr using the modern objects:\n\nWe're at the point now where:\n• Remote access only applies to servers added through\n• it doesn't apply to servers added through\n\nWhich brings me to my question:\n• How to execute a stored procedure against a linked server?\n• How to not execute a stored procedure against an added (i.e. \"remote\") server?\n\nThe remote access configuration option, that you adjust using , is also exposed through the user interface. The SSMS UI describes the feature incorrectly:\n\nIt should be phrased:\n\nThe Books Online also document the feature incorrectly:\n\nIt should be:\n\nIt makes sense that the youngsters at Microsoft these days don't remember what a 20 year old deprecated feature that they've never touched does.\n\nSQL Server 2000 was the last time this feature was documented. Reproduced here for posterity and debugging purposes:\n\nA remote server configuration allows a client connected to one instance of Microsoft® SQL Server™ to execute a stored procedure on another instance of SQL Server without establishing another connection. The server to which the client is connected accepts the client request and sends the request to the remote server on behalf of the client. The remote server processes the request and returns any results to the original server, which in turn passes those results to the client. If you want to set up a server configuration in order to execute stored procedures on another server and do not have existing remote server configurations, use linked servers instead of remote servers. Both stored procedures and distributed queries are allowed against linked servers; however, only stored procedures are allowed against remote servers. Note Support for remote servers is provided for backward compatibility only. New applications that must execute stored procedures against remote instances of SQL Server should use linked servers instead.\n• Security Audit requires turning Remote Access off on all SQL 2005 and SQL 2008 Servers"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/linked-servers/linked-servers-database-engine?view=sql-server-ver16",
        "document": "Linked servers enable the SQL Server Database Engine and Azure SQL Managed Instance to read data from the remote data sources and execute commands against the remote database servers (for example, OLE DB data sources) outside of the instance of SQL Server. Typically linked servers are configured to enable the Database Engine to execute a Transact-SQL statement that includes tables in another instance of SQL Server, or another database product such as Oracle. Many types OLE DB data sources can be configured as linked servers, including third-party database providers and Azure Cosmos DB.\n\nWhen to use linked servers?\n\nLinked servers enable you to implement distributed databases that can fetch and update data in other databases. Linked servers are a good solution in the scenarios where you need to implement database sharding without need to create a custom application code or directly load from remote data sources. Linked servers offer the following advantages:\n• None The ability to access data from outside of SQL Server.\n• None The ability to issue distributed queries, updates, commands, and transactions on heterogeneous data sources across the enterprise.\n\nYou can configure a linked server by using SQL Server Management Studio or by using the sp_addlinkedserver statement. OLE DB providers vary greatly in the type and number of parameters required. For example, some providers require you to provide a security context for the connection using sp_addlinkedsrvlogin. Some OLE DB providers allow SQL Server to update data on the OLE DB source. Others provide only read-only data access. For information about each OLE DB provider, consult documentation for that OLE DB provider.\n\nAn OLE DB provider is a DLL that manages and interacts with a specific data source. An OLE DB data source identifies the specific database that can be accessed through OLE DB. Although data sources queried through linked server definitions are ordinarily databases, OLE DB providers exist for various files and file formats. These include text files, spreadsheet data, and the results of full-text content searches.\n\nStarting with SQL Server 2019 (15.x), the Microsoft OLE DB Driver for SQL Server (PROGID: MSOLEDBSQL) is the default OLE DB provider. In earlier versions, the SQL Server Native Client (PROGID: SQLNCLI11) was the default OLE DB provider.\n\nLinked servers to Microsoft Access and Excel sources are only supported by Microsoft when using the 32-bit Microsoft.JET.OLEDB.4.0 OLE DB provider.\n\nThe following illustration shows the basics of a linked server configuration.\n\nTypically, linked servers are used to handle distributed queries. When a client application executes a distributed query through a linked server, SQL Server parses the command and sends requests to OLE DB. The rowset request might be in the form of executing a query against the provider or opening a base table from the provider.\n\nThere's a set of options that control how SQL Server loads and uses OLE DB providers that are specified in the registry.\n\nWhen you're setting up a linked server, register the connection information and data source information with SQL Server. After being registered, that data source can be referred to with a single logical name.\n\nYou can use stored procedures and catalog views to manage linked server definitions:\n• None View information about the linked servers defined in a specific instance of SQL Server by running a query against the system catalog view.\n• None Delete a linked server definition by running . You can also use this stored procedure to remove a remote server.\n\nYou can also define linked servers by using SQL Server Management Studio. In the Object Explorer, right-click Server Objects, select New, and select Linked Server. You can delete a linked server definition by right-clicking the linked server name and selecting Delete.\n\nWhen you execute a distributed query against a linked server, include a fully qualified, four-part table name for each data source to query. This four-part name should be in the form linked_server_name.catalog.schema.object_name.\n\nReferences to temporary objects will always resolve to the local instance's where applicable, even when prefixing with the linked server name.\n\nLinked servers can be defined to point back (loop back) to the server on which they are defined. Loopback servers are most useful when testing an application that uses distributed queries on a single server network. Loopback linked servers are intended for testing and are not supported for many operations, such as distributed transactions.\n\nAzure SQL Managed Instance linked servers support both SQL authentication and authentication with Microsoft Entra ID (formerly Azure Active Directory).\n\nTo use SQL Agent jobs on Azure SQL Managed Instance to query a remote server through a linked server, use sp_addlinkedsrvlogin to create a mapping from a login on the local server to a login on the remote server. When the SQL Agent job connects to the remote server through the linked server, it executes the T-SQL query in the context of the remote login. For more information, see SQL Agent jobs with Azure SQL Managed Instance.\n\nTwo supported Microsoft Entra authentication modes are: managed identity and pass-through. Managed identity authentication can be used to allow local logins to query remote linked servers. Pass-through authentication allows a principal that can authenticate with a local instance to access a remote instance via a linked server.\n\nTo use Microsoft Entra pass-through authentication for a linked server in Azure SQL Managed Instance, you need the following prerequisites:\n• The same principal is added as a login on the remote server.\n• Both instances are members of the SQL trust group.\n\nThe following limitations apply to Microsoft Entra authentication for linked servers in Azure SQL Managed Instance:\n• Microsoft Entra authentication isn't supported for SQL managed instances in different Microsoft Entra tenants.\n• Microsoft Entra authentication for linked servers is supported only with OLE DB driver version 18.2.1 and higher.\n\nCurrently, MSOLEDBSQL19 prevents the creation of linked servers without encryption and a trusted certificate (a self-signed certificate is insufficient). If linked servers are required, use the existing supported version of MSOLEDBSQL."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/linked-servers/create-linked-servers-sql-server-database-engine?view=sql-server-ver16",
        "document": "This article shows how to create a linked server and access data from another SQL Server, an Azure SQL Managed Instance, or another data source by using SQL Server Management Studio (SSMS) or Transact-SQL. Linked servers enable the SQL Server database engine and Azure SQL Managed Instance to read data from the remote data sources and execute commands against the remote database servers (for example, OLE DB data sources) outside of the instance of SQL Server.\n\nLinked servers are typically configured to enable the database engine to execute a Transact-SQL statement that includes tables in another instance of SQL Server, or another database product such as Oracle. Many types of data sources can be configured as linked servers, including third-party database providers and Azure Cosmos DB.\n\nAfter a linked server is created, distributed queries can be run against this server, and queries can join tables from more than one data source. If the linked server is defined as an instance of SQL Server or an Azure SQL Managed Instance, remote stored procedures can be executed.\n\nThe capabilities and required arguments of the linked server can vary significantly. The examples in this article provide a typical example but all options aren't described. For more information, see sp_addlinkedserver (Transact-SQL).\n\nWhen using Transact-SQL statements, requires ALTER ANY LINKED SERVER permission on the server or membership in the setupadmin fixed server role. When using Management Studio requires CONTROL SERVER permission or membership in the sysadmin fixed server role.\n\nCreate a linked server with SSMS using the following procedure:\n\nEdit the General page for the linked server properties\n\nOn the General page, in the Linked server box, type the name of the instance of SQL Server that you're linking to.\n\nSpecify the Server type and related information if needed:\n• None SQL Server\n\n Identify the linked server as an instance of Microsoft SQL Server or an Azure SQL Managed Instance. If you use this method of defining a linked server, the name specified in Linked server must be the network name of the server. Also, any tables retrieved from the server are from the default database defined for the login on the linked server.\n• None Other data source\n\n Specify an OLE DB server type other than SQL Server. Clicking this option activates the options below it.\n• None Provider\n\n Select an OLE DB data source from the list box. The OLE DB provider is registered with the given PROGID in the registry.\n• None Product name\n\n Type the product name of the OLE DB data source to add as a linked server.\n• None Data source\n\n Type the name of the data source as interpreted by the OLE DB provider. If you're connecting to an instance of SQL Server, provide the instance name.\n• None Provider string\n\n Type the unique programmatic identifier (PROGID) of the OLE DB provider that corresponds to the data source. For examples of valid provider strings, see sp_addlinkedserver (Transact-SQL).\n• None Location\n\n Type the location of the database as interpreted by the OLE DB provider.\n• None Catalog\n\n Type the name of the catalog to use when making a connection to the OLE DB provider.\n\nEdit the Security page for the linked server properties\n\nOn the Security page, specify the security context that is used when the original instance connects to the linked server. There are two strategies to configure here that can be used alone or combined. The first is to map logins from the local server to the remote server, and the second is how the linked server should treat logins that aren't mapped.\n\nYou can optionally specify how specific local server logins authenticate using the linked server.\n\nUnder Local server login to remote server login mappings, repeat the following process for each login you would like to map:\n• Specify the local login that can connect to the linked server. The local login can be either a login using SQL Server authentication or a Windows authentication login. Using a Windows group or a contained database user isn't supported. Use this list to restrict the connection to specific logins, or to allow some logins to connect as a different login. Common issues with linked servers using Windows authentication to a remote SQL Server instance arise from issues with service principal names (SPNs). For more information, see Service Principal Name (SPN) Support in Client Connections. Microsoft Kerberos Configuration Manager for SQL Server is a diagnostic tool that helps troubleshoot Kerberos related connectivity issues with SQL Server. For more information, see Microsoft Kerberos Configuration Manager for SQL Server.\n• Pass the username and password from the local login to the linked server. For SQL Server authentication, a login with the exact same name and password must exist on the remote server. For Windows logins, the login must be a valid login on the linked server. To use impersonation, the configuration must meet the requirement for delegation.\n• None Specify a Remote User if you aren't using impersonation. Use the remote user to map user defined in Local login. The Remote User must be a SQL Server authentication login on the remote server.\n• None Specify a Remote Password if you aren't using impersonation.\n• Specify the password of the Remote User.\n• None Select Remove to remove an existing local login, if desired.\n\nSpecify the default security context for logins not present in the mapping list\n\nIn a domain environment where users are connecting by using their domain logins, selecting Be made using the login's current security context is often the best choice. When users connect to the original SQL Server by using a SQL Server login, the best choice is often to select By using this security context, and then providing the necessary credentials to authenticate at the linked server.\n\nSelect one of the following options:\n• None Not be made\n\n A connection won't be made for logins not defined in the list.\n• None Be made without using a security context\n\n A connection will be made without using a security context for logins not defined in the list.\n• None Be made using the login's current security context\n\n A connection will be made using the current security context of the login for logins not defined in the list. If connected to the local server using Windows Authentication, your Windows credentials will be used to connect to the remote server. If connected to the local server using SQL Server Authentication, login name and password will be used to connect to the remote server. In this case, a login with the exact same name and password must exist on the remote server.\n• None Be made using this security context\n\n A connection will be made using the login and password specified in the Remote login and With password boxes for logins not defined in the list. The remote login must be a SQL Server Authentication login on the remote server. If a linked server is configured with option Be made using this security context, any user on the instance can access the remote linked server using this context. This may have the unintended potential for abuse or malicious internal access. The SQL authenticated Remote login provided to the linked server should be granted minimum necessary permissions on the remote server, to ensure a principle of least privilege and to reduce attack surface.\n\nTo view or specify server options, select the Server Options page. You can edit any of the following options:\n• None Collation Compatible\n\n Affects Distributed Query execution against linked servers. If this option is set to true, SQL Server assumes that all characters in the linked server are compatible with the local server, with regard to character set and collation sequence (or sort order). This enables SQL Server to send comparisons on character columns to the provider. If this option isn't set, SQL Server always evaluates comparisons on character columns locally. This option should be set only if it's certain that the data source corresponding to the linked server has the same character set and sort order as the local server.\n• None RPC\n\n Enables remote procedure calls (RPC) from the specified server.\n• None RPC Out\n\n Enables RPC to the specified server.\n• None Use Remote Collation\n\n Determines whether the collation of a remote column or of a local server will be used. If true, the collation of remote columns is used for SQL Server data sources, and the collation specified in collation name is used for non-SQL Server data sources. If false, distributed queries will always use the default collation of the local server, while collation name and the collation of remote columns are ignored. The default is false.\n• None Collation Name\n\n Specifies the name of the collation used by the remote data source if use remote collation is true and the data source isn't a SQL Server data source. The name must be one of the collations supported by SQL Server. Use this option when accessing an OLE DB data source other than SQL Server, but whose collation matches one of the SQL Server collations. The linked server must support a single collation to be used for all columns in that server. Don't set this option if the linked server supports multiple collations within a single data source, or if the linked server's collation can't be determined to match one of the SQL Server collations.\n• None Connection Timeout\n\n Time-out value in seconds for connecting to a linked server. If 0, use the default remote login timeout option value.\n• None Query Timeout\n\n Time-out value in seconds for queries against a linked server. If 0, use the default remote query timeout option value.\n• None Enable Promotion of Distributed Transactions\n\n Use this option to protect the actions of a server-to-server procedure through a Microsoft Distributed Transaction Coordinator (MS DTC) transaction. When this option is TRUE, calling a remote stored procedure starts a distributed transaction and enlists the transaction with MS DTC. For more information, see sp_serveroption (Transact-SQL).\n\nAll providers don't have the same options available. For example, some types of data have indexes available and some might not. Use this dialog box to help SQL Server understand the capabilities of the provider. SQL Server installs some common data providers, however when the product providing the data changes, the provider installed by SQL Server might not support all the newest features. The best source of information about the capabilities of the product providing the data is the documentation for that product.\n\n To open the linked server Providers Options page in SSMS:\n\nProvider options are defined as follows:\n• None Dynamic parameter\n\n Indicates that the provider allows '?' parameter marker syntax for parameterized queries. Set this option only if the provider supports the ICommandWithParameters interface and supports a '?' as the parameter marker. Setting this option allows SQL Server to execute parameterized queries against the provider. The ability to execute parameterized queries against the provider can result in better performance for certain queries.\n• None Nested queries\n\n Indicates that the provider allows nested statements in the FROM clause. Setting this option allows SQL Server to delegate certain queries to the provider that require nesting SELECT statements in the FROM clause.\n• None Level zero only\n\n Only level 0 OLE DB interfaces are invoked against the provider.\n• SQL Server allows the provider to be instantiated as an in-process server. When this option isn't set, the default behavior is to instantiate the provider outside the SQL Server process. Instantiating the provider outside the SQL Server process protects the SQL Server process from errors in the provider. When the provider is instantiated outside the SQL Server process, updates or inserts referencing long columns (text, ntext, or image) aren't allowed.\n• None Non transacted updates\n\n SQL Server allows updates, even if ITransactionLocal isn't available. If this option is enabled, updates against the provider aren't recoverable, because the provider doesn't support transactions.\n• None Index as access path\n\n SQL Server attempts to use indexes of the provider to fetch data. By default, indexes are used only for metadata and are never opened\n• None Disallow ad hoc access\n\n SQL Server doesn't allow ad hoc access through the OPENROWSET and OPENDATASOURCE functions against the OLE DB provider. When this option isn't set, SQL Server also doesn't allow ad hoc access.\n• None Supports 'Like' operator\n\n Indicates that the provider supports queries using the LIKE key word.\n\nTo create a linked server by using Transact-SQL, use the sp_addlinkedserver (Transact-SQL), CREATE LOGIN (Transact-SQL), and sp_addlinkedsrvlogin (Transact-SQL) statements.\n\nThis example creates a linked server to another instance of SQL Server using Transact-SQL:\n• None In Query Editor, enter the following Transact-SQL command to link to an instance of SQL Server named : USE [master] GO EXEC master.dbo.sp_addlinkedserver @server = N'SRVR002\\ACCTG', @srvproduct=N'SQL Server'; GO\n• None Execute the following code to configure the linked server to use the domain credentials of the login that is using the linked server.\n\nFollow Up: Steps to take after you create a linked server\n\nThe following steps help you validate a linked server.\n\nConsidering either of the following two approaches to test a linked server's authentication in your current security context.\n• None To test the ability to connect to a linked server in SSMS, browse to the linked server in Object Explorer, right-click the linked server and then select Test Connection.\n• None To test the ability to connect to a linked server in T-SQL, execute a simple statement, for example, to retrieve basic database catalog information. This example returns the names of the databases on the linked server. SELECT name FROM [SRVR002\\ACCTG].master.sys.databases; GO\n\nUse four-part names to refer to an object on a linked server. Execute the following code to return a list of all logins on the local server and their matching logins on the linked server.\n\nWhen is returned for the linked server login, it indicates that the login doesn't exist on the linked server. These logins won't be able to use the linked server unless the linked server is configured to pass a different security context or the linked server accepts anonymous connections.\n\nIf you're using Azure SQL Managed Instance, see the following examples from sp_addlinkedserver (Transact-SQL):\n\nLearn more about managing linked servers in these articles:"
    },
    {
        "link": "https://arc.cdata.com/blog/sql-server-linked-server-guide",
        "document": "This website stores cookies on your computer. These cookies are used to collect information about how you interact with our website and allow us to remember you. We use this information in order to improve and customize your browsing experience and for analytics and metrics about our visitors both on this website and other media. To find out more about the cookies we use, see our Privacy Policy"
    },
    {
        "link": "https://dba.stackexchange.com/questions/144660/execute-stored-procedure-remotely-using-linked-server",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://straightpathsql.com/archives/2024/06/sql-server-security-best-practices-for-linked-servers-2",
        "document": "SQL Server Linked Servers provide a method to directly execute distributed queries on remote databases. However, they are not an ideal tool due to performance issues. If you decide to use them, it’s crucial to ensure they are secure. This post will outline some best practices for securing SQL Server Linked Servers.\n\nThere are two types of connections in SQL Server Linked Servers: mapped and unmapped. We have seen some use the option for connections to ‘Be made using this security context’ and then use an overprivileged account such as a login with sysadmin or even sa (as seen below). This is an extremely dangerous configuration option because anyone who has access to server has the rights of this specific context.\n\nWe recommend using the unmapped option to ‘Be made using the login’s current security context’ as it requires specific logins or groups to be on both servers, and the permissions to have been defined for the linked server connection to work. Alternatively, if your linked servers are using a general mapping as in the fourth option, you should have a permissions review to reduce those login’s permissions to the least privilege necessary to complete the tasks it will be used for.\n\nThe principle of least privilege should be used when configuring SQL Server Linked Servers. This principle states that users and systems should have the bare minimum privileges needed to carry out their jobs. The urge to overprovision access to make a process work is high here, resist the urge and work through only granting permissions for the work that will be done and nothing more.\n\nTo identify what linked servers are configured, what access methods are being used, and what remote account is being used, you can use the following script:\n\nThis script will return a list of all linked servers, their data sources, any local to remote mapped users, whether current context use is allowed, and the one result you should really pay attention to is if there is no local name but there is a remote name – that means the ‘Be made using this security context’ option was selected and every user can run queries against the linked server with the permissions of the remote login. The picture below shows sa as the remote context everyone gets to use, and yes, this is based on configurations we have seen before.\n\nIn conclusion, while SQL Server Linked Servers can be a useful tool in some cases, they must be used with security in mind. By following these best practices, you can help ensure the security of your SQL Server environment."
    },
    {
        "link": "https://dba.stackexchange.com/questions/256243/sql-server-linked-server-best-practices-step-by-step",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://netwrix.com/sql-server-security-best-practices.html",
        "document": "While SQL Server is designed to be a secure database platform, following best practices for configuring, managing, and monitoring your SQL Server environment can significantly reduce your risk of costly breaches, downtime, and violations of data protection and privacy regulations such as GDPR, HIPAA, PCI DSS, and SOX.\n\nTo help, this article details the critical SQL Server security best practices to implement. You’ll learn about implementing robust access controls, regularly patching and updating software, conducting security assessments, and more.\n\nHardening the Windows Server operating system before installing SQL Server is one of the most critical security best practices. Attackers who gain access to the OS can copy your valuable database files to their server, where they can break passwords and encryption at their leisure. To learn how to strengthen your Windows Server, review these Windows Server hardening best practices.\n\nLike any database management system, SQL Server is susceptible to threats that could compromise data integrity, confidentiality and availability. Common threats to be aware of include:\n• SQL injection attacks occur when malicious SQL code is injected into the input fields or parameters of a SQL query. This can enable attackers to execute commands or to steal sensitive data, modify database records or gain access to the underlying system.\n• Unauthorized access refers to exploiting weak authentication mechanisms or misconfigured access controls to gain entry into SQL Server instances or databases. Attackers may attempt to brute-force passwords, exploit default credentials or bypass access controls to gain elevated privileges or access sensitive data.\n• Data leakage occurs when sensitive or confidential information is improperly exposed from SQL Server databases. This can happen due to misconfigured permissions, insecure data storage practices or inadequate encryption of sensitive data.\n• Denial of service (DoS) attacks target SQL Server instances or databases with the intent of disrupting service availability or causing system downtime. Attackers may flood SQL Server with excessive requests, execute resource-intensive queries or exploit vulnerabilities to exhaust system resources and disrupt normal operations.\n• Database exploitation involves the exploitation of vulnerabilities in SQL Server or the underlying operating system to gain unauthorized access to or control over the database server. Attackers may exploit unpatched vulnerabilities, insecure configurations or weak encryption mechanisms to compromise the integrity or availability of SQL Server databases.\n• Privilege escalation occurs when attackers exploit vulnerabilities or misconfigurations to elevate their privileges in order to gain access to sensitive data or administrative functions on the database server.\n• Insufficient auditing and logging practices may hinder detecting and responding to security incidents in SQL Server environments. Inadequate logging of security events, weak audit policies or lack of monitoring may prevent timely detection of unauthorized access, data breaches or suspicious activities.\n• Social engineering attacks target SQL Server administrators, developers or users through manipulation or deception to expose sensitive information or grant unauthorized access. Attackers may use phishing emails, pretexting or impersonation techniques to trick individuals into revealing credentials, executing malicious code or disclosing confidential information.\n\nYou should limit the installation to just the components your database needs to perform its tasks. This approach reduces your attack surface area by eliminating components that could have security vulnerabilities. It also minimizes resource utilization by the database and simplifies administration by removing services and components that must be managed.\n\nBelow are some essential components to consider:\n• Database Engine Services — This is the core component of SQL Server responsible for storing, processing and securing data.\n• SQL Server management tools — Include SQL Server Management Studio (SSMS) or Azure Data Studio for managing and administering the SQL Server instance.\n• Integration services — If your applications require ETL (extract, transform, load) functionality, select Integration Services to enable SSIS package execution.\n• Full-text and semantic extractions for search — Enable this feature if your applications require full-text search capabilities.\n• Analysis services — Choose this option if you need multidimensional or tabular data analysis services.\n\nLimit the Permissions of Service Accounts According to the Principle of Least Privilege\n\nEach SQL Server service runs under a specified account. Those service accounts should be configured based on the principle of least privilege, which states that each account should have the minimum permissions it needs to function. To improve accuracy and transparency, those rights should be assigned using security groups rather than directly.\n\nBest practices include assigning each service a separate account. That way, even if the account for one service is compromised or damaged, other services will still operate normally.\n\nHere are the types of accounts you can use for SQL Server services:\n• Active Directory (AD) managed service account (MSA) — This is the best option for two reasons. First, managed service accounts cannot be used to log on to a server, so they are more secure than domain user accounts. Second, you do not need to manually manage password resets for service accounts, which reduces the risk of account compromise.\n• Domain user account — This is the most common type of account used to run services. This account type is entirely secure in a domain environment because it doesn’t have administrator privileges.\n• Local user account — This is a good choice for non-domain environments.\n• Local system account — These accounts are highly privileged, so you should avoid using them to run services.\n• Network service account — This type of account has fewer privileges than a system account. Still, it enables a service to access network resources, so you should avoid using it whenever possible.\n• Virtual service account — A virtual service account is similar to an AD managed service account, but it is a type of local account that you can use to manage services without a domain. NT Service\\MSSQLSERVER is an example of a virtual account that gets created when you install SQL Server and is assigned to the service. These accounts have minimal privileges by default and are more secure than domain user accounts.\n\nYou can further enhance the security posture of your SQL Server environment by implementing the following firewall and network security best practices:\n• Limit network access to SQL Server by configuring firewalls to allow connections only from trusted IP addresses or subnets. Use network segmentation to isolate SQL Server from other systems and services to reduce the attack surface. Disable unnecessary network protocols and services on SQL Server, such as Named Pipes and TCP/IP.\n• Change the default port used by SQL Server (1433 for default instances, 1434 for SQL Server Browser) to a non-standard port to make it harder for attackers to discover and target SQL Server instances.\n• Use IPsec (Internet Protocol Security) to secure network communication between SQL Server instances and client applications. IPsec provides authentication and encryption at the IP packet level, enhancing network security.\n• Use Windows Firewall or a third-party firewall to control inbound and outbound traffic to SQL Server. Configure firewall rules to allow only necessary traffic to SQL Server ports.\n• Implement an intrusion detection and prevention system (IDPS) to monitor network traffic and alert administrators about suspicious activity.\n\nConfiguring SSL/TLS to encrypt SQL data in transit helps protect sensitive information from unauthorized access during communication between client applications and the SQL Server instance. You should obtain a server authentication certificate from a trusted Certificate Authority (CA) or create a self-signed certificate. The certificate should include the fully qualified domain name (FQDN) of the SQL Server computer as the Common Name (CN) or as a Subject Alternative Name (SAN).\n\nTest SSL/TLS encryption by connecting to the SQL Server instance from a client application using SQL Server Management Studio (SSMS) or another database client.\n\nThe SQL Server Browser service eliminates the need to assign port numbers to instances. While enabling this service enables SQL admins and authorized users to discover database instances over the network, it also makes it possible for attackers to gain knowledge of the available SQL Server resources.\n\nWhen running a default instance of SQL Server, you should turn off the SQL Server Browser service or configure another port for it to use to communicate. Then restart the SQL Server instance service, test application and client connectivity to the SQL Server, and update your firewall rules to allow direct access to the SQL Server.\n\nServer roles provide an easy way to delegate administrative privileges, but you must assign these roles carefully. Always follow the principle of least privilege when assigning roles to users. For example, if a user needs only to be able to shut down the server and end processes, they should be assigned the server admin and process admin roles; assigning them the sysadmin role would violate the principle of least privilege. There are several types of roles to understand:\n• Fixed server roles are predefined server-level roles with a specific set of permissions. They provide administrative access to various server-level operations. Examples of fixed server roles include:\n• sysadmin — Members of this role have full administrative privileges on the SQL Server instance.\n• Fixed database roles are predefined roles within each database with specific permissions. They control access to database-level operations. Examples of fixed database roles include:\n• db_owner — Members of this role have complete control over the database, including the ability to modify the schema, execute DDL statements and manage users.\n• db_datareader — Members can read all data in the database.\n• db_datawriter — Members can add, modify and delete data in the database.\n• db_ddladmin — Members can execute DDL statements in the database.\n• db_securityadmin — Members can manage security permissions in the database.\n• User-defined roles are created by administrators or database owners to meet specific application or business requirements. These roles can have custom sets of permissions tailored to the needs of the application or users.\n\nCreate containers (such as groups or roles) and assign them permissions to access resources. Then, make accounts of members of those groups of roles.\n\nFollowing this best practice will be easier to understand the effective permissions for each account. Moreover, simply by putting a user in the right groups or roles, you can easily assign the correct permissions to new hires, accurately modify permissions as a user’s role changes and remove a user’s permissions when they leave the organization.\n\nWhen multiple permissions are granted to a user through different roles or groups, SQL Server follows a hierarchy to determine the effective permissions. Generally, the most permissive permission prevails, but if any permissions are explicitly denied, that overrides any grants.\n\nThere are three levels of permissions to understand:\n• Server-level permissions — Server-level permissions control actions that can be performed at the server level, such as creating databases, altering server configuration settings and shutting down the server.\n• Database-level permissions — Database-level permissions control actions that can be performed within a specific database, such as querying tables, updating data and executing stored procedures.\n• Object-level permissions — Object-level permissions control access to individual database objects, such as tables, views, stored procedures and functions. You can grant permissions such as SELECT, INSERT, UPDATE, DELETE, EXECUTE and CONTROL at the object level.\n\nStrong passwords are necessary for all database administrator accounts to make them resistant to brute-force attacks. Be sure to follow current password best practices for password length and complexity.\n\nBoth white-hat and malicious hackers are constantly discovering vulnerabilities and exploits in SQL Server. Microsoft releases several types of updates to fix them:\n• Hotfixes, also known Quick Fix Engineering (QFE), are released to solve problems ASAP. Due to the tight time constraints, hotfixes receive limited testing, so they should be applied only to systems known to have the specific issues they address.\n• Cumulative updates (CUs) are periodic releases of hotfixes with thorough testing.\n• Service packs (SPs) are collections of patches and fixes that have been adequately tested and can easily be installed as a single package.\n\nThe simplest way to keep SQL Server up to date is to enable automatic updates from Microsoft. Organizations with a solid change process should apply updates only after performing their own testing.\n• Windows Authentication is recommended in environments where SQL Server and client applications are in a Windows domain. Users connect to the SQL Server using their Windows credentials and the SQL Server validates their identity. This provides a more secure and centralized authentication mechanism.\n• SQL authentication or mixed mode authentication requires users to provide an SQL server login ID and password when connecting to the SQL server. User credentials are stored in SQL Server's security system rather than managed by Windows, providing flexibility for environments where Windows authentication is not feasible. If you use this authentication mode to connect to SQL Server, do not use the SA account since it is the first account attackers will try to compromise in a brute-force attack.\n• Microsoft Entra authentication (introduced in SQL Server 2022) allows users to connect to SQL Server using their Entra ID identities. It provides centralized identity management and integrates with Azure AD's security features, such as conditional access and multifactor authentication. It requires the SQL Server to be configured for Azure AD authentication and for users to be synchronized with Azure AD. Microsoft Entra authentication supports Azure SQL database, Azure SQL managed instance, SQL Server on Windows Azure VMs, Azure Synapse Analytics and SQL Server.\n\nIn a Windows environment, administrators can enable policies that control user password complexity and expiration. You have similar options for SQL Server logins:\n• MUST_CHANGE — SQL Server will prompt users to change their password the next time they log on. Use this option whenever you create a new user. You can also use it to force a user to reset their password.\n• CHECK_POLICY —The Windows password policies of the computer on which the SQL Server is running will be enforced for the user. Always enable this setting.\n• CHECK_EXPIRATION — The user will be required to reset their password regularly. Always enable this setting.\n\nBe Diligent about Disabling and Deleting Logins\n\nIf a login will not be used for longer than one month, it should be disabled for the interim and then re-enabled. Regularly review all logins and delete any that have been disabled for more than one year.\n\nBackups help ensure that data can be recovered in case of system failure. Full backups back up the entire database, while differential backups back up only the changes since the last full backup.\n\nDifferential backups are much faster and occupy less disk space than full backups, so they are especially useful for large databases. However, full backups should still be taken periodically. For small databases, the best practice is to use full backups every time.\n\nYou can also take file and filegroup backups, which back up only specific files or filegroups. This strategy can reduce backup time and speed recovery of a single file or filegroup. However, be aware that managing filegroup backups can be complex.\n\nEffective monitoring is critical to detecting, diagnosing and resolving problems. For example, you might be able to identify long-running queries that could be malicious. Valuable tools include the following:\n• SQL Server Management Studio (SSMS) — Utilize SSMS tools to monitor processes, resource usage and system performance. In particular, SSMS Activity Monitor provides real-time insights into CPU usage, memory consumption, disk I/O and active sessions.\n• Dynamic management views (DMVs) — Use DMVs to identify long-running queries, blocking processes, memory pressure and other performance bottlenecks. Common DMVs include:\n• SQL Server Profiler — Use SQL Server Profiler to capture and analyze SQL Server events, including queries, stored procedure executions, errors and security-related events. Customize trace templates to capture specific events or filter out unnecessary information. Analyze captured traces to identify performance issues, diagnose errors and optimize queries.\n• Extended Events — Use Extended Events for lightweight and customizable event monitoring. Create custom event sessions to capture specific events, performance metrics and diagnostic information. Compared to SQL Server Profiler, Extended Events offer lower overhead and more event filtering and analysis flexibility.\n• Performance Monitor (PerfMon) — Use PerfMon to monitor SQL Server performance metrics such as CPU usage, memory utilization, disk I/O and network activity. Create data collector sets to collect performance counters over time and analyze performance trends. Monitor key performance indicators (KPIs) to identify performance issues and resource bottlenecks proactively.\n• Third-party monitoring tools — Consider using third-party monitoring tools specifically designed for SQL Server monitoring and management. These tools offer comprehensive monitoring capabilities, customizable dashboards, alerting mechanisms and performance analysis features.\n\nIn addition, configure alerts and notifications to proactively notify administrators about critical events, performance issues and system failures. You can use SQL Server Agent alerts, Database Mail or external monitoring systems to send alerts via email, SMS or other communication channels.\n\nConcurrency issues in SQL Server include deadlocks and blocking. Deadlocks occur when two or more transactions wait for each other to release resources, so none of the transactions can proceed. Blocking occurs when one transaction holds a lock on a resource, preventing other transactions from accessing or modifying it.\n\nThe following strategies can help mitigate the risk of these issues:\n• Minimize transaction duration by breaking down long-running transactions into smaller units to reduce the likelihood of deadlocks.\n• Use proper indexing and query optimization. These options can significantly reduce contention and improve concurrency by minimizing the time and resources required for query execution. Analyze query execution plans, identify performance bottlenecks, and optimize queries and indexes accordingly.\n• Identify and monitor blocking chains using DMVs like sys.dm_exec_requests and sys.dm_tran_locks, and optimize queries and indexes to minimize the duration and scope of locks.\n• Implement row versioning techniques such as snapshot isolation or Read Committed Snapshot Isolation (RCSI).\n• Choose the appropriate isolation level ((e.g., READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE) based on the application requirements and sensitivity to concurrency issues.\n• Use optimistic concurrency control mechanisms, such as row versioning, optimistic locking and timestamp-based concurrency, to reduce contention and improve scalability.\n• Design applications with concurrency in mind, considering factors such as transaction boundaries, data access patterns and error handling.\n\nTo identify and troubleshoot concurrency issues, monitor SQL Server performance metrics like locks, blocking, and deadlock events using tools like SQL Server Profiler, Extended Events, and performance monitoring dashboards.\n\nEstablish a baseline of normal behavior for your SQL Server instance, including CPU usage, memory utilization, disk I/O, locking and blocking events, query execution times, and other relevant performance indicators. Monitor these metrics to capture typical usage patterns and performance characteristics under normal operating conditions and establish threshold values. Be sure to periodically update the baselines and threshold values to account for changes in workload patterns, system configuration, or database schema modifications.\n\nImplement anomaly detection rules to identify deviations from the baselines. This can include simple threshold-based alerts or more advanced statistical methods for anomaly detection. Then, investigate the root causes of the deviations, which can include attacks, resource contention, and application issues.\n\nAudit Access Attempts and Changes to Access Permissions\n\nEnable login auditing in SQL Server and monitor the SQL Server error logs for information about failed and successful login attempts, as well as changes and deletions of database objects containing restricted data.\n\nIn addition, track changes to SQL Server configurations and permissions so you can spot and remediate unwanted changes before you suffer significant damage. This tracking can be done using SQL traces or third-party software like Netwrix Auditor for SQL Server.\n\nEnable the SQL Server Audit feature of SQL Server and specify the events to be audited, such as SELECT, INSERT, UPDATE, DELETE, and EXECUTE. Configure audit log filtering to capture relevant events and minimize the volume of audit data generated.\n\nFor more granular information, use SQL Server Audit to capture database level events such as data access, schema changes and object modifications.\n\nSQL injection is a technique in which an attacker injects malicious SQL code into an application's input fields, forms or queries. As a result, they can steal or modify data, alter database schemas, execute resource-intensive SQL queries that overload the database server, deface websites, and hijack user sessions. Top of Form\n\nThe following techniques can reduce the risk of SQL injection attacks in your applications and databases:\n• Use parameterized queries — Instead of dynamically constructing SQL queries by concatenating user input, use parameterized queries or prepared statements provided by your programming language or ORM framework. Parameterized queries separate SQL code from user input, preventing attackers from injecting malicious SQL code.\n• Require input validation — Validate and sanitize all user-supplied input before using it in SQL queries. Reject input that contains unexpected characters or patterns, such as SQL keywords, special characters or escape sequences. Use whitelisting rather than blacklisting to validate input, as it's more robust against evasion techniques.\n• Parameterize APIs — If you are using APIs to interact with the database, ensure that API parameters are adequately validated and parameterized to prevent SQL injection attacks. Apply input validation and parameterization techniques at the API and database levels.\n• Use stored procedures — Utilize stored procedures to encapsulate database operations. This helps prevent SQL injection by ensuring user input is treated as data, not executable SQL code.\n• Escape special characters — If parameterized queries or prepared statements are not feasible, ensure that special characters in user input are correctly escaped before being included in SQL queries. Use database-specific escape functions or libraries to handle special characters safely.\n• Conduct security testing— Conduct regular security assessments, including code reviews, vulnerability scans and penetration testing, to identify potential injection points and validate input sanitization mechanisms.\n\nIn a side-channel attack, an adversary attempts to gather information or influence the execution of a system by measuring or exploiting its indirect effects, rather than targeting the system. Below are some strategies to mitigate the risk of side-channel attacks.\n• Use well-established cryptographic algorithms and protocols that have undergone rigorous analysis and scrutiny and come from reputable sources such as NIST or IETF. Avoid custom cryptographic implementations.\n• Protect cryptographic keys from unauthorized access or disclosure. Use hardware security modules (HSMs) or trusted execution environments (TEEs) to generate, store and use cryptographic keys securely. Regularly rotate encryption keys and revoke compromised keys to mitigate the impact of key leakage.\n• Use a defense-in-depth approach that combines cryptographic protections with other security measures such as access controls, network segmentation and intrusion detection systems.\n• Use secure memory allocation and deallocation techniques to prevent memory-related side-channel attacks such as memory scraping or timing attacks. Avoid storing sensitive data in memory for longer than necessary and securely wipe memory buffers afterward.\n• Mitigate the risk of timing side-channel attacks Implement constant-time algorithms and data structures. Avoid branching or conditional statements that can leak information through timing discrepancies. Use performance counters or timing-resistant functions to ensure consistent execution time regardless of input or conditions.\n• Implement secure error-handling mechanisms to avoid leaking sensitive information through error messages or exception handling. Use generic error messages that do not reveal details about the internal state or operation of the system.\n• Conduct regular security assessments to identify side-channel vulnerabilities. In addition to performing code reviews, penetration testing, and vulnerability scanning, use tools and techniques specifically designed to detect timing, power consumption, and electromagnetic emanation leaks.\n\nEncrypting data helps keep it secure even if unauthorized users access it, but encryption and decryption operations can introduce overhead and impact database performance. Evaluate the performance impact of encryption on your workload and optimize queries, indexes, and server configurations to mitigate performance bottlenecks.\n\nYou can use several encryption features in SQL Server to protect your data:\n• Transparent data encryption (TDE) — TDE encrypts database files on disk, so it requires minimal changes to applications and queries. However, it does not protect data in memory or during transmission.\n• SQL column-level protection — The Always Encrypted option allows you to encrypt individual columns containing sensitive data, such as credit card details or Social Security numbers, while still allowing the database users to perform operations on the data. The data is encrypted in client applications before being sent to SQL Server and decrypted in the application after retrieval from SQL Server, ensuring the data remains encrypted both at rest and in transit.\n• SQL row-level protection — Row-level security (RLS) enables you to define security policies that specify which rows users can access based on user attributes, session context, or other criteria, allowing fine-grained control over row-level access. You can also create indexes on a subset of rows in a table that meet specified filter criteria. SQL table views can also implement row level security by limiting the rows returned to users based on their permissions. Triggers can enforce row-level security by intercepting data modification operations (e.g., INSERT, UPDATE, DELETE) and applying custom security logic.\n\nSQL Server provides several data masking techniques to obfuscate sensitive information while preserving data integrity and usability for non-production environments. These techniques help prevent unauthorized access to sensitive data during development, testing, or troubleshooting activities.\n\nThe following are some common data masking techniques in SQL Server:\n• Dynamic data masking (DDM) masks sensitive data in real time based on user permissions without modifying the underlying data.\n• Static data masking permanently obfuscates sensitive data in non-production environments while preserving data relationships and characteristics. Static data masking can be applied to entire databases, specific tables or individual columns.\n• Hashing involves transforming sensitive data into irreversible hashed values using cryptographic hash functions such as SHA-256 or MD5. Hashing masks sensitive data by converting it into a fixed-length string that cannot be reversed to obtain the original value. While hashing helps protect passwords and other one-way encrypted data, it is unsuitable for preserving data usability in all scenarios.\n• Subsetting involves extracting a subset of data from a production database for non-production environments. During data extraction, subsetting techniques can mask sensitive data by excluding or obfuscating specific rows or columns.\n• Tokenization replaces sensitive data with randomly generated tokens or placeholders while storing the original data in a secure vault. Tokenization allows you to preserve data relationships and usability while masking sensitive information. Tokenization is commonly used in payment processing and other applications where data security in SQL and compliance are critical.\n• Format-preserving encryption (FPE) encrypts sensitive data while preserving its original format, such as maintaining the same data type, length, and structure. FPE ensures that the masked data remains compatible with existing applications and databases without requiring extensive modifications. FPE techniques can encrypt credit card numbers, Social Security numbers, and other structured data elements.\n\nFor help in evaluating and improving the security posture of your SQL Server environment, consider the following Microsoft tools:\n• Assessment and Planning Toolkit (MAP) is a free tool that helps organizations assess their SQL Server environment's readiness for migration, identify security vulnerabilities, and generate reports with actionable recommendations. The assessment reports cover SQL Server versions, security configurations, and compliance with best practices.\n• Secure Score for SQL Server is a feature of Microsoft Defender for SQL Server (formerly SQL Advanced Threat Protection). It analyzes SQL Server configurations, security settings, and user permissions to identify potential security risks and provides actionable recommendations for improving security posture.\n• SQL Server Vulnerability Assessment (SSVA)is a feature of SQL Server Management Studio (SSMS) that helps identify security vulnerabilities in SQL Server databases. It performs automated checks against a predefined set of security best practices and recommendations and provides detailed findings and remediation steps."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/security/sql-server-security-best-practices?view=sql-server-ver16",
        "document": "This article provides information about best practices and guidelines that help establish security for SQL Server. For a comprehensive review of SQL Server security features, see Securing SQL Server.\n\nFor specific product security best practices, see Azure SQL Database and SQL Managed Instance and SQL Server on Azure VMs.\n\nA layered security methodology provides a defense-in-depth solution by using multiple security capabilities targeted at different security scopes. The security features made available in SQL Server 2016, and improved in subsequent releases, help counter security threats and provide well-secured database applications.\n\nAzure complies with several industry regulations and standards that can enable you to build a compliant solution with SQL Server running in a virtual machine. For information about regulatory compliance with Azure, see Azure Trust Center.\n\nOrganizations often need to protect data at the column level as data regarding customers, employees, trade secrets, product data, healthcare, financial, and other sensitive data is often stored in SQL Server databases. Sensitive columns often include identification/social security numbers, mobile phone numbers, first name, family name, financial account identification, and any other data that could be deemed personal data.\n\nThe methods and features mentioned in this section raise the level of protection at the column level with minimal overhead, and without requiring extensive changes to application code.\n\nUse Always Encrypted to encrypt data at rest and over the wire. Encrypted data is only decrypted by client libraries at the application client level. Use randomized encryption over deterministic where possible. Always Encrypted with secure enclaves can improve performance for comparison operations such as BETWEEN, IN, LIKE, DISTINCT, Joins, and more for randomized encryption scenarios.\n\nUse Dynamic Data Masking (DDM) to obfuscate data at the column level when Always Encrypted isn't an available option. Dynamic Data Masking (DDM) isn't compatible with Always Encrypted. Use Always Encrypted over dynamic data masking whenever possible.\n\nYou can also GRANT permissions at the column level to a table, view, or table-valued function. Consider the following: - Only , , and permissions can be granted on a column. - A table-level doesn't take precedence over a column-level .\n\nRow-Level Security (RLS) enables the ability to use user execution context in order to control access to rows in a database table. RLS ensures that users can only see the record that pertains to them. This gives your application 'record level' security without having to make significant changes to your application.\n\nThe business logic is encapsulated within table-valued functions controlled by a security policy that toggles the RLS functionality on and off. The security policy also controls the and predicates that are bound to the tables RLS operates against. Use Row-Level Security (RLS) to limit the records that are returned to the user making the call. Use SESSION_CONTEXT (T-SQL) for users who connect to the database through a middle-tier application where application users share the same SQL Server user account. For optimal performance and manageability, follow the Row-Level Security best practices.\n\nTransparent Data Encryption (TDE) protects the data at the file level by providing encryption-at-rest to the database files. Transparent Data Encryption (TDE) ensures that database files, backup files, and files can't be attached and read without proper certificates decrypting database files. Without Transparent Data Encryption (TDE), it's possible for an attacker to take the physical media (drives or backup tapes) and restore or attach the database to read the contents. Transparent Data Encryption (TDE) is supported to work with all other security capabilities in SQL Server. Transparent Data Encryption (TDE) provides real-time I/O encryption and decryption of the data and log files. TDE encryption uses a database encryption key (DEK) is stored in the user database. The database encryption key can also be protected using a certificate, which is protected by the database master key of the database.\n\nUse TDE to protect data at rest, backups, and .\n\nTo audit SQL Server, create an audit policy at either the server or database level. Server policies apply to all existing and newly created databases on the server. For simplicity, enable server-level auditing and allow the database-level auditing to inherit the server-level property for all databases.\n\nAudit tables and columns with sensitive data that have security measures applied to them. If a table or column is important enough to need protection by a security capability, then it should be considered important enough to audit. It's especially important to audit and regularly review tables that contain sensitive information but where it's not possible to apply desired security measures due to some kind of application or architectural limitation.\n\nSQL Server supports two authentication modes, Windows authentication mode and 'SQL Server and Windows Authentication mode' (mixed mode).\n\nLogins are separate from database users. First, map logins or Windows groups to database users or roles separately. Next, grant permissions to users, server roles, and/or database roles to access database objects.\n\nSQL Server supports the following types of logins:\n• A local Windows user account or Active Directory domain account - SQL Server relies on Windows to authenticate the Windows user accounts.\n• Windows group - Granting access to a Windows group grants access to all Windows user logins that are members of the group. Removing a user from a group removes the rights from the user that came from the group. Group membership is the preferred strategy.\n• SQL Server login - SQL Server stores the username and a hash of the password in the database.\n• Contained database users authenticate SQL Server connections at the database level. A contained database is a database that is isolated from other databases and from the instance of SQL Server (and the database) that hosts the database. SQL Server supports contained database users for both Windows and SQL Server authentication.\n\nThe following recommendations and best practices help secure your identities and authentication methods:\n• \n• It's standard to place Active Directory users in AD groups, AD groups should exist in SQL Server roles, and SQL Server roles should be granted the minimum permissions required by the application.\n• None In Azure, use least-privilege security by using role-based access (RBAC) controls\n• None Choose Active Directory over SQL Server authentication whenever possible, and especially choose Active Directory over storing the security at the application or database level.\n• If a user leaves the company, it's easy to disable the account.\n• It's also easy to remove users from groups when users change roles or leave the organization. Group security is considered a best practice.\n• None Use multifactor authentication for accounts that have machine-level access, including accounts that use RDP to log into the machine. This helps guard against credential theft or leaks, as single-factor password-based authentication is a weaker form of authentication with credentials at risk of being compromised or mistakenly given away.\n• None Require strong and complex passwords that can't be easily guessed, and aren't used for any other accounts or purposes. Regularly update passwords and enforce Active Directory policies.\n• None Group-Managed Service Accounts (gMSA) provide automatic password management, simplified service principal name (SPN) management and delegate the management to other administrators.\n• With gMSA, the Windows operating system manages passwords for the account instead of relying on the administrator to manage the password.\n• gMSA reduces the administrative surface-level and improves the separation of duties.\n• None Minimize the rights granted to the AD account of the DBA; Consider a separation of duties that limit access to the virtual machine, the ability to log into the operating system, the ability to modify error and auditing logs, and the ability to install applications and/or features.\n• None Consider removing DBA accounts from the sysadmin role and granting CONTROL SERVER to DBA accounts rather than making them a member of the sysadmin role. The system admin role doesn't respect while CONTROL SERVER does.\n\nKeeping historical records of data changes over time can be beneficial to address accidental changes to the data. It can also be useful for application-change auditing and can recover data elements when a bad actor introduces data changes that weren't authorized.\n• Use temporal tables to preserve record versions over time, and to see data as it was over the record's life span to provide a historical view of your application's data.\n• Temporal Tables can be used to supply a version of the current table at any point in time.\n\nThe following configuration and assessment tools address surface-area security, identify data security opportunities, and provide a best practice assessment of the security of your SQL Server environment at the instance level.\n• Surface area configuration - You should enable only the features required by your environment, to minimize the number of features that can be attacked by a malicious user.\n• Vulnerability assessment for SQL Server (SSMS) - SQL vulnerability assessment is a tool in SSMS v17.4+ that helps discover, track, and remediate potential database vulnerabilities. The vulnerability assessment is a valuable tool to improve your database security and is executed at the database level, per database.\n• SQL Data Discovery and Classification (SSMS) - It's common for DBAs to manage servers and databases and not be aware of sensitivity of the data that is contained in the database. Data Discovery & Classification adds the capability to discover, classify, label, and report on the sensitivity level of your data. Data Discovery & Classification is supported starting with SSMS 17.5.\n\nIt helps to know what are some common threats that risk SQL Server:\n• SQL injection - SQL injection is a type of attack where malicious code is inserted into strings that are passed to an instance of SQL Server for execution.\n• The injection process works by terminating a text string and appending a new command. Because the inserted command might have more strings appended to it before it executes, the attacker terminates the injected string with a comment mark .\n• SQL Server executes any syntactically valid query that is received.\n• Be aware of Side-channel attacks, malware & other threats.\n\nTo minimize the risk of a SQL injection, consider the following items:\n• Review any SQL process that constructs SQL statements for injection vulnerabilities.\n• Developers and security admins should review all code that calls , , or .\n• Disallow the following input characters:\n• : Catalog-extended stored procedures, such as .\n• It isn't recommended to use on any SQL Server environment. Use SQLCLR instead, or look for other alternatives due to the risks can introduce.\n• Always validate user inputs and scrub error outputs from being spilled and exposed to the attacker.\n\nTo minimize the risk of a side-channel attack, consider the following:\n• Ensure the latest application and operating system patches are applied.\n• For hybrid workloads, ensure the latest firmware patches are applied for any hardware on-premises.\n• In Azure, for highly sensitive applications and workloads, you can add additional protection against side-channel attacks with isolated virtual machines, dedicated hosts, or by using Confidential Compute virtual machines such as the DC-series and Virtual Machines that use 3rd Gen AMD EPYC processors.\n\nConsider the following common infrastructure threats:\n• Brute force access - the attacker attempts to authenticate with multiple passwords on different accounts until a correct password is found.\n• Password cracking / password spray - attackers try a single carefully crafted password against all of the known user accounts (one password to many accounts). If the initial password spray fails, they try again, utilizing a different carefully crafted password, normally waiting a set amount of time between attempts to avoid detection.\n• Ransomware attacks is a type of targeted attack where malware is used to encrypt data and files, preventing access to important content. The attackers then attempt to extort money from victims, usually in the form of cryptocurrencies, in exchange for the decryption key. Most ransomware infections start with email messages with attachments that try to install ransomware, or websites hosting exploit kits that attempt to use vulnerabilities in web browsers and other software to install ransomware.\n\nSince you don't want attackers to easily guess account names, or passwords, the following steps help reduce the risk of passwords being discovered:\n• Use complex strong passwords for all your accounts. For more information about how to create a strong password, see Create a strong password article.\n• By default, Azure selects Windows Authentication during SQL Server virtual machine setup. Therefore, the SA login is disabled and a password is assigned by setup. We recommend that the SA login shouldn't be used or enabled. If you must have a SQL login, use one of the following strategies:\n• None Create a SQL account with a unique name that has sysadmin membership. You can do this from the portal by enabling SQL Authentication during provisioning. If you don't enable SQL Authentication during provisioning, you must manually change the authentication mode to SQL Server and Windows Authentication Mode. For more information, see Change server authentication mode.\n• None If you must use the SA login, enable the login after provisioning and assign a new strong password.\n\nConsider the following to minimize ransomware risks:\n• The best strategy to guard against ransomware is to pay particular attention to RDP and SSH vulnerabilities. Additionally, consider the following recommendations:\n• Use firewalls and lock down ports\n• Ensure the latest operating system and application security updates are applied\n• Improve Surface Area Security by avoiding installing tools including sysinternals and SSMS on the local machine\n• Additionally, there should be a regular full backup scheduled that is separately secured from a common administrator account so it can't delete copies of the databases."
    },
    {
        "link": "https://datasturdy.com/understanding-sql-server-linked-servers",
        "document": "SQL Server is a powerful relational database management system (RDBMS) that allows users to store and manage data in highly structured formats. However, modern applications often require data to be pulled from various data sources, not just SQL Server databases, but also Oracle databases, Excel files, or other external sources. Linked Servers in SQL Server offer a solution to this challenge by enabling SQL Server to interact with external data sources as if they were local databases.\n\nIn this blog, we will explore Linked Servers in SQL Server, how to set them up, and the best practices for querying and managing external data sources.\n\nA Linked Server in SQL Server is a configuration that allows SQL Server to connect to and query external data sources such as other SQL Servers, Oracle databases, Excel spreadsheets, or even other RDBMS systems. Essentially, it is a way of creating an alias for an external data source within SQL Server, enabling you to run queries on that external data as if it were part of your SQL Server instance.\n\nA linked server can point to various types of external data sources:\n\nWhen we set up a linked server, SQL Server creates a connection to an external data source, and we can then use the fully qualified four-part name to reference the external data. This four-part naming convention consists of:\n• LinkedServerName: The name we assign to the linked server.\n• DatabaseName: The database we’re querying on the linked server.\n• SchemaName: The schema of the object (typically dbo).\n• ObjectName: The table or view we want to query.\n\nFor example, if we have a linked server named OracleDB and we want to query the Employees table in the HR database, query would look like this:\n\nSetting up a linked server involves a few steps that we can do through SQL Server Management Studio (SSMS) or T-SQL. Here’s how to configure a linked server.\n• Navigate to the Linked Servers Section:\n• In the Object Explorer, expand the Server Objects node.\n• Right-click on the Linked Servers folder and select New Linked Server.\n• Configure Linked Server:\n• General Tab: Enter the name of the linked server in the Linked server field.\n• Choose the Server type. For example, if you’re linking to another SQL Server, select SQL Server.\n• Data Source: For an SQL Server linked server, enter the network name or IP address of the server you’re linking to.\n• Security Tab: Choose how to authenticate when connecting to the linked server. You can map local SQL Server logins to remote logins.\n• Server Options: You can configure additional options such as collation compatibility and RPC settings.\n• Click OK to create the linked server.\n\nOnce the linked server is set up, we can query data from it using the four-part naming convention. Here’s an example for querying data from a linked SQL Server:\n\nWe can also use the OPENQUERY function for querying linked servers. This method sends the query directly to the linked server and returns the result set.\n\nUsing OPENQUERY can sometimes improve performance by offloading the query execution to the linked server.\n\nWhile linked servers are a powerful feature, it’s important to follow best practices to ensure optimal performance and reliability.\n• Limit Cross-Server Joins: While cross-server joins are possible, they can significantly degrade performance, especially when large datasets are involved. Try to limit the use of linked servers in joins and keep operations on the same server when possible.\n• Use OPENQUERY for Complex Queries: When querying a linked server, use OPENQUERY to minimize the overhead of translating the query from SQL Server to the linked server. This can improve performance, especially for complex queries.\n• Handle Errors Gracefully: Linked server queries can fail for various reasons (e.g., network issues, server unavailability). Implement error handling using TRY…CATCH blocks to handle these cases gracefully.\n• Monitor Linked Server Performance: Regularly monitor the performance of queries using linked servers, as they can affect overall SQL Server performance. Use SQL Server Profiler and Extended Events to identify bottlenecks in cross-server queries.\n• Security Considerations: Be careful with user permissions. Always adhere to the Principle of Least Privilege, and avoid granting unnecessary permissions on linked servers. Use specific SQL Server logins for linked server authentication to minimize the risk of unauthorized access.\n• Avoid Overusing Linked Servers: Linked servers should be used selectively, as overuse can result in performance degradation. Consider using other solutions such as ETL (Extract, Transform, Load) tools like SSIS for data movement.\n\nSQL Server Linked Servers are an essential tool for integrating external data sources with SQL Server instance. By setting up linked servers, we can query and interact with remote databases, applications, or even flat files, directly from your SQL Server environment.\n\nHowever, it’s important to use them judiciously, keeping in mind performance implications and best practices. By following the setup instructions, utilizing best practices, and troubleshooting effectively, we can successfully leverage linked servers to create a more powerful and integrated SQL Server environment."
    }
]