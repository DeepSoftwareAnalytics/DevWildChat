[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/http/file-uploads",
        "document": "When Django handles a file upload, the file data ends up placed in (for more on the object see the documentation for request and response objects). This document explains how files are stored on disk and in memory, and how to customize the default behavior.\n\nA view handling this form will receive the file data in , which is a dictionary containing a key for each (or , or other subclass) in the form. So the data from the above form would be accessible as . Note that will only contain data if the request method was , at least one file field was actually posted, and the that posted the request has the attribute . Otherwise, will be empty. Most of the time, you’ll pass the file data from into the form as described in Binding uploaded files to a form. This would look something like: Notice that we have to pass into the form’s constructor; this is how file data gets bound into a form. Here’s a common way you might handle an uploaded file: Looping over instead of using ensures that large files don’t overwhelm your system’s memory. There are a few other methods and attributes available on objects; see for a complete reference. If you’re saving a file on a with a , using a makes this process much easier. The file object will be saved to the location specified by the argument of the corresponding when calling : If you are constructing an object manually, you can assign the file object from to the file field in the model: If you are constructing an object manually outside of a request, you can assign a like object to the : If you want to upload multiple files using one form field, create a subclass of the field’s widget and set its class attribute to . In order for such files to be all validated by your form (and have the value of the field include them all), you will also have to subclass . See below for an example. Django is likely to have a proper multiple file field support at some point in the future. Then override the method of your subclass to handle multiple file uploads: # Replace with your URL or reverse(). # Do something with each file. This will allow you to handle multiple files at the form level only. Be aware that you cannot use it to put multiple files on a single model instance (in a single field), for example, even if the custom widget is used with a form field related to a model .\n\nWhen a user uploads a file, Django passes off the file data to an upload handler – a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the setting, which defaults to: Together and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. You can write custom handlers that customize how Django handles files. You could, for example, use custom handlers to enforce user-level quotas, compress data on the fly, render progress bars, and even send data to another storage location directly without storing it locally. See Writing custom upload handlers for details on how you can customize or completely replace upload behavior. Before you save uploaded files, the data needs to be stored somewhere. By default, if an uploaded file is smaller than 2.5 megabytes, Django will hold the entire contents of the upload in memory. This means that saving the file involves only a read from memory and a write to disk and thus is very fast. However, if an uploaded file is too large, Django will write the uploaded file to a temporary file stored in your system’s temporary directory. On a Unix-like platform this means you can expect Django to generate a file called something like . If an upload is large enough, you can watch this file grow in size as Django streams the data onto disk. These specifics – 2.5 megabytes; ; etc. – are “reasonable defaults” which can be customized as described in the next section. There are a few settings which control Django’s file upload behavior. See File Upload Settings for details. Sometimes particular views require different upload behavior. In these cases, you can override upload handlers on a per-request basis by modifying . By default, this list will contain the upload handlers given by , but you can modify the list as you would any other list. For instance, suppose you’ve written a that provides feedback on upload progress to some sort of AJAX widget. You’d add this handler to your upload handlers like this: You’d probably want to use in this case (instead of ) because a progress bar handler would need to run before any other handlers. Remember, the upload handlers are processed in order. If you want to replace the upload handlers completely, you can assign a new list: You can only modify upload handlers before accessing or – it doesn’t make sense to change upload handlers after upload handling has already started. If you try to modify after reading from or Django will throw an error. Thus, you should always modify uploading handlers as early in your view as possible. Also, is accessed by which is enabled by default. This means you will need to use on your view to allow you to change the upload handlers. You will then need to use on the function that actually processes the request. Note that this means that the handlers may start receiving the file upload before the CSRF checks have been done. Example code: If you are using a class-based view, you will need to use on its method and on the method that actually processes the request. Example code:"
    },
    {
        "link": "https://stackoverflow.com/questions/8249042/uploading-large-files-with-python-django",
        "document": "Django will by default, put uploaded file data into memory if it is less than 2.5MB. Anything larger will be written to the server's directory and then copied across when the transfer completes. Many of Django's file upload settings can be customised, details are available in the documentation. You can also customise the file handling and you'll certainly want to do this.\n\nBefore we consider any technical constraints, uploading such large files with the browser will give the user a very poor experience. There is no feedback about how the transfer is going (although google chrome does display the upload status as a percentage) and no way to pause or resume transfers.\n\nYou are also likely to run into problems on the server. Apart from the extremely long time that each thread will be taken with dealing with the streamed data, you have the time it takes for the system to copy the resulting file from to its correct location.\n\nUnless you are very confident that you can foresee any problem that the server might have with the uploads, I would suggest that this is a bad idea. It's pretty hard to find any information on this via google and there do seem to be a lot of hits that describe problems with large file uploads.\n\nWhile Django is technically capable of receiving uploaded files this large, the very poor user experience and technical difficulties mean this may not be the best approach. Have you considered using dedicated software to handle the file transfer?"
    },
    {
        "link": "https://medium.com/codex/practical-guide-to-file-uploads-in-django-with-real-world-examples-6fdedcfc6249",
        "document": "Uploading files is a common task for web applications, and Django makes it straightforward. Whether it’s a profile picture, a PDF, or a batch of documents, Django’s built-in tools can handle file uploads securely and efficiently.\n\nThis guide explores file uploads using Django’s , , custom upload handlers, and best practices through practical, real-world examples.\n\nLet’s start with a scenario familiar to most: uploading a user profile picture. Imagine a social media platform where users can upload and update their profile pictures.\n\nWe create a simple form with a to handle the upload:\n\nStep 2: Handling the File Upload in the View\n\nThe view will process the form, save the file to a specific directory, and store the file’s path in the user’s profile."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/files",
        "document": "This document describes Django’s file access APIs for files such as those uploaded by a user. The lower level APIs are general enough that you could use them for other purposes. If you want to handle “static files” (JS, CSS, etc.), see How to manage static files (e.g. images, JavaScript, CSS).\n\nBy default, Django stores files locally, using the and settings. The examples below assume that you’re using these defaults.\n\nHowever, Django provides ways to write custom file storage systems that allow you to completely customize where and how Django stores files. The second half of this document describes how these storage systems work.\n\nWhen you use a or , Django provides a set of APIs you can use to deal with that file. Consider the following model, using an to store a photo: Any instance will have a attribute that you can use to get at the details of the attached photo: This object – in the example – is a object, which means it has all the methods and attributes described below. The file is saved as part of saving the model in the database, so the actual file name used on disk cannot be relied on until after the model has been saved. For example, you can change the file name by setting the file’s to a path relative to the file storage’s location ( if you are using the default ): # Move the file on the filesystem To save an existing file on disk to a : While non-image data attributes, such as , , and are available on the instance, the underlying image data cannot be used without reopening the image. For example:\n\nInternally, Django uses a instance any time it needs to represent a file. Most of the time you’ll use a that Django’s given you (i.e. a file attached to a model as above, or perhaps an uploaded file). If you need to construct a yourself, the easiest way is to create one using a Python built-in object: Now you can use any of the documented attributes and methods of the class. Be aware that files created in this way are not automatically closed. The following approach may be used to close files automatically: # Create a Python file object using open() and the with statement Closing files is especially important when accessing file fields in a loop over a large number of objects. If files are not manually closed after accessing them, the risk of running out of file descriptors may arise. This may lead to the following error:\n\nBehind the scenes, Django delegates decisions about how and where to store files to a file storage system. This is the object that actually understands things like file systems, opening and reading files, etc. Django’s default file storage is . If you don’t explicitly provide a storage system in the key of the setting, this is the one that will be used. See below for details of the built-in default file storage system, and see How to write a custom storage class for information on writing your own file storage system. Though most of the time you’ll want to use a object (which delegates to the proper storage for that file), you can use file storage systems directly. You can create an instance of some custom file storage class, or – often more useful – you can use the global default storage system: See File storage API for the file storage API. For example, the following code will store uploaded files under regardless of what your setting is: Custom storage systems work the same way: you can pass them in as the argument to a . You can use a callable as the parameter for or . This allows you to modify the used storage at runtime, selecting different storages for different environments, for example. Your callable will be evaluated when your models classes are loaded, and must return an instance of . In order to set a storage defined in the setting you can use :"
    },
    {
        "link": "https://stackoverflow.com/questions/78995179/what-is-the-best-way-to-handle-potentially-large-file-uploads-in-django",
        "document": "I've been reading the django docs and posts here on stackoverflow but still not sure how to. So far this is my code:\n\nThis is what I've been working with but I've been reading that it is better to handle uploads as chunks so that large files don't overwhelm the website.\n\nThe website uploads to directly DigitalOcean Spaces with no files stored on the server and the maximum file upload size allowed by my website is 10GB if that is important."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/forms/modelforms",
        "document": "Like regular formsets, Django provides a couple of enhanced formset classes to make working with Django models more convenient. Let’s reuse the model from above: Using restricts the formset to use only the given fields. Alternatively, you can take an “opt-out” approach, specifying which fields to exclude: This will create a formset that is capable of working with the data associated with the model. It works just like a regular formset: uses to generate formsets. This means that a model formset is an extension of a basic formset that knows how to interact with a particular model. When using multi-table inheritance, forms generated by a formset factory will contain a parent link field (by default ) instead of an field. By default, when you create a formset from a model, the formset will use a queryset that includes all objects in the model (e.g., ). You can override this behavior by using the argument: Alternatively, you can create a subclass that sets in : Then, pass your class to the factory function: If you want to return a formset that doesn’t include any preexisting instances of the model, you can specify an empty QuerySet: By default, when you use , a model form will be created using . Often, it can be useful to specify a custom model form. For example, you can create a custom model form that has custom validation: # custom validation for the name field Then, pass your model form to the factory function: It is not always necessary to define a custom model form. The function has several arguments which are passed through to , which are described below. Specifying widgets to use in the form with ¶ Using the parameter, you can specify a dictionary of values to customize the ’s widget class for a particular field. This works the same way as the dictionary on the inner class of a works: Using the parameter, you can enable localization for fields in the form. If is set to the special value , all fields will be localized. As with regular formsets, it’s possible to specify initial data for forms in the formset by specifying an parameter when instantiating the model formset class returned by . However, with model formsets, the initial values only apply to extra forms, those that aren’t attached to an existing model instance. If the length of exceeds the number of extra forms, the excess initial data is ignored. If the extra forms with initial data aren’t changed by the user, they won’t be validated or saved. As with a , you can save the data as a model object. This is done with the formset’s method: # Assuming all is valid, save the data. The method returns the instances that have been saved to the database. If a given instance’s data didn’t change in the bound data, the instance won’t be saved to the database and won’t be included in the return value ( , in the above example). When fields are missing from the form (for example because they have been excluded), these fields will not be set by the method. You can find more information about this restriction, which also holds for regular , in Selecting the fields to use. # do something with instance This gives you the ability to attach data to the instances before saving them to the database. If your formset contains a , you’ll also need to call to ensure the many-to-many relationships are saved properly. After calling , your model formset will have three new attributes containing the formset’s changes: As with regular formsets, you can use the and parameters to to limit the number of extra forms displayed. does not prevent existing objects from being displayed: Also, doesn’t prevent creation of new model instances as you can add additional forms with JavaScript or send additional POST data. See Preventing new objects creation on how to do this. If the value of is greater than the number of existing related objects, up to additional blank forms will be added to the formset, so long as the total number of forms does not exceed : A value of (the default) puts a high limit on the number of forms displayed (1000). In practice this is equivalent to no limit. Using the parameter, you can prevent creation of any new objects: Here, the formset will only edit existing instances. No other objects will be created or edited. Model formsets are very similar to formsets. Let’s say we want to present a formset to edit model instances: As you can see, the view logic of a model formset isn’t drastically different than that of a “normal” formset. The only difference is that we call to save the data into the database. (This was described above, in Saving objects in the formset.) Just like with , by default the method of a will validate that none of the items in the formset violate the unique constraints on your model (either , or ). If you want to override the method on a and maintain this validation, you must call the parent class’s method: # example custom validation across forms in the formset Also note that by the time you reach this step, individual model instances have already been created for each . Modifying a value in is not sufficient to affect the saved value. If you wish to modify a value in you must modify : As stated earlier, you can override the default queryset used by the model formset: Note that we pass the argument in both the and cases in this example. Using the formset in the template¶ There are three ways to render a formset in a Django template. First, you can let the formset do most of the work: Second, you can manually render the formset, but let the form deal with itself: When you manually render the forms yourself, be sure to render the management form as shown above. See the management form documentation. Third, you can manually render each field: If you opt to use this third method and you don’t iterate over the fields with a loop, you’ll need to render the primary key field. For example, if you were rendering the and fields of a model: Notice how we need to explicitly render . This ensures that the model formset, in the case, will work correctly. (This example assumes a primary key named . If you’ve explicitly defined your own primary key that isn’t called , make sure it gets rendered.)\n\nInline formsets is a small abstraction layer on top of model formsets. These simplify the case of working with related objects via a foreign key. Suppose you have these two models: If you want to create a formset that allows you to edit books belonging to a particular author, you could do this: ’s prefix is ( ). If ’s to has a , that’s used instead. When overriding methods on , you should subclass rather than . For example, if you want to override : # example custom validation across forms in the formset See also Overriding clean() on a ModelFormSet. Then when you create your inline formset, pass in the optional argument : More than one foreign key to the same model¶ If your model contains more than one foreign key to the same model, you’ll need to resolve the ambiguity manually using . For example, consider the following model: To resolve this, you can use to : Using an inline formset in a view¶ You may want to provide a view that allows a user to edit the related objects of a model. Here’s how you can do that: # Do something. Should generally end with a redirect. For example: Notice how we pass in both the and cases. Specifying widgets to use in the inline form¶ uses and passes most of its arguments to . This means you can use the parameter in much the same way as passing it to . See Specifying widgets to use in the form with widgets above."
    },
    {
        "link": "https://stackoverflow.com/questions/657607/setting-the-selected-value-on-a-django-forms-choicefield",
        "document": "Note: This answer is quite comprehensive and focuses on both static and dynamic initial values as this Q/A comes up for searches related to dynamic changing of initial value, and I believe that the information below will be of great use to junior programmers.\n\nHow to set the initial value\n\nThere are multiple options how to set the initial value of a (or any other field, e.g. ). The various options can be\n• form-dynamic (i.e. initial value can be calculated/changed in the form constructor in ),\n• view-dynamic (i.e. initial value can be calculated/changed in the ).\n\nAll of the options presented below can be combined, but beware of the initial value precedences!\n\nOption A - Static initial value defined in the class\n\nYou can set the initial value right in the definition of the field in the form class. This option is only static.\n\nYou can set the initial value when creating a form instance. This option can be static or form-dynamic.\n\nYou could also use instead of but this is not recommened unless you want the initial value to be overridable.\n\nOption C - Initial value in the form call\n\nYou can set the initial value in the arguments of the form call. This option can be static or view-dynamic.\n\nYou can also send the initial value as a keyword argument (kwarg) to the form constructor, and then use this kwarg as the initial value. This option can be static, form-dynamic or view-dynamic.\n\nNote: Lines 4 to 7 can be simplified to\n\nYou can create the form as a bound form and pass the initial value as the data for the bound form. This option can be static or view-dynamic.\n\nFor more about bound and unbound forms see Django docs.\n\nNote that the initial value refers to the key of the item to be selected, not its index nor display text - see this answer. So, if you had this list of choices\n\nand wanted to set as the initial value, you would use"
    },
    {
        "link": "https://stackoverflow.com/questions/20012533/how-to-choose-the-value-and-label-from-django-modelchoicefield-queryset",
        "document": "I was trying to create a django form and one of my field contain a ModelChoiceField\n\nWhen I try the code above what it return as an html ouput is\n\non my Person Model I have the fields \"id, fname, lname, is_active\" . Is it possible to specify that my dropdown option will use \"id\" as the value and \"lname\" as the label? The expected html should be"
    },
    {
        "link": "https://vindevs.com/blog/how-to-use-django-field-choices-with-code-examples-p60",
        "document": "Django provides a powerful framework for defining models and their associated fields. One of the useful features is the ability to define \"choices\" for a field, which limits the possible values that can be assigned to that field. This feature is particularly helpful for fields like status indicators, categories, or any field where you want to constrain the options to a predefined set.\n\nDjango models are the foundation of any Django project, allowing developers to define the structure of the database through Python code. Each field in a model represents a column in a database table.\n\nThe option in a Django model field restricts the set of allowed values for that field to a predefined list. Each choice is a tuple, where the first element is the actual value stored in the database, and the second element is the human-readable name displayed in forms and the Django admin.\n\nThe most common way to define choices in Django is by using tuples. Each choice is represented as a tuple where: - The first element is the value stored in the database. - The second element is the human-readable label.\n\nStarting from Django 3.0, you can also use Python classes to define choices. This method is more robust and readable.\n\nIn this example, the field will only accept the values , , or . When rendered in a form, these values will appear as \"Not Started\", \"In Progress\", and \"Done\" respectively.\n• Use meaningful constants for the choices to avoid magic numbers or strings.\n• Keep the choices tuples or enums well-organized and readable.\n• Consider using Django's for internationalization of choice labels.\n\nDjango provides a handy method called for model instances to retrieve the human-readable name of the choice.\n\nIn a Django template, you can use the method to display the choice's label:\n\nWhen you use choices in a model, Django automatically generates a select input in forms. Here's how it looks:\n\nIf you want more control over the form field, you can explicitly define a :\n\nIn the Django admin, choice fields automatically render as dropdowns, making it easy to select an option.\n\nYou can customize how the choices are displayed in the Django admin by using the attribute and methods like .\n\nYou can filter and query your models based on the choice field values.\n\nDjango's admin interface allows you to add filters for choice fields easily.\n\nIf needed, you can create custom validators to enforce additional rules on choice fields.\n\nCustom validation logic can be used to ensure that only specific choices are allowed under certain conditions.\n\nYou can dynamically extend choices based on some conditions or user input.\n\nYou can override the default choices by modifying the attribute at runtime.\n\nTo make your application multilingual, use Django’s translation utilities:\n• Always use for choice labels.\n• Ensure that your translations are accurate and culturally appropriate.\n\nWhen working with Django REST Framework (DRF), you can serialize choice fields easily:\n\ncan include the human-readable choice label in your API response by overriding the serializer methods.\n\nUnit tests are essential to ensure that your choice fields behave as expected:\n\nMake sure to test edge cases, such as invalid choices or dynamically added choices.\n\n13. Common Mistakes and How to Avoid Them\n• Hardcoding Choices: Avoid hardcoding choices outside of your models.\n• Invalid Choices: Ensure that the choice values stored in the database are valid.\n• Use Django's framework to validate your models.\n• Ensure that your migrations reflect the latest changes to choices.\n\nYou can generate choices dynamically based on external data or user input.\n\nChoices can be related to other model fields, providing more complex data relationships.\n\nDjango's field option is a powerful feature that ensures data integrity and provides an intuitive interface for users. Whether you're working with static or dynamic choices, it's essential to follow best practices for maintainability and scalability.\n• Use constants or enums for defining choices.\n• Integrate choices seamlessly into your forms, admin, and APIs.\n• Test thoroughly to ensure that all choice-related functionality works as expected."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Forms",
        "document": "An HTML Form is a group of one or more fields/widgets on a web page, which can be used to collect information from users for submission to a server. Forms are a flexible mechanism for collecting user input because there are suitable widgets for entering many different types of data, including text boxes, checkboxes, radio buttons, date pickers and so on. Forms are also a relatively secure way of sharing data with the server, as they allow us to send data in requests with cross-site request forgery protection. While we haven't created any forms in this tutorial so far, we've already encountered them in the Django Admin site — for example, the screenshot below shows a form for editing one of our Book models, comprised of a number of selection lists and text editors. Working with forms can be complicated! Developers need to write HTML for the form, validate and properly sanitize entered data on the server (and possibly also in the browser), repost the form with error messages to inform users of any invalid fields, handle the data when it has successfully been submitted, and finally respond to the user in some way to indicate success. Django Forms take a lot of the work out of all these steps, by providing a framework that lets you define forms and their fields programmatically, and then use these objects to both generate the form HTML code and handle much of the validation and user interaction. In this tutorial, we're going to show you a few of the ways you can create and work with forms, and in particular, how the generic editing views can significantly reduce the amount of work you need to do to create forms to manipulate your models. Along the way, we'll extend our LocalLibrary application by adding a form to allow librarians to renew library books, and we'll create pages to create, edit and delete books and authors (reproducing a basic version of the form shown above for editing books).\n\nFirst, a brief overview of HTML Forms. Consider a simple HTML form, with a single text field for entering the name of some \"team\", and its associated label: The form is defined in HTML as a collection of elements inside tags, containing at least one element of . <form action=\"/team_name_url/\" method=\"post\"> <label for=\"team_name\">Enter name: </label> <input id=\"team_name\" type=\"text\" name=\"name_field\" value=\"Default name for team.\" /> <input type=\"submit\" value=\"OK\" /> </form> While here we just have one text field for entering the team name, a form may have any number of other input elements and their associated labels. The field's attribute defines what sort of widget will be displayed. The and of the field are used to identify the field in JavaScript/CSS/HTML, while defines the initial value for the field when it is first displayed. The matching team label is specified using the tag (see \"Enter name\" above), with a field containing the value of the associated . The input will be displayed as a button by default. This can be pressed to upload the data in all the other input elements in the form to the server (in this case, just the field). The form attributes define the HTTP used to send the data and the destination of the data on the server ( ):\n• : The resource/URL where data is to be sent for processing when the form is submitted. If this is not set (or set to an empty string), then the form will be submitted back to the current page URL.\n• : The HTTP method used to send the data: post or get.\n• The method should always be used if the data is going to result in a change to the server's database, because it can be made more resistant to cross-site forgery request attacks.\n• The method should only be used for forms that don't change user data (for example, a search form). It is recommended for when you want to be able to bookmark or share the URL. The role of the server is first to render the initial form state — either containing blank fields or pre-populated with initial values. After the user presses the submit button, the server will receive the form data with values from the web browser and must validate the information. If the form contains invalid data, the server should display the form again, this time with user-entered data in \"valid\" fields and messages to describe the problem for the invalid fields. Once the server gets a request with all valid form data, it can perform an appropriate action (such as: saving the data, returning the result of a search, uploading a file, etc.) and then notify the user. As you can imagine, creating the HTML, validating the returned data, re-displaying the entered data with error reports if needed, and performing the desired operation on valid data can all take quite a lot of effort to \"get right\". Django makes this a lot easier by taking away some of the heavy lifting and repetitive code!\n\nThe class is the heart of Django's form handling system. It specifies the fields in the form, their layout, display widgets, labels, initial values, valid values, and (once validated) the error messages associated with invalid fields. The class also provides methods for rendering itself in templates using predefined formats (tables, lists, etc.) or for getting the value of any element (enabling fine-grained manual rendering). The declaration syntax for a is very similar to that for declaring a , and shares the same field types (and some similar parameters). This makes sense because in both cases we need to ensure that each field handles the right types of data, is constrained to valid data, and has a description for display/documentation. Form data is stored in an application's forms.py file, inside the application directory. Create and open the file django-locallibrary-tutorial/catalog/forms.py. To create a , we import the library, derive from the class, and declare the form's fields. A very basic form class for our library book renewal form is shown below — add this to your new file: from django import forms class RenewBookForm(forms.Form): renewal_date = forms.DateField(help_text=\"Enter a date between now and 4 weeks (default 3).\") In this case, we have a single for entering the renewal date that will render in HTML with a blank value, the default label \"Renewal date:\", and some helpful usage text: \"Enter a date between now and 4 weeks (default 3 weeks).\" As none of the other optional arguments are specified the field will accept dates using the input_formats: YYYY-MM-DD (2024-11-06), MM/DD/YYYY (02/26/2024), MM/DD/YY (10/25/24), and will be rendered using the default widget: DateInput. There are many other types of form fields, which you will largely recognize from their similarity to the equivalent model field classes: The arguments that are common to most fields are listed below (these have sensible default values):\n• : If , the field may not be left blank or given a value. Fields are required by default, so you would set to allow blank values in the form.\n• : The label to use when rendering the field in HTML. If a label is not specified, Django will create one from the field name by capitalizing the first letter and replacing underscores with spaces (e.g. Renewal date).\n• : By default, a colon is displayed after the label (e.g. Renewal date​:). This argument allows you to specify a different suffix containing other character(s).\n• : The initial value for the field when the form is displayed.\n• : The display widget to use.\n• (as seen in the example above): Additional text that can be displayed in forms to explain how to use the field.\n• : A list of error messages for the field. You can override these with your own messages if needed.\n• : A list of functions that will be called on the field when it is validated.\n• : Enables the localization of form data input (see link for more information).\n• : The field is displayed but its value cannot be edited if this is . The default is . Django provides numerous places where you can validate your data. The easiest way to validate a single field is to override the method for the field you want to check. So for example, we can validate that entered values are between now and 4 weeks by implementing as shown below. Update your forms.py file so it looks like this: import datetime from django import forms from django.core.exceptions import ValidationError from django.utils.translation import gettext_lazy as _ class RenewBookForm(forms.Form): renewal_date = forms.DateField(help_text=\"Enter a date between now and 4 weeks (default 3).\") def clean_renewal_date(self): data = self.cleaned_data['renewal_date'] # Check if a date is not in the past. if data < datetime.date.today(): raise ValidationError(_('Invalid date - renewal in past')) # Check if a date is in the allowed range (+4 weeks from today). if data > datetime.date.today() + datetime.timedelta(weeks=4): raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead')) # Remember to always return the cleaned data. return data There are two important things to note. The first is that we get our data using and that we return this data whether or not we change it at the end of the function. This step gets us the data \"cleaned\" and sanitized of potentially unsafe input using the default validators, and converted into the correct standard type for the data (in this case a Python object). The second point is that if a value falls outside our range we raise a , specifying the error text that we want to display in the form if an invalid value is entered. The example above also wraps this text in one of Django's translation functions, (imported as ), which is good practice if you want to translate your site later. Note: There are numerous other methods and examples for validating forms in Form and field validation (Django docs). For example, in cases where you have multiple fields that depend on each other, you can override the Form.clean() function and again raise a . That's all we need for the form in this example!\n\nAs discussed in the Django form handling process above, the view has to render the default form when it is first called and then either re-render it with error messages if the data is invalid, or process the data and redirect to a new page if the data is valid. In order to perform these different actions, the view has to be able to know whether it is being called for the first time to render the default form, or a subsequent time to validate data. For forms that use a request to submit information to the server, the most common pattern is for the view to test against the request type ( ) to identify form validation requests and (using an condition) to identify the initial form creation request. If you want to submit your data using a request, then a typical approach for identifying whether this is the first or subsequent view invocation is to read the form data (e.g. to read a hidden value in the form). The book renewal process will be writing to our database, so, by convention, we use the request approach. The code fragment below shows the (very standard) pattern for this sort of function view. import datetime from django.shortcuts import render, get_object_or_404 from django.http import HttpResponseRedirect from django.urls import reverse from catalog.forms import RenewBookForm def renew_book_librarian(request, pk): book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) # If this is a GET (or any other method) create the default form. else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) First, we import our form ( ) and a number of other useful objects/methods used in the body of the view function:\n• : Returns a specified object from a model based on its primary key value, and raises an exception (not found) if the record does not exist.\n• : This creates a redirect to a specified URL (HTTP status code 302).\n• : This generates a URL from a URL configuration name and a set of arguments. It is the Python equivalent of the tag that we've been using in our templates. In the view, we first use the argument in to get the current (if this does not exist, the view will immediately exit and the page will display a \"not found\" error). If this is not a request (handled by the clause) then we create the default form passing in an value for the field, 3 weeks from the current date. book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a GET (or any other method) create the default form else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) After creating the form, we call to create the HTML page, specifying the template and a context that contains our form. In this case, the context also contains our , which we'll use in the template to provide information about the book we're renewing. However, if this is a request, then we create our object and populate it with data from the request. This process is called \"binding\" and allows us to validate the form. We then check if the form is valid, which runs all the validation code on all of the fields — including both the generic code to check that our date field is actually a valid date and our specific form's function to check the date is in the right range. book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) If the form is not valid we call again, but this time the form value passed in the context will include error messages. If the form is valid, then we can start to use the data, accessing it through the attribute (e.g. ). Here, we just save the data into the value of the associated object. Warning: While you can also access the form data directly through the request (for example, or if using a GET request), this is NOT recommended. The cleaned data is sanitized, validated, and converted into Python-friendly types. The final step in the form-handling part of the view is to redirect to another page, usually a \"success\" page. In this case, we use and to redirect to the view named (this was created as the \"challenge\" in Django Tutorial Part 8: User authentication and permissions). If you didn't create that page consider redirecting to the home page at URL ). That's everything needed for the form handling itself, but we still need to restrict access to the view to just logged-in librarians who have permission to renew books. We use to require that the user is logged in, and the function decorator with our existing permission to allow access (decorators are processed in order). Note that we probably should have created a new permission setting in ( ), but we will reuse the existing one to keep the example simple. The final view is therefore as shown below. Please copy this into the bottom of django-locallibrary-tutorial/catalog/views.py. import datetime from django.contrib.auth.decorators import login_required, permission_required from django.shortcuts import get_object_or_404 from django.http import HttpResponseRedirect from django.urls import reverse from catalog.forms import RenewBookForm @login_required @permission_required('catalog.can_mark_returned', raise_exception=True) def renew_book_librarian(request, pk): \"\"\"View function for renewing a specific BookInstance by librarian.\"\"\" book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) # If this is a GET (or any other method) create the default form. else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context)\n\nCreate the template referenced in the view (/catalog/templates/catalog/book_renew_librarian.html) and copy the code below into it: Most of this will be completely familiar from previous tutorials. We extend the base template and then redefine the content block. We are able to reference (and its variables) because it was passed into the context object in the function, and we use these to list the book title, borrower, and the original due date. The form code is relatively simple. First, we declare the tags, specifying where the form is to be submitted ( ) and the for submitting the data (in this case a ) — if you recall the HTML Forms overview at the top of the page, an empty as shown, means that the form data will be posted back to the current URL of the page (which is what we want). Inside the tags, we define the input, which a user can press to submit the data. The added just inside the form tags is part of Django's cross-site forgery protection. Note: Add the to every Django template you create that uses to submit data. This will reduce the chance of forms being hijacked by malicious users. All that's left is the template variable, which we passed to the template in the context dictionary. Perhaps unsurprisingly, when used as shown this provides the default rendering of all the form fields, including their labels, widgets, and help text — the rendering is as shown below: <tr> <th><label for=\"id_renewal_date\">Renewal date:</label></th> <td> <input id=\"id_renewal_date\" name=\"renewal_date\" type=\"text\" value=\"2023-11-08\" required /> <br /> <span class=\"helptext\"> Enter date between now and 4 weeks (default 3 weeks). </span> </td> </tr> Note: It is perhaps not obvious because we only have one field, but, by default, every field is defined in its own table row. This same rendering is provided if you reference the template variable . If you were to enter an invalid date, you'd additionally get a list of the errors rendered on the page (see below). <tr> <th><label for=\"id_renewal_date\">Renewal date:</label></th> <td> <ul class=\"errorlist\"> <li>Invalid date - renewal in past</li> </ul> <input id=\"id_renewal_date\" name=\"renewal_date\" type=\"text\" value=\"2023-11-08\" required /> <br /> <span class=\"helptext\"> Enter date between now and 4 weeks (default 3 weeks). </span> </td> </tr> Other ways of using form template variable Using as shown above, each field is rendered as a table row. You can also render each field as a list item (using ) or as a paragraph (using ). It is also possible to have complete control over the rendering of each part of the form, by indexing its properties using dot notation. So, for example, we can access a number of separate items for our field:\n• : The id of the label. For more examples of how to manually render forms in templates and dynamically loop over template fields, see Working with forms > Rendering fields manually (Django docs).\n\nCreating a class using the approach described above is very flexible, allowing you to create whatever sort of form page you like and associate it with any model or models. However, if you just need a form to map the fields of a single model then your model will already define most of the information that you need in your form: fields, labels, help text and so on. Rather than recreating the model definitions in your form, it is easier to use the ModelForm helper class to create the form from your model. This can then be used within your views in exactly the same way as an ordinary . A basic containing the same field as our original is shown below. All you need to do to create the form is add with the associated ( ) and a list of the model to include in the form. Note: You can also include all fields in the form using , or you can use (instead of ) to specify the fields not to include from the model). Neither approach is recommended because new fields added to the model are then automatically included in the form (without the developer necessarily considering possible security implications). Note: This might not look all that much simpler than just using a (and it isn't in this case, because we just have one field). However, if you have a lot of fields, it can considerably reduce the amount of code required! The rest of the information comes from the model field definitions (e.g. labels, widgets, help text, error messages). If these aren't quite right, then we can override them in our , specifying a dictionary containing the field to change and its new value. For example, in this form, we might want a label for our field of \"Renewal date\" (rather than the default based on the field name: Due Back), and we also want our help text to be specific to this use case. The below shows you how to override these fields, and you can similarly set and if the defaults aren't sufficient. class Meta: model = BookInstance fields = ['due_back'] labels = {'due_back': _('New renewal date')} help_texts = {'due_back': _('Enter a date between now and 4 weeks (default 3).')} To add validation you can use the same approach as for a normal — you define a function named and raise exceptions for invalid values. The only difference with respect to our original form is that the model field is named and not . This change is necessary since the corresponding field in is called . from django.forms import ModelForm from catalog.models import BookInstance class RenewBookModelForm(ModelForm): def clean_due_back(self): data = self.cleaned_data['due_back'] # Check if a date is not in the past. if data < datetime.date.today(): raise ValidationError(_('Invalid date - renewal in past')) # Check if a date is in the allowed range (+4 weeks from today). if data > datetime.date.today() + datetime.timedelta(weeks=4): raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead')) # Remember to always return the cleaned data. return data class Meta: model = BookInstance fields = ['due_back'] labels = {'due_back': _('Renewal date')} help_texts = {'due_back': _('Enter a date between now and 4 weeks (default 3).')} The class above is now functionally equivalent to our original . You could import and use it wherever you currently use as long as you also update the corresponding form variable name from to as in the second form declaration: .\n\nOpen the views file (django-locallibrary-tutorial/catalog/views.py) and append the following code block to the bottom of it: from django.views.generic.edit import CreateView, UpdateView, DeleteView from django.urls import reverse_lazy from .models import Author class AuthorCreate(PermissionRequiredMixin, CreateView): model = Author fields = ['first_name', 'last_name', 'date_of_birth', 'date_of_death'] initial = {'date_of_death': '11/11/2023'} permission_required = 'catalog.add_author' class AuthorUpdate(PermissionRequiredMixin, UpdateView): model = Author # Not recommended (potential security issue if more fields added) fields = '__all__' permission_required = 'catalog.change_author' class AuthorDelete(PermissionRequiredMixin, DeleteView): model = Author success_url = reverse_lazy('authors') permission_required = 'catalog.delete_author' def form_valid(self, form): try: self.object.delete() return HttpResponseRedirect(self.success_url) except Exception as e: return HttpResponseRedirect( reverse(\"author-delete\", kwargs={\"pk\": self.object.pk}) ) As you can see, to create, update, or delete the views you need to derive from , , and (respectively) and then define the associated model. We also restrict calling these views to only logged in users with the , , and permissions, respectively. For the \"create\" and \"update\" cases you also need to specify the fields to display in the form (using the same syntax as for ). In this case, we show how to list them individually and the syntax to list \"all\" fields. You can also specify initial values for each of the fields using a dictionary of field_name/value pairs (here we arbitrarily set the date of death for demonstration purposes — you might want to remove that). By default, these views will redirect on success to a page displaying the newly created/edited model item, which in our case will be the author detail view we created in a previous tutorial. You can specify an alternative redirect location by explicitly declaring parameter . The class doesn't need to display any of the fields, so these don't need to be specified. We also set a (as shown above), because there is no obvious default URL for Django to navigate to after successfully deleting the . Above we use the function to redirect to our author list after an author has been deleted — is a lazily executed version of , used here because we're providing a URL to a class-based view attribute. If deletion of authors should always succeed that would be it. Unfortunately deleting an will cause an exception if the author has an associated book, because our model specifies for the author field. To handle this case the view overrides the method so that if deleting the succeeds it redirects to the , but if not, it just redirects back to the same form. We'll update the template below to make clear that you can't delete an instance that is used in any ."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/request-response",
        "document": "Django uses request and response objects to pass state through the system. When a page is requested, Django creates an object that contains metadata about the request. Then Django loads the appropriate view, passing the as the first argument to the view function. Each view is responsible for returning an object. This document explains the APIs for and objects, which are defined in the module.\n\nAll attributes should be considered read-only, unless stated otherwise. A string representing the scheme of the request ( or usually). The raw HTTP request body as a bytestring. This is useful for processing data in different ways than conventional HTML forms: binary images, XML payload etc. For processing conventional form data, use . You can also read from an using a file-like interface with or . Accessing the attribute after reading the request with either of these I/O stream methods will produce a . A string representing the full path to the requested page, not including the scheme, domain, or query string. Under some web server configurations, the portion of the URL after the host name is split up into a script prefix portion and a path info portion. The attribute always contains the path info portion of the path, no matter what web server is being used. Using this instead of can make your code easier to move between test and deployment servers. For example, if the for your application is set to , then might be and would be . A string representing the HTTP method used in the request. This is guaranteed to be uppercase. For example: A string representing the current encoding used to decode form submission data (or , which means the setting is used). You can write to this attribute to change the encoding used when accessing the form data. Any subsequent attribute accesses (such as reading from or ) will use the new value. Useful if you know the form data is not in the encoding. A string representing the MIME type of the request, parsed from the header. A dictionary of key/value parameters included in the header. A dictionary-like object containing all given HTTP GET parameters. See the documentation below. A dictionary-like object containing all given HTTP POST parameters, providing that the request contains form data. See the documentation below. If you need to access raw or non-form data posted in the request, access this through the attribute instead. It’s possible that a request can come in via POST with an empty dictionary – if, say, a form is requested via the POST HTTP method but does not include form data. Therefore, you shouldn’t use to check for use of the POST method; instead, use (see ). does not include file-upload information. See . A dictionary containing all cookies. Keys and values are strings. A dictionary-like object containing all uploaded files. Each key in is the from the . Each value in is an . See Managing files for more information. will only contain data if the request method was POST and the that posted to the request had . Otherwise, will be a blank dictionary-like object. A dictionary containing all available HTTP headers. Available headers depend on the client and server, but here are some examples:\n• None – The length of the request body (as a string).\n• None – The MIME type of the request body.\n• None – The HTTP Host header sent by the client.\n• None – The referring page, if any.\n• None – The IP address of the client.\n• None – The hostname of the client.\n• None – The user authenticated by the web server, if any.\n• None – A string such as or .\n• None – The hostname of the server.\n• None – The port of the server (as a string). With the exception of and , as given above, any HTTP headers in the request are converted to keys by converting all characters to uppercase, replacing any hyphens with underscores and adding an prefix to the name. So, for example, a header called would be mapped to the key . Note that strips all headers with underscores in the name, so you won’t see them in . This prevents header-spoofing based on ambiguity between underscores and dashes both being normalizing to underscores in WSGI environment variables. It matches the behavior of web servers like Nginx and Apache 2.4+. is a simpler way to access all HTTP-prefixed headers, plus and . A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus and ) from the request. The name of each header is stylized with title-casing (e.g. ) when it’s displayed. You can access headers case-insensitively: For use in, for example, Django templates, headers can also be looked up using underscores in place of hyphens: An instance of representing the resolved URL. This attribute is only set after URL resolving took place, which means it’s available in all views but not in middleware which are executed before URL resolving takes place (you can use it in though). Django doesn’t set these attributes itself but makes use of them if set by your application. The template tag will use its value as the argument to . This will be used as the root URLconf for the current request, overriding the setting. See How Django processes a request for details. can be set to to revert any changes made by previous middleware and return to using the . This will be used instead of for the current request. See Custom error reports for details. This will be used instead of for the current request. See Custom error reports for details. Some of the middleware included in Django’s contrib apps set attributes on the request. If you don’t see the attribute on a request, be sure the appropriate middleware class is listed in . From the : A readable and writable, dictionary-like object that represents the current session. From the : An instance of or as returned by representing the current site. From the : An instance of representing the currently logged-in user. If the user isn’t currently logged in, will be set to an instance of . You can tell them apart with , like so: # Do something for logged-in users. # Do something for anonymous users. The method does the same thing but can be used from async contexts. From the : Coroutine. Returns an instance of representing the currently logged-in user. If the user isn’t currently logged in, will return an instance of . This is similar to the attribute but it works in async contexts. Returns the originating host of the request using information from the (if is enabled) and headers, in that order. If they don’t provide a value, the method uses a combination of and as detailed in PEP 3333. Raises if the host is not in or the domain name is invalid according to RFC 1034/1035. The method fails when the host is behind multiple proxies. One solution is to use middleware to rewrite the proxy headers, as in the following example: Rewrites the proxy headers so that only the most This middleware should be positioned before any other middleware that relies on the value of – for instance, or . Returns the originating port of the request using information from the (if is enabled) and variables, in that order. Returns the , plus an appended query string, if applicable. Like , but uses instead of . Returns the absolute URI form of . If no location is provided, the location will be set to . If the location is already an absolute URI, it will not be altered. Otherwise the absolute URI is built using the server variables available in this request. For example: Mixing HTTP and HTTPS on the same site is discouraged, therefore will always generate an absolute URI with the same scheme the current request has. If you need to redirect users to HTTPS, it’s best to let your web server redirect all HTTP traffic to HTTPS. Returns a cookie value for a signed cookie, or raises a exception if the signature is no longer valid. If you provide the argument the exception will be suppressed and that default value will be returned instead. The optional argument can be used to provide extra protection against brute force attacks on your secret key. If supplied, the argument will be checked against the signed timestamp attached to the cookie value to ensure the cookie is not older than seconds. 'Tony' # assuming cookie was set using the same salt See cryptographic signing for more information. Returns if the request is secure; that is, if it was made with HTTPS. Returns if the request header matches the argument: Most browsers send by default, so this would return for all content types. Setting an explicit header in API requests can be useful for returning a different content type for those consumers only. See Content negotiation example of using to return different content to API consumers. If a response varies depending on the content of the header and you are using some form of caching like Django’s , you should decorate the view with so that the responses are properly cached. Methods implementing a file-like interface for reading from an instance. This makes it possible to consume an incoming request in a streaming fashion. A common use-case would be to process a big XML payload with an iterative parser without constructing a whole XML tree in memory. Given this standard interface, an instance can be passed directly to an XML parser such as :\n\nIn an object, the and attributes are instances of , a dictionary-like class customized to deal with multiple values for the same key. This is necessary because some HTML form elements, notably , pass multiple values for the same key. The s at and will be immutable when accessed in a normal request/response cycle. To get a mutable version you need to use . implements all the standard dictionary methods because it’s a subclass of dictionary. Exceptions are outlined here: If is not passed in, the resulting will be empty (it will have no keys or values). Most s you encounter, and in particular those at and , will be immutable. If you are instantiating one yourself, you can make it mutable by passing to its . Strings for setting both keys and values will be converted from to . If is not set, it defaults to . Creates a new with keys from and each value equal to . For example: Returns the value for the given key. If the key has more than one value, it returns the last value. Raises if the key does not exist. (This is a subclass of Python’s standard , so you can stick to catching .) Sets the given key to (a list whose single element is ). Note that this, as other dictionary functions that have side effects, can only be called on a mutable (such as one that was created via ). Returns if the given key is set. This lets you do, e.g., . Uses the same logic as , with a hook for returning a default value if the key doesn’t exist. Like , except it uses internally. Takes either a or a dictionary. Like , except it appends to the current dictionary items rather than replacing them. For example: Like , except this uses the same last-value logic as and returns an iterator object instead of a view object. For example: Like , except this uses the same last-value logic as and returns an iterator instead of a view object. For example: In addition, has the following methods: Returns a copy of the object using . This copy will be mutable even if the original was not. Returns a list of the data with the requested key. Returns an empty list if the key doesn’t exist and is . It’s guaranteed to return a list unless the default value provided isn’t a list. Sets the given key to (unlike ). Appends an item to the internal list associated with key. Like , except it takes a list of values instead of a single value. Like , except it includes all values, as a list, for each member of the dictionary. For example: Returns a list of values for the given key and removes them from the dictionary. Raises if the key does not exist. For example: Removes an arbitrary member of the dictionary (since there’s no concept of ordering), and returns a two value tuple containing the key and a list of all values for the key. Raises when called on an empty dictionary. For example: Returns a representation of . For every (key, list) pair in , will have (key, item), where item is one element of the list, using the same logic as : Returns a string of the data in query string format. For example: Use the parameter to pass characters which don’t require encoding. For example:\n\nIn contrast to objects, which are created automatically by Django, objects are your responsibility. Each view you write is responsible for instantiating, populating, and returning an . The class lives in the module. Typical usage is to pass the contents of the page, as a string, bytestring, or , to the constructor: \"Here's the text of the web page.\" But if you want to add content incrementally, you can use as a file-like object: \"<p>Here's the text of the web page.</p>\" Finally, you can pass an iterator rather than strings. will consume the iterator immediately, store its content as a string, and discard it. Objects with a method such as files and generators are immediately closed. If you need the response to be streamed from the iterator to the client, you must use the class instead. To set or remove a header field in your response, use : You can also manipulate headers by treating your response like a dictionary: This proxies to , and is the original interface offered by . When using this interface, unlike a dictionary, doesn’t raise if the header field doesn’t exist. You can also set headers on instantiation: For setting the and header fields, it is recommended to use the and methods from , since these fields can have multiple, comma-separated values. The “patch” methods ensure that other values, e.g. added by a middleware, are not removed. HTTP header fields cannot contain newlines. An attempt to set a header field containing a newline character (CR or LF) will raise Telling the browser to treat the response as a file attachment¶ To tell the browser to treat the response as a file attachment, set the and headers. For example, this is how you might return a Microsoft Excel spreadsheet: There’s nothing Django-specific about the header, but it’s easy to forget the syntax, so we’ve included it here. A bytestring representing the content, encoded from a string if necessary. A object holding the cookies included in the response. A case insensitive, dict-like object that provides an interface to all HTTP headers on the response, except a header. See Setting header fields and . A string denoting the charset in which the response will be encoded. If not given at instantiation time, it will be extracted from and if that is unsuccessful, the setting will be used. The HTTP status code for the response. Unless is explicitly set, modifying the value of outside the constructor will also modify the value of . The HTTP reason phrase for the response. It uses the HTTP standard’s default reason phrases. Unless explicitly set, is determined by the value of . This attribute exists so middleware can treat streaming responses differently from regular responses. if the response has been closed. Instantiates an object with the given page content, content type, and headers. is most commonly an iterator, bytestring, , or string. Other types will be converted to a bytestring by encoding their string representation. Iterators should return strings or bytestrings and those will be joined together to form the content of the response. is the MIME type optionally completed by a character set encoding and is used to fill the HTTP header. If not specified, it is formed by and the settings, by default: . is the HTTP status code for the response. You can use Python’s for meaningful aliases, such as . is the HTTP response phrase. If not provided, a default phrase will be used. is the charset in which the response will be encoded. If not given it will be extracted from , and if that is unsuccessful, the setting will be used. is a of HTTP headers for the response. Sets the given header name to the given value. Both and should be strings. Deletes the header with the given name. Fails silently if the header doesn’t exist. Case-insensitive. Returns the value for the given header name. Case-insensitive. Returns the value for the given header, or an if the header doesn’t exist. Returns or based on a case-insensitive check for a header with the given name. Acts like for HTTP headers on the response. Sets a header unless it has already been set. Sets a cookie. The parameters are the same as in the cookie object in the Python standard library.\n• None should be a object, an integer number of seconds, or (default) if the cookie should last only as long as the client’s browser session. If is not specified, it will be calculated.\n• None should either be a string in the format or a object in UTC. If is a object, the will be calculated.\n• None Use if you want to set a cross-domain cookie. For example, will set a cookie that is readable by the domains www.example.com, blog.example.com, etc. Otherwise, a cookie will only be readable by the domain that set it.\n• None Use if you want the cookie to be only sent to the server when a request is made with the scheme.\n• None Use if you want to prevent client-side JavaScript from having access to the cookie. HttpOnly is a flag included in a Set-Cookie HTTP response header. It’s part of the RFC 6265 standard for cookies and can be a useful way to mitigate the risk of a client-side script accessing the protected cookie data.\n• None Use or to tell the browser not to send this cookie when performing a cross-origin request. SameSite isn’t supported by all browsers, so it’s not a replacement for Django’s CSRF protection, but rather a defense in depth measure. Use (string) to explicitly state that this cookie is sent with all same-site and cross-site requests. RFC 6265 states that user agents should support cookies of at least 4096 bytes. For many browsers this is also the maximum size. Django will not raise an exception if there’s an attempt to store a cookie of more than 4096 bytes, but many browsers will not set the cookie correctly. Like , but cryptographic signing the cookie before setting it. Use in conjunction with . You can use the optional argument for added key strength, but you will need to remember to pass it to the corresponding call. Deletes the cookie with the given key. Fails silently if the key doesn’t exist. Due to the way cookies work, and should be the same values you used in – otherwise the cookie may not be deleted. This method is called at the end of the request directly by the WSGI server. Returns the value of . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Writes a list of lines to the response. Line separators are not added. This method makes an instance a stream-like object. Django includes a number of subclasses that handle different types of HTTP responses. Like , these subclasses live in . The first argument to the constructor is required – the path to redirect to. This can be a fully qualified URL (e.g. ), an absolute path with no domain (e.g. ), or even a relative path (e.g. ). In that last case, the client browser will reconstruct the full URL itself according to the current path. See for other optional constructor arguments. Note that this returns an HTTP status code 302. This read-only attribute represents the URL the response will redirect to (equivalent to the response header). Like , but it returns a permanent redirect (HTTP status code 301) instead of a “found” redirect (status code 302). The constructor doesn’t take any arguments and no content should be added to this response. Use this to designate that a page hasn’t been modified since the user’s last request (status code 304). Acts just like but uses a 400 status code. Acts just like but uses a 404 status code. Acts just like but uses a 403 status code. Like , but uses a 405 status code. The first argument to the constructor is required: a list of permitted methods (e.g. ). Acts just like but uses a 410 status code. Acts just like but uses a 500 status code. If a custom subclass of implements a method, Django will treat it as emulating a , and the method must itself return a valid response object. If you find yourself needing a response class that Django doesn’t provide, you can create it with the help of . For example:\n\nThe class is used to stream a response from Django to the browser. is somewhat advanced, in that it is important to know whether you’ll be serving your application synchronously under WSGI or asynchronously under ASGI, and adjust your usage appropriately. Please read these notes with care. An example usage of under WSGI is streaming content when generating the response would take too long or uses too much memory. For instance, it’s useful for generating large CSV files. There are performance considerations when doing this, though. Django, under WSGI, is designed for short-lived requests. Streaming responses will tie a worker process for the entire duration of the response. This may result in poor performance. Generally speaking, you would perform expensive tasks outside of the request-response cycle, rather than resorting to a streamed response. When serving under ASGI, however, a need not stop other requests from being served whilst waiting for I/O. This opens up the possibility of long-lived requests for streaming content and implementing patterns such as long-polling, and server-sent events. Even under ASGI note, should only be used in situations where it is absolutely required that the whole content isn’t iterated before transferring the data to the client. Because the content can’t be accessed, many middleware can’t function normally. For example the and headers can’t be generated for streaming responses. The is not a subclass of , because it features a slightly different API. However, it is almost identical, with the following notable differences:\n• None It should be given an iterator that yields bytestrings, , or strings as content. When serving under WSGI, this should be a sync iterator. When serving under ASGI, then it should be an async iterator.\n• None You cannot access its content, except by iterating the response object itself. This should only occur when the response is returned to the client: you should not iterate the response yourself. Under WSGI the response will be iterated synchronously. Under ASGI the response will be iterated asynchronously. (This is why the iterator type must match the protocol you’re using.) To avoid a crash, an incorrect iterator type will be mapped to the correct type during iteration, and a warning will be raised, but in order to do this the iterator must be fully-consumed, which defeats the purpose of using a at all.\n• None It has no attribute. Instead, it has a attribute. This can be used in middleware to wrap the response iterable, but should not be consumed.\n• None You cannot use the file-like object or methods. Doing so will raise an exception. The base class is common between and . An iterator of the response content, bytestring encoded according to . The HTTP status code for the response. Unless is explicitly set, modifying the value of outside the constructor will also modify the value of . The HTTP reason phrase for the response. It uses the HTTP standard’s default reason phrases. Unless explicitly set, is determined by the value of . Boolean indicating whether is an asynchronous iterator or not. This is useful for middleware needing to wrap . If the client disconnects during a streaming response, Django will cancel the coroutine that is handling the response. If you want to clean up resources manually, you can do so by catching the : This example only shows how to handle client disconnection while the response is streaming. If you perform long-running operations in your view before returning the object, then you may also want to handle disconnections in the view itself.\n\nis a subclass of optimized for binary files. It uses wsgi.file_wrapper if provided by the wsgi server, otherwise it streams the file out in small chunks. If , the header is set to , which asks the browser to offer the file to the user as a download. Otherwise, a header with a value of (the browser default) will be set only if a filename is available. If doesn’t have a name or if the name of isn’t appropriate, provide a custom file name using the parameter. Note that if you pass a file-like object like , it’s your task to it before passing it to . The header is automatically set when it can be guessed from the content of . The header is automatically set when it can be guessed from the , or the name of . accepts any file-like object with binary content, for example a file open in binary mode like so: The file will be closed automatically, so don’t open it with a context manager. Python’s file API is synchronous. This means that the file must be fully consumed in order to be served under ASGI. In order to stream a file asynchronously you need to use a third-party package that provides an asynchronous file API, such as aiofiles. This method is automatically called during the response initialization and set various headers ( , , and ) depending on ."
    },
    {
        "link": "https://stackoverflow.com/questions/59404278/how-to-properly-send-a-file-with-additional-variables-in-a-django-http-response",
        "document": "I know how to return a JSON response:\n\nand also know how to return a file response:\n\nBut if I want to send both in one response, how can I properly do that? Django documentation gives an example for setting additional header fields:\n\nBut from reading a couple answers I've seen, it looks like sending business data in headers it not the way to go. Is there a better solution?"
    },
    {
        "link": "https://stackoverflow.com/questions/62745439/how-do-i-use-fileresponse-set-headers-in-my-django-application-to-enable-mp3",
        "document": "I am trying to use to set Content-Disposition to attachment, so that Audio file can be downloaded rather than playing on the browser, in my python/django powered website. is there any way i can implement this code bellow to make it work?\n\nthis code does not give me any error but it's not working.\n\nSo i discovered about in the django doc, so i tried using it like so.\n\nThen i got an error AttributeError: 'str' object has no attribute 'filename'. please can anyone help me out, or if there is another way to do that in django i will so much appreciate someone's help. Or any other possible way i can set my Content-Disposition, in django, Nginx or in Javascript."
    },
    {
        "link": "https://forum.djangoproject.com/t/returning-an-httpresponse-with-streamed-object-and-messages-from-messages-framework/11512",
        "document": "I have a page with a bunch of reports/files (pdf, xlsx, etc) that can be generated & downloaded by users. For instance this mixin:\n\nWhere contains the xlsx files formatted by xlsxwriter. Similarly for PDF, with adjusted headers, content-types etc. Works fine, downloads the file as attachements.\n\nThe user clicks a button to obtain the report:\n\n\n\nWhich submits via a POST (where I use the value attribute to determine what to build for a file response). THen I typically have some parameters the user can set for the different reports, which are processed as forms submitted.\n\nThat all works fine, however if I add stuff via the framework, they don’t get displayed. Guessing because I tell the browser I want to stream stuff, and it doesn’t refresh.\n\nI could rewrite stuff so that I actually do the same thing ajax with jquery I guess (and once I get the response, resfresh the page to display the messages as per normal). However is that a way to just tweak the mixin/headers of the HttpResponse so I don’t have to rewrite as much stuff? Maybe tweaking the headers or http content so that the browsers knows to display the messages as well?"
    },
    {
        "link": "https://django.readthedocs.io/en/latest/ref/request-response.html",
        "document": "Django uses request and response objects to pass state through the system. When a page is requested, Django creates an object that contains metadata about the request. Then Django loads the appropriate view, passing the as the first argument to the view function. Each view is responsible for returning an object. This document explains the APIs for and objects, which are defined in the module.\n\nAll attributes should be considered read-only, unless stated otherwise. A string representing the scheme of the request ( or usually). The raw HTTP request body as a bytestring. This is useful for processing data in different ways than conventional HTML forms: binary images, XML payload etc. For processing conventional form data, use . You can also read from an using a file-like interface with or . Accessing the attribute after reading the request with either of these I/O stream methods will produce a . A string representing the full path to the requested page, not including the scheme, domain, or query string. Under some web server configurations, the portion of the URL after the host name is split up into a script prefix portion and a path info portion. The attribute always contains the path info portion of the path, no matter what web server is being used. Using this instead of can make your code easier to move between test and deployment servers. For example, if the for your application is set to , then might be and would be . A string representing the HTTP method used in the request. This is guaranteed to be uppercase. For example: A string representing the current encoding used to decode form submission data (or , which means the setting is used). You can write to this attribute to change the encoding used when accessing the form data. Any subsequent attribute accesses (such as reading from or ) will use the new value. Useful if you know the form data is not in the encoding. A string representing the MIME type of the request, parsed from the header. A dictionary of key/value parameters included in the header. A dictionary-like object containing all given HTTP GET parameters. See the documentation below. A dictionary-like object containing all given HTTP POST parameters, providing that the request contains form data. See the documentation below. If you need to access raw or non-form data posted in the request, access this through the attribute instead. It’s possible that a request can come in via POST with an empty dictionary – if, say, a form is requested via the POST HTTP method but does not include form data. Therefore, you shouldn’t use to check for use of the POST method; instead, use (see ). does not include file-upload information. See . A dictionary containing all cookies. Keys and values are strings. A dictionary-like object containing all uploaded files. Each key in is the from the . Each value in is an . See Managing files for more information. will only contain data if the request method was POST and the that posted to the request had . Otherwise, will be a blank dictionary-like object. A dictionary containing all available HTTP headers. Available headers depend on the client and server, but here are some examples:\n• None – The length of the request body (as a string).\n• None – The MIME type of the request body.\n• None – The HTTP Host header sent by the client.\n• None – The referring page, if any.\n• None – The IP address of the client.\n• None – The hostname of the client.\n• None – The user authenticated by the web server, if any.\n• None – A string such as or .\n• None – The hostname of the server.\n• None – The port of the server (as a string). With the exception of and , as given above, any HTTP headers in the request are converted to keys by converting all characters to uppercase, replacing any hyphens with underscores and adding an prefix to the name. So, for example, a header called would be mapped to the key . Note that strips all headers with underscores in the name, so you won’t see them in . This prevents header-spoofing based on ambiguity between underscores and dashes both being normalizing to underscores in WSGI environment variables. It matches the behavior of web servers like Nginx and Apache 2.4+. is a simpler way to access all HTTP-prefixed headers, plus and . A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus and ) from the request. The name of each header is stylized with title-casing (e.g. ) when it’s displayed. You can access headers case-insensitively: For use in, for example, Django templates, headers can also be looked up using underscores in place of hyphens: An instance of representing the resolved URL. This attribute is only set after URL resolving took place, which means it’s available in all views but not in middleware which are executed before URL resolving takes place (you can use it in though). Django doesn’t set these attributes itself but makes use of them if set by your application. The template tag will use its value as the argument to . This will be used as the root URLconf for the current request, overriding the setting. See How Django processes a request for details. can be set to to revert any changes made by previous middleware and return to using the . This will be used instead of for the current request. See Custom error reports for details. This will be used instead of for the current request. See Custom error reports for details. Some of the middleware included in Django’s contrib apps set attributes on the request. If you don’t see the attribute on a request, be sure the appropriate middleware class is listed in . From the : A readable and writable, dictionary-like object that represents the current session. From the : An instance of or as returned by representing the current site. From the : An instance of representing the currently logged-in user. If the user isn’t currently logged in, will be set to an instance of . You can tell them apart with , like so: # Do something for logged-in users. # Do something for anonymous users. The method does the same thing but can be used from async contexts. From the : Coroutine. Returns an instance of representing the currently logged-in user. If the user isn’t currently logged in, will return an instance of . This is similar to the attribute but it works in async contexts. Returns the originating host of the request using information from the (if is enabled) and headers, in that order. If they don’t provide a value, the method uses a combination of and as detailed in PEP 3333. Raises if the host is not in or the domain name is invalid according to RFC 1034/1035. The method fails when the host is behind multiple proxies. One solution is to use middleware to rewrite the proxy headers, as in the following example: Rewrites the proxy headers so that only the most This middleware should be positioned before any other middleware that relies on the value of – for instance, or . Returns the originating port of the request using information from the (if is enabled) and variables, in that order. Returns the , plus an appended query string, if applicable. Like , but uses instead of . Returns the absolute URI form of . If no location is provided, the location will be set to . If the location is already an absolute URI, it will not be altered. Otherwise the absolute URI is built using the server variables available in this request. For example: Mixing HTTP and HTTPS on the same site is discouraged, therefore will always generate an absolute URI with the same scheme the current request has. If you need to redirect users to HTTPS, it’s best to let your web server redirect all HTTP traffic to HTTPS. Returns a cookie value for a signed cookie, or raises a exception if the signature is no longer valid. If you provide the argument the exception will be suppressed and that default value will be returned instead. The optional argument can be used to provide extra protection against brute force attacks on your secret key. If supplied, the argument will be checked against the signed timestamp attached to the cookie value to ensure the cookie is not older than seconds. 'Tony' # assuming cookie was set using the same salt See cryptographic signing for more information. Returns if the request is secure; that is, if it was made with HTTPS. Returns the preferred mime type from , based on the header, or if the client does not accept any of the provided types. Assuming the client sends an header of : Most browsers send by default, meaning they don’t have a preference, in which case the first item in would be returned. Setting an explicit header in API requests can be useful for returning a different content type for those consumers only. See Content negotiation example for an example of returning different content based on the header. If a response varies depending on the content of the header and you are using some form of caching like Django’s , you should decorate the view with so that the responses are properly cached. Returns if the request’s header matches the argument: Most browsers send by default, so this would return for all content types. See Content negotiation example for an example of using to return different content based on the header. Methods implementing a file-like interface for reading from an instance. This makes it possible to consume an incoming request in a streaming fashion. A common use-case would be to process a big XML payload with an iterative parser without constructing a whole XML tree in memory. Given this standard interface, an instance can be passed directly to an XML parser such as :\n\nIn an object, the and attributes are instances of , a dictionary-like class customized to deal with multiple values for the same key. This is necessary because some HTML form elements, notably , pass multiple values for the same key. The s at and will be immutable when accessed in a normal request/response cycle. To get a mutable version you need to use . implements all the standard dictionary methods because it’s a subclass of dictionary. Exceptions are outlined here: If is not passed in, the resulting will be empty (it will have no keys or values). Most s you encounter, and in particular those at and , will be immutable. If you are instantiating one yourself, you can make it mutable by passing to its . Strings for setting both keys and values will be converted from to . If is not set, it defaults to . Creates a new with keys from and each value equal to . For example: Returns the value for the given key. If the key has more than one value, it returns the last value. Raises if the key does not exist. (This is a subclass of Python’s standard , so you can stick to catching .) Sets the given key to (a list whose single element is ). Note that this, as other dictionary functions that have side effects, can only be called on a mutable (such as one that was created via ). Returns if the given key is set. This lets you do, e.g., . Uses the same logic as , with a hook for returning a default value if the key doesn’t exist. Like , except it uses internally. Takes either a or a dictionary. Like , except it appends to the current dictionary items rather than replacing them. For example: Like , except this uses the same last-value logic as and returns an iterator object instead of a view object. For example: Like , except this uses the same last-value logic as and returns an iterator instead of a view object. For example: In addition, has the following methods: Returns a copy of the object using . This copy will be mutable even if the original was not. Returns a list of the data with the requested key. Returns an empty list if the key doesn’t exist and is . It’s guaranteed to return a list unless the default value provided isn’t a list. Sets the given key to (unlike ). Appends an item to the internal list associated with key. Like , except it takes a list of values instead of a single value. Like , except it includes all values, as a list, for each member of the dictionary. For example: Returns a list of values for the given key and removes them from the dictionary. Raises if the key does not exist. For example: Removes an arbitrary member of the dictionary (since there’s no concept of ordering), and returns a two value tuple containing the key and a list of all values for the key. Raises when called on an empty dictionary. For example: Returns a representation of . For every (key, list) pair in , will have (key, item), where item is one element of the list, using the same logic as : Returns a string of the data in query string format. For example: Use the parameter to pass characters which don’t require encoding. For example:\n\nIn contrast to objects, which are created automatically by Django, objects are your responsibility. Each view you write is responsible for instantiating, populating, and returning an . The class lives in the module. Typical usage is to pass the contents of the page, as a string, bytestring, or , to the constructor: \"Here's the text of the web page.\" But if you want to add content incrementally, you can use as a file-like object: \"<p>Here's the text of the web page.</p>\" Finally, you can pass an iterator rather than strings. will consume the iterator immediately, store its content as a string, and discard it. Objects with a method such as files and generators are immediately closed. If you need the response to be streamed from the iterator to the client, you must use the class instead. To set or remove a header field in your response, use : You can also manipulate headers by treating your response like a dictionary: This proxies to , and is the original interface offered by . When using this interface, unlike a dictionary, doesn’t raise if the header field doesn’t exist. You can also set headers on instantiation: For setting the and header fields, it is recommended to use the and methods from , since these fields can have multiple, comma-separated values. The “patch” methods ensure that other values, e.g. added by a middleware, are not removed. HTTP header fields cannot contain newlines. An attempt to set a header field containing a newline character (CR or LF) will raise Telling the browser to treat the response as a file attachment¶ To tell the browser to treat the response as a file attachment, set the and headers. For example, this is how you might return a Microsoft Excel spreadsheet: There’s nothing Django-specific about the header, but it’s easy to forget the syntax, so we’ve included it here. A bytestring representing the content, encoded from a string if necessary. A string representation of , decoded using the response’s (defaulting to if empty). A object holding the cookies included in the response. A case insensitive, dict-like object that provides an interface to all HTTP headers on the response, except a header. See Setting header fields and . A string denoting the charset in which the response will be encoded. If not given at instantiation time, it will be extracted from and if that is unsuccessful, the setting will be used. The HTTP status code for the response. Unless is explicitly set, modifying the value of outside the constructor will also modify the value of . The HTTP reason phrase for the response. It uses the HTTP standard’s default reason phrases. Unless explicitly set, is determined by the value of . This attribute exists so middleware can treat streaming responses differently from regular responses. if the response has been closed. Instantiates an object with the given page content, content type, and headers. is most commonly an iterator, bytestring, , or string. Other types will be converted to a bytestring by encoding their string representation. Iterators should return strings or bytestrings and those will be joined together to form the content of the response. is the MIME type optionally completed by a character set encoding and is used to fill the HTTP header. If not specified, it is formed by and the settings, by default: . is the HTTP status code for the response. You can use Python’s for meaningful aliases, such as . is the HTTP response phrase. If not provided, a default phrase will be used. is the charset in which the response will be encoded. If not given it will be extracted from , and if that is unsuccessful, the setting will be used. is a of HTTP headers for the response. Sets the given header name to the given value. Both and should be strings. Deletes the header with the given name. Fails silently if the header doesn’t exist. Case-insensitive. Returns the value for the given header name. Case-insensitive. Returns the value for the given header, or an if the header doesn’t exist. Returns or based on a case-insensitive check for a header with the given name. Acts like for HTTP headers on the response. Sets a header unless it has already been set. Sets a cookie. The parameters are the same as in the cookie object in the Python standard library.\n• None should be a object, an integer number of seconds, or (default) if the cookie should last only as long as the client’s browser session. If is not specified, it will be calculated.\n• None should either be a string in the format or a object in UTC. If is a object, the will be calculated.\n• None Use if you want to set a cross-domain cookie. For example, will set a cookie that is readable by the domains www.example.com, blog.example.com, etc. Otherwise, a cookie will only be readable by the domain that set it.\n• None Use if you want the cookie to be only sent to the server when a request is made with the scheme.\n• None Use if you want to prevent client-side JavaScript from having access to the cookie. HttpOnly is a flag included in a Set-Cookie HTTP response header. It’s part of the RFC 6265 standard for cookies and can be a useful way to mitigate the risk of a client-side script accessing the protected cookie data.\n• None Use or to tell the browser not to send this cookie when performing a cross-origin request. SameSite isn’t supported by all browsers, so it’s not a replacement for Django’s CSRF protection, but rather a defense in depth measure. Use (string) to explicitly state that this cookie is sent with all same-site and cross-site requests. RFC 6265 states that user agents should support cookies of at least 4096 bytes. For many browsers this is also the maximum size. Django will not raise an exception if there’s an attempt to store a cookie of more than 4096 bytes, but many browsers will not set the cookie correctly. Like , but cryptographic signing the cookie before setting it. Use in conjunction with . You can use the optional argument for added key strength, but you will need to remember to pass it to the corresponding call. Deletes the cookie with the given key. Fails silently if the key doesn’t exist. Due to the way cookies work, and should be the same values you used in – otherwise the cookie may not be deleted. This method is called at the end of the request directly by the WSGI server. Returns the value of . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Always . This method makes an instance a stream-like object. Writes a list of lines to the response. Line separators are not added. This method makes an instance a stream-like object. Django includes a number of subclasses that handle different types of HTTP responses. Like , these subclasses live in . The first argument to the constructor is required – the path to redirect to. This can be a fully qualified URL (e.g. ), an absolute path with no domain (e.g. ), or even a relative path (e.g. ). In that last case, the client browser will reconstruct the full URL itself according to the current path. The constructor accepts an optional keyword argument that defaults to , producing a response with a 302 status code. If is , the status code will be 307 instead. See for other optional constructor arguments. This read-only attribute represents the URL the response will redirect to (equivalent to the response header). Like , but it returns a permanent redirect (HTTP status code 301) instead of a “found” redirect (status code 302). When , the response’s status code is 308. The constructor doesn’t take any arguments and no content should be added to this response. Use this to designate that a page hasn’t been modified since the user’s last request (status code 304). Acts just like but uses a 400 status code. Acts just like but uses a 404 status code. Acts just like but uses a 403 status code. Like , but uses a 405 status code. The first argument to the constructor is required: a list of permitted methods (e.g. ). Acts just like but uses a 410 status code. Acts just like but uses a 500 status code. If a custom subclass of implements a method, Django will treat it as emulating a , and the method must itself return a valid response object. If you find yourself needing a response class that Django doesn’t provide, you can create it with the help of . For example:\n\nThe class is used to stream a response from Django to the browser. is somewhat advanced, in that it is important to know whether you’ll be serving your application synchronously under WSGI or asynchronously under ASGI, and adjust your usage appropriately. Please read these notes with care. An example usage of under WSGI is streaming content when generating the response would take too long or uses too much memory. For instance, it’s useful for generating large CSV files. There are performance considerations when doing this, though. Django, under WSGI, is designed for short-lived requests. Streaming responses will tie a worker process for the entire duration of the response. This may result in poor performance. Generally speaking, you would perform expensive tasks outside of the request-response cycle, rather than resorting to a streamed response. When serving under ASGI, however, a need not stop other requests from being served whilst waiting for I/O. This opens up the possibility of long-lived requests for streaming content and implementing patterns such as long-polling, and server-sent events. Even under ASGI note, should only be used in situations where it is absolutely required that the whole content isn’t iterated before transferring the data to the client. Because the content can’t be accessed, many middleware can’t function normally. For example the and headers can’t be generated for streaming responses. The is not a subclass of , because it features a slightly different API. However, it is almost identical, with the following notable differences:\n• None It should be given an iterator that yields bytestrings, , or strings as content. When serving under WSGI, this should be a sync iterator. When serving under ASGI, then it should be an async iterator.\n• None You cannot access its content, except by iterating the response object itself. This should only occur when the response is returned to the client: you should not iterate the response yourself. Under WSGI the response will be iterated synchronously. Under ASGI the response will be iterated asynchronously. (This is why the iterator type must match the protocol you’re using.) To avoid a crash, an incorrect iterator type will be mapped to the correct type during iteration, and a warning will be raised, but in order to do this the iterator must be fully-consumed, which defeats the purpose of using a at all.\n• None It has no attribute. Instead, it has a attribute. This can be used in middleware to wrap the response iterable, but should not be consumed.\n• None It has no attribute, as it would require iterating the response object.\n• None You cannot use the file-like object or methods. Doing so will raise an exception. The base class is common between and . An iterator of the response content, bytestring encoded according to . The HTTP status code for the response. Unless is explicitly set, modifying the value of outside the constructor will also modify the value of . The HTTP reason phrase for the response. It uses the HTTP standard’s default reason phrases. Unless explicitly set, is determined by the value of . Boolean indicating whether is an asynchronous iterator or not. This is useful for middleware needing to wrap . If the client disconnects during a streaming response, Django will cancel the coroutine that is handling the response. If you want to clean up resources manually, you can do so by catching the : This example only shows how to handle client disconnection while the response is streaming. If you perform long-running operations in your view before returning the object, then you may also want to handle disconnections in the view itself.\n\nis a subclass of optimized for binary files. It uses wsgi.file_wrapper if provided by the wsgi server, otherwise it streams the file out in small chunks. If , the header is set to , which asks the browser to offer the file to the user as a download. Otherwise, a header with a value of (the browser default) will be set only if a filename is available. If doesn’t have a name or if the name of isn’t appropriate, provide a custom file name using the parameter. Note that if you pass a file-like object like , it’s your task to it before passing it to . The header is automatically set when it can be guessed from the content of . The header is automatically set when it can be guessed from the , or the name of . accepts any file-like object with binary content, for example a file open in binary mode like so: The file will be closed automatically, so don’t open it with a context manager. Python’s file API is synchronous. This means that the file must be fully consumed in order to be served under ASGI. In order to stream a file asynchronously you need to use a third-party package that provides an asynchronous file API, such as aiofiles. This method is automatically called during the response initialization and set various headers ( , , and ) depending on ."
    }
]