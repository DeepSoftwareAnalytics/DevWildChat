[
    {
        "link": "https://cedalo.com/blog/mqtt-keep-alive-explained",
        "document": "How many devices does your IoT system contain? The number can be small, up to five clients, or enormous with hundreds. For example, sensors, including magnetic contact sensors, power meters, chair occupancy sensors, etc. Regardless of the number of clients, it’s most likely that not all of them continuously transmit data. For example, if the temperature inside the fridge changes, a fridge’s sensor will send a message about this. For the rest of the time, this client remains ‘silent.’\n\nIf the clients remain silent for different reasons, an MQTT broker will disconnect them. At the same time, clients can ask the broker not to do this by notifying them that they are ‘alive.’ The MQTT Keep Alive parameter actually helps do this, and the intricacies we will cover in this article. So, let’s go!\n\nWhat is MQTT Keep Alive, and why do you need it?\n\nKeep Alive in MQTT is a flag that defines a time interval in seconds during which a client shall notify an MQTT broker that the connection is alive by sending a message. If the client is not sending a message, the MQTT broker is getting attentive to it and disconnects the client after another half of the specified interval. The parameter can be specified in the variable header of an MQTT CONNECT request as follows:\n\nIn this example, the broker would start caring about the status after 300 seconds without communication between the client and the broker. It waits for the message from the client. If the client is silent, the broker disconnects it after another 150 seconds. Likewise, if the broker does not respond to the client with the message, the client shuts down the connection.\n\nSo, Keep Alive enables the broker to detect when the client drops off the so-called half-open connection.\n\nKnowledge refresh: A half-open connection is a state of incomplete TCP connection when one part of the communication is not notified about the malfunction of the other part. As a result, it keeps sending messages waiting for an acknowledgment.\n\nWith the MQTT Keep Alive interval enabled, the MQTT broker will know the client’s status and keep it connected or cut off. Similarly, the client will be aware of any broker’s failure and close the connection, as it can detect the half-open connection also.\n\nSo, the primary value of the MQTT Keep Alive parameter is to detect disconnection between a broker and a client.\n\nWe’ve already talked a lot about the value and some ins and outs of the MQTT Keep Alive parameter. However, the hands-on case can better illustrate the flow of this broker-client communication.\n\nSo, everything starts with an MQTT CONNECT request from a client to the broker. Here is what the CONNECT message with the Keep Alive header can look like:\n\nWith the help of , the client told the MQTT broker that the Keep Alive interval is 300 seconds. Learn more about the other headers of the CONNECT request in our MQTT Connection Guide.\n\nThe connection is successfully established once the MQTT broker sends the CONNACK response with a 0 returnCode. After this, the parties start communicating with the help of PINGREQ and PINGRESP messages – , that the client sends, being ‘I am still connected,’ : ‘Yes, me too.’\n\nTo learn more about MQTT Last Will parameters, check out this blog post.\n\nIf the client is idle and does not send any MQTT PUBLISH or SUBSCRIBE messages, it notifies the broker that it’s alive with the help of messages. The broker responds with messages. The communication takes place according to the specified MQTT Keep Alive interval; this is every 300 seconds in our example. It’s okay if no messages are sent within the Keep Alive interval.\n\nIf the client sends an MQTT packet, for example, a PUBLISH message, the process of Keep Alive is cut and restored to the original status. Such a client is active and does not need to send messages. The Keep Alive interval resets since, in fact, the message exchange has already taken place.\n• PINGREQ Keep Alive message is the packet sent by the client to the MQTT broker according to the specified Keep Alive interval. A message tells that the client is alive and the connection is open.\n• PINGRESP Keep Alive message is the packet sent by the MQTT broker to the client in response to its message.\n\nUnless the equals 0, the connection will be closed if the MQTT broker does not receive any message from the client within the specified Keep Alive interval plus another half of the interval. In this case, the client will receive the LWT (last will and testament) message if the LWT was specified when establishing the connection. Likewise, the client closes the connection if the MQTT broker does not reply with a message to the client’s . However, in most cases, a disconnected client tries to reconnect.\n\nImportant: As the client sends any packet, the PINGREQ – PINGRESP exchange becomes obsolete, and the Keep Alive interval starts over at 0 seconds.\n\nWhen the client is back online, and the previous connection is kept half-open, the broker performs a simple client take-over:\n• It shuts down the previous connection to this client\n• It establishes a new connection with this client.\n\nHow long can the MQTT Keep Alive interval be?\n\nThe value for the parameter is an integer representing time in seconds. For example, means that a client shall send a message, e.g., PUBLISH, to the MQTT broker every 300 seconds. After another 150 seconds, the broker closes the connection.\n\nThe maximum value for the Keep Alive interval is 65535, which is 18 hours, 12 minutes, and 15 seconds.\n\nWhat is an MQTT Keep Alive default period?\n\nThe default value differs by the MQTT client library you use. For example, the Python MQTT client has 60 seconds as the default Keep Alive interval. The same is for Eclipse Paho MQTT browser-based client library written in JavaScript. And the Arduino’s MQTT PubSubClient interval is set to 15 seconds by default.\n\nHowever, you can set any other Keep Alive interval up to 65535 when establishing the connection between a broker and a client.\n\nYou can deactivate the MQTT Keep Alive mechanism if you use 0 as the interval: .\n\nCan the MQTT Keep Alive interval be different for broker and client?\n\nLet’s assume that you use the Eclipse Mosquitto MQTT broker… or even the Pro Edition for Mosquitto, which is a better option for commercial projects. You can test advanced Pro Mosquitto MQTT broker functionalities with our free Cedalo MQTT Platform trial. Sign up here!\n\nSo we assume that your MQTT broker’s default Keep Alive timeout is 10 seconds. Meanwhile, the client library you use is Arduino’s MQTT PubSubClient with 15 seconds as the default Keep Alive interval. Will this work?\n\nThe client determines the Keep Alive interval in the MQTT protocol when establishing a connection. So, in our example, the Mosquitto broker will use the client’s 15 seconds Keep Alive interval specified as a parameter in the CONNECT message.\n\nHowever, for MQTT v.5.0 clients, there could also be a reverse way of setting an MQTT Keep Alive value – from the broker to the client. The broker can tell the client what Keep Alive interval it should use. The option allows clients to connect with the Keep Alive interval less than or equal to the specified value. Unfortunately, there is no such mechanism for telling what Keep Alive interval to use for the MQTT v.3.1 and v.3.1.1 clients.\n\nLet’s wrap up this guide with a recap of the value provided by the Keep Alive parameter. It detects disconnected connections between the client and broker and discards these connections when they are no longer active.\n\nThe clients can remain idle for a specified interval, but then they must notify the broker that they are still alive with a PING request ( ) message. This will let the MQTT broker keep them connected. If the client fails to send any message for any reason, it will be disconnected. Although, the broker can take the client over once it’s online. The PINGREQ-PINGRESP exchange becomes obsolete as the client sends any other packet while exchanging the messages. The interval starts counting again at zero seconds.\n\nThe Keep Alive functionality is quite useful for monitoring sensor connectivity. PING messages sent from sensors (clients) will let them stay connected even if they are inactive for some time. In addition, you could create sensor-specific rules to trigger alarms or other actions in case of communication failure."
    },
    {
        "link": "https://hivemq.com/blog/mqtt-essentials-part-10-alive-client-take-over",
        "document": "Keep Alive is a feature of the MQTT protocol that allows an MQTT client to maintain its connection with a broker by sending regular control packets called PINGREQ to the broker. Here’s Part 10 of MQTT Essentials, a ten-part blog series on the core features and concepts of the MQTT protocol, where we focus on Keep Alive feature of MQTT. If you are looking to understand what is MQTT Last Will and Testament (LWT), check out Part 9 of this series. Else, let’s dive into MQTT Keep Alive’s critical role in mobile networks, and in maintaining a robust and efficient MQTT connection. What is MQTT Keep Alive and Why It’s Important? The Keep Alive mechanism in MQTT ensures the connection’s liveliness and provides a way for the broker to detect if a client becomes unresponsive or disconnected. When a client establishes a connection with an MQTT broker, it negotiates a Keep Alive value, which is a time interval expressed in seconds. The client must send a PINGREQ packet to the broker at least once within this interval to indicate its presence and keep the connection alive. Upon receiving a PINGREQ packet, the broker responds with a PINGRESP packet, confirming that the connection is still active.\n\nThe Problem of Half-Open TCP Connections in MQTT The problem of half-open TCP connections arises within MQTT, which relies on the Transmission Control Protocol (TCP) to ensure “reliable, ordered, and error-checked” packet transfer over the internet. Despite TCP’s robustness, there are instances where the synchronization between communicating parties can falter due to crashes or transmission errors. In TCP, this state of an incomplete connection is referred to as a half-open connection, where one side of the communication remains unaware of the other side’s failure. The connected side persistently attempts to send messages while eagerly awaiting acknowledgments. Andy Stanford-Clark, the inventor of the MQTT protocol, highlights that the issue of half-open connections becomes more pronounced in mobile networks. While TCP/IP theoretically notifies users when a socket breaks, practical scenarios, particularly on mobile and satellite links, involve the “faking” of TCP over the air with added headers at each end. This practice can lead to a phenomenon known as a “black hole” TCP session, where the connection appears open but, in reality, discards any transmitted data.\n\nHow Does MQTT Keep Alive Work? To address the challenge of half-open connections and enable continuous assessment of connection status, MQTT incorporates a vital feature called Keep Alive. This mechanism guarantees that the connection between the MQTT broker and client remains active and that both parties know their connection status. When a client establishes a connection with the broker, it specifies a time interval in seconds known as the Keep Alive duration. This duration sets the maximum allowed time gap during which the broker and client may not exchange any communication. According to the MQTT specification, the Keep Alive interval is defined as follows: \"The Keep Alive ... is the maximum time interval permitted to elapse between the point at which the Client finishes transmitting one Control Packet and the point it starts sending the next. It is the responsibility of the Client to ensure that the interval between Control Packets being sent does not exceed the Keep Alive value. In the absence of sending any other Control Packets, the Client MUST send a PINGREQ Packet.\" As long as messages are transmitted frequently within the Keep Alive interval, there is no need to send an additional message to verify the connection status. However, if the client remains inactive during the Keep Alive period, it must send a PINGREQ packet to the broker as a confirmation of its availability and to ensure that the broker is still accessible. If a client fails to send any messages or a PINGREQ packet within one and a half times the Keep Alive interval, the broker is responsible for disconnecting the client. Likewise, the client should close the connection if it does not receive a response from the broker within a reasonable timeframe. By employing the Keep Alive mechanism, MQTT enhances connection stability, mitigates the risks associated with half-open connections, and facilitates efficient communication between brokers and clients in various network conditions. How Does Keep Alive Ensure Connection Vitality? Let’s examine the flow of Keep Alive messages to gain a deeper understanding of the Keep Alive mechanism. The Keep Alive feature utilizes two packets: PINGREQ and PINGRESP. What is PINGREQ in MQTT Keep Alive? When a client wants to signal its continued presence and activity to the broker, it sends a PINGREQ packet. This packet is a “heartbeat” message indicating that the client is still alive. If the client has not sent any other type of packet, such as a PUBLISH or SUBSCRIBE packet, it must send a PINGREQ packet to the broker. The client can choose to send a PINGREQ packet at any time to verify the ongoing vitality of the network connection. Notably, the PINGREQ packet does not contain any payload. What is PINGRESP in MQTT Keep Alive? Upon receiving a PINGREQ packet from a client, the broker is obligated to respond with a PINGRESP packet. The PINGRESP packet serves as an acknowledgment from the broker to the client, confirming its availability and continued connection. Like the PINGREQ packet, the PINGRESP packet does not include a payload. How Can I Customize Keep Alive Settings for Optimal Performance?\n• None If the broker does not receive a PINGREQ packet or any other packet from a client within the expected time frame, the broker will close the connection and dispatch the last will and testament message(LWT) message if the client has specified one.\n• None The MQTT client is responsible for setting an appropriate keep alive value. For instance, the client can adjust the keep-alive interval based on its current signal strength, optimizing the connection for its specific circumstances.I.\n• None Importantly, the maximum Keep Alive interval is 18 hours, 12 minutes, and 15 seconds. Conversely, setting the Keep Alive interval to 0 effectively deactivates the Keep Alive mechanism, removing its influence on the connection’s stability and management. What is Client Take-Over in MQTT? In the MQTT protocol, when a client becomes disconnected, it typically attempts to reconnect. However, there are instances when the broker still maintains a half-open connection for that client. In such cases, when a client, which the MQTT broker perceives as online, initiates a reconnection and performs a `client take-over, the broker takes necessary action. It promptly terminates the previous connection associated with the same client (identified by the client identifier) and establishes a fresh connection with the client. This intelligent behavior ensures that half-open connections do not impede the disconnected client from successfully re-establishing its connection. By seamlessly managing client take-over, MQTT guarantees smooth connectivity and resilient communication in the face of intermittent network interruptions. The keep alive feature and client take-over mechanism are vital components of MQTT that ensure reliable and efficient communication in various scenarios. By implementing Keep Alive messages through PINGREQ and PINGRESP packets, MQTT enables clients to actively signal their presence and verify network connectivity. This mechanism prevents half-open connections and allows for timely detection of inactive or lost connections. Furthermore, client take-over facilitates seamless reconnection for disconnected clients. When a client initiates a reconnection, the MQTT broker intelligently closes any existing half-open connection associated with that client and establishes a fresh connection. This process ensures that disconnections do not hinder the client’s ability to regain connectivity and resume communication smoothly. MQTT clients must set appropriate keep alive values, considering factors such as signal strength and network conditions. This allows for optimal management of the keep alive mechanism and ensures efficient resource utilization. Understanding the intricacies of the keep alive feature and client take-over in MQTT empowers developers to build robust and resilient MQTT applications. By leveraging these capabilities, MQTT facilitates the creation of reliable, real-time IoT and messaging solutions that thrive even in challenging network environments. Watch the video below that complements the concepts discussed in this article."
    },
    {
        "link": "https://emqx.com/en/blog/mqtt-keep-alive",
        "document": "Why We Need Keep Alive\n\nThe MQTT protocol is hosted on top of the TCP protocol, which is connection-oriented, and provides a stable and orderly flow of bytes between two connected parties. However, in some cases, TCP can have half-connection problems. A half-connection is a connection that has been disconnected or not established on one side, while the connection on the other side is still maintained. In this case, the half-connected party may continuously send data, which obviously never reaches the other side. To avoid black holes in communication caused by half-connections, the MQTT protocol provides a Keep Alive mechanism that allows the client and MQTT server to determine whether there is a half-connection problem, and close the corresponding connection.\n\nMechanism and Use of MQTT Keep Alive\n\nWhen an MQTT client creates a connection to the MQTT broker, the Keep Alive mechanism can be enabled between the communicating parties by setting the Keep Alive variable header field in the connection request protocol packet to a non-zero value. Keep Alive is an integer from 0 to 65535, representing the maximum time in seconds allowed to elapse between MQTT packets sent by the client.\n\nWhen the broker receives a connection request from a client, it checks the value of the Keep Alive field in the variable header. When there is a value, the broker will enable the Keep Alive mechanism.\n\nIn the MQTT 5.0 standard, the concept of Server Keep Alive was also introduced, allowing the broker to choose to accept the Keep Alive value carried in the client request, or to override it, depending on its implementation and other factors. If the broker chooses to override this value, it needs to set the new value in the Server Keep Alive field of the Connection Acknowledgement Packet (CONNACK), and the client needs to use this value to override its own previous Keep Alive value when it reads it in the CONNACK.\n\nAfter the connection is established, the client needs to ensure that the interval between any two MQTT protocol packets it sends does not exceed the Keep Alive value. If the client is idle and has no packets to send, it can send PINGREQ protocol packets, instead.\n\nWhen the client sends a PINGREQ packet, the broker must return a PINGRESP packet. If the client does not receive a PINGRESP packet from the server within a reliable time, it means that there is a half-connection, the broker is offline, or there is a network failure, and the client should close the connection.\n\nAfter the connection is established, if the broker does not receive any packets from the client within 1.5 times the Keep Alive time, it will assume that there is a problem with the connection to the client, and the broker will disconnect from the client.\n\nIf the broker receives a PINGREQ protocol packet from the client, it needs to reply with a PINGRESP protocol packet for confirmation.\n\nWhen there is a half-connection within the broker, and when the corresponding client initiates a reconnection or a new connection, the broker will start the client takeover mechanism: it closes the old half-connection and establishes a new connection with the client.\n\nThis mechanism ensures that the client will not be prevented from reconnecting due to a half-connection problem.\n\nKeep Alive is typically used in conjunction with Will Message, which allow the device to promptly notify other clients in the event of an unexpected offline event.\n\nAs shown in the figure, when this client connects, Keep Alive is set to 5 seconds and a will message is set. If the server does not receive any packets from the client within 7.5 seconds (1.5 times the Keep Alive), it will send a will message with a payload of 'offline' to the 'last_will' topic.\n\nFor more details on MQTT Will Message, please check the blog Use of MQTT Will Message.\n\nHow to Use Keep Alive in EMQX\n\nIn EMQX, you can customize the behavior of the Server Keep Alive mechanism through the configuration file. The relevant field is as follows:\n\nIf this value is not set, the Keep Alive time will be determined by the client at the time it creates a connection.\n\nIf this value is set, the broker forces the Server Keep Alive mechanism to be enabled for all connections in that zone and will use that value to override the value in the client connection request.\n\nThe MQTT protocol requires the broker to assume that the client is disconnected when it does not receive any protocol packets from the client within 1.5 times the Keep Alive time.\n\nIn EMQX, we introduced the keepalive backoff factor and exposed this factor through the configuration file in order to allow users to more flexibly control the Keep Alive behavior on the broker side.\n\nAfter introducing the backoff factor, EMQX calculates the maximum timeout using the following formula:\n\nThe default value of backoff is 0.75. Therefore, the behavior of EMQX will be fully compliant with the MQTT standard when the user does not modify this configuration.\n\nRefer to the EMQX configuration documentation for more information.\n\nThis article introduces the Keep Alive mechanism in the MQTT protocol and how to use it in EMQX. You can use this feature to ensure the stability of MQTT connections and build more robust IoT applications.\n\nNext, you can check out MQTT Guide series of articles provided by EMQ to learn about MQTT protocol features, explore more advanced applications of MQTT, and get started with MQTT application and service development.\n• None How to Set Parameters When Establishing an MQTT Connection?\n• None MQTT Will Message (Last Will & Testament) Explained and Example"
    },
    {
        "link": "https://dev.to/emqx/what-is-the-mqtt-keep-alive-parameter-for-fk1",
        "document": "Why we Need Keep Alive\n\nThe MQTT protocol is hosted on top of the TCP protocol, which is connection-oriented, and provides a stable and orderly flow of bytes between two connected parties. However, in some cases, TCP can have half-connection problems. A half-connection is a connection that has been disconnected or not established on one side, while the connection on the other side is still maintained. In this case, the half-connected party may continuously send data, which obviously never reaches the other side. To avoid black holes in communication caused by half-connections, the MQTT protocol provides a Keep Alive mechanism that allows the client and MQTT server to determine whether there is a half-connection problem, and close the corresponding connection.\n\nMechanism and Use of Keep Alive\n\nWhen an MQTT client creates a connection to the MQTT broker, the Keep Alive mechanism can be enabled between the communicating parties by setting the Keep Alive variable header field in the connection request protocol packet to a non-zero value. Keep Alive is an integer from 0 to 65535, representing the maximum time in seconds allowed to elapse between MQTT protocol packets sent by the client.\n\nWhen the broker receives a connection request from a client, it checks the value of the Keep Alive field in the variable header. When there is a value, the broker will enable the Keep Alive mechanism.\n\nIn the MQTT 5.0 standard, the concept of Server Keep Alive was also introduced, allowing the broker to choose to accept the Keep Alive value carried in the client request, or to override it, depending on its implementation and other factors. If the broker chooses to override this value, it needs to set the new value in the Server Keep Alive field of the Connection Acknowledgement Packet (CONNACK), and the client needs to use this value to override its own previous Keep Alive value when it reads it in the CONNACK.\n\nAfter the connection is established, the client needs to ensure that the interval between any two MQTT protocol packets it sends does not exceed the Keep Alive value. If the client is idle and has no packets to send, it can send PINGREQ protocol packets, instead.\n\nWhen the client sends a PINGREQ packet, the broker must return a PINGRESP packet. If the client does not receive a PINGRESP packet from the server within a reliable time, it means that there is a half-connection, the broker is offline, or there is a network failure, and the client should close the connection.\n\nAfter the connection is established, if the broker does not receive any packets from the client within 1.5 times the Keep Alive time, it will assume that there is a problem with the connection to the client, and the broker will disconnect from the client.\n\nIf the broker receives a PINGREQ protocol packet from the client, it needs to reply with a PINGRESP protocol packet for confirmation.\n\nWhen there is a half-connection within the broker, and when the corresponding client initiates a reconnection or a new connection, the broker will start the client takeover mechanism: it closes the old half-connection and establishes a new connection with the client.\n\nThis mechanism ensures that the client will not be prevented from reconnecting due to a half-connection problem.\n\nHow to Use Keep Alive in EMQX\n\nIn EMQX, you can customize the behavior of the Server Keep Alive mechanism through the configuration file. The relevant field is as follows:\n\nIf this value is not set, the Keep Alive time will be determined by the client at the time it creates a connection.\n\nIf this value is set, the broker forces the Server Keep Alive mechanism to be enabled for all connections in that zone and will use that value to override the value in the client connection request.\n\nThe MQTT protocol requires the broker to assume that the client is disconnected when it does not receive any protocol packets from the client within 1.5 times the Keep Alive time.\n\nIn EMQX, we introduced the keepalive backoff factor and exposed this factor through the configuration file in order to allow users to more flexibly control the Keep Alive behavior on the broker side.\n\nAfter introducing the backoff factor, EMQX calculates the maximum timeout using the following formula:\n\n\n\nThe default value of backoff is 0.75. Therefore, the behavior of EMQX will be fully compliant with the MQTT standard when the user does not modify this configuration.\n\nRefer to the EMQX configuration documentation for more information.\n\nEMQX supports client access via WebSockets. When a client initiates a connection using WebSockets, it only needs to set the Keep Alive value in the client connection parameters. Refer to Connecting to an MQTT Server Using WebSocket.\n\nThis article introduces the Keep Alive mechanism in the MQTT protocol and how to use it in EMQX. Developers can use this feature to ensure the stability of MQTT connections and build more robust IoT applications."
    },
    {
        "link": "https://emqx.com/en/blog/how-to-set-parameters-when-establishing-an-mqtt-connection",
        "document": "Establishing an MQTT connection is the first step in communicating using the MQTT protocol. The MQTT protocol provides rich connection parameters to enable developers to create IoT applications that meet different business needs.\n\nThis article introduces the role of each connection parameter in MQTT and helps developers take their first steps in using MQTT.\n\nMQTT connections are initiated from the client to the broker. Any application or device running the MQTT client library is an MQTT client. The MQTT Broker handles client connection, disconnection, subscribe (or unsubscribe) requests, and routes messages up on receiving publish requests.\n\nAfter establishing a network connection with the broker, the very first message the client must send is a packet. The broker must reply with a to the client as a response, and the MQTT connection is established successfully after the client receives the packet. If the client does not receive a packet from the broker in time (usually a configurable timeout from the client side), it may actively close the network connection.\n\nMQTT protocol specification does not limit which transport to use, the mostly commonly adopted transport protocol for MQTT is TCP/TLS and Websocket. EMQ has also implemented MQTT over QUIC.\n\nTCP/TLS is widely used and is a connection-oriented, reliable, byte-stream-based transport layer communication protocol. It ensures that the bytes received are the same as those sent through the acknowledgment and retransmission mechanism.\n\nMQTT is usually based on TCP/TLS, which inherits many of the advantages of TCP/TLS and can run stably in low bandwidth, high latency, and resource-constrained environments.\n\nWith the rapid development of the Web technology, more and more applications can be implemented in the web browser taking advantage of the powerful rendering engine for UI. WebSocket, the native communication method for Web applications, is also widely used.\n\nMany IoT web-based applications such as device monitoring systems need to display device data in real-time in a browser. However, browsers transmit data based on the HTTP protocol and cannot use MQTT over TCP.\n\nThe founder of the MQTT protocol foresees the importance of Web applications, so the MQTT protocol supports communication through MQTT over WebSocket since its creation. Check out the blog for more information on how to use MQTT over WebSocket.\n\nQUIC (RFC 9000) is the underlying transport protocol of the next-generation Internet protocol HTTP/3, which provides connectivity for the modern mobile Internet with less connection overhead and message latency compared to TCP/TLS protocols.\n\nBased on the advantages of QUIC, which make it highly suitable for IoT messaging scenarios, EMQX 5.0 introduces MQTT over QUIC. Check out the blog for more information.\n\nThe connection address of MQTT usually includes the broker IP (or domain name), broker port, and protocol. In case of clustered MQTT brokers, there is typically a load-balancer put in front, so the IP or domain name might actually be the load-balancer.\n\nFor example, is a TCP-based MQTT connection address, and is a TLS/SSL based MQTT secure connection address.\n\nThe connection address also needs to contain the Path when using a WebSocket connection. The default Path configured for EMQX is .\n\nFor example, is a WebSocket-based MQTT connection address, and is a WebSocket-based MQTT secure connection address.\n\nThe MQTT Broker uses Client ID to identify clients, and each client connecting to the broker must have a unique Client ID. Client ID is a UTF-8 encoded string. If the client connects with a zero-length string, the broker should assign a unique one for it.\n\nDepending on the MQTT protocol version and implementation details of the broker, the valid set of characters accepted by the broker varies. The most conservative scheme is to use characters and limit the length to 23 bytes.\n\nDue to the uniqueness nature of the Client ID, if two clients connect to the same broker with the same Client ID, the client connects later will force the one connected earlier to go offline.\n\nThe MQTT protocol supports username-password authentication, but if the underlying transport layer is not encrypted, the username and password will be transmitted in plaintext, hence for the best security, or protocol is recommended.\n\nMost MQTT brokers default to allow anonymous login, meaning there is no need to provide username or password (or set empty strings).\n\nThe waiting time before receiving the broker packet, if the is not received within this time, the connection is closed.\n\nKeep Alive is an interval in seconds. When there is no message to send, the client will periodically send a heartbeat message to the broker according to the value of Keep Alive to ensure that the broker will not disconnect the connection.\n\nAfter the connection is established successfully, if the broker does not receive any packets from the client within 1.5 times of Keep Alive, it will consider that there is a problem with the connection with the client, and the broker will disconnect from the client.\n\nCheck out the blog for more details on Keep Alive.\n\nSet to means to create a persistent session. When the client disconnects, the session remains and saves offline messages until the session expires. Set to to create a new temporary session that is automatically destroyed when the client disconnects.\n\nThe persistent session makes it possible for the subscribe client to receive messages while it has gone offline. This feature is very useful in IoT scenarios where the network is unstable.\n\nThe number of messages the broker keeps for persistent sessions depends on the broker's settings. For example, the public MQTT broker provided by EMQ is set to keep offline messages for 5 minutes, and the maximum number of messages is 1000 (for QoS 1 and QoS 2 messages).\n\nCheck out the blog for more details on Clean Session.\n\nWhen an MQTT client that has set a Will Message goes offline abnormally, the MQTT broker publishes the Will Message set by that client.\n\nThe Will Message can be seen as a simplified MQTT message that also contains Topic, Payload, QoS, Retain, etc.\n• None When the device goes offline unexpectedly, the will message will be sent to the .\n• None The is the content of the message to be sent.\n• None The is the same as the QoS of standard MQTT messages. Check out the blog to learn more about MQTT QoS.\n• None The set to means the will message is a retained message. Upon receiving a message with the flag set, the MQTT broker must store the message for the topic to which the message was published, and it must store only the latest message. So the subscribers which are interested in this topic can go offline, and reconnect at any time to receive the latest message instead of having to wait for the next message from the publisher after the subscription. Check out the blog to learn more about MQTT Retained.\n\nThe most used versions of the MQTT protocol are MQTT v3.1, MQTT v3.1.1, and MQTT v5.0. Currently, MQTT 5.0 has become the protocol of choice for most IoT enterprises, and we recommend that first-time MQTT developers use this version directly.\n\nCheck out the MQTT 5.0 blog series provided by EMQ to learn about using the new features of MQTT 5.0.\n\nClean Session was removed in MQTT 5.0, but Clean Start and Session Expiry Interval were added.\n\nWhen Clean Start is it discards any existing session and creates a new session. A value means that the server must use the session associated with the Client ID to resume communication with the client (unless the session does not exist).\n\nIf Session Expiry Interval is set to 0 or is absent, the session ends when the network connection is closed. If it is (UINT_MAX), the session does not expire. If it is greater than 0, the number of seconds the session will remain after the network connection is closed.\n\nCheck out the blog to learn more about Clean Start & Session Expiry Interval.\n\nMQTT 5.0 also adds new connection properties to enhance the extensibility of the protocol. Check out the blog to learn more about Connect Properties.\n\nAlthough the MQTT protocol provides authentication mechanisms such as username-password, Client ID, etc., this is not enough for IoT security. With TCP-based plaintext transmission communication, it is difficult to guarantee data security.\n\nTLS (Transport Layer Security), or in some context, the new-deprecated name SSL, aims primarily to provide privacy and data integrity between two or more communicating computer applications. Running on top of TLS, MQTT can take full advantage of its security features to secure data integrity and client trustworthy.\n\nThe steps to enable SSL/TLS vary from MQTT broker to MQTT broker. EMQX has built-in support for TLS/SSL, including support for one-way/two-way authentication, X.509 certificates, load-balanced SSL, and many other security certifications.\n\nOne-way authentication is a way to establish secure communication only by verifying the server certificate. It ensures the communication is encrypted but cannot verify the client's authenticity. It usually needs to be combined with authentication mechanisms such as username-password and client ID. Check out the blog to learn how to establish a secure One-way authenticated MQTT connection.\n\nTwo-way authentication means that both the server and the client must provide certificates when authenticating communications, and both parties need to authenticate to ensure that the other is trusted. Some application scenarios with high-security requirements require Two-way authentication to be enabled. Check out the blog to learn how to establish a secure Two-way authenticated MQTT connection.\n\nAt this point, you should have a good understanding of how MQTT connections are established and the role of each connection parameter.\n\nNext, you can check out MQTT Guide series of articles provided by EMQ to learn about MQTT Topics, Wildcards, Retained Messages, Last-Will, and other features. Explore more advanced applications of MQTT and get started with MQTT application and service development.\n• MQTT Will Message (Last Will & Testament) Explained and Example\n• What is the MQTT Keep Alive parameter for?"
    },
    {
        "link": "https://github.com/aws-amplify/amplify-js/issues/2692",
        "document": "** Which Category is your question related to? **\n\n PubSub connection problems\n\n** What AWS Services are you utilizing? **\n\n PubSub in aws-amplify 1.1.19\n\n** Provide additional details e.g. code snippets **\n\n What is the best way to keep PubSub connection alive by using aws-amplify? Or is there even any way?\n\nI am using similar code as you mention in the documentation:\n\n PubSub.subscribe(['myTopic1','myTopic1']).subscribe({ next: data => console.log('Message received', data), error: error => console.error(error), // this never logs anything) close: () => console.log('Done'), // this never logs anything) })\n\nHowever, I have the problem that clients Internet connection can be lost for a short period of time and then these can no longer receive messages. For example, if portable Wifi router switch connection from 4G to 3G, I get the following message in console:\n\n \n\n I would like to catch these connection problems somehow in order to subscribe to topics again so that I can keep connection alive."
    },
    {
        "link": "https://github.com/eclipse/paho.mqtt.javascript/issues/106",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/49413553/mqtt-js-how-to-handle-connection-errors",
        "document": "I'm trying to use it in an Angular service and connecting and communicating with the server seems to work fine when the server is running but never fires.\n\nI managed to detect errors when connecting by attaching the error callback to instead, but seems to be a private property since it isn't exposed in the official TypeScript definitions, so not sure if this really is the correct way to go.\n\nBut what I still don't get to work are errors when the connection is lost, none of the error handlers fire. Instead the browser console logs unhandled websocket errors."
    },
    {
        "link": "https://stackoverflow.com/questions/66463611/paho-mqtt-js-client-loses-connection-to-mosquitto-broker-when-i-publish-or-recei",
        "document": "Bottom line up front: The Paho MQTT client sucessfully connects to my Mosquitto broker, but immediately disconnects when I try to publish a message or when it receives a message from a topic it's subscribed to. I've tried changing Mosquitto's listening port and authentication settings, and using two different versions of Paho MQTT, and I still have the same problem.\n\nNow let's get into detail.\n\nIntro: I'm making a dashboard for some facial recognition devices that communicate through MQTT. I set up a Mosquitto broker and I've had no problems connecting to it and communicating with the devices using the Paho MQTT client for Python (I made a kind of server to sync the device's info to a database). Now I'm making the web interface, so I added a WebSockets listener to my and wrote a script using the Paho MQTT library for Javascript to connect to it, subscribe to topic , send a simple JSON message to topic to get the list of online devices, and process the response of the Python server once it arrives.\n\nProblem and attempted solutions: I ran the Django server, loaded the web page and opened the JS console to find that the MQTT client successfully connected to the broker but immediately disconnected when it tried to publish the message to topic . Here's each line of console output with their explanations:\n• The message produced by the onSuccess function, which indicates that the client successfully connected to the Mosquitto broker:\n• In the onConnected function, I added to see the URI used by the client to connect to the broker. I got:\n• After printing to console, I made the client subscribe to and then print 'subscribed' to console:\n• Then I call , a function which creates a simple JSON string and publishes it to the topic . But first, it prints the strign to the console so that I can check it (just in case):\n• Then, when the method is actually executed, is when I get this error (captured by the onConnectionLost function): Pérdida de conexión con el broker MQTT: AMQJS0005E Internal error. Error Message: message is not defined, Stack trace: No Error Stack Available (código: 5)\n\nI checked the Mosquitto log file and it only says when a new client was connected and then when it was disconnected because of a socket error (each time for every page reload). Tail of :\n\nI tried changing the listening port in , and enabling and disabling authentication, but it changes nothing. And obviously I've had to restart Mosquito every time I changed the config file. I don't think the problem is Mosquitto.\n\nI have the same problem whether I use Paho MQTT version 1.1.0 or 1.0.3.\n\nAs an experiment, I commented out the call to in my Javascript so that it doesn't try to publish anything, reloaded the page and there was no error, as expected. Then, I used MQTTX to send a JSON message to the topic to which the MQTT JS client is subscribed to, and it immediately disconnected with the same error message.\n\nCode: At the bottom of the page ( ) I have the following code (the original code has Django template tags to fill in some values, so this is the actual code received by the browser):\n\nThe files mentioned above just has some functions that I think will be useful for other pages, so I separated them to a file:\n\nHere are the contents of my file:\n\nIt just sets up a TCP listener and a WebSockets listener, both disallow anonymous connections, and authenticate using a pwdfile. As I said before, I have enabled and disabled anonymous connections, and changed the port number to 9001 and back to 61613, and I still have the same error.\n\nConclusion: I don't know what to do and this project's deadline is next week."
    },
    {
        "link": "https://docs.emqx.com/en/cloud/latest/connect_to_deployments/mqtt_client_error_codes.html",
        "document": "For devices connected via the MQTT protocol, the server's common error codes are explained as follows.\n\nMQTT v3.1.1 protocol has only 10 return codes. These return codes can represent little meaning, and the same return code value can have different meanings in different messages.\n\nThere are only 6 return codes in the CONNECT packet. Only when the return code of the CONNACK packet sent back by the server is 0, the connection is successfully established.\n\nThere are only 4 return codes in the SUBACK packet. Except that the return code 0x80 indicates failure, the other return codes indicate that the subscription is successful, and the three values 0, 1, 2 represent the maximum QoS value of the subscribed message.\n\nThe MQTT v5.0 protocol renames the return code to a reason code, adding a reason code to indicate more types of errors.\n\nThe following table is a list of reason codes that represent the value of the reason code and the control packet containing the reason code:\n\nThe reason code is a single-byte unsigned value used to indicate the result of the operation. The reason code less than 0x80 indicates that the result of the operation is successful. Under normal circumstances, the reason code value returned by the operation is 0. If the reason code returned is greater than or equal to 0x80, the operation has failed.\n\nThe reason codes for CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, DISCONNECT and AUTH control packets are stored in the variable header. The SUBACK and UNSUBACK packets contain a list of reason codes in the payload."
    }
]