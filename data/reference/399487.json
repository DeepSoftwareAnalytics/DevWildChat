[
    {
        "link": "https://dotnetustad.com/c-sharp/tree-traversal-using-recursion",
        "document": "Tree traversal refers to the process of visiting and accessing all nodes in a tree data structure in a specific order. Recursive tree traversal involves using recursion to traverse the tree, visiting each node and its children in a particular sequence. The three common types of recursive tree traversal are in-order, pre-order, and post-order traversal.\n\n1. In-order Tree Traversal:\n\n In in-order traversal, the left subtree is visited first, then the current node, and finally the right subtree. For binary search trees (BST), the nodes are visited in ascending order.\n\n2. Pre-order Tree Traversal:\n\n In pre-order traversal, the current node is visited first, followed by the left subtree, and then the right subtree.\n\n3. Post-order Tree Traversal:\n\n In post-order traversal, the left subtree is visited first, then the right subtree, and finally the current node.\n\nBinary Tree Traversal Using Recursion:\n\n Binary trees are a specific type of tree where each node has at most two children: left and right. The recursive tree traversal methods mentioned above can be applied to binary trees as well.\n\nHere's an example of using the recursive methods for binary tree traversal:\n\nWhen you run this program, you'll see the output for in-order, pre-order, and post-order traversals of the binary tree. The output will be as follows:"
    },
    {
        "link": "https://stackoverflow.com/questions/3518508/recursively-traversing-a-tree-in-c-sharp-from-top-down-by-row",
        "document": "Update: Haha, wow, this is completely wrong, I just realized (as in it is not doing what you asked for). Never mind -- looks like you already got a correct answer, anyway :)\n\nI think I understand your problem. Let me know if I'm getting something wrong.\n\nYou have a class that looks something like this:\n\nFirst order of business would be to write a function that takes a parameter and, given some enumerable collection of objects, returns all of its descendents in a recursive fashion:\n\nNext up: write a function that takes a object and finds the highest descendent with a specified . This is really a pretty simple operation, so I won't even define a proper function; I'll just use a lambda:\n\nNow for any given Id value, it is quite trivial to find the highest matching :"
    },
    {
        "link": "https://stackoverflow.com/questions/5338519/traversing-a-tree-structure-using-recursion",
        "document": "I am dealing with one table on the database. The columns are: id, name, parent_id, hasChildren. (parent_id would be an id on the table. if parent_id is null, the record is a parent.)\n\nWhat would be the best way to loop through this data so I can add it to a list like:\n\nedit - when i say \"list\" i mean like a listbox\n\nedit2 - woops, yes, list needs to be sorted by parent record alphabetically. i'm using mssql."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/6xmhxo/simplest_way_to_flatten_a_tree_structure",
        "document": "I have a tree structure which could look like this:\n\nThe data is saved in a database like this (using the entity framework):\n\nwhile parent_id is null if it's the top element.\n\nI'd like to make a flatten list of all those items so in the end it should look like this, but is till in the hierarchical order:\n\nI was thinking about using a recursive method, but I think there are some more elegant approaches using anonymous functions / lambda expressions.\n\nThe reason is I have to delete those items one by one in the correct hierarchical order."
    },
    {
        "link": "https://gunnarpeipman.com/traverse-hierarchy-sharepoint-sql",
        "document": "I started playing with small idea about how to go through document repository on SharePoint using more universal approach than just piling code to using-blocks and methods that depend on these. My goal was to separate in code hierarchy traversing logic from document exporting logic so I can use traversing part also in other projects on different types of hirarchies. Here is my nice and clean solution.\n\nWhen working out my solution I suddenly got to my safe waters – generalizing out something universal I can use also for other projects that deal with hierarchical data. After some coding I got my current implementation done. Ladies and gentlemen – meet my new invention called HierarchyTraverser!\n\nMy solution contains one interface and two classes.\n• IHierarchyProvider<T> – interface for classes that provide hierarchy loading functionalities and know about hierarchies to be traversed. Class following this interface is used by HierarchyTraverser class.\n• HierarchyTraverser<T> – class that does actual work on traversing hierarchies. It uses IHierarchyProvider<T> to step through hierarchies.\n• NodeLoadedEventArgs<T> – event fired by HierarchyTraverser<T> to handle control over to client after hierarchy node is loaded.\n\nThe idea of hierarchy provider is to hide details of hierarchy implementation to classes that follow this interface. My solution doesn’t want to know any dirty details about hierarchies except one thing – is there root node or not. If there’s no root node then null in provider calls is considered to be root node. This is the case with menu tables in some databases where all first level menu items have null for parent level id.\n\nTraverser class is longer but not too long. Here is hierarchy traversing actually done.\n\nSome of readers probably want to know why I keep path of nodes in hierarchy traverser class. When exporting documents from repositories then very we have to know also at least some folders in parent folders tree. It’s not needed always but this far there have always been some little evils in details.\n\nHere is a simple example about how to use HierarchyTraverser<T> to traverse SharePoint based document repository. Here is sample IHierarchyProvider of SharePoint. Notice how hierarchy details are handled in this class. I think the code is simple enough to understand also for those who doesn’t develop SharePoint solutions.\n\nIn real scenarios we are not done with this simple provider but it is still good starting point.\n\nSuppose we have command line application that traverses some SharePoint document library and prints out folder structure.\n\nThis is sample output of this console application.\n\nNodeLoaded event is the integration point where calls to document exporting functionalities are made.\n\nAnother example is SQL Server database with menu table. There is no root folder and all menu items on first level just doesn’t have parent menu items set.\n\nFor database I wrote generic hierarchy provider that is not bound to any specific database server. The code is a bit long but it’s actually easy to understand. Notice how this provider uses null as root node.\n\nTo see database hierarchy provider in action we have to write simple program that uses it. Following example uses this provider to print out menu structure to console windows.\n\nThis is the output we will see on console when running the application.\n\nI started with annoying problem. I wanted to separate hierarchy traversal from business logic of document importer and I ended up with this nice and general hierarchy traverser solution. It’s a good example about how creating order to chaos may lead to even more order if we make some more steps ahead. Hierarchy traverser presented here is good fit for almost all types of hierarchies as it doesn’t depend directly on technical details of any hierarchy."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/66893/tree-data-structure-in-c-sharp",
        "document": "I just want a generic tree which can be unbalanced. Think of a directory tree. C5 looks nifty, but their tree structures seem to be implemented as balanced red-black trees better suited to search than representing a hierarchy of nodes.\n\nI feel a bit silly implementing my own tree, just as I would implementing my own ArrayList.\n\nI was looking for a tree or graph data structure in C#, but I guess there isn't one provided. An Extensive Examination of Data Structures Using C# 2.0 a bit about why. Is there a convenient library which is commonly used to provide this functionality? Perhaps through a strategy pattern to solve the issues presented in the article.\n\nMy best advice would be that there is no standard tree data structure because there are so many ways you could implement it that it would be impossible to cover all bases with one solution. The more specific a solution, the less likely it is applicable to any given problem. I even get annoyed with LinkedList - what if I want a circular linked list? The basic structure you'll need to implement will be a collection of nodes, and here are some options to get you started. Let's assume that the class Node is the base class of the entire solution. If you need to only navigate down the tree, then a Node class needs a List of children. If you need to navigate up the tree, then the Node class needs a link to its parent node. Build an AddChild method that takes care of all the minutia of these two points and any other business logic that must be implemented (child limits, sorting the children, etc.)\n\nMost trees are formed by the data you are processing. Say you have a class that includes details of someone’s , would you rather have the tree structure as part of your “domain class”, or use a separate tree class that contained links to your person objects? Think about a simple operation like getting all the of a , should this code be in the class, or should the user of the class have to know about a separate tree class? Another example is a parse tree in a compiler… Both of these examples show that the concept of a tree is part of the domain of the data and using a separate general-purpose tree at least doubles the number of objects that are created as well as making the API harder to program again. We want a way to reuse the standard tree operations, without having to reimplement them for all trees, while at the same time, not having to use a standard tree class. Boost has tried to solve this type of problem for C++, but I am yet to see any effect for .NET to get it adapted.\n\nI'm Akira. I came across your question about tree data structures in C# and thought that my library, VirtualStorageLibrary, might be useful for you. This library is not based on a physical file system; instead, it is an in-memory tree structure collection designed from scratch, inspired by file systems. It supports unbalanced tree structures, making it ideal for creating hierarchical structures like a directory tree. Currently, the library is available as a pre-release version 0.9.0. VirtualStorageLibrary allows you to handle tree structures flexibly, enabling operations similar to those of a file system. For more detailed usage examples, please refer to the documentation here:\n\n Getting Started with VirtualStorageLibrary."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/collections",
        "document": "Similar data can often be handled more efficiently when stored and manipulated as a collection. You can use the System.Array class or the classes in the System.Collections, System.Collections.Generic, System.Collections.Concurrent, and System.Collections.Immutable namespaces to add, remove, and modify either individual elements or a range of elements in a collection.\n\nThere are two main types of collections; generic collections and non-generic collections. Generic collections are type-safe at compile time. Because of this, generic collections typically offer better performance. Generic collections accept a type parameter when they're constructed. They don't require that you cast to and from the Object type when you add or remove items from the collection. In addition, most generic collections are supported in Windows Store apps. Non-generic collections store items as Object, require casting, and most aren't supported for Windows Store app development. However, you might see non-generic collections in older code.\n\nIn .NET Framework 4 and later versions, the collections in the System.Collections.Concurrent namespace provide efficient thread-safe operations for accessing collection items from multiple threads. The immutable collection classes in the System.Collections.Immutable namespace (NuGet package) are inherently thread-safe because operations are performed on a copy of the original collection, and the original collection can't be modified.\n\nAll collections provide methods for adding, removing, or finding items in the collection. In addition, all collections that directly or indirectly implement the ICollection interface or the ICollection<T> interface share these features:\n• None The ability to enumerate the collection .NET collections either implement System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> to enable the collection to be iterated through. An enumerator can be thought of as a movable pointer to any element in the collection. The foreach, in statement and the For Each...Next Statement use the enumerator exposed by the GetEnumerator method and hide the complexity of manipulating the enumerator. In addition, any collection that implements System.Collections.Generic.IEnumerable<T> is considered a queryable type and can be queried with LINQ. LINQ queries provide a common pattern for accessing data. They're typically more concise and readable than standard loops and provide filtering, ordering, and grouping capabilities. LINQ queries can also improve performance. For more information, see LINQ to Objects (C#), LINQ to Objects (Visual Basic), Parallel LINQ (PLINQ), Introduction to LINQ Queries (C#), and Basic Query Operations (Visual Basic).\n• None The ability to copy the collection contents to an array All collections can be copied to an array using the method. However, the order of the elements in the new array is based on the sequence in which the enumerator returns them. The resulting array is always one-dimensional with a lower bound of zero.\n\nIn addition, many collection classes contain the following features:\n• The capacity of a collection is the number of elements it can contain. The count of a collection is the number of elements it actually contains. Some collections hide the capacity or the count or both. Most collections automatically expand in capacity when the current capacity is reached. The memory is reallocated, and the elements are copied from the old collection to the new one. This design reduces the code required to use the collection. However, the performance of the collection might be negatively affected. For example, for List<T>, if Count is less than Capacity, adding an item is an O(1) operation. If the capacity needs to be increased to accommodate the new element, adding an item becomes an O( ) operation, where is Count. The best way to avoid poor performance caused by multiple reallocations is to set the initial capacity to be the estimated size of the collection. A BitArray is a special case; its capacity is the same as its length, which is the same as its count.\n• The lower bound of a collection is the index of its first element. All indexed collections in the System.Collections namespaces have a lower bound of zero, meaning they're 0-indexed. Array has a lower bound of zero by default, but a different lower bound can be defined when creating an instance of the Array class using Array.CreateInstance.\n• None Synchronization for access from multiple threads (System.Collections classes only). Non-generic collection types in the System.Collections namespace provide some thread safety with synchronization; typically exposed through the SyncRoot and IsSynchronized members. These collections aren't thread-safe by default. If you require scalable and efficient multi-threaded access to a collection, use one of the classes in the System.Collections.Concurrent namespace or consider using an immutable collection. For more information, see Thread-Safe Collections.\n\nIn general, you should use generic collections. The following table describes some common collection scenarios and the collection classes you can use for those scenarios. If you're new to generic collections, the following table will help you choose the generic collection that works best for your task:\n\nWhen choosing a collection class, it's worth considering potential tradeoffs in performance. Use the following table to reference how various mutable collection types compare in algorithmic complexity to their corresponding immutable counterparts. Often immutable collection types are less performant but provide immutability - which is often a valid comparative benefit.\n\nA can be efficiently enumerated using either a loop or a loop. An , however, does a poor job inside a loop, due to the O(log ) time for its indexer. Enumerating an using a loop is efficient because uses a binary tree to store its data instead of an array like uses. An array can be quickly indexed into, whereas a binary tree must be walked down until the node with the desired index is found.\n\nAdditionally, has the same complexity as because they both use binary trees. The significant difference is that uses an immutable binary tree. Since also offers a System.Collections.Immutable.ImmutableSortedSet<T>.Builder class that allows mutation, you can have both immutability and performance."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-list-class",
        "document": "In C#, the List<T> class represents the list of objects that can be accessed by index. It comes under the System.Collections.Generic namespace. List class can be used to create a collection of different types like integers, strings, etc. List<T> class also provides the methods to search, sort, and manipulate lists.\n• None It is different from the arrays. A List<T> can be resized dynamically\n• None List<T> class can accept null as a valid value for reference types and it also allows duplicate elements.\n• None If the Count becomes equal to Capacity, then the capacity of the List increases automatically by reallocating the internal array. The existing elements will be copied to the new array before the addition of the new element.\n• None List<T> class is the generic equivalent of the\n• None This class can use both equality and ordering comparisons.\n• None List<T> class is not sorted by default and elements are accessed by a zero-based index.\n• None For very large List<T> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the enabled attribute of the configuration element to true in the run-time environment.\n\nExample: This example demonstrates how to create a list, add elements to it, and then display the elements using the for-each loop.\n\nExample: This example demonstrates how to create an empty List and display its initial count.\n\nThe List class provides several properties to access its state.\n\nExample: This example, demonstrates the list capacity and count.\n\nAdds an object to the end of the List<T>. Adds the elements of the specified collection to the end of the List<T>. Uses a binary search algorithm to locate a specific element in the sorted List<T> or a portion of it. Removes all elements from the List<T>. Determines whether an element is in the List<T>. Converts the elements in the current List<T> to another type, and returns a list containing the converted elements. Copies the List<T> or a portion of it to an array. Determines whether the specified object is equal to the current object. Determines whether the List<T> contains elements that match the conditions defined by the specified predicate. Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List<T>. Retrieves all the elements that match the conditions defined by the specified predicate. Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within the List<T> or a portion of it. This method returns -1 if an item that matches the conditions is not found. Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire List<T>. Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within the List<T> or a portion of it. Performs the specified action on each element of the List<T>. Returns an enumerator that iterates through the List<T>. Creates a shallow copy of a range of elements in the source List<T>. Gets the Type of the current instance. Returns the zero-based index of the first occurrence of a value in the List<T> or in a portion of it. Inserts an element into the List<T> at the specified index. Inserts the elements of a collection into the List<T> at the specified index. Returns the zero-based index of the last occurrence of a value in the List<T> or in a portion of it. Removes the first occurrence of a specific object from the List<T>. Removes all the elements that match the conditions defined by the specified predicate. Removes the element at the specified index of the List<T>. Removes a range of elements from the List<T>. Reverses the order of the elements in the List<T> or a portion of it. Sorts the elements or a portion of the elements in the List<T> using either the specified or default IComparer<T> implementation or a provided Comparison<T> delegate to compare list elements. Copies the elements of the List<T> to a new array. Sets the capacity to the actual number of elements in the List<T>, if that number is less than a threshold value. Determines whether every element in the List<T> matches the conditions defined by the specified predicate.\n\nExample 1: This example demonstrates how to check if a specified element is present in the list using Contains().\n\nExample 2: This example printing the list before and after removing elements at specified index."
    },
    {
        "link": "https://stackoverflow.com/questions/72212894/creating-a-tree-from-a-collection-listt",
        "document": "I wrote an algoritm to build a tree from a flat list. (a faster approach than filtering the same list over and over) As the items comes from a database, the parentId's should exists, and circular references should not occur. This example isn't able to handle those. But it might give you a jump-start how to make a faster algoritm.\n\nIn a nutshell, loop until all items are added. Use a while-loop instead of a foreach. The problem with foreach is that you aren't allowed to make modifications to the collection while iterating. This can be solved by creating copies, but it will end-up in many copy actions.\n\nWhen it is a child (so the parentId is filled), I use the lookup dictionary to check if his parent was already added. If not, I'll skip it and check the next item. (this makes it possible that the parent is below the child in de list). When it is added to the parent, also add the child to the lookup, so their children are able to add them as child.\n\nWhen it is a parent, I add it to the rootNodes, and add it to the lookup.\n\nThe classes I used are:"
    }
]