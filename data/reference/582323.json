[
    {
        "link": "https://realpython.com/list-comprehension-python",
        "document": "List comprehensions in Python provide a concise way to create lists by embedding a loop and optional conditional logic in a single line. You use a list comprehension to transform and filter elements from an iterable efficiently. It allows you to replace complex loops and functions with more readable and often faster expressions. By understanding list comprehensions, you can optimize your code for better performance and clarity.\n\nBy the end of this tutorial, you’ll understand that:\n• A list comprehension in Python is a tool for creating lists by iterating over an iterable and optionally applying a condition.\n• You should use list comprehensions instead of loops when you want concise, readable code that performs transformations or filtering.\n• You add conditional logic to a list comprehension by including an statement within the comprehension.\n• A list comprehension can be faster than a loop because it’s optimized for performance by Python’s internal mechanisms.\n• A Python list comprehension is not lazy—it generates and stores the entire list in memory eagerly.\n• The difference between list comprehensions and is that the former creates a list, while the latter returns a object, which is iterable.\n\nIn this tutorial, you’ll explore how to leverage list comprehensions to simplify your code. You’ll also gain an understanding of the trade-offs that come with using them so that you can determine when other approaches are preferable.\n\nThere are a few different ways to create and add items to a lists in Python. In this section, you’ll explore loops and the function to perform these tasks. Then, you’ll move on to learn about how to use list comprehensions and when list comprehensions can benefit your Python program. The most common type of loop is the loop. You can use a loop to create a list of elements in three steps:\n• Loop over an iterable or range of elements.\n• Append each element to the end of the list. If you want to create a list containing the first ten perfect squares, then you can complete these steps in three lines of code: Here, you instantiate an empty list, . Then, you use a loop to iterate over . Finally, you multiply each number by itself and append the result to the end of the list. For an alternative approach that’s based in functional programming, you can use . You pass in a function and an iterable, and will create an object. This object contains the result that you’d get from running each iterable element through the supplied function. As an example, consider a situation in which you need to calculate the price after tax for a list of transactions: Here, you have an iterable, , and a function, . You pass both of these arguments to and store the resulting object in . Finally, you convert into a list using . List comprehensions are a third way of making or transforming lists. With this elegant approach, you could rewrite the loop from the first example in just a single line of code: Rather than creating an empty list and adding each element to the end, you simply define the list and its contents at the same time by following this format: Every list comprehension in Python includes three elements:\n• is the member itself, a call to a method, or any other valid expression that returns a value. In the example above, the expression is the square of the member value.\n• is the object or value in the list or iterable. In the example above, the member value is .\n• is a list, set, sequence, generator, or any other object that can return its elements one at a time. In the example above, the iterable is . Because the expression requirement is so flexible, a list comprehension in Python works well in many places where you would use . You can rewrite the pricing example with its own list comprehension: The only distinction between this implementation and is that the list comprehension in Python returns a list, not a map object.\n\nOne benefit of using a list comprehension in Python is that it’s a single tool that you can use in many different situations. In addition to standard list creation, list comprehensions can also be used for mapping and filtering. In this section, you’ll find advanced techniques to work with list comprehensions in Python. The most common way to add conditional logic to a list comprehension is to add a conditional to the end of the expression. Earlier, you saw this formula for how to create list comprehensions: While this formula is accurate, it’s also a bit incomplete. A more complete description of the comprehension formula adds support for optional conditionals. Here, your conditional statement comes just before the closing bracket: Conditionals are important because they allow list comprehensions to filter out unwanted values, which would normally require a call to : \"the rocket came back from mars\" In this code block, the conditional statement filters out any characters in that aren’t vowels. The conditional can test any valid expression. If you need a more complex filter, then you can even move the conditional logic to a separate function: \"The rocket, who was named Ted, came back \" \"from Mars because he missed his friends.\" Here, you create a complex filter, , and pass this function as the conditional statement for your list comprehension. Note that you also pass the member value as an argument to your function. You can place the conditional at the end of the statement for basic filtering, but what if you want to change a member value instead of filtering it out? In this case, it’s useful to place the conditional near the beginning of the expression. You can do so by taking advantage of the conditional expression: By placing the conditional logic at the beginning of a list comprehension, you can use conditional logic to select from multiple possible output options. For example, if you have a list of prices, then you may want to replace negative prices with and leave the positive values unchanged: Here, your expression is a conditional expression, . This tells Python to output the value of if the number is positive, but to use if the number is negative. If this seems overwhelming, then it may be helpful to view the conditional logic as its own function: Now, your conditional expression is contained within , and you can use it as part of your list comprehension. While the list comprehension in Python is a common tool, you can also create set and dictionary comprehensions. A set comprehension is almost exactly the same as a list comprehension in Python. The difference is that set comprehensions make sure the output contains no duplicates. You can create a set comprehension by using curly braces instead of brackets: Your set comprehension outputs all the unique vowels that it found in . Unlike lists, sets don’t guarantee that items will be saved in any particular order. This is why the first member of the set is , even though the first vowel in is . Dictionary comprehensions are similar, with the additional requirement of defining a key: To create the dictionary, you use curly braces ( ) as well as a key-value pair ( ) in your expression. Python 3.8 introduced the assignment expression, also known as the walrus operator. To understand how you can use it, consider the following example. Say you need to make ten requests to an API that will return temperature data. You only want to return results that are greater than 100 degrees Fahrenheit. Assume that each request will return different data. In this case, the formula expression for member in iterable if conditional provides no way for the conditional to assign data to a variable that the expression can access. You need the temperature in both the expression and the conditional so this is a challenge. The walrus operator ( ) solves this problem. It allows you to run an expression while simultaneously assigning the output value to a variable. The following example shows how this is possible, using to generate fake weather data: Note that the walrus operator needs to be in the conditional part of your comprehension. You won’t often need to use the assignment expression inside of a list comprehension in Python, but it’s a useful tool to have at your disposal when necessary.\n\nDeciding When Not to Use a List Comprehension List comprehensions are useful and can help you write elegant code that’s easy to read and debug, but they’re not the right choice for all circumstances. They might make your code run more slowly or use more memory. If your code is less performant or harder to understand, then it’s probably better to choose an alternative. You can nest comprehensions to create combinations of lists, dictionaries, and sets within a collection. For example, say a climate laboratory is tracking the high temperature in five different cities for the first week of June. The perfect data structure for storing this data could be a Python list nested within a dictionary. You can create the data using nested comprehensions: You create the outer dictionary with a dictionary comprehension. The expression is a key-value pair that contains yet another comprehension. This code will quickly generate a list of data for each city in . Nested lists are a common way to create matrices, which you’ll often use for mathematical purposes. Take a look at the code block below: The outer list comprehension creates six rows, while the inner list comprehension fills each of these rows with values. So far, the purpose of each nested comprehension is pretty intuitive. However, there are other situations, such as flattening lists, where the logic arguably makes your code more confusing. Take this example, which uses a nested list comprehension to flatten a matrix: The code to flatten the matrix is concise, but it may not be so intuitive to understand how it works. On the other hand, if you used loops to flatten the same matrix, then your code would be much more straightforward to understand: Now you can see that the code traverses one row of the matrix at a time, pulling out all the elements in that row before moving on to the next one. A list comprehension in Python works by loading the entire output list into memory. For small or even medium-sized lists, this is generally fine. If you want to sum the squares of the first one-thousand integers, then a list comprehension will solve this problem admirably: But what if you wanted to sum the squares of the first billion integers? If you tried that on your machine, then your computer might become unresponsive. That’s because Python is trying to create a list with one billion integers, which consumes more memory than your computer would like. If you tried to do it anyway, then your machine could slow down or even crash. When the size of a list becomes problematic, it’s often helpful to use a generator instead of a list comprehension in Python. A generator doesn’t create a single, large data structure in memory, but instead returns an iterable. Your code can ask for the next value from the iterable as many times as necessary or until you’ve reached the end of your sequence, while only storing a single value at a time. If you sum the first billion squares with a generator, then your program will likely run for a while, but it shouldn’t cause your computer to freeze. In the example below, you use a generator: You can tell this is a generator because the expression isn’t inside brackets or curly braces. Optionally, generators can be inside parentheses. The example above still requires a lot of work, but it performs the operations lazily. Because of lazy evaluation, your code only calculates values when they’re explicitly requested. After the generator yields a value, it can add that value to the running sum, then discard that value and generate the next value. When the function requests the next value, the cycle starts over. This process keeps the memory footprint small. The function also operates lazily, meaning memory won’t be an issue if you choose to use it in this case: It’s up to you whether you prefer the generator expression or . So, which approach is faster? Should you use list comprehensions or one of their alternatives? Rather than adhere to a single rule that’s true in all cases, it’s more useful to ask yourself whether or not performance matters in your specific circumstance. If not, then it’s usually best to choose whatever approach leads to the cleanest code! If you’re in a scenario where performance is important, then it’s typically best to profile different approaches and listen to the data. The library is useful for timing how long it takes chunks of code to run. You can use to compare the runtime of , loops, and list comprehensions: Here, you define three methods that each use a different approach for creating a list. Then, you tell to run each of those functions 100 times each, and returns the total time it took to run those 100 executions. As your code demonstrates, the biggest difference is between the loop-based approach and , with the loop taking 50 percent longer to execute. Whether or not this matters depends on the needs of your application.\n\nIn this tutorial, you learned how to use a list comprehension in Python to accomplish complex tasks without making your code overly complicated. Whenever you have to choose a list creation method, try multiple implementations and consider what’s most convenient to read and understand in your specific scenario. If performance is important, then you can use profiling tools to give you actionable data instead of relying on hunches or guesses about what works the best.\n• Determine when code clarity or performance dictates an alternative approach Remember that while Python list comprehensions get a lot of attention, your intuition and ability to use data when it counts will help you write clean code that serves the task at hand. This, ultimately, is the key to making your code Pythonic! Get Your Code: Click here to download the free code that shows you how and when to use list comprehensions in Python.\n\nNow that you have some experience with list comprehensions in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned. These FAQs are related to the most important concepts you’ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer. What is a list comprehension in Python?Show/Hide A list comprehension is a Python construct that lets you create a new list by applying an expression to each item in an existing iterable, all in a single line of code. When should you use a list comprehension instead of a loop in Python?Show/Hide You should use a list comprehension when you want to create a list in a concise, readable manner, especially when transforming or filtering elements from an existing iterable. How can you add conditional logic to a list comprehension in Python?Show/Hide You can add conditional logic by including an statement at the end of the comprehension to filter elements, or you can use a conditional expression within the comprehension to modify elements. Is a list comprehension faster than a loop in Python?Show/Hide In general, list comprehensions are faster than loops because they’re optimized for performance, but you should profile your specific use case to confirm this. How do you optimize performance with list comprehensions in Python?Show/Hide You can optimize performance by using list comprehensions for operations that fit within memory constraints, and by using profiling tools like to compare different approaches in your specific context. Test your knowledge with our interactive “When to Use a List Comprehension in Python” quiz. You’ll receive a score upon completion to help you track your learning progress: When to Use a List Comprehension in Python In this quiz, you'll test your understanding of Python list comprehensions. You'll revisit how to rewrite loops as list comprehensions, how to choose between comprehensions and loops, and how to use conditional logic in your comprehensions."
    },
    {
        "link": "https://w3schools.com/python/python_lists_comprehension.asp",
        "document": "List comprehension offers a shorter syntax when you want to create a new list based on the values of an existing list.\n\nBased on a list of fruits, you want a new list, containing only the fruits with the letter \"a\" in the name.\n\nWithout list comprehension you will have to write a statement with a conditional test inside:\n\nWith list comprehension you can do all that with only one line of code:\n\nnewlist = [expression for item in iterable if condition == True]\n\nThe return value is a new list, leaving the old list unchanged.\n\nThe condition is like a filter that only accepts the items that evaluate to .\n\nThe condition if x != \"apple\" will return for all elements other than \"apple\", making the new list contain all fruits except \"apple\".\n\nThe condition is optional and can be omitted:\n\nThe iterable can be any iterable object, like a list, tuple, set etc.\n\nSame example, but with a condition:\n\nThe expression is the current item in the iteration, but it is also the outcome, which you can manipulate before it ends up like a list item in the new list:\n\nYou can set the outcome to whatever you like:\n\nThe expression can also contain conditions, not like a filter, but as a way to manipulate the outcome:\n\nThe expression in the example above says:\n\n\"Return the item if it is not banana, if it is banana return orange\"."
    },
    {
        "link": "https://geeksforgeeks.org/python-list-comprehension",
        "document": "List comprehension is a way to create lists using a concise syntax. It allows us to generate a new list by applying an expression to each item in an existing iterable (such as a list or range). This helps us to write cleaner, more readable code compared to traditional looping techniques.\n\nFor example, if we have a list of integers and want to create a new list containing the square of each element, we can easily achieve this using list comprehension.\n• expression: The transformation or value to be included in the new list.\n• item: The current element taken from the iterable.\n• if condition (optional): A filtering condition that decides whether the current item should be included.\n\nThis syntax allows us to combine iteration, modification, and conditional filtering all in one line.\n\nThe main difference is that a for loop requires multiple lines to create a new list by iterating over items and manually adding each one. Whereas, list comprehension do the same task in a single line, this makes the code simpler and easier to read.\n\nExample: Let’s take an example, where we want to double each number of given list into a new list\n\nExplanation: Create an empty list ‘res‘ to store results and iterate over each element in list ‘a‘ and for each items in list ‘a‘, multiply it by 2 and append it to ‘res‘ using append() method.\n\nExplanation: In the above list comprehension, the iterable is a list ‘a’, and the expression is val * 2, which multiplies each value from the list by 2.\n\nList comprehensions can include conditional statements to filter or modify items based on specific criteria. These conditionals help us create customized lists quickly and making the code cleaner and more efficient.\n\nExample: Suppose we want to filter all even list from the given list.\n\nTo learn more about filtering conditions in list comprehensions, please refer to “Python List Comprehension Using If-Else“\n\nA simple example is creating a list of numbers from 0 to 9.\n\nList comprehension can also be used with nested loops. Here, we generate a list of coordinate pairs for a simple 3×3 grid.\n\nSuppose we have a list of lists and we want to convert it into a single list.\n\nExplanation: The line [val for row in mat for val in row] uses nested list comprehension to iterate through each row in mat. For each row, it iterates through each val in that row and collecting all values into a single list."
    },
    {
        "link": "https://zerotomastery.io/blog/list-comprehension-python",
        "document": "Have you ever written a loop in Python and thought, \"Isn't there a simpler way to do this?\" If so, you’re not alone.\n\nFortunately, Python offers an elegant solution called 'list comprehensions'. With just a single line of code, you can transform, filter, or generate lists — saving time and keeping your code clean.\n\nList comprehensions don’t just help you write shorter code either. They also help you to write better code. So whether you’re brand new to Python or already have some experience, learning this tool will boost your efficiency and make your code more readable.\n\nIn this guide, I'll share exactly what list comprehensions are, why they’re such a powerful feature in Python, and how you can start using them today (with code examples).\n\nWith that out of the way, let's get into this 5-minute tutorial!\n\nHow List Comprehensions can help simplify your Python code\n\nWhen you first start programming in Python, loops are often your go-to tool for iterating over lists and manipulating data.\n\nHowever, while loops work great, they can become cumbersome as your codebase grows, and this is where list comprehensions come in. They offer a cleaner and more efficient way to handle tasks that might otherwise take multiple lines of code.\n\nBut why use a list comprehension instead of a regular loop? The answer comes down to readability and performance.\n\nList comprehensions allow you to express the logic of a loop in a single line, which makes your code easier to read and maintain. Instead of several lines defining the loop, condition, and result, list comprehensions combine these into one clear and concise statement.\n\nOn top of that, list comprehensions are often faster. Python internally optimizes them in ways that aren’t available to regular loops. So, while the difference may be small in short scripts, it becomes more noticeable when working with larger datasets or in performance-sensitive applications.\n\nAt their core, list comprehensions allow you to create a new list by applying an expression to each item in an existing list—all in one line. This makes your code more concise and easier to follow, while still maintaining the full functionality of traditional loops.\n\nThe benefits of using list comprehensions are significant:\n• Cleaner and More Readable Code: You can express logic in a shorter form, making your code easier to follow\n• Fewer Mistakes: Fewer lines of code mean fewer opportunities for errors\n• Time Saver: Tasks like filtering or transforming data can be completed in a single line rather than multiple lines of loop logic\n• Performance Boost: Python’s built-in optimizations make list comprehensions faster than traditional loops in many cases\n\nNow that you understand what list comprehensions are and why they’re useful, let’s explore some real-world scenarios where they truly shine. Whether you’re filtering data, transforming it, or automating tasks, list comprehensions can significantly simplify your Python code.\n\nHere are a few examples that illustrate how to apply list comprehensions to common tasks, and more importantly, why you might want to use them in these cases.\n\nImagine you’re building an e-commerce application and have a list of product prices. You want to quickly identify which products are on sale for less than $20.\n\nWithout list comprehensions, you’d likely write a loop to filter the data, but a list comprehension allows you to do this in one clear line.\n\nFiltering is a common task when dealing with data. Whether you’re working with product prices, user inputs, or dataset rows, you often need to select a subset of items that meet certain conditions.\n\nList comprehensions allow you to do this efficiently and with minimal code. The benefit is not only cleaner code but also improved performance for larger datasets since list comprehensions are optimized by Python.\n\nSuppose you’re dealing with data that comes in as nested lists, like tags for products or categories in an online store. You may need to flatten this nested structure into a single list for easier processing.\n\nA list comprehension makes this task both simple and readable.\n\nNested lists are common in data pulled from databases or APIs, especially when dealing with hierarchical data structures.\n\nFlattening them with a list comprehension reduces the complexity of your code, making it easier to manage and process further. Without it, you might write more verbose code that’s harder to maintain.\n\nLet’s say you’re working with a list of usernames from an API and need them all in uppercase for uniformity before storing them in your database.\n\nList comprehensions allow you to transform each item in the list in one line, making your data consistent and standardized.\n\nData transformation is an essential part of many applications, whether it’s cleaning up user inputs, preparing data for reports, or normalizing it for database storage.\n\nUsing list comprehensions for this keeps your code concise and readable, avoiding the need for multi-line loops.\n\nSuppose you’re building a financial app, and you need to calculate projected savings for users over several years. By using list comprehensions, you can quickly generate dynamic lists based on user input or other variables.\n\nGenerating lists dynamically is essential in applications where calculations depend on variables like user input.\n\nIn this case, a list comprehension simplifies the process, allowing you to quickly produce calculated values. This is useful in scenarios like financial forecasting, inventory management, or any case where dynamic data generation is required.\n\nLet’s say you’re analyzing customer feedback, and you have a list of strings, but some of the entries contain extra spaces or are blank. You can use list comprehensions to clean the data quickly:\n\nCleaning and normalizing data is a key task in data analysis, especially when working with user-generated content or messy input from external sources.\n\nList comprehensions offer a concise and effective way to filter out unwanted entries while transforming data into a usable format—all in one step.\n\nImagine you’re building an automated monitoring tool with Python, that checks whether a list of websites is online or offline.\n\nUsing list comprehensions, you can easily send requests to multiple sites and capture their status in just one line of code.\n\nAutomating repetitive tasks like checking the status of websites is a common need in web development, server monitoring, and DevOps.\n\nBut with list comprehensions, you can quickly gather the HTTP status codes for multiple sites without writing long loops. This saves you time and makes your automation scripts more concise and efficient.\n\nIn this case, the status codes (e.g., for success, for not found) are collected in one line, simplifying the monitoring of multiple services. The benefit of using a list comprehension here is simplicity and speed, especially when you're working with long lists of URLs.\n\nList comprehensions are great, but like any tool, they should be used wisely. Here are some best practices to ensure you make the most of list comprehensions while avoiding common pitfalls.\n\nKeep it simple for readability\n\nThe main appeal of list comprehensions is simplicity and readability, but it’s easy to overcomplicate them. When you try to pack too much logic into a single line, it can make your code harder to understand.\n\nThis works, but it takes a few seconds to figure out what’s happening.\n\nBy using , we simplify the logic and make it easier to understand at a glance.\n\nWhile list comprehensions allow for concise code, readability should always be a priority. If you or someone else revisits the code later, it should be easy to understand at a glance.\n\nIf the logic starts to feel too complex, it’s a sign you might want to break it up into a regular loop or rethink the expression. Remember, conciseness is valuable, but not at the cost of clarity.\n\nKnow when to use or not use List Comprehension\n\nNot every task is suited for list comprehensions. If your logic requires multiple conditions, heavy error handling, or nested loops, it may be better to stick with a regular loop.\n\nExample (Better with a Loop):\n\nWhile list comprehensions are great for simple filtering and transformation, forcing more complex logic into them can make your code difficult to read or maintain.\n\nThe key is to recognize when using a traditional loop would be clearer. If you find yourself adding too many conditions or trying to do too much in one line, take a step back and ask if it’s worth the trade-off in readability.\n\nList comprehensions are memory-efficient for small to moderately sized datasets, but when working with very large datasets, they create lists in memory that can become a performance bottleneck.\n\nFor larger data, consider using generator expressions instead.\n\nWhen working with large datasets, memory usage becomes a concern. List comprehensions store the entire result in memory, which can lead to inefficiencies if the list is huge.\n\nGenerator expressions, on the other hand, yield one item at a time, making them more efficient for streaming data or working with large datasets without exhausting memory.\n\nList comprehensions assume that everything will go smoothly, but when working with real-world data, errors are inevitable—especially when interacting with external resources like APIs.\n\nYou can handle errors within the comprehension itself by adding simple conditions or using a and block.\n\nError handling is critical when working with data from external sources. If your list comprehension doesn’t account for potential errors (e.g., a website returning an error code), your code may break unexpectedly.\n\nBy adding simple error handling directly into the comprehension, you ensure your code remains robust and resilient, even when things go wrong.\n\nLearn to strike a balance between efficiency and clarity\n\nIt’s tempting to use list comprehensions everywhere, especially because they feel efficient and Pythonic. But your goal should always be to write code that is both efficient and understandable. If a list comprehension begins to look too complex, it’s time to rethink it. Example:\n\nLet’s say you have a list of student records where each record is a dictionary, and you want to extract the names of students who scored more than 90. While you can write a list comprehension that filters and extracts the names, combining too much logic in one line can make it hard to follow.\n\nIn the first version, the list comprehension packs both filtering and extracting into one line, which may be harder to understand at a glance.\n\nIn contrast, the second approach, though longer, separates the logic into distinct steps, making it clearer and easier to debug.\n\nWhen balancing efficiency with clarity, always prioritize readability, especially if the logic gets complex. You’ll thank yourself later!\n\nSo now it’s your turn\n\nList comprehensions may seem like a small feature, but they can transform how you write Python code. By mastering them, you’ll adopt a cleaner, more efficient style that serves you well as your projects grow.\n\nWhether you're filtering data, transforming it, or automating tasks, list comprehensions improve both the readability and performance of your code. Just remember to balance efficiency with clarity—use them where they fit, but don’t hesitate to use traditional loops for more complex logic.\n\nNow, put what you've learned into practice. The more you experiment with list comprehensions, the more natural they’ll become. Soon, writing concise, Pythonic code will be second nature.\n\nHappy coding, and keep pushing your Python skills forward!\n\nRemember - If you want to dive deep into Python then be sure to check out Andrei's Complete Python Developer course:\n\nIt’ll take you from an absolute beginner and teach you everything you need to get hired ASAP and ace the tech interview.\n\nThis is the only Python course you need if you want to go from complete Python beginner to getting hired as a Python Developer this year!\n\nAlternatively, if you're already pretty good at Python and want to build some interesting and useful projects, why not check out my course on Python Automation:\n\nIt'll show you how to automate all of the boring or repetitive tasks in you life - and makes for some pretty stand out portfolio projects!\n\nPlus, as part of your membership, you'll get access to both of these courses and others, and be able to join me and 1,000s of other people (some who are alumni mentors and others who are taking the same courses that you will be) in the ZTM Discord.\n\nAsk questions, help others, or just network with other Python Developers, students, and tech professionals."
    },
    {
        "link": "https://programiz.com/python-programming/list-comprehension",
        "document": "List comprehension offers a concise way to create a new list based on the values of an existing list.\n\nSuppose we have a list of numbers and we desire to create a new list containing the double value of each element in the list.\n\nHere is how the list comprehension works:\n\nfor every in , execute the the is .\n\nNote: The statement in list comprehension is optional.\n\nList comprehension makes the code cleaner and more concise than loop.\n\nLet's write a program to print the square of each list element using both loop and list comprehension.\n\nIt's much easier to understand list comprehension once you know Python for loop().\n\nList comprehensions can utilize conditional statements like if…else to filter existing lists.\n\nLet's see an example of an statement with list comprehension.\n\nHere, list comprehension checks if the number from is even or odd. If even, it appends the number in the list.\n\nNote: The function generates a sequence of numbers. To learn more, visit Python range().\n\nWe can also use list comprehension with iterables other than lists.\n\nHere, we used list comprehension to find vowels in the string ."
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://w3schools.com/python/python_ref_string.asp",
        "document": "Python has a set of built-in methods that you can use on strings.\n\nLearn more about strings in our Python Strings Tutorial."
    }
]