[
    {
        "link": "https://st.com/resource/en/user_manual/um1718-stm32cubemx-for-stm32-configuration-and-initialization-c-code-generation-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://st.com/en/development-tools/stm32cubemx.html",
        "document": ""
    },
    {
        "link": "https://gab.wallawalla.edu/~larry.aamodt/cptr480/stm/stm32CubeMX_um1718_user_manual.pdf",
        "document": ""
    },
    {
        "link": "https://edu.domski.pl/wp-content/uploads/ARC/lab/en.DM00104712.pdf",
        "document": ""
    },
    {
        "link": "https://wiki.stmicroelectronics.cn/stm32mpu/wiki/STM32CubeMX",
        "document": "This article describes STM32CubeMX, an official STMicroelectronics graphical software configuration tool.\n\nThe STM32CubeMX application helps developers to use the STM32 by means of a user interface, and guides the user through to the initial configuration of a firmware project.\n\nIt provides the means to:\n• simulate the power consumption of the resulting project\n• generate the Device Tree for a Linux kernel, TF-A and U-Boot firmware for Cortex-A7\n\nIt uses a rich library of data from the STM32 microcontroller portfolio.\n\nThe application is intended to ease the initial development phase by helping developers to select the best product in terms of features and power. \n\n\n\nHow to get STM32CubeMX\n\nPlease, refer to the following link STM32CubeMX to find STM32CubeMX, the Release Note, the User Manual and the product specification."
    },
    {
        "link": "https://digikey.com/en/maker/projects/getting-started-with-stm32-working-with-adc-and-dma/f5009db3a3ed4370acaf545a3370c30c",
        "document": "One of the most common peripherals on many modern microcontrollers is the analog-to-digital converter (ADC). These embedded devices read an analog voltage (usually somewhere between 0 V and the given reference voltage) and report it as a binary value. The exact implementation of the ADC can change among STM32 chips, as some use the successive-approximation register (SAR) technique while others rely on sigma-delta modulation for more resolution (but lower speeds). Make sure you check your datasheet to find out which ADC is in your particular chip!\n\nIn this tutorial, we will show how to use the ADC on the STM32L476 with STM32CubeIDE and HAL. We’ll also introduce the direct memory access (DMA) controller to demonstrate how you might handle moving (relatively) large amounts of data in your microcontroller.\n\nIf you are working with large amounts of data, whether from the ADC or trying to pipe the contents of memory over the UART, you might find that your processor quickly gets bogged down. If every byte has to pass through the CPU, you’ll quickly run out of cycles to do useful things! That’s where the separate direct memory access controller comes in--it can help transfer data without any code running.\n\nWe might normally think about memory transfer in a microcontroller in this (overly simplified) fashion:\n\nWe have a number of peripherals controlled by the central processing unit (CPU). Each time we want to send data from one peripheral to the other, the CPU must read data from that peripheral’s data register (or memory) and send it to another peripheral (or memory). If we start working with large amounts of data, we can quickly overwhelm the CPU if it has to touch every byte of data.\n\nLuckily for us, many modern microcontrollers (and microprocessors) include a DMA controller, which is a separate peripheral that can be configured to automatically send data from one peripheral to another (including memory). There is a small amount of overhead involved in setting up the DMA, but once it’s done, the CPU can work on other things while the DMA moves data.\n\nFor example, let’s say that we wanted to collect data from the ADC and store it to a large buffer in memory. We can configure to the DMA to do just that:\n\nBecause of the overhead involved in setting up the DMA, using it is usually only worthwhile if you need to move long, contiguous streams of data. If you need to take only one ADC reading, setting up the DMA controller is likely not worth the extra CPU cycles.\n\nYou will need the following components to complete this tutorial: https://www.digikey.com/short/pfr0r8\n\nNote that any Nucleo board may be used, but steps are shown for the Nucleo-L476RG.\n\nFor the few demonstrations that follow, we will need a Nucleo board (I’m using a Nucleo-L476RG) and a potentiometer connected to A0:\n\nGetting the STM32 to take 1 ADC reading is relatively straightforward. Start a new project in STM32CubeIDE with C. Change PA10 (which is connected to header pin D2) to GPIO_Output. Change PA0 to ADC1_IN5. Under Categories, go to Analog, and select ADC1. Change IN5 to IN5 Single-ended, which allows us to use PA0 as an ADC pin. The ADC configuration settings can stay at default.\n\nThe mbed Nucleo-L476RG page has a great pinout diagram, if you need help finding which pin goes where on the Nucleo board.\n\nOpen main.c and change the following (note that I’ve left out the bottom portion of the auto-generated Cube functions):\n\nBuild and debug the project. Run the code and bring up a serial terminal. When you connect the terminal to your Nucleo board, you should see a string of numbers showing the raw ADC values. 0 means 0 V and 4095 means 3.3 V (or whatever you might have VREF set to). Try turning the potentiometer knob to change the values.\n\nYou can connect an oscilloscope probe to D2 to measure the time it takes to set up the ADC and perform one conversion, which we see is about 9.6 μs.\n\nIf we want to take multiple ADC readings to fill a buffer without CPU intervention, then we will need to rely on DMA. One of the easiest ways to see DMA in action is to use it in conjunction with the UART. So, we’ll create a rather large buffer filled with arbitrary text, and we’ll tell the DMA to send that data, one byte at a time, to the UART peripheral. The UART will then send out the data to our serial terminal program.\n\nTo do this, we’ll first configure the UART to output data. We’ll create our message as a long string in memory, and then, we’ll configure our DMA to read that message, one byte at a time, to the UART transmitter.\n\nYou can use the same circuit from the first demo, but we won’t use the potentiometer.\n\nCreate a new STM32 project, and under System Core, select DMA. Add a new DMA request in DMA1 (the STM32L476 has 2 DMA peripherals). Change the request to USART2_TX, and you can leave the rest of the settings at their defaults.\n\nOpen main.c, and copy in the following code. Note that I’ve left out some of the auto-generated Cube/HAL functions for brevity. However, you will still need to define the DMATransferComplete() function as shown. This function acts as a callback that we assign in main.\n\nBuild and debug. Open a serial terminal, and you should see your message being printed every second.\n\nYou should also see the LED on LD2 flashing every second. This should tell you that the callback is getting called as part of the interrupt service routine whenever the DMA is done transferring all the data from the memory buffer.\n\nThe DMA is a great tool to use with the ADC when you want to transfer lots of samples to memory continuously. It can be used for audio sampling, a custom oscilloscope, etc. The STM32 HAL makes it a little easier to use, as there’s some built-in functions that control the DMA with the ADC, specifically. For this reason, I wanted to show how to set up the DMA manually in the previous example.\n\nOnce again, use the circuit from Demo 1, as we’ll need the potentiometer.\n\nFeel free to start a new project in STM32CubeIDE again, if you wish (or use the one from Demo 1). You’ll need PA0 assigned to ADC1_IN5. We’ll be using LD2 (PA5) to time the transfer (instead of PA10) for this example.\n\nUnder Analog, click ADC1, and change IN5 to IN5 Single-ended. In the Parameter Settings, change Continuous Conversion Mode to Enabled.\n\nWe can’t set the ADC pin to DMA mode yet, as we need to first assign the DMA request. So, under System Core, click on DMA. Under DMA1, add a new request, and change it to ADC1. Change Mode to Circular, which allows the DMA to wrap around to the top of our buffer when it’s done filling it up (creating a circular buffer). Leave the rest of the settings alone.\n\nGo back to Analog > ADC1. In the settings, change DMA Continuous Requests to Enabled. The rest of the settings can be left as default.\n\nSave and generate code. Open main.c. Change the code to the following:\n\nNote again the addition of two callbacks: HAL_ADC_ConvHalfCpltCallback() and HAL_ADC_ConvCpltCallback(). The first is called whenever the ADC (and DMA) fills up half the buffer. The second function is called whenever the second half the buffer is filled. You can use this to create an easy double (or “ping pong”) buffer. Do something with the data in half the buffer while the second half is being filled by the DMA.\n\nRun the program in the debugger. Add a breakpoint in one of the HAL_ADC callbacks and let the program stop there. Hover your mouse over the adc_buf variable to peek inside the buffer. You should see it filled with ADC conversion values.\n\nWe’re not doing anything with this data, as this is just an example to show how to fill up a buffer with DAC values without using the CPU, which should be idling in our while(1) loop! Note that both halves of the buffer get filled, as the DMA clock does not stop when we stop the CPU with the debugger, so it will just keep working to put values into the buffer.\n\nIf you connect an oscilloscope to D13, you should see the line toggling each time one of the callback functions runs.\n\nAs you can see, it takes about 472 μs to fill up one half of the buffer. That means in a little under a millisecond, we can fill up the entire buffer--4096 samples--without using the CPU! This comes out to be around 4 Msamples/sec.\n\nIf you take a look at the ADC clocks in STM32CubeIDE, you can see that they are set to 64 MHz and asynchronous from the system clock. If you connect the ADC clock to an 80 MHz source, you can get that sampling rate up even a little higher. Additionally, we are using 12-bit conversions. You can sacrifice some resolution for faster sample and convert times.\n\nI hope this helps you get started with the ADC and DMA on the STM32! The ADC is a wonderful tool, and it offers a vast array of features that you can customize and tweak. Similarly, the DMA can be a bit daunting to set up, but once you do, you’ll be looking for excuses to use it on lots of projects.\n\nHere are some resources that might help you in your journey:\n• Using the DMA Controller on STM32 Devices"
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus/using-timers-to-trigger-adc-conversions-periodically/ta-p/49889",
        "document": "Some applications require periodic sampling of analog signals using an ADC (Analog to Digital Converter) for digital signal processing. The objective of this article is to explain how to configure an STM32 Timer to trigger ADC conversions at a configurable sampling frequency. A GPIO pin will be toggled with every ADC conversion to show that the sampling is at the expected frequency.\n\nSome applications require periodic sampling of analog signals using an ADC (Analog to Digital Converter) for digital signal processing. The objective of this article is to explain how to configure an STM32 Timer to trigger ADC conversions at a configurable sampling frequency. A GPIO pin will be toggled with every ADC conversion to show that the sampling is at the expected frequency.\n• None Micro USB Cable used to power the Nucleo board from a Host Machine. The same cable is used to load the code into the STM32 on the Nucleo board.\n• None Oscilloscope to check the frequency of the toggling GPIO pin.\n• None Open STM32CubeIDE and create a project using the board NUCLEO-H745ZI-Q\n\nSTM32CubeIDE, by default, will initialize a GPIO for the on-board green LED (PB0).\n\nPlease change “Pin Context Assignment” to ARM Cortex-M7 as shown in the screenshot below.\n\nMake sure the configuration of PB0, which is the GPIO being used is configured as follows:\n\nIn this section we will configure the ADC1 peripheral of the STM32H7 as follows:\n• None Enable interrupts for ADC1 so that the GPIO can be toggled at the end of the ADC conversion in the call back function.\n\nWe are running the STM32H7 at its maximum speed: 480 MHz for the system frequency and 240 MHz for the peripheral bus frequency.\n\nIn this section we will configure the timer that will be used to trigger the ADC conversions per the following:\n• None PWM generation, no output needed since timer is triggering ADC internally\n• None Trigger out set to Update Event i.e. trigger event every time the timer counter reaches ARR\n\nSave the STM32CubeIDE and that will generate the code.\n• None Code to be added in main.c for CM7 project\n• None Calibrate ADC for better accuracy and start the ADC with interrupts and Start the Timer\n• None Save the ADC conversion value and Toggle LED for every completed conversion\n\nNow compile and flash the code to your Nucleo board, reset the board to run the code.\n\nThe Green LED is toggling every 100 us indicating the ADC is sampling at the desired 10 KHz rate.\n\nHere is an oscilloscope capture that shows the Green LED GPIO toggling at the desired rate:\n• None STM32H745 datasheet: Datasheet - STM32H753xI - 32-bit Arm® Cortex®-M7 400MHz MCUs, up to 2MB Flash, 1MB RAM, 46 com. and analog interfaces, crypto\n\nIn this video we discuss the different steps that were covered in this article:"
    },
    {
        "link": "https://reddit.com/r/embedded/comments/18g3aae/stm32_learning_curve_for_beginners",
        "document": "tldr: a beginner in the embedded world, and STM32 in particular, is finding a huge learning curve, and having a good old moan.\n\nI'm of average intelligence. I read mathematics at a top uni many years ago. I'm no expert in programming but an enthusiastic amateur. I'm fascinated by IOT and the prospect of controlling these incredibly powerful and incredibly cheap MCUs.\n\nI looked at Arduinos but found it fundamentally unsatisfying. If you follow the official tutorials you got instant and predictable results. But everything was hidden in the libraries.\n\nI then tried bare metal programming the Microchip PIC 10F200. The CircuitBread course was first class, but realistically I've left it too late in life to be a competent assembly language programmer. I moved on to C programming the PIC18F14K50, still with Circuitbread.\n\nAt this point I tried to make the move to STM32s and I'm finding it quite hard. There are dozens of YouTube videos taking you from installing the STM32CubeIDE to blinking an LED. Beyond that, the choice is very limited.\n\nI'm working through Dogan Ibrahim's book on Nucleo Board programming with the STM32Cube32IDE. I have just added Carmine Noviello's Mastering STM32. The styles are quite different, but complementary. Ibrahim's book takes you through a number of examples exploiting the peripherals in turn. Noviello's book is more technical in nature and, despite what is says, assumes a fair bit of knowledge in the reader.\n\nReally useful YouTube channels are Mitch's Guide to STM32 (but way too short) and the Digikey Shawn Hymel series.\n\nCommon advice on these forums is to learn to program by reading the data sheet (RM in ST parlance). Maybe if you have a background in EE this is possible; otherwise the first sentence in the first chapter will have you googling every second word and acronym. I think it's hard for forum experts to remember a time when this sentence was incomprehensible (this is the first sentence of the ref manual for the MCU I'm focusing on): \" In STM32F411xC/E, the main system consists of 32-bit multilayer AHB bus matrix that interconnects Six masters, Cortex M4 with FPU core I-bus, D-bud and S-bus, DMA1 memory bus.... etcetera\".\n\nEvery attempt to Google the meaning of a word generates another 10 words to be Googled in an exponential nightmare.\n\nLooking at the STM32CubeMX generated C code: efforts to trace the meaning of functions take you through a nest of interconnected C and header files that has my head spinning.\n\nEnough of my moaning. Nobody told me I had to do this stuff. I'm only doing it for \"fun\". I'm not a quitter so I'm planning on ploughing ahead on my STM32 journey and hoping that what I lack in comprehension can be partially replaced by familiarity. Reconciling the easy results of the Arduino with the complexity of register level ops on the STM32 is never going to happen."
    },
    {
        "link": "https://deepbluembedded.com/stm32-adc-tutorial-complete-guide-with-examples",
        "document": "This tutorial is the first part of our STM32 ADC Tutorial Series. In this tutorial series, you’ll learn everything about ADC in STM32 microcontrollers. We’ll go through examples for each and every single mode of operation (Single-Channel, Multi-Channel, Scan, Continuous Conversion, Discontinuous Mode, Injected Channels, Analog Watchdog, etc). We’ll perform the ADC data reading with all possible techniques for every mode of operation (using Polling, Interrupt, and DMA).\n\nThis pretty long journey starts off here, in this STM32 ADC Tutorial, where we’ll introduce all the fundamentals and the knowledge base that we’ll be using in later tutorials in this series. Without further ado, let’s get right into it!\n\nAn ADC (Analog-To-Digital) converter is an electronic circuit that takes in an analog voltage as input and converts it into digital data, a value that represents the voltage level in binary code. The ADC samples the analog input whenever you trigger it to start conversion. It performs a process called quantization to decide on the voltage level and its binary code that gets pushed into the output register.\n\nThe ADC does the counter operation that of a DAC, while an ADC (A/D) converts analog voltage to digital data the DAC (D/A) converts digital numbers to the analog voltage on the output pin.\n\nThe ADC is one of the most expensive electronic components especially when it does have a high sampling rate and high resolution. Therefore, it’s a valuable resource in microcontrollers and different manufacturers provide us (the firmware engineers) with various features to make the best use of it. And the flexibility also to make a lot of decisions like sacrificing resolution in exchange for a higher resolution or having the ADC to trigger on an internal timer signal to periodically sample the analog channels, and much more as we’ll see in this tutorial.\n\nFor those who like to have a solid introduction to ADC, how it works at the low level, different types of ADCs, ADC errors, equations, and all other details. The ADC Tutorial down below is a complete introductory guide for this topic and is highly recommended.\n\nThe STM32F103C8 (Blue Pill) & STM32F432KC both have a 12-bit ADC which is a successive approximation analog-to-digital converter. It has up to 18 multiplexed channels allowing it to measure signals from sixteen external and two internal sources. A/D conversion of the various channels can be performed in single, continuous, scan, or discontinuous mode. The result of the ADC is stored in a left-aligned or right-aligned 16-bit data register.\n• None Scan mode for automatic conversion of channel 0 to channel ‘n’\n• None External trigger option for both regular and injected conversion\n• None Dual-mode (on devices with 2 ADCs or more)\n\nThe ADCCLK clock provided by the Clock Controller is synchronous with the PCLK2 (APB2 clock). The RCC controller has a dedicated programmable Prescaler for the ADC clock, and it must not exceed 14 MHz.\n\nThere are 16 multiplexed channels. It is possible to organize the conversions into two groups: regular and injected. A group consists of a sequence of conversions that can be done on any channel and in any order. For instance, it is possible to do the conversion in the following order: Ch3, Ch8, Ch2, Ch2, Ch0, Ch2, Ch2, Ch15.\n\nThe Regular Group is composed of up to 16 conversions.\n\nThe Injected Group is composed of up to 4 conversions.\n\nthe ADC needs a stabilization time of t before it starts converting accurately. After the start of ADC conversion and after 14 clock cycles, the EOC flag is set and the 16-bit ADC Data register contains the result of the conversion.\n\nThe STM32 Analog Watchdog ADC Mode acts like a window comparator running in the background of the ADC operation. Its job is to check the voltage level of the AWD-enabled channels to make sure it’s within the “programmed” threshold levels. If the analog input voltage goes out of the configured voltage window, the AWD will fire an interrupt.\n\nThe ADC result data is 12 bits in width and the buffer register is 16 bits. Therefore, it can be left or right-aligned as shown in the diagram below. The injected group channels converted data value can be decreased by the user-defined offset written in the ADC_JOFRx registers so the result can be a negative value. The SEXT bit is the extended sign value. For regular group channels, no offset is subtracted so only twelve bits are significant.\n\nThere are so many operating modes for the STM32 ADC to give us, the system designers/programmers, the flexibility to configure it in any way imaginable that suits the application’s needs. This comes at the cost of having a really complex piece of hardware that can be configured in so many ways as we’ll briefly discuss here in this section. Each mode has a dedicated tutorial in this STM32 ADC tutorial series.\n\nIn Single Conversion mode, the ADC does one conversion. This mode is started either by setting the ADON bit in the ADC_CR2 register (for a regular channel only) or by an external trigger (for a regular or injected channel), while the CONT bit is 0. Once the conversion of the selected channel is complete:\n• – The converted data is stored in the 16-bit ADC_DR register \n\n – The EOC (End Of Conversion) flag is set \n\n – and an interrupt is generated if the EOCIE is set.\n• None If an injected channel was converted: \n\n – The converted data is stored in the 16-bit ADC_DRJ1 register \n\n – The JEOC (End Of Conversion Injected) flag is set \n\n – and an interrupt is generated if the JEOCIE bit is set.\n\nThe ADC is then stopped.\n\nIn continuous conversion mode, ADC starts another conversion as soon as it finishes one. This mode is started either by an external trigger or by setting the ADON bit in the ADC_CR2 register, while the CONT bit is 1. After each conversion:\n• – The converted data is stored in the 16-bit ADC_DR register \n\n – The EOC (End Of Conversion) flag is set \n\n – An interrupt is generated if the EOCIE is set.\n• None If an injected channel was converted: \n\n – The converted data is stored in the 16-bit ADC_DRJ1 register \n\n – The JEOC (End Of Conversion Injected) flag is set \n\n – An interrupt is generated if the JEOCIE bit is set.\n\nThis mode is used to scan a group of analog channels. A single conversion is performed for each channel of the group. After each end of conversion, the next channel of the group is converted automatically. If the CONT bit is set, conversion does not stop at the last selected group channel but continues again from the first selected group channel.\n\nWhen using scan mode, DMA bit must be set and the direct memory access controller is used to transfer the converted data of regular group channels to SRAM after each update of the ADC_DR register. The injected channel converted data is always stored in the ADC_JDRx registers.\n\nThis mode is enabled by setting the DISCEN bit in the ADC_CR1 register. It can be used to convert a short sequence of n conversions (n <=8) which is a part of the sequence of conversions selected in the ADC_SQRx registers. The value of n is specified by writing to the DISCNUM[2:0] bits in the ADC_CR1 register.\n\nWhen an external trigger occurs, it starts the next n conversions selected in the ADC_SQRx registers until all the conversions in the sequence are done. The total sequence length is defined by the L[3:0] bits in the ADC_SQR1 register.\n\nThe default option to trigger the STM32 ADC to start the conversion process is the Software Trigger source. Therefore, we had to manually call the HAL_ADC_Start() function whenever we wanted to start a new ADC conversion. However, the ADC can also be automatically triggered by internal or external trigger sources in the STM32 microcontroller itself.\n\nThis can be really useful to set the ADC conversion to occur periodically using a timer trigger to achieve a desired ADC sampling rate. Or to trigger the ADC conversion to start at a specific time relative to some output PWM signal (a very important feature for advanced measurement systems).\n\nThis mode is explained in more detail with practical example projects in a dedicated tutorial in this STM32 ADC series.\n\nThe ADC has a built-in self-calibration mode. Calibration significantly reduces accuracy errors due to internal capacitor bank variations. During calibration, an error correction code (digital word) is calculated for each capacitor, and during all subsequent conversions, the error contribution of each capacitor is removed using this code.\n\nCalibration is started by setting the CAL bit in the ADC_CR2 register. Once calibration is over, the CAL bit is reset by hardware and normal conversion can be performed. It is recommended to calibrate the ADC once at power on. The calibration codes are stored in the ADC_DR as soon as the calibration phase ends. It is recommended to perform a calibration after each power-up.\n\nThe STM32 HAL does provide a function within the ADC APIs dedicated to starting the calibration process and as said before it’s a recommended step after initializing the ADC hardware at the system power-up.\n\nThe STM32 ADC samples the input voltage for a number of ADC_CLK cycles which can be modified using the SMP[2:0] bits in the ADC_SMPR1 and ADC_SMPR2 registers. Each channel can be sampled with different sample times.\n\nThe Total ADC Conversion Time is calculated as follows:\n\nWith an ADCCLK = 14 MHz and a sampling time of 1.5 cycles: Tconv = 1.5 + 12.5 = 14 cycles = 1 µs\n\nThe ADC Sampling Rate (Frequency) is calculated using this formula:\n\nFor The Previous example where Tconv = 1µs, The samplingRate = 1000000 = 1Ms/sec\n\nThe STM32 ADC has a resolution of 12-bit which results in a total conversion time of SamplingTime+12.5 clock cycles. However, higher sampling rates can be achieved by sacrificing the high resolution. Therefore, the resolution can be dropped down to 10-bit, 8-bit, or 6-bit, and hence the conversion time is much shorter, and the sampling rate increases.\n\nThis can be configured and implemented in software by the programmer and the STM32 HAL does provide APIs to set all the ADC parameters including its resolution.\n\nThe ADC reference voltage pins are defined in the datasheet and assumed to be connected to a voltage level in a certain range. This is shown in the table below. You can choose to set the reference voltage to its maximum allowable level for a wider range of conversion but less voltage measurement resolution. Alternatively, you can set the reference voltage to the minimum allowable value for better voltage reading resolution.\n\nIf you’re using a development board, you may need to check out its schematic diagram as it may not be connecting the ADC Vref at all or connecting it to a 2.5v for example, so the ADC will saturate and give you 4096 before the input analog voltage reaches 3.3v and you’re wondering why! it may be because the reference voltage is set to a value less than 3.3v, so it’s something to consider.\n\nAn interrupt can be produced at the end of conversion for regular and injected groups and when the analog watchdog status bit is set. Separate interrupt enable bits are available for flexibility.\n\nSince converted regular channel values are stored in a unique data register, it is necessary to use DMA for the conversion of more than one regular channel. This avoids the loss of data already stored in the ADC_DR register.\n\nOnly the end of the conversion of a regular channel generates a DMA request, which allows the transfer of its converted data from the ADC_DR register to the destination location selected by the user.\n\nThere are mainly three different ways to read the STM32 ADC conversion result upon conversion completion. In this section, we’ll briefly describe each method and in the following tutorials, we’ll implement all of those 3 techniques for each operation mode of the ADC.\n\nIt’s the easiest way in code to perform an analog-to-digital conversion using the ADC on an analog input channel. However, it’s not an efficient way in all cases as it’s considered to be a blocking way of using the ADC. Because in this way we start the A/D conversion and wait for the ADC until it completes the conversion so the CPU can resume processing the main code.\n\nThe interrupt method is an efficient way to do ADC conversion in a non-blocking manner, so the CPU can resume executing the main code routine until the ADC completes the conversion and fires an interrupt signal so the CPU can switch to the ISR context and save the conversion results for further processing.\n\nHowever, when you’re dealing with multiple channels in a circular mode or so, you’ll have periodic interrupts from the ADC that are too much for the CPU to handle. This will introduce jitter injection, interrupt latency, and all sorts of timing issues to the system. This can be avoided by using DMA.\n\nLastly, the DMA method is the most efficient way of converting multiple ADC channels at very high rates and still transfers the results to the memory without CPU intervention which is so cool and time-saving technique.\n\nNote That: Code Examples For The 3 Methods Are Provided in The Next Tutorials.\n\nThe next section will help you identify and optimize the error sources in your STM32 ADC measurement system. However, it’s not mandatory for everyone to study it in the meantime and you can now move on to the next part of this STM32 ADC tutorial series.\n\nYou’ve almost completed the first Part of The Following Multi-Part Tutorial Series:\n\nThis section lists the main error types that have an effect on A/D conversion accuracy. These types of errors occur in all A/D converters and conversion quality depends on eliminating the source of each error of them.\n\n1) ADC Errors Due To The ADC Itself\n\nThe offset error is the deviation between the first actual transition and the first ideal transition. The first transition occurs when the digital ADC output changes from 0 to 1. Ideally, when the analog input ranges between 0.5 LSB and 1.5 LSB, the digital output should be 1. Still, ideally, the first transition occurs at 0.5 LSB. The offset error is denoted by E . The offset error can easily be calibrated by the application firmware.\n\nThe gain error is the deviation between the last actual transition and the last ideal transition. It is denoted by E . The last actual transition is the transition from 0xFFE to 0xFFF. Ideally, there should be a transition from 0xFFE to 0xFFF when the analog input is equal to V + – 0.5 LSB. So for V += 3.3 V, the last ideal transition should occur at 3.299597 V. If the ADC provides the 0xFFF reading for V < V + – 0.5 LSB, then a negative gain error is obtained. The gain error is obtained by the formula below:\n\nThe integral linearity error is the maximum deviation between any actual transition and the endpoint correlation line. The ILE is denoted by E . The endpoint correlation line can be defined as the line on the A/D transfer curve that connects the first actual transition with the last actual transition.\n\nE is the deviation from this line for each transition. The endpoint correlation line thus corresponds to the actual transfer curve and has no relation to the ideal transfer curve. The ILE is also known as the integral non-linearity error (INL). The ILE is the integral of the DLE over the whole range.\n\nAs the ADC output is the ratio between the analog signal voltage and the reference voltage, any noise on the analog reference causes a change in the converted digital value. V analog power supply is used on some packages as the reference voltage (V +), so the quality of the V power supply has an influence on ADC error.\n\nSmall but high-frequency signal variation can result in big conversion errors during sampling time. This noise is generated by electrical devices, such as motors, engine ignition, power lines. It affects the source signal (such as sensors) by adding an unwanted signal. As a consequence, the ADC conversion results are not accurate.\n\nTo obtain the maximum ADC conversion precision, it is very important that the ADC dynamic range matches the maximum amplitude of the signal to be converted. Let us assume that the signal to be converted varies between 0 V and 2.5 V and that VREF+ is equal to 3.3 V. The maximum signal value converted by the ADC is 3102 (2.5 V) as shown in the diagram down below. In this case, there are 993 unused transitions (4095 – 3102 = 993). This implies a loss in the converted signal accuracy.\n\nThe impedance of the analog signal source, or series resistance (R ), between the source and pin, causes a voltage drop across it because of the current flowing into the pin. The charging of the internal sampling capacitor (C ) is controlled by switches with a resistance R . With the addition of source resistance (with R ), the time required to fully charge the hold capacitor increases.\n\nIf the sampling time is less than the time required to fully charge the C through R + R (ts < tc), the digital value converted by the ADC is less than the actual value.\n\nThis error can be reduced or completely eliminated by setting the sampling time of the analog channel in such a way that guarantees an appropriate voltage level on the input pin is present before the ADC starts the conversion.\n\nWhen converting analog signals, it is necessary to account for the capacitance at the source and the parasitic capacitance seen on the analog input pin. The source resistance and capacitance form an RC network. In addition, the ADC conversion results may not be accurate unless the external capacitor (C + C ) is fully charged to the level of the input voltage.\n\nThe greater value of (C + C ), the more limited the source frequency. The external capacitance at the source and the parasitic capacitance are denoted by C and C , respectively.\n\nA negative injection current on any analog pin (or a closely positioned digital input pin) may introduce leakage current into the ADC input. The worst case is the adjacent analog channel. A negative injection current is introduced when V < V , causing current to flow out from the I/O pin. Which can potentially shift the voltage level on the pin and distort the measurement result.\n\nSwitching the I/Os may induce some noise in the analog input of the ADC due to capacitive coupling between I/Os. Crosstalk may be introduced by PCB tracks that run close to each other or that cross each other.\n\nInternally switching digital signals and IOs introduces high-frequency noise. Switching high sink I/Os may induce some voltage dips in the power supply caused by current surges. A digital track that crosses an analog input track on the PCB may affect the analog signal.\n\nElectromagnetic emissions from neighboring circuits may introduce high-frequency noise in an analog signal because the PCB tracks may act as an antenna. It’s called electromagnetic interference (EMI) noise.\n\nIn the next few tutorials, we’ll be practicing the ADC peripheral and doing some practical LABs to learn how to configure and program the ADC to do certain tasks in different ways. The ADC example applications will include the following:"
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/how-to-configure-gpio-interrupt-with-cubemx/td-p/469373",
        "document": "Actually it does NOT works with the latest version of cube MX (4.9). I'm using STM32F411 :\n\n- I have configured input pins as EXTI 2, 3, 12 and 14 in the ''pinout'' tab\n\n- The NVIC allow EXTI interrupts for lines 3 and [15:10], so due to a bug I not able to have interrupt on EXTI2. Since this line is connected to a hi-speed ADC DRDY signal, I will obviously NOT handle it in polling mode.\n\nThis is the third project in only one month that don't work because of a cubeMX bug."
    }
]