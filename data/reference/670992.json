[
    {
        "link": "https://css-tricks.com/snippets/css/a-guide-to-flexbox",
        "document": "The (Flexible Box) module (a W3C Candidate Recommendation as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”). The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space or shrinks them to prevent overflow. Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts.\n\nSince flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”). If “regular” layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout. Items will be laid out following either the (from to ) or the cross axis (from to ).\n• main axis – The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the property (see below).\n• main-start | main-end – The flex items are placed within the container starting from main-start and going to main-end.\n• main size – A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension.\n• cross axis – The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction.\n• cross-start | cross-end – Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.\n• cross size – The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension.\n\nThis defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children. Note that CSS columns have no effect on a flex container. \n\nThis establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.\n• (default): left to right in ; right to left in\n• : right to left in ; left to right in\n• : same as but top to bottom\n• : same as but bottom to top By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property.\n• (default): all flex items will be on one line\n• : flex items will wrap onto multiple lines, from top to bottom.\n• : flex items will wrap onto multiple lines from bottom to top. There are some visual demos of here. This is a shorthand for the and properties, which together define the flex container’s main and cross axes. The default value is . \n\nThis defines the alignment along the main axis. It helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.\n• (default): items are packed toward the start of the flex-direction.\n• : items are packed toward the end of the flex-direction.\n• : items are packed toward the start of the direction.\n• : items are packed toward the end of the direction.\n• : items are packed toward left edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are packed toward right edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are centered along the line\n• : items are evenly distributed in the line; first item is on the start line, last item on the end line\n• : items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.\n• : items are distributed so that the spacing between any two items (and the space to the edges) is equal. Note that that browser support for these values is nuanced. For example, never got support from some versions of Edge, and start/end/left/right aren’t in Chrome yet. MDN has detailed charts. The safest values are , , and . There are also two additional keywords you can pair with these values: and . Using ensures that however you do this type of positioning, you can’t push an element such that it renders off-screen (e.g. off the top) in such a way the content can’t be scrolled too (called “data loss”). \n\nThis defines the default behavior for how flex items are laid out along the cross axis on the current line. Think of it as the version for the cross-axis (perpendicular to the main-axis).\n• / / : items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the rules or the rules.\n• / / : items are placed at the end of the cross axis. The difference again is subtle and is about respecting rules vs. rules.\n• : items are centered in the cross-axis\n• : items are aligned such as their baselines align The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. \n\nThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how aligns individual items within the main-axis. Note: This property only takes effect on multi-line flexible containers, where is set to either or ). A single-line flexible container (i.e. where is set to its default value, ) will not reflect .\n• (default): items are packed in their default position as if no value was set.\n• / : items packed to the start of the container. The (more supported) honors the while honors the direction.\n• / : items packed to the end of the container. The (more support) honors the while end honors the direction.\n• : items evenly distributed; the first line is at the start of the container while the last one is at the end\n• : items evenly distributed with equal space around each line\n• : items are evenly distributed with equal space around them\n• : lines stretch to take up the remaining space The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. The property explicitly controls the space between flex items. It applies that spacing only between items not on the outer edges. The behavior could be thought of as a minimum gutter, as if the gutter is bigger somehow (because of something like ) then the gap will only take effect if that space would end up smaller. It is not exclusively for flexbox, works in grid and multi-column layout as well. \n\nBy default, flex items are laid out in the source order. However, the property controls the order in which they appear in the flex container. Items with the same revert to source order. \n\nThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have set to , the remaining space in the container will be distributed equally to all children. If one of the children has a value of , that child would take up twice as much of the space as either one of the others (or it will try, at least). This defines the ability for a flex item to shrink if necessary. This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The keyword means “look at my width or height property” (which was temporarily done by the keyword until deprecated). The keyword means “size it based on the item’s content” – this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren , , and do. If set to , the extra space around content isn’t factored in. If set to , the extra space is distributed based on its value. See this graphic. This is the shorthand for and combined. The second and third parameters ( and ) are optional. The default is , but if you set it with a single number value, like , that changes the to 0%, so it’s like setting . It is recommended that you use this shorthand property rather than set the individual properties. The shorthand sets the other values intelligently. \n\nThis allows the default alignment (or the one specified by ) to be overridden for individual flex items. Please see the explanation to understand the available values. Note that , and have no effect on a flex item.\n\nFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass to help with some of the prefixing, which also gives you an idea of what kind of things need to be done:\n\nLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. .parent { display: flex; height: 300px; /* Or whatever */ } .child { width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */ } This relies on the fact a margin set to in a flex container absorb extra space. So setting a margin of will make the item perfectly centered in both axes. Now let’s use some more properties. Consider a list of 6 items, all with fixed dimensions, but can be auto-sized. We want them to be evenly distributed on the horizontal axis so that when we resize the browser, everything scales nicely, and without media queries. .flex-container { /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around; } Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. Let’s try something else. Imagine we have a right-aligned navigation element on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. /* Large */ .navigation { display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end; } /* Medium screens */ @media all and (max-width: 800px) { .navigation { /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; } } /* Small screens */ @media all and (max-width: 500px) { .navigation { /* On small screens, we are no longer using row direction but column */ flex-direction: column; } } Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. .wrapper { display: flex; flex-flow: row wrap; } /* We tell all items to be 100% width, via flex-basis */ .wrapper > * { flex: 1 100%; } /* We rely on source order for mobile-first approach * in this case: * 1. header * 2. article * 3. aside 1 * 4. aside 2 * 5. footer */ /* Medium screens */ @media all and (min-width: 600px) { /* We tell both sidebars to share a row */ .aside { flex: 1 auto; } } /* Large screens */ @media all and (min-width: 800px) { /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main { flex: 3 0px; } .aside-1 { order: 1; } .main { order: 2; } .aside-2 { order: 3; } .footer { order: 4; } }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox",
        "document": "The flexible box layout module (usually referred to as flexbox) is a one-dimensional layout model for distributing space between items and includes numerous alignment capabilities. This article gives an outline of the main features of flexbox, which we will explore in more detail in the rest of these guides. When we describe flexbox as being one-dimensional we are describing the fact that flexbox deals with layout in one dimension at a time — either as a row or as a column. This can be contrasted with the two-dimensional model of CSS Grid Layout, which controls columns and rows together.\n\nAnother vital area of understanding is how flexbox makes no assumption about the writing mode of the document. Flexbox doesn't just assume that all lines of text start at the top left of a document and run towards the right-hand side, with new lines appearing one under the other. Rather, it supports all writing modes, like other logical properties and values. You can read more about the relationship between flexbox and writing modes in a later article; however, the following description should help explain why we do not talk about left and right and top and bottom when we describe the direction that our flex items flow in. If the is and I am working in English, then the start edge of the main axis will be on the left, the end edge on the right. If I were to work in Arabic, then the start edge of my main axis would be on the right and the end edge on the left. In both cases the start edge of the cross-axis is at the top of the flex container and the end edge at the bottom, as both languages have a horizontal writing mode. After a while, thinking about start and end rather than left and right becomes natural, and will be useful to you when dealing with other layout methods such as CSS Grid Layout which follow the same patterns.\n\nWhile flexbox is a one dimensional model, it is possible to make flex items wrap across multiple lines. If you do this, you should consider each line as a new flex container. Any space distribution will happen across each line, without reference to the previous or subsequent lines. To cause wrapping behavior add the property with a value of . Now, if your items are too large to all display in one line, they will wrap onto another line. The live sample below contains items that have been given a . The total width of the items is too wide for the flex container. As is set to , the items wrap across multiple lines. If you set it to , which is the initial value, they will shrink to fit the container. They shrink because they are using initial flexbox values, including , that allows items to shrink. Using would cause an overflow if the items were not able to shrink, or could not shrink small enough to fit. Find out more about wrapping flex items in the guide Mastering wrapping of flex items.\n\nTo control the inline-size of each flex item, we target them directly via three properties: We will take a brief look at these properties below, but if you want more comprehensive information, take a look at the Controlling ratios of flex items on the main axis guide. Before we can make sense of these properties we need to consider the concept of available space. What we are doing when we change the value of these flex properties is to change the way that available space is distributed amongst our items. This concept of available space is also important when we come to look at aligning items. If we have three 100 pixel-wide items in a container which is 500 pixels wide, then the space we need to lay out our items is 300 pixels. This leaves 200 pixels of available space. If we don't change the initial values then flexbox will put that space after the last item. If we instead would like the items to grow and fill the space, then we need to have a method of distributing the leftover space between the items. The properties that we apply to the items themselves, enable dictating how that available space should be distributed among the sibling flex items.\n\nWith the property set to a positive integer, if there is available space, the flex item can grow along the main axis from its . Whether the item stretches to take up all the available space on that axis, or just a portion of the available space depends on if the other items are allowed to grow too and the value of their properties. Each item with a positive value consumes a portion of any available space based on their value. If we gave all of our items in the example above a value of 1 then the available space in the flex container would be equally shared between our items and they would stretch to fill the container on the main axis. If we give our first item a value of 2, and the other items a value of 1 each, there are a total of 4 parts; 2 parts of the available space will be given to the first item (100px out of 200px in the case of the example above) and 1 part each the other two (50px each out of the 200px total).\n\nWhere the property deals with adding space in the main axis, the property controls how it is taken away. If we do not have enough space in the container to lay out our items, and is set to a positive integer, then the item can become smaller than the . As with , different values can be assigned in order to cause one item to shrink faster than others — an item with a higher value set for will shrink faster than its siblings that have lower values. An item can shrink down to its size. This minimum size is taken into account while working out the actual amount of shrinkage that will happen, which means that has the potential to appear less consistent than in behavior. We'll therefore take a more detailed look at how this algorithm works in the article Controlling ratios of items along the main axis. Note: These values for and are proportions. Typically if we had all of our items set to and then wanted one item to grow at twice the rate, we would set that item to . However you could also use and if you wanted.\n\nYou will very rarely see the , , and properties used individually; instead they are combined into the shorthand. The shorthand allows you to set the three values in this order — , , . The live sample below allows you to test out the different values of the flex shorthand; remember that the first value is . Giving this a positive value means the item can grow. The second is — with a positive value the items can shrink, but only if their total values overflow the main axis. The final value is ; this is the value the items are using as their base value to grow and shrink from. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1 1 auto; } .two { flex: 1 1 auto; } .three { flex: 1 1 auto; } There are also some predefined shorthand values which cover most of the use cases. You will often see these used in tutorials, and in many cases these are all you will need to use. The predefined values are as follows: The value is a CSS-wide keyword that represents the initial value for a property. Setting resets the item to the initial values of the three longhand properties, which is the same as . The initial value of is , so items will not grow larger than their size. The initial value of is , so items can shrink if they need to rather than overflowing. The initial value of is . Items will either use any size set on the item in the main dimension, or they will get their size from the content size. Using is the same as using ; this is similar to , except that the items can grow and fill the container as well as shrink if needed. Using will create fully inflexible flex items. It is as if you wrote . The items cannot grow or shrink and will be laid out using flexbox with a of . The shorthand you often see in tutorials is or and so on. This is the same as writing or and so on, respectively. The items get minimum size due to and then proportionally grow to fill the available space. In this case, the value of is redundant because the items start with minimum size — they're not given any size that could cause them to overflow the flex container. Try these shorthand values in the live sample below. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1; } .two { flex: 1; } .three { flex: 1; }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Center_an_element",
        "document": "In this recipe, you will see how to center one box inside another by using flexbox and grid, centering content both horizontally and vertically.\n\nTo center a box within another box, first turn the containing box into a flex container by setting its property to . Then set to for vertical centering (on the block axis) and to for horizontal centering (on the inline axis). And that's all it takes to center one box inside another!\n\nWe set a height for the container to demonstrate that the inner item is indeed vertically centered within the container.\n\nInstead of applying on the container, you can also vertically center the inner item by setting to on the inner item itself.\n\nAnother method you can use for centering one box inside another is to first make the containing box a grid container and then set its property to to center align its items on both the block and inline axes.\n\nInstead of applying on the container, you can achieve the same centering by setting on the container or by applying either or on the inner item itself."
    },
    {
        "link": "https://w3schools.com/css/css3_flexbox.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://shecodes.io/athena/8553-centering-a-horizontal-list-with-flexbox-in-css",
        "document": "how do you get a hover for a background but not a button\n\nWhat is SASS? What are the advantages of using it?\n\nI need a grid system that is 2 columns, but the second column has multiple rows and the first column does not\n\nHow to make the text scale down as the container get smaller"
    },
    {
        "link": "https://sitepoint.com/set-css-margins-padding-cool-layout-tricks",
        "document": "In this tutorial, you’ll learn the difference between CSS margins and padding and how these properties affect the space between elements on a web page. We’ll also discuss margin collapsing, the effect of using different units while creating responsive websites, and conclude with some layout tricks you can do with CSS margins and padding.\n• Understanding the CSS Box Model is crucial as elements in CSS are represented as a rectangular box, the size of which is determined by the element’s content, padding, border, and margin.\n• Box sizing is a common stumbling block for CSS beginners. The default setting of ‘box-sizing: content-box’ means padding and borders are added to the width and height set for an element, often causing confusion. A common solution is to set boxes to ‘box-sizing: border-box’.\n• CSS allows control over the padding and margin applied to the four sides of an element. Padding surrounds the element’s content, while margin is the external layer, creating space between the element and its surrounding elements.\n• Interesting uses of margins and padding include centering elements within their parents, using margin to space elements apart, and maintaining image aspect ratios. Understanding these techniques can help solve a number of layout-related issues.\n\nElements in CSS are represented as a rectangular box. The size of this rectangular box is determined by the element’s:\n\nThe content area of an element lies in the middle of the element. The padding surrounds the element’s content. The borders surround the padding. The margin of the element is its external layer: that is, it lies outside the element.\n\nThe following diagram should make the arrangement clearer.\n\nBox sizing is one of the first things to trip up CSS beginners. It’s common to see two elements sitting side by side, and it’s natural to expect that, if they both have a width of , they should be able to fit within their container. But it’s confusing when they don’t.\n\nBy default, if we set a width on an element and then add padding and/or borders left or right, the overall width of the element grows. That is, any padding or border is added to the overall width of the element. So if our elements also have left/right padding and/or border, they are wider than 50%.\n\nThe W3C box model defaults to as setting of . This means that padding and borders are added to the width and height we’ve set for an element. Generally speaking, this default makes page layout quite difficult, as we have to think about more than just the width we set for elements.\n\nIt’s often much more convenient to set a width on an element and know that any padding and border we set on the element will be included in that width measurement. To ensure this is the case, we can set our boxes to . That way, we don’t have to worry about our elements getting too big for their layout.\n\nIt’s not uncommon to see CSS resets applying to all elements:\n\nNote: there are simpler resets than this, but this one makes it easier to change your mind if you do want an element to have a different box sizing.\n\nYou can read more about box sizing on MDN or in the box-sizing specification.\n\nIf you learn best by doing, try experimenting with this fun interactive demo by Guy Routledge.\n\nHow to Set Padding in CSS\n\nWe can control the padding applied to the four sides of an element using the , , and properties. We can also specify the padding using the shorthand property.\n\nWhen a single padding value is present, CSS uses this value to determine the padding of all four sides:\n\nWhen two values are present, the first value determines the top and bottom padding and the second value determines the left and right padding:\n\nWhen three values are present, the first value determines the top padding, the second value determines the left and right padding and the third value determines the bottom padding:\n\nWhen all four values are present, they set the top, right, bottom and left padding in this exact order:\n\nThe padding examples above are shown in the following CodePen demo. Each box has a blue background and a white border.\n\nAll elements in the demo above are set to . If you comment out that setting in the Pen above, you’ll see the boxes get bigger, since the padding is added to the overall width and height of the boxes.\n\nHow to Set Margin in CSS\n\nJust like with padding, we can control the margin applied to the four sides of an element using the , , and properties. We can also specify the margin for all the four sides of an element using the shorthand margin property:\n\nMargins serve to create space between elements. In the demo below, each box is floated left and the first two have a value.\n\nThings to Keep in Mind about Margin and Padding\n\nLet’s look at some useful things to keep in mind when using margin and padding.\n\nUsing the right units\n\nWhen applying margins and padding, think carefully about whether or not you want to use absolute units (such as pixels). This is because these units won’t adapt to the changes in font size or screen width.\n\nLet’s say you have set the width of an element to and also applied a margin of on it. At , its width would be and its margin would be . At , its width would be and its margin would still be .\n\nIn this case, the width of the element has changed by 36% but its margin still has the same old value. In most cases, this might not be a big deal. However, setting the element’s margin in terms of percentages will allow you to have finer control over the layout of the webpage on all screen sizes. This way you can make everything proportional without any sudden jumps in the value of applied margins and padding.\n\nSimilarly, you may want to add padding to text elements on a web page. Generally, you would like the padding to be proportional to the font size of the corresponding element. This can’t be achieved with absolute units. However, if the padding is specified in terms of units, it will automatically scale with the font size. Here is a demo that shows this scaling in action.\n\nHow browsers compute margin and padding values for different units\n\nBrowsers compute the final margin and padding values for an element differently based on the unit being used.\n\nAny margin or padding that has been specified as a percentage is calculated based on the width of the containing element. This means that padding of will be equal to when the parent element is wide, and it will be equal to when the parent element is wide. Remember that the top and bottom values are also calculated based on the width of the parent element.\n\nIn case of units, the computed value for margin and padding is based on the font size of the element. In the previous CodePen demo, the padding applied to the bottom three text elements is . However, the computed value of padding is different in each case because of the different font size.\n\nThere are also four different viewport based units called , , and . The computed value of margin and padding in this case is based on the viewport. For example, a padding of will be equal to when the viewport is wide and a padding of will be equal to for the same viewport width. You can read more about these units in CSS Viewport Units: A Quick Start on SitePoint.\n\nAs a beginner, knowing how these different units work can help you quickly figure out why the padding or margin of HTML elements is changing based on the parent element’s size, font size or even the viewport, which gives you the power to take control of your layout.\n\nAnother concept that you should be aware of is collapsing margins. In certain situations, the top and bottom margins on two elements can collapse into one. This phenomenon is called margin collapsing.\n\nLet’s say you have two elements side by side — that is, adjacent siblings. If the property on the first element is set to and the property on the second element is set to , the final margin between the two elements will not be . Its actual value will be equal to the value of the bigger margin — that is, .\n\nSimilarly, margins can also collapse between a parent element and its first/last child. This happens when there is no border, padding or inline content to separate the child’s and parent’s respective margins. In this case, if there’s no padding or border on the parent element, the child’s margin will look as if it were bleeding out of the parent.\n\nOne way to avoid this situation is to add a barrier between the parent’s margin and the child’s. This can be done by either using a border or a padding. The following demo shows how adding a border or padding on the parent element can avoid the bleeding margin.\n\nIn case of negative margins, the final value of the collapsed margins is the sum of the largest positive margin and the smallest negative margin.\n\nYou can read more on this topic in Collapsing Margins, by Adam Roberts.\n\nInteresting Uses of Margins and Padding\n\nSometimes, you can use CSS margin and padding properties to solve a number of layout related issues. Here are a few examples.\n\nCentering block-level elements horizontally inside their parent is very easy with the help of the margin property. All you have to do is set the value of the and properties of the element to :\n\nIn the following demo, you can see three instances of a parent element: the first one is set to be a block-level element, the second one to be an inline-block element, and the third one is a block-level element that has been floated to the right. The child element results to be centered horizontally in all cases.\n\nUsing margin to space elements apart\n\nA super cool (but often little-known) use of margins is to isolate elements from one another using margins. This is incredibly handy in many scenarios, such as when laying out Flexbox items. Take a look at the examples in the following CodePen demo.\n\nIn each case, we’re pushing one box away from the others using margin. This can be done with vertical spacing as well.\n\nFor more margin tips like this, check out Kevin Powell’s video on more amazing things you can do with auto margins.\n\nOften, the images on a web page do not have a fixed aspect ratio. If you have to show all images with the same aspect ratio, CSS padding can help.\n\nThe trick is to set the of the parent element to zero and its property to be equal to the value of the desired aspect ratio expressed as a percentage.\n\nFor example, an aspect ratio of 16:9 can be achieved by using . Here, the value 56.25 was obtained after calculating . The same method can be used to calculate the percentage of padding for any other aspect ratio.\n\nYou can read more about this technique on How to Maintain Image Aspect Ratios in Responsive Web Design, by Craig Buckler. You can also read about newer ways to maintain aspect-ratio in our article on the new CSS aspect-ratio property.\n\nOther interesting (though a bit more advanced) uses of margins and padding, include creating full-width containers inside limited width parents and adding consistent spacing at the bottom of different modules in a web page. You can consider these to be your next steps in mastering CSS margins and padding.\n\nIf you are new to CSS, we hope this tutorial has helped you understand the differences between margins and padding. You should also be comfortable setting margins and padding with the shorthand syntax and appropriate units. In the last section, we mentioned a few interesting layout-related uses of these properties and pointed you to further resources to find out more.\n\nTake your CSS skills to the next level with our book CSS Master, 3rd Edition by Tiffany B. Brown – covering CSS animations, transitions, transformations and much more."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-style-the-html-div-element-with-css",
        "document": "This tutorial will introduce you to styling the HTML Content Division element—or element—using CSS. The element can be used to structure the layout of a page and break up a webpage into separate components for individual styling. In this tutorial, you will create and style elements, as well as learn how to add and style other elements inside a container. These skills will prepare you to use elements as layout tools later on in the series when you begin recreating the demonstration website.\n\nThe element is used by adding opening and closing tags to an HTML document. On its own, the element typically has little visual effect on the presentation of a webpage. To specify the size, color, and other properties of a element, you can assign it style rules using CSS.\n\nTo follow this tutorial, make sure you have set up the necessary files and folders as instructed in a previous tutorial in this series How To Set Up You CSS and HTML Practice Project.\n\nLet’s try a hands-on exercise to study how the element works. Erase everything in your file (if you added content from previous tutorials). Next, add the following CSS rule for the tag selector:\n\nSave the file. Next, return to your file, erase everything that’s there (except for the first line of code: ) and add the following code snippet:\n\nNotice that the element has opening and closing tags but does not require any content. Save the file and reload it in your browser. (For instructions on loading an HTML file, please visit our tutorial step How To View An Offline HTML File In Your Browser).\n\nYour webpage should display a green box 100 pixels wide and 100 pixels tall as specified by the CSS rule:\n\nNow that you have a styling rule for your element, every element you add to your page will be styled in the precisely the same manner. However, when creating a website, it is unlikely that you will want all of your HTML elements to be styled in the same way. For this reason, developers often create classes that they can use to style elements in different ways.\n\nTo practice creating classes for elements, erase the CSS rule you just created and add the following new three CSS rulesets to the file:\n\nIn this code snippet, you have created styling rules for three different classes: , , and . Note that you have added a before the class selector as required when declaring CSS rules for classes.\n\nSave the file and return to your file. Erase the element you just created and, add the three elements to your file, applying a class to each one that corresponds to the CSS class selectors that you defined in :\n\nNote that you have added the class as an attribute to the tag by adding the class attribute and class name to each opening tag. Save the file and reload it in your browser. You should receive something like this:\n\nYour webpage should display three elements, each styled with a different color and size according to their assigned CSS style rules. Note that each element starts on its own new line as elements are block-level elements and have this default behavior.\n\nYou can put text inside a container by inserting text in between the opening and closing tags. Try adding text inside each of the elements in your file:\n\nSave the file and reload it in your browser. You should now have text displayed in each of your containers:\n\nYou can add additional HTML elements to your text inside the elements. For example, try adding the HTML heading tags ( to ) to your text inside the tags in your file:\n\nSave the file and reload it in your browser. The text inside the containers should now be styled according to the default properties of the to tags:\n\nNote that the elements have also adjusted their positions slightly. This repositioning is caused by the default margin properties of the through elements. You’ll learn more about margins in the next tutorial on the CSS Box Model, but for now it is fine to ignore them\n\nTo style text inside the containers, you can specify text property values in the rulesets for your classes. Try adding the properties and values to your rulesets in your file as highlighted in the in the following code snippet:\n\nSave your file and reload the file in your browser. The text inside the containers should now be styled according to the CSS rules in your file:\n\nIn this tutorial you explored how to style the color and size of a element and how to add and style text inside a element. You will use the element to control the layout of a page when you begin building the website. In the next tutorial, you will learn about the CSS Box Model, and how to use it to adjust the size of an element’s content, padding, borders, and margin."
    },
    {
        "link": "https://stackoverflow.com/questions/1007965/how-to-organize-page-layout-with-divs",
        "document": "I have a question for the more experienced programmers here.\n\nHow can I best organize the div's to have like a left side, a middle side and a right side?\n\nI am doing my website now for a while and I spend half a day moving div's around because they don't stay in place after I put another one in and I want to work with the relative option.\n\nAlso what I do is get them into position with big negative numbers. It just does not seem to be the right way to do things. I also get scrolbars when everything fits on the screen. Working in designmode in dreamweaver cs3 is not possible, because everything is tumbling all over each other.\n\nI am hoping for some input on how to do this better."
    },
    {
        "link": "https://w3schools.com/css/css_margin.asp",
        "document": "Margins are used to create space around elements, outside of any defined borders.\n\nThis element has a margin of 70px.\n\nThe CSS properties are used to create space around elements, outside of any defined borders.\n\nWith CSS, you have full control over the margins. There are properties for setting the margin for each side of an element (top, right, bottom, and left).\n\nCSS has properties for specifying the margin for each side of an element:\n\nAll the margin properties can have the following values:\n• % - specifies a margin in % of the width of the containing element\n• inherit - specifies that the margin should be inherited from the parent element\n\nTo shorten the code, it is possible to specify all the margin properties in one property.\n\nThe property is a shorthand property for the following individual margin properties:\n\nSo, here is how it works:\n\nIf the property has four values:\n\nIf the property has three values:\n• margin: 25px 50px 75px;\n• right and left margins are 50px\n\nIf the property has two values:\n• margin: 25px 50px;\n• right and left margins are 50px\n\nIf the property has one value:\n• margin: 25px;\n• all four margins are 25px\n\nYou can set the margin property to to horizontally center the element within its container.\n\nThe element will then take up the specified width, and the remaining space will be split equally between the left and right margins.\n\nThis example lets the left margin of the <p class=\"ex1\"> element be inherited from the parent element (<div>):"
    },
    {
        "link": "https://helpx.adobe.com/sk/dreamweaver/how-to/use-css-to-style-divs.html",
        "document": ""
    }
]