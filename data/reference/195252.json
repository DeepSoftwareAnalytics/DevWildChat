[
    {
        "link": "https://learn.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-170",
        "document": "When is specified, the linker only produces an image if it can also produce a table of the image's safe exception handlers. This table specifies to the operating system which exception handlers are valid for the image.\n\nis only valid when linking for x86 targets. isn't supported for platforms that already have the exception handlers noted. For example, on x64 and ARM, all exception handlers are noted in the PDATA. ML64.exe has support for adding annotations that emit SEH information (XDATA and PDATA) into the image, allowing you to unwind through ml64 functions. For more information, see MASM for x64 (ml64.exe).\n\nIf isn't specified, the linker will produce an image with a table of safe exceptions handlers if all code segments are compatible with the safe exception handling feature. If any code segments weren't compatible with the safe exception handling feature, the resulting image won't contain a table of safe exception handlers. If specifies or one of the options, the linker won't attempt to produce an image with a table of safe exceptions handlers, as neither of those subsystems can make use of the information.\n\nIf is specified, the linker won't produce an image with a table of safe exceptions handlers even if all code segments are compatible with the safe exception handling feature.\n\nThe most common reason the linker can't produce an image is because one or more of the input files to the linker was incompatible with the safe exception handlers feature. A common reason why code is incompatible with safe exception handlers is because it was created with a compiler from a previous version of Visual C++.\n\nYou can also register a function as a structured exception handler by using .\n\nIt isn't possible to mark an existing binary as having safe exception handlers (or no exception handlers); information on safe exception handling must be added at build time.\n\nThe linker's ability to build a table of safe exception handlers depends on the application using the C runtime library. If you link with and you want a table of safe exception handlers, you need to supply a load config struct (such as can be found in the CRT source file) that contains all the entries defined for Visual C++. For example:\n\nTo set this linker option in the Visual Studio development environment\n• None Open the Property Pages dialog box for the project. For more information, see Set compiler and build properties.\n• None Modify the Image Has Safe Exception Handlers property. Choose OK or Apply to save your changes."
    },
    {
        "link": "https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/build/reference/safeseh-image-has-safe-exception-handlers.md",
        "document": "When is specified, the linker only produces an image if it can also produce a table of the image's safe exception handlers. This table specifies to the operating system which exception handlers are valid for the image.\n\nis only valid when linking for x86 targets. isn't supported for platforms that already have the exception handlers noted. For example, on x64 and ARM, all exception handlers are noted in the PDATA. ML64.exe has support for adding annotations that emit SEH information (XDATA and PDATA) into the image, allowing you to unwind through ml64 functions. For more information, see MASM for x64 (ml64.exe).\n\nIf isn't specified, the linker will produce an image with a table of safe exceptions handlers if all code segments are compatible with the safe exception handling feature. If any code segments weren't compatible with the safe exception handling feature, the resulting image won't contain a table of safe exception handlers. If specifies or one of the options, the linker won't attempt to produce an image with a table of safe exceptions handlers, as neither of those subsystems can make use of the information.\n\nIf is specified, the linker won't produce an image with a table of safe exceptions handlers even if all code segments are compatible with the safe exception handling feature.\n\nThe most common reason the linker can't produce an image is because one or more of the input files to the linker was incompatible with the safe exception handlers feature. A common reason why code is incompatible with safe exception handlers is because it was created with a compiler from a previous version of Visual C++.\n\nYou can also register a function as a structured exception handler by using .\n\nIt isn't possible to mark an existing binary as having safe exception handlers (or no exception handlers); information on safe exception handling must be added at build time.\n\nThe linker's ability to build a table of safe exception handlers depends on the application using the C runtime library. If you link with and you want a table of safe exception handlers, you need to supply a load config struct (such as can be found in the CRT source file) that contains all the entries defined for Visual C++. For example:\n• Open the Property Pages dialog box for the project. For more information, see Set compiler and build properties.\n• Modify the Image Has Safe Exception Handlers property. Choose OK or Apply to save your changes."
    },
    {
        "link": "https://auscitte.github.io/posts/Exception-Directory-pefile",
        "document": "Particularly faithful readers stoically following the adventure of bringing my OS back from the abyss may have noticed a certain python library for parsing Window Portable Executable (PE) format appearing here and there throughout the article series. It is pefile by Ero Carrera and I found it immensely useful. Naturally, it was the first library that I thought of when the subject of stack unwinding on 64-bit platforms spiked my interest. It so happened, the required functionality was not in the library and I decided to fill the void.\n\nThat said, my focus was on x64 native code specifically and, while my implementation should work with IA64 binaries by extension, it does not take into account other architectures (such as ARM). I left those for another willing sole to work on.\n\nWindows implements a mechanism called Structured Exception Handling (SEH) that gives users, applications, and drivers an opportunity to respond to exceptions in a stratified fashion. Assuming the reader could not have possibly avoided exposure to the ubiquitous information on the subject, I will only recap the main points.\n\nAn exception, whether hardware- or software-initiated, is initially processed by a kernel-mode handler routine assigned to its exception number by the Interrupt Dispatch/Descriptor Table (IDT). Intel’s 64 and AI-32 Architectures Developer’s Manual classifies exceptions as faults, traps and aborts depending on their severity and whether the originating instruction could be restarted and the program execution, continued without loss of state. The respective exception handler routines are called fault, trap, or abort handlers. In the following we talk about the exceptions that are not considered fatal or (silently) dealt with by the OS itself.\n\nThe said routine creates a trap frame, containing a subset of register values, and an exception record on the kernel-mode stack. If the exception was caused by the code running in kernel mode, the process of locating an appropriate developer-supplied exception handler starts right away (subject to IRQ level checks). For user-mode exceptions, the processing is a bit more involved; it begins with an elaborate dance of exception dispatcher, exception port, and debug port trio resulting in the first- and second-chance exceptions all user-mode Windows developers are well familiar with (implementation details can be found in the “System Mechanisms” chapter of Windows Internals). When no debugger is activated to deal with the exception, CPU is switched back into user mode, the trap frame and exception information being copied onto the user-mode stack, and the system tries to locate a handler for this exception within the application (or service) itself. This is where the processing routes (or algorithmic pathways, if you will) for kernel-mode and user-mode exceptions converge, safe the privilege level.\n\nWith the introduction of Windows ABI and PE+ format came a new method for locating a suitable exception handler on the stack of that thread-troublemaker. On good old x86 platforms, every function that wished to take part in SEH would register its handler by inserting an entry into a linked list of handlers, the list that was maintained on stack with the address of its head stored in Thread Information Block (TIB). The registration was done in function’s prolog; epilog performed a matching set of instructions with the opposite effect of canceling the registration. The OS would look through the list of handlers, executing them one by one until the one that recognized the exception would be found (an excellent article by Matt Pietrek is available for those craving more information on the subject).\n\nWindows uses another method, which an undisclosed correspondent of NT Insider ;-) refers to in their article as “table-based”, to implement SEH in 64-bit software. An extended version of Portable Executable (PE+) format was designed for 64-bit binaries. Stored inside the 64-bit PE+ image file, is a so-called “exception directory” with an entry for every non-leaf function (a leaf function does not modify non-volatile registers, use stack, or call other functions, thereby ensuring rsp points to one byte past the return address at all times). Every function utilizing / / constructs has in its exception directory entry a reference to a (usually, compiler-supplied) function, which, when called, would invoke the code within and blocks; and this is how OS is able to locate the handlers. As Matt Miller (aka epakskape or skape) points out, this approach is beneficial in two ways: firstly, it is no longer susceptible to buffer overflow attacks and, secondly, there is no overhead associated with maintaining the linked list of handlers.\n\nMoving on, the faulty function may not be able to handle the exception at hand, while some of its predecessors down the call stack has a facility to do so. Activating this savvy handler is, however, problematic for it must be called “in the context” of the function where the corresponding exception handler was defined. Let me explain.\n\nAbove is, probably, the simplest possible example demonstrating the issue; therein we assume that some instruction in causes an exception of some sort.\n\nNotice block of referencing a local variable named in line 10; in general, code within and blocks needs a way of accessing local variables and the arguments passed to its parent function. The task is accomplished with the help of rsp or rbp (relative to which addresses on stack are computed) and non-volatile registers, where first four function arguments and, possibly, some of local variables are stored. What the system would like to have at its disposal is the thread context initialized exactly as it would have been at the instruction following the call to (in this case, moving an address of to rcx in preparation for the call); apart from the volatile registers, which nobody cares about.\n\nOn this screenshot of Visual Studio’s Debugger, one can observe being passed as the argument named just the thread context we need. How do we know it? Well, on x64 platforms, when dynamic stack allocation (alloca()) is not used, the stack frame can be identified by the value of rsp register, so let us see what this value was for .\n\nCompare the value of rsp with the one recorded in and let me assure you that the rest of non-volatile registers are initialized correctly as well. , in turn, executes the code in and blocks.\n\nSo far so good, but where did that come from? is called from somewhere in the depths of OS’s exception processing routines that were brought into action by a spurious instruction at a different place: namely, , and, for that reason, are blithely unaware of ’s register values and stack frame location. Well, before makes itself at home on stack by establishing its frame and initializing variables, it courteously saves the values of non-volatile registers it is going to modify (including rsp). Thereby, everything (and and blocks within, by extension) needs for its successful operation could be found on stack if only someone cleaned up after by reversing the effects of its prolog and it is exactly what is being done in this case. This procedure goes by the name of “stack unwinding”. Stack unwinding can be virtual when the actual CPU registers are left untouched while the desired thread context is recorded in a structure instead.\n\nStack unwinding procedure must know what instructions (and in what order) are executed as part of the prolog, as well as some stable reference point in relation to which to compute the register addresses on stack. On x86 platforms, Windows acquired this information by analyzing machine codes constituting the function whose stack it was unwinding and relied on the value of frame pointer (rbp) for reference (remember how compiler would not let you use frame pointer omission optimization together with SEH?). Key “skywing” Johnson calls this method “code-driven” in his “Programming against the x64 exception handling support” series.\n\nWhen it came to x64 (and IA64), the implementation of stack unwinding received a major overhaul. Microsoft has done away with the calling conventions zoo and introduced a universal Application Binary Interface (ABI). It brought a unified layout of function parameters in registers/on stack and some restrictions on stack alignment. The latter incurred changes in stack usage patterns thereby making rsp a more likely “stable reference”, but on that – later. The most significant (in setting of this work) novelty, however, is precise specification for the types of instructions that may appear in prolog or epilog of a function. Furthermore, prologs are now present in the PE+ binary image in two forms simultaneously: regular machine code in .text segment and sequences of architecture-independent data structures (one for each instruction in the prolog), stored in .xdata segment and referenced by the entries for their respective functions in the exception directory. It is these structures (rather than the actual machine code) that Windows mostly relies on when unwinding stacks and, on account of this fact, the new unwind algorithm is referred to as “data-driven” (as opposed to “code-driven”) in skywing’s posts.\n\nIntroduction of prolog-defining meta-data in PE+ along with new stack unwinding procedures sent ripples of (albeit moderate, but yet) excitement through the debugging crowd. In his “Improving Automated Analysis of Windows x64 Binaries”, Matt Miller lists various applications thereof in binary analysis, for example. Ken Johnson also sings praises of this new approached to stack unwinding. “This is a very powerful capability indeed, as it allows for a much more complete and thorough traversal of call frames than ever possible on x86”, he says.\n\nThe contribution to pefile this article presents consists in parsing of the very exception directory (along with the prolog code-related structures) I keep mentioning. With this addition to the library, anyone who desires to implement (64-bit) stack walking in python and fancies employing pefile for the purpose may now get straight to the business.\n\nApart for me dismissively talking about x86 platforms as a thing of the past (which it is not), I hope, it was a satisfactory review of basic concepts for those who might have gotten a bit rusty in SEH matters. Having gotten that out of the way, I can finally dive into the technical details.\n\nFor whatever reason, I liked this quote from “Exceptional Behavior” by NT Insider, so I am using it in the way of an introductory paragraph:\n\nSo structure is defined as follows:\n\nThis definition is pretty much self-explanatory, the only useful remark being that all three addresses stored in this structure are actually offsets from the beginning of the binary image file. There is one such structure for every frame (i.e. non-leaf) function in the exception directory.\n\nGiven how uninformative appears, one might reasonably assume that all the juiciest bits are hidden away in “unwind data” stored at an RVA of . Let us take a look (borrowed from ducumentation).\n\n, to nobody’s surprise, holds the version of structure. As of the time of writing, the newest encountered version is 2; it differs from the previous version of the same structure by (potential) presence of EPILOG codes. Interestingly, only version 1 of is fully documented.\n\nFlag is an OR-combination of , , and , such that ( , ) and ( , ) are pairwise mutually exclusive:\n\nthereby making only one: or (from the union following the array of unwind codes) relevant at a time. Let us leave alone for now and focus on exception handling.\n\nThe most observant among readers might have gotten perplexed by my use of block to demonstrate the need for setting up a proper execution context when invoking an exception handler (in example). Aren’t blocks supposed to deal with exceptions? Well, yes, but…\n\nFrom C/C++ compiler’s perspective, there are three sides to exception handling: exception filtering, exception processing, and termination (aka unwinding) handling. The former two are performed by filter expressions and compound statements inside blocks respectively, while blocks and a special clean-up subroutine that calls destructors for local objects constitute the latter. Complex as it is, the picture would not be complete without mentioning the possibility of multiple (and even nested) / and / blocks per function.\n\nAs far as Windows is concerned, there is only one function to do all that, the function whose RVA is stored in . Here is its prototype (as declared in docs):\n\ncan be advertised as an exception handler, termination handler, or both by setting the appropriate flags in the corresponding structure. It is a double-duty function in that it can be invoked twice – the first time, to handle the exception and the second time (with to distinguish between the calls), right before the function stack is unwound. To complicate the matter further, there are also secondary (“nested” or “chained”) exceptions and collided unwinds to grapple with, but they are beyond the scope of this discussion.\n\nAlso among the topics we are not discussing here is the internal organization of as specific to the programming language and language runtime used. Microsoft’s C compiler (MSVC), for example, employs for the purpose. field of is initialized with an instance of the structure listing all the / and / blocks within the function; this data is what relies on when determining which code to execute in response to an exception. More information on the subject can be found in Ken Johnson’s posts.\n\nOne cannot stress enough how important stack unwinding is to exception handling. Let us begin by expanding the example given earlier a little.\n\nNow imagine some nefarious instruction in causes an exception. The system begins by (virtually) unwinding two stack frames in order to provide a proper execution context for calling with the most current value of as a parameter. Then, provided returned , Windows has to go back and check if needs to do some cleaning-up before terminating (in other words, it comes with a termination handler). After that, all traces of are erased from the stack and non-volatile registers are restored to establish a context for executing block of . That done and properly terminated, another stack unwind is in order. This time Windows needs to invoke an exception handler defined in and then pass control to the remainder of the function, which, in turn, would do “more useful work”.\n\nStack unwinding being an essential component of exception handling, the operating system must be able to unwind stacks for a variety of functions, ranging in complexity and programming languages used to implement them. In particular, it should be able to infer a layout of the function’s stack frame at any point in its execution. To this end, a reliable method of identifying if the function was interrupted in the middle of its prolog or epilog must exist. This is accomplished by posing tight restrictions on the content of function prologs and epilogs, compiler developers should familiarize themselves with by reading the documentation.\n\nTo further aid the unwinding procedure, prolog is translated into a sequence of unwind codes to be stored as the array in . By the way, the unwind codes are stored in reverse order; after all, this is the order a stack unwinding algorithm must follow to “undo” the effects of executing the prolog.\n\nAs expected, gives us the number of -sized slots the unwind codes occupy in the array, but, remarkably, not the number of codes itself for one code may be one to three slots in length. Moreover, length of must always be even, irrespective of the actual number of unwind codes (thus, possibly, leaving one slot unused), hence the weird expression.\n\nDespite vigorous protests about restrictions stifling their creativity (potentially) coming from imaginative compilers, prologs and epilogs may only alter the stack by means of instructions from a predefined set. These instructions are then translated into unwind codes.\n\nA header for an unwind code is defined as follows:\n\nThe field will tell you this instruction’s offset relative to the beginning of the function and , its type. Presented below are all possible (as of today) types of unwind codes along with their layouts in PE+ file and, where applicable, usage examples in the form of NASM macros and matching assembler instructions.\n\nThese are nothing more than the good old instructions.\n\nAlthough I have nothing of importance to say about the instructions themselves, it seems a suitable place to discuss the stack alignment requirements. x64 ABI requests that rsp be 16-byte aligned when a instruction is executed thereby enabling the callee to put its local variables on 16- or 8-byte boundaries and then use the optimal instructions to access them. Interestingly (though not surprisingly), Intel CPU follows the same guidelines on hardware level by making sure the stack pointer is 16-byte aligned before invoking an interrupt handler. “This allows the stack to be formatted for optimal storage of 16-byte XMM registers, which enables the interrupt handler to use faster 16-byte aligned loads and stores (MOVAPS rather than MOVUPS) to save and restore XMM registers.” Intel explains.\n\nNow notice that a function actually starts off with an unaligned stack due to the instruction pushing a QWORD-long return address on top of it. An often encountered at the very beginning of prolog will bring the proper alignment back, but only until the next instruction is executed. Obviously, a function is not expected to maintain stack alignment during prolog/epilog. As to its body, this is what Rich Skorski has to say:\n\nHowever, Microsoft’s documentation notes that normally “the stack will always be maintained 16-byte aligned, except within the prolog.” In order to understand the mechanism behind it, another class of instructions must be introduced.\n\nInstructions of this type allocate space for local variables and temporaries on stack. Notice that layout (and size!) of structure describing the corresponding unwind code may vary depending on the size of the region being allocated.\n\nGoing back to the subject of alignment, there are only two possible ways to meet the requirement one can concoct, the first of which consists in adding an extra (“dummy”) instruction (if necessary) before pushing on stack arguments for a function and executing a instruction. The second technique is to allocate a stack region that would fit all the parameters (and other temporaries such as the complex objects callees might return) for all the functions being called in advance, adding extra bytes (to ensure rsp is a multiple of 16) if need be. This way rsp is set in prolog and it remains unchanged throughout the function’s body; meanwhile (with rsp-relative addressing) instructions are being used to initialize those arguments that are passed via stack (in place of the traditional instructions). Nowadays 64-bit software (including, notably, Windows itself) seems to prefer the second approach. I came across this phenomenon when reverse-engineering basesrv.dll as part of the Abyss endeavor; anyone wishing for a real-life example should read this section in one of the Abyss posts.\n\nThis method eliminates the need for a frame pointer in many cases. Indeed, with rsp value staying fixed, all stack addresses can be easily computed relative to it at any point in the course of function’s lifetime. The reader, perhaps, remembers a mention of rsp becoming a possible “stable reference point” on x64 from the introduction and a promise to elaborate on it later. Well, there it was, fulfilled.\n\nHowever, a frame pointer may still be useful in some situations and even necessary in others, hence the next set of instructions.\n\nrbp is often used for the purpose of optimization; to this end, it is set to point somewhere between rsp and the beginning (base) of the stack frame so that addresses of some local variables could be calculated relative to rbp and some, relative to rsp (whichever is closer). It works since smaller offsets make shorter machine instructions that fit into cache much better. In this situation the frame pointer is optional, however. Where one cannot do without it, is in functions that allocate space on their stacks dynamically (say, with ).\n\nDynamic stack allocation means rsp changing its value by the amounts unknown at the time of compilation. While the function itself could manage (at the expense of efficiency) by using dynamic offsets, there is no way for the system’s stack unwinding procedure to deduce where the non-volatile registers are stored. “If space is dynamically allocated (alloca) in a function, then a nonvolatile register must be used as a frame pointer to mark the base of the fixed part of the stack and that register must be saved and initialized in the prolog.” the documentation states.\n\nrbp typically serves as a frame pointer, although I have seen other registers (r14 and r15) appropriated for the purpose instead.\n\nWith stack allocation instructions provided, an option of saving registers with instructions (rather than pushing them on stack) in prolog becomes available. Whichever tickles your fancy. Notice the difference in unwind code structure for instructions with long and short rsp-relative offsets.\n\nA function can also save values of XMM registers in its prolog if it is so inclined.\n\nThe remaining two types of unwind codes are not embodied by actual instructions, but rather serve to describe the function itself. Let us begin with the one that has been documented.\n\nThis unwind code signals that the function is an interrupt or exception handler and, as such, will have a so-called machine frame recorded on its stack prior to being called. Listed below are the steps a CPU running in 64-bit mode takes, according to Intel’s manual (pp. 195, 201), before passing control to a handler:\n• Current stack is switched to a kernel-mode stack if the interrupted code has been running in user mode.\n• The values ss and rsp had at the moment the interrupt occurred are pushed onto the (possibly, new) stack.\n• Current values of rflags, cs, and rip are saved on stack.\n• If the CPU is interrupted by an exception that comes with an error-code, the error code is recorded on stack.\n\nThe combined values of ss, rsp, rflags, cs, rip and the optional error code constitute a machine frame (not to be confused with a trap frame which is an entirely different beast); it is used by to switch back to a user-mode stack (if required) and restore the flags register before resuming the interrupted routine. Functions of this type need special treatment: it is crucial that before leaving the function, rsp is set to the value recorded in the machine frame; additionally, return address is not where one expects to find it – it is stored in the form of rip value (saved as a part of the machine frame) instead.\n\nWhy not peek inside some exception handler to see this unwind code being used in practice? I, personally, fancy examining a page fault handler. According to Intel’s manual, page fault is assigned an exception number ( ) and supplemented with an error code (a collection of flags characterizing the memory access operation that caused the exception).\n\nNow that we know the name a handler for page faults goes by in global symbols and which module it lives in, we can find its RVA (with the help of pdbparse). The reason why we need a symbol file to figure it out is because is not exported.\n\nIt would not be unreasonable to begin by making sure actually has the unwind code in question listed in its exception directory entry. This is where my extension for pefile proves useful.\n\nRunning these commands results in the output below:\n\nAs expected, first among unwind codes (remember, they are stored in reverse order) is a with an error code and, sure enough, this unwind code is not reflected in the prolog on account of machine frame being created by the CPU itself (the disassembly listing is obtained with Cutter):\n\nOne can easily follow the prolog, short as it is: rbp is saved on stack at , then a 344 byte-long storage space is allocated, also on stack, at , and, finally, at , a frame pointer is initialized.\n\nProlog completed, the function goes on, as trap handlers do, to save a trap frame on stack. A trap frame is meant to preserve a thread context as it was at the point in time when the page fault occurred.\n\nSo far so good. In the unwind code is used the way it is prescribed by the documentation. Having poked around in ntoskrnl.exe a little more, I discovered another use case. Consider, for example, ZwClose(), one of the functions from Zw* family.\n\nalso has a in its unwind info, even though it is not registered as an exception handler. Why is that? The answer can be found in the “System Service Dispatcher” chapter of Windows Internals. In user mode, system services are invoked by means of a instruction (on x64) that elevates the CPU privilege level; since the latter is not needed if the processor already runs in kernel mode, Windows provides separate versions of Windows Native API functions for drivers. These functions “build a fake interrupt stack (the stack that the CPU would generate after an interrupt) and call the directly, essentially emulating the CPU interrupt” the book says. Let us launch Cutter once more and see for ourselves.\n\nIndeed, seems to emulate the creation of a machine frame without an error code. It starts by allocating 16 bytes on stack, of which only the last 8 are included in the machine frame; these bytes are meant to hold the value of ss, but remain uninitialized. Allegedly, the first QWORD is there to ensure the said frame is aligned to a 16-byte boundary (remember that pushes a 64-bit return address on [initially aligned] stack). Values of rsp (the way it was on entering the function) and rflags are saved next. Shamefully, I do not have even the foggiest idea how 64-bit Windows 10 uses cs: whenever I check its value, it always seems to be ( ).\n\nAnd this is exactly the value recorded on stack by the instruction at (so neither ss nor cs appear to have meaningful values). Finally, an address marked by label is saved in place of rip. Residing at this address is a ret instruction. Once the system call is completed, the processor will restore rsp and rip from the values kept in the machine frame in an attempt to resume a non-existent interrupted routine. As a result, the return address pushed on stack by will be on top of the stack and ret – the next instruction to execute. It is a rather neat trick, if you ask me.\n\nHopefully, this little tour of Windows’ inner workings have demystified machine frames at least to some degree and we can safely move on to the next type of unwind codes.\n\nA stack unwinding procedure needs a way of distinguishing which part of the function has been interrupted by the exception: its body, prolog, or epilog. The former two are easy to tell apart thanks to the field of structure; what is more, it is possible to determine which instructions have been executed (and, thus, require an “annulment”) so far with the help of instruction offsets given by the values of fields. In this respect, the stack unwinding procedure can be completely data-driven.\n\nThe situation changes, however, when it comes to epilogs and, unless the epilog is an exact opposite of the prolog (i.e. there is one-to-one correspondence between the sequence of instructions in prolog and that in epilog, in reverse order), the unwinding procedure cannot avoid analyzing the machine code. For this reason, Microsoft is very specific about what is permitted in epilogs:\n\nNevertheless, an additional method for identifying epilogs, divulged only among friends, seems to exist. The unwind code appears in version 2 of and, as of the time of writing, is undocumented. These codes specify offsets for all epilogs of a function. At least, this is what they are supposed to do if you believe the sources, scarce as they are. It sounds simple enough.\n\nThe reality is a bit more complicated. s seem to mark only some instructions as belonging to an epilog; in particular, deallocating stack space ( ) and restoring register values by means of instructions are ignored while and are included in the epilog (we will see the examples later). In short, the compiler appears to draw the line at and whatever comes after it is considered a part of epilog. Now a few word on how epilog unwind codes are structured.\n\nA function typically has one prolog only, situated at its entry point; as for epilog, there can be several of them – one for each exit point. Hence, there can be multiple unwind codes. Evidently, it is assumed that all the epilogs are identical or, at the very least, of the same length; thereby only the first epilog entry stores the length of epilogs (in bytes). Epilog offsets are given relative to the end of the function (that is, relative to ).\n\nWhen an epilog is located at the very end of the function, its offset and length are equal and no extra space is needed to store the offset. Even so, there must always be an even number of consecutive entries, the last one potentially unused, in the array of unwind codes. The unused entry will be zeroed out. Here is an example of such a function:\n\n… and its entry in the exception directory:\n\nIn compliance with the earlier remark, the unwind code for the epilog only includes a sequence of s and a terminating instruction: seven bytes in total (for comparison, instructions constituting prolog and epilog are highlighted in the assembly listing). Since the epilog is at the very end of the function, the size is also its offset. Physically, that leaves one slot for the epilog unwind codes unoccupied. My implementation does not show empty unwind codes, but one can still ascertain their presence by consulting dumpbin.\n\nCompilers tend to rearrange basic blocks (of their internal control flow graphs) so as to ensure optimal performance; as a result, the epilog might end up residing at an arbitrary location within the function. In this case the epilog offset is stored separately (hence the two different versions of structure). Below is an example illustrating this case:\n\nIt is not easy to spot an epilog in a homogeneous fabric of instructions, but it is there, at an RVA of . Following the logic, the epilog unwind code should count two instructions only: and – giving an epilog 2 bytes in length located at an offset of relative to the end of the function. Right? Let us see…\n\nWe appear to be correct in our calculations. For the sake of completeness, I am including dumbin’s output as well:\n\nThe complexity of accommodating offsets and sizes in pertains solely to the first EPILOG entry; subsequent entries contain offsets only. To people who found matching epilogs in assembly listings to unwind codes in exception directory entertaining, I am giving yet another example. The pleasure is all mine.\n\nIt is a rather curious case. Look! The epilog begins by restoring the value of xmm3 (at ), then after a shot interference from some other code, resumes its execution, splitting into two nearly identical copies: one starting at and another, at . For some reason, decided not to restore the values of xmm4 and xmm5 to their pre-call states before passing control to a function whose address had been stored in rax. If the prior experience is something to go by, the exception directory entry for should hold two epilog unwind codes, both marking an RVA of as their starting points: namely, and . The offset of the second epilog, given its location, will also be its size.\n\nThe epilog codes are exactly as we expected to find them. Note, however, that the first epilog ends in a 3 byte-long instruction, not the usual 1-byte , therefore, only the first byte of is included in the epilog. :-) It makes one wonder: should an exception be thrown at the instruction, will it be deemed as occurring inside the epilog or body of the function? I will leave the speculations for another time.\n\nAs usual, I am including an output from dumpbin.\n\nOn this note, I conclude this unduly lengthy treatise on the subject of unwind codes.\n\nSometimes compilers redistribute machine code within the binary image, presumably, in such a way that the branches executed most often end up close together. Thus, blocks of code from multiple functions may be intertwined. I describe the phenomenon and propose a method for listing all the separated code blocks for any function (32- or 64-bit) in one of my earlier posts. Here is an example borrowed from there:\n\nbasesrv.dll is loaded at its preferred base address of ; in terms RVAs, the blocks of code constituting , hereby, are: and . Notice a gap between the and relative addresses; as pointed out here, “the body of is fragmented with the instructions from other functions, and , squeezed in between its code blocks”.\n\nNow let us attempt obtaining the same list of code fragments by means of our extended pefile.\n\nThis set of commands produces the output below.\n\nEasily discernible in the output are the primary record for , with its exception and unwind handlers specified, and the separated block (listed last), the latter having its set to to indicate it being a part of a chain of code fragments. Equally easily, however, we can see that the body of the function was further subdivided into a set of contiguous blocks: , , , . Every one of these fragments has equal to , the start address (RVA) of . Microsoft reveals the reason behind such an organization here :\n\nIndeed, the chained fragments (all, but the first one) have s only in their lists of unwind codes.\n\nSumming it all up, the body of a function can be divided into code fragments, each with its own structure in exception directory. Of these, only the first one can have or flags set; the rest cannot specify exception handlers of their own and must use the flag to signal belonging to a chain. In addition, for all but the first blocks, the field must be set to the of the function. These fragments may still have their own unwind codes, but there is restriction placed on the type of codes they can use.\n\nBefore moving on, I would like to add a couple more remarks on the subject. Rumor has it, there is an alternative, more efficient but undocumented, way of specifying that a is a part of some chain. It is applicable only if the code block does not have unwind codes; in this case the structure carries no useful information and can be done away with. Since s are required to be DWORD-aligned, the lowest bit of in may be used as an indicator that this field (when AND’ed with the mask ) gives an RVA of another (the first one in the chain) instead of unwind data. Both, Ken Johnson and Matt Miller, mention this special case. That said, I have not encountered a binary that would use this feature yet.\n\nA reasonably comprehensive overview of exception directory’s structure and applications having been provided, notes on implementing a parser for it are in order.\n\nThere are two types of data containers found in pefile: a generic , used to store an arbitrary collection of attributes (no strings attached), and that comes with the functionality for specifying data format in declarative form, generating a textual representation for the structure, and serialization to/deserialization from a binary stream. Another feature one would like to utilize is patching; pefile maintains a list of instances and, if requested, all modifications done to them might be written back to the PE+ image.\n\nIn order to leverage the existing functionality, class will underlie the representations of , , and derivatives of . Internally, keeps a list (named ) of fields that make up the structure it embodies and a format string for packing and unpacking this structure by means of the struct library. For example, in case when a instance represents a its and will be initialized to (the nested lists are there to store aliases for fields of the structure as part of [partial] support for C unions) and .\n\nThe reader steeped in python will know that struct does not provide any means to handle bitfields, so I have decided on implementing the missing functionality in a subclass of , unimaginatively named . An instance of needs two lists of field names instead of one: the first one, to store bitfields in their compound form and another, to enumerate all the subfields in a bitfield by name. For , the said lists will be and respectively. By switching between the lists, it is possible to reuse the implementations of packing/unpacking and conversion to a human-readable text format from the parent class, thereby ensuring these tasks are accomplished in a uniform fashion across the library. A notable disadvantage of this solution is that and become closely coupled and, as such, must be maintained (i.e. modified) together.\n\nAdding a second list leads to memory overhead that, in most cases, is insignificant. The good fortune is a byproduct (or rather serendipity) of LRU caching enabled for , the function that generates and (and other auxiliary data structures). As of version 2021.5.24, pefile applies shallow copying to whatever returns, resulting in the upper-most tuple only being duplicated. Consequently, is shared among all the with the same format, which is reasonable and beneficial from the performance standpoint. I applied the same technique to (see function ). Of course, caching is done only for python 3, but python 2 is rarely used these days.\n\nWhen it comes to , presence of bitfields is not the only complication. The structure also contains an array of structures of variable length and optional fields thereby necessitating another level of inheritance (that is, further subclassing). is unpacked in two stages, first of which determines the size of the structure and the second, completes the deserialization.\n\nThe same technique is applied to unwind codes. As explained in the Unwind Codes section, unwind codes of different types, although varying in their layouts in memory, share the same header, . identifies the type of unwind code and further particularizes its structure. The deserialization routine begins by unpacking the header, which is then, following the principles of the Factory Method design pattern, passed to a factory of unwind codes. The factory creates an instance of a class, suitable for the given header, and this newly created object, in turn, deserializes itself.\n\nFor summary, I am including a conceptual UML class diagram created with YUML. The diagram is “conceptual” in the sense that its comprehensiveness and accuracy have been sacrificed in favor of readability.\n\nThe implementation itself is not “conceptual”, however, and the python script, in all its completeness, can be found here.\n\nThis post aimed to provide the necessary background material to anyone interested in taking advantage of SEH-related meta-data available in 64-bit PE+ binaries (or anyone intending to use or improve my implementation of exception directory parser).\n\nWhile most of the information presented here could be found elsewhere, the reader, hopefully, benefited from the relatively in-depth treatment of aspects (e.g. machine frames or epilog unwind codes) that were either undocumented or not discussed in detail before.\n• Ero Carrera, pefile : a Python module to read and work with PE (Portable Executable) files\n• Ken Johnson, Programming against the x64 exception handling support, Nynaeve: Adventures in Windows debugging and reverse engineering\n• Matt Pietrek, A Crash Course on the Depths of Win32 Structured Exception Handling, Microsoft Systems Journal, January 1997\n• Mark E. Russinovich, David A. Solomon, and Alex Ionescu. (2012), Exception Dispatching, in Windows Internals, Part 1: Covering Windows Server 2008 R2 and Windows 7 (6th. ed.). Microsoft Press, USA.\n• Ken Johnson, Frame pointer omission (FPO) optimization and consequences when debugging, Nynaeve: Adventures in Windows debugging and reverse engineering\n• Ry Auscitte, A Quick Note: Locating All Code Blocks Belonging to a (Fragmented) Function with pdbparse\n• Ry Auscitte, Decompilers: Comparative Analysis and Outcome, in Bringing My OS Back from the Abyss: Reversing basesrv.dll Initialization Procedure (Part 2)\n• Ry Auscitte, Calling Convention In 64-bit Windows in Bringing My OS Back from the Abyss: Reversing basesrv.dll Initialization Procedure (Part 2)\n• Mark E. Russinovich, David A. Solomon, and Alex Ionescu. (2012), System Service Dispatching, in Windows Internals, Part 1: Covering Windows Server 2008 R2 and Windows 7 (6th. ed.). Microsoft Press, USA.\n• Anatoly Mikhailov, Exceptions on Windows x64. How it works. Part 2. (original)\n• Anatoly Mikhailov, Exceptions on Windows x64. How it works. Part 2. (translated)\n• Ry Auscitte, Bringing My OS Back from the Abyss : Windows Crash Dump Analysis (Part 1)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/assembler/masm/dot-safeseh?view=msvc-170",
        "document": "identifier must be the ID for a locally defined PROC or EXTRN PROC. A LABEL is not allowed. The .SAFESEH directive requires the /safeseh ml.exe command-line option.\n\nFor more information about structured exception handlers, see /SAFESEH.\n\nFor example, to register a safe exception handler, create a new MASM file (as follows), assemble with /safeseh, and add it to the linked objects."
    },
    {
        "link": "https://github.com/corkami/docs/blob/master/PE/PE.md",
        "document": "This page deals with the PE format, or more specifically, x86/x64 Windows (from XP to W7) binaries (ie, not other OSes or systems, not OBJ format, etc...)\n\nif you're not familiar with this format, check PE 101 - a Windows executable walkthrough.\n\nIt deals with the reality of the loader, not the theory of the format itself, as specified in Microsoft PE and COFF Specification. Many malwares or packers actually run without a problem, while they theoretically shouldn't.\n\nAll proof of concepts are included with source:\n• They're all generated in asssembly, by hand, from scratch, so no superfluous information is included (they might be wrongly detected as suspicious for that).\n\na standard (high aligments, sections, imports) PE such as can be defined with only the following structure elements:\n\nso everything else is not required.\n\na more extreme PE can rely on even less elements:\n• is a working PE with the minimum amount of defined elements.\n\nas most elements are actually unused, they can be used for other reasons.\n• contains a maximum of executed code in its header, and calculate fibonacci numbers via FPU.\n• TBC's 1kb Traceless demo also contains an executable header <wiki:video url=\"http://www.youtube.com/watch?v=EDc0qmDrjtM\"/>\n• IMAGE_OPTIONAL_HEADER32/64.BaseOfData, Dword in 32 bits, is absent in 64 bits\n• most values only matters to the DOS stub.\n• While it's usually just printing a string and terminating, the dos stub can do everything: open, modify files, and even executes PE.\n\nthis file is a broken 32b PE that is fixed (on disk), then launched by its (16b) dos stub. What's the most surprising is that a 16b process can launch the 32b part of a PE: if you were in a DOS environment, the 16b stub would be executed.\n• it can be on an (non-PE) EXE. These executables still work under XP via ntvdm.\n• points to the dos stub, shifted by 4 (count of paragraphs)\n• is the only required element (besides the signature) of the DOS HEADER to turn the EXE into a PE.\n• is a relative offset to the NT Headers.\n• can't be null (signatures would overlap)\n• can be 4 at minimum\n• has a of 4, which means the NT Headers is overlapping the DOS Header.\n• and have both a of 400h, which puts the NT Headers in appended data. However, it's required under XP that the Header is extended till there via SizeOfHeaders.\n• is an unofficial structure generated by compilers.\n• has no consequence on PE execution\n• is not documented officially, but documented by lifewire and Daniel Pistelli.\n• this is the smallest requirement for a valid PE. see\n• has to be dword-aligned.\n• for 32b, which officially correspond to 'Intel 386 or later'. / are unofficially corresponding to 486 and Pentium, however such Machine types are rejected for execution by Windows.\n• for 64b (AMD64 only, not Itaniums, with )\n• is not required when no code should be executed (see Data_Files data or resource-only PEs)\n• can be null with low alignment PEs\n• and in this case, the values are just checked but not really used (under XP) <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_maxsecxp.swf up_FlashHeight=234 up_FlashWidth=509 up_ContainerCol=\"#d1dae3\" height=234 width=509 title=\"\" border=0/>\n• can be up to 96 under XP:\n• can be up to 65535 under Vista and later:\n• has 65535 sections, that are all virtually executed. <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_65535.swf up_FlashHeight=417 up_FlashWidth=510 up_ContainerCol=\"#d1dae3\" height=417 width=510 title=\"\" border=0/>\n• has a different meaning whether it's a Borland or a Microsoft compiler\n• is used for bound imports check\n\nno importance whatsoever for the loader\n• is not the size of the optional header, but the delta between the top of the Optional header and the start of the section table. Thus, it can be null (the section table will overlap the Optional Header, or can be null when no sections are present), or bigger than the file (the section table will be in virtual space, full of zeroes), but can't be negative.\n• is a PE with a null SizeOfHeaders. the section table is thus overlapping the optional header. (XP only). <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_nullSOH-xp.swf up_FlashHeight=211 up_FlashWidth=511 up_ContainerCol=\"#d1dae3\" height=211 width=511 title=\"\" border=0/>\n• is a PE with its 82 sections of empty information, with its section table in virtual space. <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_virtsectblxp.swf up_FlashHeight=273 up_FlashWidth=548 up_ContainerCol=\"#d1dae3\" height=273 width=548 title=\"\" border=0/>\n• 0x2 IMAGE_FILE_EXECUTABLE_IMAGE is required when code is executed.\n• 0x2000 / IMAGE_FILE_DLL is required in for DLLs, in most cases, except:\n• if it's not set, the DLLMain will not be called, but the DLL is loaded and exports are usable. if it was dynamically called, the imports of the DLL won't be resolved\n• is staticly-loaded, has no valid DllMain, but its export is executed.\n• is an import-less dynamically loaded dll with no DllMain\n• IMAGE_FILE_DLL should NOT be set for a non-DLL PE.\n• has all its characteristics set excepted IMAGE_FILE_DLL.\n• 0x100 / IMAGE_FILE_32BIT_MACHINE is not required, even in 32b.\n• it can be set for a 64b PE32+, and causes no problem.\n• nothing else is required\n• is anything but optional, as soon as execution is required.\n\nif LinkerVersion < 2.5, Microsoft AppLocker might wrongly report is not a valid Win32 application. (Exception from HRESULT: 0x800700C1) for no apparent reason. Changing these fields might fix the problem.\n• Under Windows 8, AddressOfEntryPoint is not allowed to be smaller than SizeOfHeaders, except if it's null.\n• can be null in DLLs: in this case, DllMain is just not called.\n• has a null EntryPoint: Execution starts at ImageBase, executing 'MZ' as 'dec ebp/pop edx' <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_nullep.swf up_FlashHeight=247 up_FlashWidth=557 up_ContainerCol=\"#d1dae3\" height=247 width=557 title=\"\" border=0/>\n• can be absent/bypassed (see TLS)\n• has an external EntryPoint that is located in (a dll with no relocations) <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_dllextep.swf up_FlashHeight=238 up_FlashWidth=608 up_ContainerCol=\"#d1dae3\" height=238 width=608 title=\"\" border=0/>\n• code starts one byte before the start of the section. This virtual space will be full of 0 on loading, so the first opcode will be made from one virtual byte and one physical byte. <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_virtEP.swf up_FlashHeight=268 up_FlashWidth=358 up_ContainerCol=\"#d1dae3\" height=268 width=358 title=\"\" border=0/>\n• has an 'invalid' EntryPoint, but the TLS allocates the memory space and generates some codes, so the EntryPoint works fine. <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_tlsvirtEP.swf up_FlashHeight=284 up_FlashWidth=532 up_ContainerCol=\"#d1dae3\" height=284 width=532 title=\"\" border=0/>\n• is not used when a staticly loaded DLL doesn't have IMAGE_FILE_DLL set as IMAGE_FILE_HEADER.Characteristics\n• when a static DLL's DllMain is executed, the context of the not-executed-yet PE is available via lpvReserved. Thus, a static DLL can freely modify the value of the future EntryPoint to be executed\n• and are an example of such context modification via lpvReserved.\n• can be null, under XP. In this case, the binary will be relocated to 10000h\n• can be any value as long as\n• has an ImageBase of 7ffd0000h, and no relocations\n• ImageBase can't collide with ntdll.dll or kernel32, even if relocations are present (in the loaded PE), because they can't be relocated.\n• in this case, it gives a unique error message, under Windows 7: the subsystem needed to support the image type is not present. even if it has nothing to do with the subsystem.\n• if the ImageBase is bigger than that, the binary will be relocated to 10000h\n• has an ImageBase of 0FFFF0000h and relocations.\n• both are power of 2 (4, 8, 16...)\n• all have alignments of 1/1\n• MajorSubsystemVersion.MinorSubsystemVersion has to be at least 3.10\n• in DLLs, MajorSubsystemVersion is ignored until Windows 8. It can have any value. Under Windows 8, it needs a standard value (3.10 < 6.30)\n• if SubsystemVersion is 6.30, the loader enforces the presence of the LoadConfig entry, with a valid cookie, unless GuardFlags are set to IMAGE_GUARD_SECURITY_COOKIE_UNUSED.\n• has a Subsystem version of 6.30, and the minimum amount of information to get it running.\n• has a Subsystem version of 6.30, and no cookie\n• officially defined as ''reserved'' and should be null\n• if non null, it overrides MajorVersion/MinorVersion/BuildNumber/PlatformId OperatingSystem Versions values located in the PEB, after loading.\n• has a non-null Win32VersionValue to shows altered values, via GetVersionExA\n• normally equal the total virtual size of all sections + headers\n• has a SizeOfImage of 0x7027A000 (W7 only)\n• has a SizeOfImage of 0x2e. it only covers up to the EntryPoint value.\n• can be extended to the whole file, and sometimes be smaller than the header itself.\n• is a PE with standard alignments and a SizeOfHeaders of 1.\n\nFrom a technical perspective, drivers and gui/console PEs are identical, except that:\n• DRIVER need low alignments, a correct checksum, and to be signed under Vista or later (if not running in debug mode).\n• a CONSOLE PE is exactly like a GUI PE except that it comes with a pre-attached console.\n• is a multi subsystem PE that will work correctly under all 3 subsystems, and display a message. <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_multiss.swf up_FlashHeight=245 up_FlashWidth=397 up_ContainerCol=\"#d1dae3\" height=245 width=397 title=\"\" border=0/>\n• determines the level of execution by checking CS\n• resolve NTOSKRNL/KERNEL32 imports manually (by checksum, as it can't have any static import)\n• in Dlls, Subsystem is ignored - it can have any value.\n• has a Subsystem value of -1.\n• is a working DLL with this value set to 0\n• 0080h enforces that the executable is signed before execution\n• executes code on the stack, with no NX_COMPAT flag set\n• executes code on the stack, which is forbidden as NX_COMPAT flag is set, and catches the exception\n• 0400h (0400h) prevents the executable to uses Structured Exception Handler. Vectored Exception Handler still work.\n• has set, triggers an exception, handled via its VEH.\n• 1000h is only to be used by Metro Apps in Windows 8. A standard PE can't run under Windows 8 if this flag is set.\n• 4000h indicates that the file supports the Control Flow guard (data is in the LoadConfig entry), introduced in Windows 8.1.\n• can be zero, but not any value\n• has these value set to zero.\n• rounded down to 16 if bigger\n• has a maximum of PE structures set to FF, including its NumberOfRvaAndSizes which is set to FFFF\n• has no data directory (see )\n• .Net loaders ignores this value, even if it requires relocations and a COM data directory, and will parse them. Thus, a .Net PE can work with a NumberOfRvaAndSizes of 2.\n• like many data directories, Exports' size are not necessary, except for forwarding (see below).\n• Characteristics, TimeDateStamp, MajorVersion and MinorVersion are not necessary.\n• Base is only used for ordinal imports\n• has a small export table, for one named entry:\n• the Export Name is not necessary, and can be anything.\n• is correctly exported, with a corrupted Export Name\n• AddressOfNames is lexicographically-ordered (like a dictionary): the pointer to a name starting with A shouldn't be after a name starting with B, and so on...\n• has some exports wrongly ordered, which makes them unusable with the official loader.\n• export names can have any value (even null or more than 65536 characters long, with unprintable characters), just null terminated.\n• an .EXE can have exports (no need of relocation nor DLL flag), and can use them normally\n• uses its own exports\n• or they can be not used for execution, but for documenting the internal code\n• has internal exports used as address symbols\n• or they can have external or virtual addresses (but no address of 0, (un?)surprisingly)\n• has a -1 export, to which it jumps (after adding 1). It also has an export in virtual space, which is executed. https://corkami.googlecode.com/svn/wiki/pics/PE_virtual_exports.gif\n• exports at fixed value can be used to encode data, when their values are filled in the Import Address Table (their actual value doesn't matter as long as they are not executed, it's just a copied dword)\n• 's code is stored as dodgy exports RVAs, and is restored when imports are resolved\n• ordinals-only exports can make the structure even smaller (no NumberOfFunctions/NumberOfNames/AddressOfNames/AddressOfNameOrdinals). Fake entries can be also present in exports as long as Base + Ordinal matches the wanted export.\n• calls its own imports by ordinals\n• exports can be used just to forward imports. in this case, the forwarded import is written as and must be within and .\n• exports can also forward each other and create loops\n• forwards its own imports until the right API is called.\n• Imports size is not used.\n• ImportAddressTable is typically not required (excepted in low alignments, under XP)\n• under XP and later, a DLL can be called by his filename only (no extension). Extension is required under Win2K.\n• under XP, W8, but not W7, a file can be imported even if the imports name has trailing spaces/dots\n• uses standard APIs via names with trailing characters\n• importing your own exports with trailing characters might generate a crash in debuggers, and fail at loading.\n• imports himself, but as\n• a DLL can be dynamically loaded via ANSI (LoadLibraryA) or UNICODE (LoadLibraryW).\n• like in any filename, case of the DLL can be mixed\n• the Import Lookup Table is not required and can be replaced by the Import Adress Table, or it can be just null\n• contains no ILT, the import descriptor are linking twice to the IAT.\n• because it can be null, it can be put in virtual space, like the next 2 dwords (timestamp, forwarderchain)\n• has an import descriptor starting in virtual space over its 3 first dwords\n• if the Import Lookup Table is present, then it also determins the length of the Import Address Table, as they are parsed in parallel. In this case, the Import Address Table doesn't have to be null-terminated.\n• has a non null-terminated IAT but a null-terminated ILT\n• if the IAT is linked in the descriptor but empty, then the DLL is not loaded, and the file is loaded even with an invalid dll name - the descriptor is skipped.\n• has a bogus descriptor with an empty IAT, and a bogus DLL name, between real descriptors.\n• the imports directory is not compulsory (XP or later). either don't call any API (ex, resource placeholders), or locate Kernel32 and its exports by hand (see below, )\n• the imports descriptor terminator just need to have null values. So, it can be placed in virtual space.\n• the terminator of imports descriptor only needs to have its Name offset null, or its IAT. Then, the other values are not important.\n• has a bad terminator, that looks almost like a valid one:\n• under Vista and Windows 7, the dll names can be redirected from to standard system DLLs by , as documented by deroko\n• imports ExitProcess via which is redirected during loading to\n• as most fields of a descriptor are not necessary, it's possible to squeeze an overlapping IAT in it.\n• combines a lot of these techniques with ordinals, to make a working imports structure as small as possible (40 bytes for 2 imports from 2 dlls)\n• imports' Data Directory is not required to load imports: by locating kernel32 manually then parsing its exports manually, it's possible to resolve LoadLibraryA, then it's possible to manually load any DLL and resolve any of its exports (manually or via GetProcAddress).\n• has no data directory, and loads its imports manually.\n• .Net requires an import to , and an import size to be at least 0x28. It doesn't accept to import to (without extension).\n• in standard, 3 levels: but anything else is possible.\n• contains several loops between resource directories\n• Names and Types of a resource can be used:\n• immediate integers (aka IDs) converted as string for loading - like\n• strings (aka Names). the Name in resource directory is with the format - like\n• the resource structures are relative to the start of the Data Directory, but the resource data can be anywhere in the file (RVA)\n• has its resource data in the PE header\n• resource strings have their own awkward format, in which 16 strings are stored in each block, and a null string is equivalent to no string, as all strings of the same block are stored consecutively as .\n• stores and access its message via resource string\n• thus, parsing version informations requires Data directories and resource parsing, which is not-trivial in extreme cases (folded headers, resource loops...). It might be preferable to just check the 's TimeDateStamp (which is straightforward, see ) if you just require some minor version check.\n• under XP, the resource DataDirectory has to start at the beginning of its own section, or the properties dialog fails to parse the resources.\n• the structure is required as well as it's signature, even if not used. contains minimal version informations, which generates the version tab but doesn't show any information\n• implements a children StringFileInfo structure, which actually displays some minimal version information (and crashes Windows XP explorer).\n• the FixedFileInfo structure can contain any value besides its signature. contains only FFs in it.\n• the StringFileInfo structure accepts standard values, but also unknown strings, empty strings and duplicates.\n• Manifest are XML resource that store informations about the executable.\n• Manifest presence can be checked by\n• XP SP2 used to BSOD with a simple manifest PE\n• a manifest with an invalid type will be ignored, thus the file will run.\n• has an invalid manifest with an invalid type, so it's ignored altogether\n• used by 64b binaries for structured exception handling.\n• is a minimalist 64b PE that use exceptions.\n• the OS relies on the DataDirectory itself in memory.\n• alterates the handler in memory, which is taken into account by the OS.\n• defines the offset and size of the digital certificate blob (as it can be appended after appended data itself).\n• the area covered by this data directory is not included in the signature checking. Thus, increasing the size of a certificate and appending some data that won't be checked is possible without breaking the signature. This leads to security problems if the file is an installer with a ZIP in appended data / last section, as ZIPs are parsed bottom-up.\n• moreover, it was possible to move the certificate so that its starts overlaps , which could lead to an alternate being used - thus, a different PE - while the signature is still valid.\n• relocations are used when the PE is loaded at a different ImageBase. Hardcoded Addresses such as and have to be adjusted.\n• at least 1 relocation is required and used for .Net files, on the EntryPoint jump\n• relocations are not used (even with corrupted ones) if the PE can be loaded at the expected address.\n• relocations size is compulsory, to tell the loader when to stop (when they're used).\n• TLS structures and callbacks have to be relocated as well\n• IMAGE_REL_BASED_ABSOLUTE doesn't do anything, used for padding.\n• IMAGE_REL_BASED_HIGHLOW is the 'standard' relocation, for which will be added to the pointed address\n• IMAGE_REL_BASED_HIGH does the same but only the highest WORD of the delta is added. (in short, same operation one WORD earlier)\n• IMAGE_REL_BASED_LOW does the same but only the lowest WORD of the delta is added, which makes no change, as both bases are 10000h-aligned.\n• IMAGE_REL_BASED_HIGHADJ (type 4) is the only one to require a parameter. However, it's buggy, so the parameter is ignored. This behavior was fixed under Windows 8.\n• IMAGE_REL_BASED_MIPS_JMPADDR16 (type 9) affects 4 bytes under Windows XP, affects 16 bytes under Windows 7, and is not supported by Windows 8.\n• IMAGE_REL_BASED_HIGH3ADJ (type 11) was only supported until Windows 2000.\n• Other sort of relocations such as Mips and 64 bits are still supported by Windows 7, even if the PE specifies an x86 CPU.\n• uses MIPS relocations (thus, involving masking and shifting):\n• forcing the binary to relocate to a known place (ex, with a null or kernel ImageBase) makes it possible for the relocations to have predictable behavior. Thus, they can be used to decrypt or clear some values in memory. Also, relocations may be used to modify themselves.\n• has a 0ffff0000h ImageBase, and its relocations are, first, modifying themselves, using uncommon relocation types, then decrypting the code to be executed.\n• if the PE is loaded at a different address, and no relocations are present, execution still happens\n• on 64b, code can be RIP-relative, which removes the need from relocations altogether.\n• some system files such as still have a relocation Data directory, but with no relocation block inside.\n• has a kernel-range ImageBase, which implies relocation will happen, but uses only RIP-relative code.\n• if the file knows where it will be relocated, it can apply its relocation manually in advance. The code will look wrong on disk, but ok in memory.\n• uses such a technique of pre-relocated code <wiki:gadget url=https://corkami.googlecode.com/svn/wiki/gadgets/flash.xml up_File=https://corkami.googlecode.com/svn/wiki/pics/wink/PE_ibkmanual.swf up_FlashHeight=151 up_FlashWidth=464 up_ContainerCol=\"#d1dae3\" height=151 width=464 title=\"\" border=0/>\n• applying manually an extra relocations on the ImageBase field itself doesn't change the memory mapping, as the used value was read from disk, and relocations are done in memory. However, once the PE is mapped, relocations are performed, altering the ImageBase in memory, and thus influencing the value of the EntryPoint (for it to work, a writeable header is required, thus low alignments)\n• is a low alignment PE with a altered EntryPoint and an extra relocation on the ImageBase field.\n• applying a relocation on alters the remaining part of the loading process: under Vista and later, the remaining DataDirectories such as imports are parsed after relocations are processed. If e_lfanew is relocated, then a different PE Header (almost empty) can be used, thus an entirely different set of DataDirectories can be used.\n• combining a relocation type 4 on top of a relocation type 9 (to turn it into a type 10 under Windows 8) gives a different loader behavior under Windows XP, 7 and 8. implements such a mechanism:\n• its DataDirectory size tells the loader how many blocks are available. Thus, it is taken into account.\n• under XP, the value of the Debug directory SIZE can't be random - even if the RVA is null\n• used in Itanium to store global pointers to variables. Useless whatsoever.\n• most values of TLS structures are not required:\n• executes TLS code with the following structure\n• The callbacks are VAs, not RVAs (ImageBase is included).\n• each callback is executed until an error happens or a null dword is next in the list. then, no matter what happened (error or not) the EntryPoint is executed:\n• a TLS doesn't need to return cleanly if it knows it's the last one\n• an incorrect entry in the list doesn't trigger a visible error\n• has many fake TLS callback entries to disrupt disassembly\n• like the entrypoint value, a callback VA is blindly called. It can be:\n• outside the PE, in a known in advance address\n• pointing an Import Address Table entry, which means an API will be called with ImageBase as parameter.\n• executes via a call to WinExec through a TLS callback in its IAT.\n• under XP, TLS are only executed with staticly loaded DLL, not dynamicly loaded ones.\n• on XP, TLS are executed twice, on process start and process termination. Thus, code is executed even after a call to ExitProcess. This is true even under Windows 7, however libraries such as user32.dll might be already unloaded, preventing code using it to work normally.\n• TLS callbacks are not executed on thread start if no DLL importing kernel32 is imported. Thus, only execution on thread stop if kernel32 is the only import.\n• only has imports to kernel32, and a TLS that is ignored on thread start and used on thread stop, while the EntryPoint code is meaningless.\n• this behavior might be altered if the OS or debugger is loading an extra DLL.\n• TLS callbacks' list is updated at each callback execution. If a TLS or the EntryPoint code add or remove an entry, it will be taken into consideration\n• 's first TLS adds a second one on the list that will be executed directly after the first one is over\n• if a callback calls ExitProcess, the EntryPoint won't be called, however the callback will be executed after the ExitProcess call\n• contains an exiting TLS callback, preventing the EntryPoint code to be ever called.\n• contains no EntryPoint, its callback calls ExitProcess, then the first callback is called again.\n• TLS AddressOfIndex is cleared on loading. Thus, it can be used to modify code execution.\n• patches the operand of a looping jump by pointing AddressOfIndex to it.\n• like DllMain, after TLS execution, only needs to be correct. the rest doesn't matter, including ESP, which could easily crash an emulator.\n• corrupts all registers except ESI, on DllMain and TLS execution.\n• stores various OS related flags, including the SafeSEH structure, which prevents the execution of an exception handler by terminating the process if that handler is not in the Handler table. This is an OS mechanism, not specific to a compiler.\n• the handler table is not protected, it's just aiming at preventing a blind exception handler change * sets a SEH on the fly and uses it:\n• sets its GlobalFlags and checks it (also works in 64 bits with\n• are a shortcut structure to hardcode some imports values in advance, to make import values faster\n• all the loader does is take a filename, compare the timestamp of the file and the one included in the bound imports table, then use the VA directly as import if they match.\n• thus, replacing the RVA in the bound import table is an easy way to redirect imports.\n• will load the wrong import of because one RVA has been changed.\n• under XP only, it's even possible to put a different filename and timestamp. a completely different DLL will be used no matter what the standard import table says.\n• will load the wrong dll , as the name and timestamp have been modified.\n• the RVA and the Size required to be set on a low alignment PE to make the import table writeable, under XP.\n• needs an IAT to make its imports writeable\n• contains completely corrupted delay imports, which doesn't alterate the file loading and running.\n• is just a trampoline added by the compiler to load imports and DLL on request, with a 'frontend' in the data directories, with a structure similar to standard imports (adress table + name table) so that external tools can still indicate that imports calls are present.\n• has working delay imports (displayed by other tools):\n• the information in the header is not required to make delay import works, are they are extra code added in the file by the compiler.\n• Erasing the data directory VA from a standard file with delay imports will not disturb its execution\n• has the same structure as , but the descriptors are empty.\n• used in .Net files to store information of the actual .Net structures\n• used by packers and malware as markers\n• the section table doesn't have to be fully covered by SizeOfHeaders. (cf )\n• has a section with a virtual size of 0x10001000 (and executes code at the bottom of it).\n• a section can have a null VirtualSize: in this case, only the SizeOfRawData is taken into consideration.\n• has a section with a null VirtualSize and a non-null SizeOfRawData.\n• sections have to be in increasing order, virtually.\n• A section can start before the previous one ends. Which means that offset-wise, the address is not constantly increasing.\n• sections don't have to be virtually contiguous\n• with standard alignments, sections can be physically empty.\n• the last section doesn't have to be physically aligned in size, cf\n• if bigger than virtual size, then virtual size is taken.\n• dupsec has 2 identical sections (besides the VirtualAddress)\n• if a section starts at offset 0, it's invalid.\n• if a section's physical start is lower than 200h (the lower limit for standard alignment), it is rounded down to 0. Thus, it's a legitimate way to map the header.\n• maps the header in a section via rounding down it's physical start:\n• sections can be in wrong order physically\n• sections can leave a physically unused space in the PE\n• has 2 section leaving an unused physical space in between\n• the physically-last section defines the appended data. However, it's easy to 'hide' appended data by either:\n• adding a fake extra section (even physically one byte), such as in (creating some slackspace)\n• enlarging the physically-last section, such as in\n• to be detailed here later - check the examples.\n\na 64b PE (PE32+) is like a 32b PE, except that the FILE HEADER's Machine and the OPTIONAL HEADER's Magic have AMD specific values, and the Imports's INT, as well as the ImageBase, and the Stack and Heap info are QWORD (which drops a few fields from the Optional header as a consequence\n\nthe minimal size for a PE is:\n• 97 bytes, under XP: . In this case, the OptionalHeader is truncated.\n• the same rule applies to drivers\n• 252 bytes, under Vista/Windows 7 (the same as under XP, with null padding): - as the OS now enforces a minimum of physical space after the start of the OptionalHeader.\n• 268 bytes, under Vista/Windows 7 (same again, just null bytes to get the required size, but the same elements as )\n\nso, 268 bytes is the smallest size for a universal tiny PE.\n• found out by Reversing Labs as 'Dual PE Header'\n• the first checks of the PE are done on file. then the file is loaded in memory. then imports are resolved, from the image in memory.\n• by extending the header until the first SectionAlignment, it's possible to have the first section overlapping the header partially. thus, the actual data directories used for imports resolving will not be the contiguous ones on the disk.\n• PDF documents don't need to have their signature starting at offset 0\n• in a ZIP archive with no compression, the file is stored in its original form\n\nSo it's possible to make a ZIP containing a PDF that also works as the PDF itself.\n• ZIP archives also don't need to start at offset 0\n• so a PE can contain such a ZIP, and work as both a PE and a ZIP\n• moving the 'PE' headers far enough via increasing enables to store any size of file in the PE\n\nso it's possible to make a PE containing a ZIP containing a uncompressed PDF, that works as both a document (PDF), an archive (ZIP), and an executable (PE), like .\n\nFile formats should have enforce their signature at offset 0.\n• start of the file (as a PE):\n• a quine is a file that prints its own source.\n• by putting the PE header further in the file and only using printable characters in between, has its own source directly accessible via the type command. after the source, an EOF character is inserted.\n• when executed, quine will open a command window to type itself.\n• the address pointed by TLS.AddressOfIndex is cleared on loading.\n• if IMAGE_IMPORT_DESCRIPTOR.Name is null, this import descriptor is considered a terminator (imports are no further parsed).\n• under XP, it's cleared after imports are parsed, thus the imports are completely loaded.\n• under W7, it's cleared before, so the descriptor is considered as a terminator, so imports are no further parsed.\n\nso, depending on the OS that is running, behaves differently by checking its own imports\n• this W7-only binary use the TLS AoI trick to clean its imports. On disk, the import table is full of bogus descriptors, which will be ignored on loading\n• by using a similar trick as in quine to make a printable DOS header, and relocating the NT HEADERS far enough so that e_lfanew contains no null char, no0code contains no null byte before the code start.\n• however, the NT HEADERS magic contains necessarily 2 null bytes, thus it's impossible to have a working PE with no null byte at all.\n\nsome specific cases require PE files with less elements than otherwise mentioned\n\nloading a file via LoadLibraryEx with LOAD_LIBRARY_AS_DATAFILE needs a PE file with only a very few defined elements: not even the Subsystem or the Machine needs to be defined for such a ''library''.\n• is a 61 bytes PE with only 3 defined elements\n\nyet even if nothing is defined, its code can still be ran. This allows us to make a non-null PE with code.\n• is a data PE with executed code and no null character\n\nA standard use for code-less PEs is to store resources. In this case, more fields are required (Machine, SizeOfOptionalHeader, SizeOfHeaders), but most fields can contain bogus values.\n• is a PE with a lot of corrupted fields yet correct and usable resources\n• a PE executing code can have either no sections, no entrypoint, no data directories - but not at least one of the 3 is required - which breaks the typical model.\n• many fields are not relevant, and can have completely bogus values (even important-looking ones such as BaseOfCode, SizeOfCode...)\n• many fields are taken into account only once the PE is mapped in memory, which requires a different way of thinking (allocated areas, mapped sections...)\n• most fields are not checked for boundaries, even important ones such as EntryPoint, TLS Callbacks, imports, exports...\n• TLS is arguably the most f cked up part of the PE format.\n\n[hashdays2012 Binary Art - byte-ing the PE that fails you], presented at Hashdays, Luzern, on the 3rd November 2012 <wiki:gadget url=\"https://corkami.googlecode.com/svn/wiki/gadgets/hashdays2012_slideshare.xml\" width=595 height=497 border=0/>\n• Maximum possible code execution in the PE header Peter Ferrie"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-170",
        "document": "When is specified, the linker only produces an image if it can also produce a table of the image's safe exception handlers. This table specifies to the operating system which exception handlers are valid for the image.\n\nis only valid when linking for x86 targets. isn't supported for platforms that already have the exception handlers noted. For example, on x64 and ARM, all exception handlers are noted in the PDATA. ML64.exe has support for adding annotations that emit SEH information (XDATA and PDATA) into the image, allowing you to unwind through ml64 functions. For more information, see MASM for x64 (ml64.exe).\n\nIf isn't specified, the linker will produce an image with a table of safe exceptions handlers if all code segments are compatible with the safe exception handling feature. If any code segments weren't compatible with the safe exception handling feature, the resulting image won't contain a table of safe exception handlers. If specifies or one of the options, the linker won't attempt to produce an image with a table of safe exceptions handlers, as neither of those subsystems can make use of the information.\n\nIf is specified, the linker won't produce an image with a table of safe exceptions handlers even if all code segments are compatible with the safe exception handling feature.\n\nThe most common reason the linker can't produce an image is because one or more of the input files to the linker was incompatible with the safe exception handlers feature. A common reason why code is incompatible with safe exception handlers is because it was created with a compiler from a previous version of Visual C++.\n\nYou can also register a function as a structured exception handler by using .\n\nIt isn't possible to mark an existing binary as having safe exception handlers (or no exception handlers); information on safe exception handling must be added at build time.\n\nThe linker's ability to build a table of safe exception handlers depends on the application using the C runtime library. If you link with and you want a table of safe exception handlers, you need to supply a load config struct (such as can be found in the CRT source file) that contains all the entries defined for Visual C++. For example:\n\nTo set this linker option in the Visual Studio development environment\n• None Open the Property Pages dialog box for the project. For more information, see Set compiler and build properties.\n• None Modify the Image Has Safe Exception Handlers property. Choose OK or Apply to save your changes."
    },
    {
        "link": "https://richard-ac.github.io/posts/SEH",
        "document": "SEH is an exception handling mechanism used in Windows programs which has been abused by exploit writers for years. This Corelan article gives a good introduction to SEH and presents the “POP/POP/RET” exploitation technique. However, there is still a lot of confusion as to why such a technique is necessary. Searching for “the need for POP/POP/RET in SEH exploits” on Google did not clear things up but only lead to more confusion.\n\nUnsatisfied with the results, I decided to dig into windows internals myself and here are the results.\n\nTo illustrate we will write an exploit for Torrent 3GP Converter, a video conversion program. A vulnerable version of the program is available here if you want to follow along. Credit goes to boku for the original exploit.\n\nIn this post we will :\n• Write an initial exploit where we directly overwrite the exception handler wih the address of our shellcode\n• Dig into the Win32 exception handling internals to understand why our first exploit failed\n\nStructued Exception Handling (SEH) is how Windows implements the try-except statement :\n\nTo do so, in Win32, Exception Registration Record are placed on the stack. Each one has two entries :\n• A pointer to the code that will try to handle the exception\n• A pointer to the next Exception Registration Record, thus creating a linked list of Records on the stack\n\nSimple view of the SEH chain on the stack\n\nWhen an exception occurs, the OS traverses the list trying to find a suitable handler.\n\nIf an attacker can overwrite, a pointer to a handler and then cause an exception, he might be able to get control of the program.\n\nAs it is not the focus of this article, let’s get through the generic exploitation process quickly and move on to SEH internals. I recommend reading the above-mentionned Corelan post for more details.\n\nThis video converter suffers from a buffer overflow in the “Code” field of the “Registration” option.\n\nLet’s attach a debugger and feed 5000 “A” characters into this field. I’ll be using Immunity Debugger.\n\nLooking through the stack we notice that our input has overwritten an Exception Registration Record. Overwritting an Exception Registration Record with “A”\n\nThanks to some trial and error we can figure out that 4500 characters are needed before reaching the exception registration record. Let’s verify this by sending 4500 “A” characters followed by “BBBB” and “CCCC”.\n\n“BBBB” and “CCCC” end up overwritting the two fields of the exception registration record, thus confirming our offset calculation\n\nNow that we control an Exception Registration Record and can trigger an exception, getting code execution should be pretty straightforward.\n\nLet’s use the mona debugger plugin to help us in the exploitation.\n\nUsing the command, we can learn about the protections used by the modules loaded in the address space.\n\nOutput of the !mona modules command (not showing OS DLLs)\n\nWe notice a few points that make the exploitation easier :\n• Data Execution Prevention is disabled so we can execute code directly on the stack.\n• There is plenty of non-ASLR modules in the address space, including the main executable.\n• There is multiple non-SafeSEH modules (we’ll come back to this).\n• Only Windows servers have SEHOP enabled by default so we won’t have to deal with it here.\n\nThe main difficulty in this exploit is the available character set. Indeed we can only send alphanumeric uppercase characters as well as a few special characters. Msfvenom is unable to generate a shellcode fully compliant with those constraints because the GetEIP procedure that it uses involves non-alphanumeric characters. To solve this problem, one may store the address of the shellcode in a controlled register and tell msfvenom not to generate the GetEIP part of the shellcode as explained here. In our case we will have just to our shellcode so ESP - 4 will point to the beginning of our shellcode allowing us to craft an easy alphanumeric GetEIP code.\n\nThis is the shellcode we will be using. It’s coming straight from with an alphanumeric uppercase GetEIP code appended at the beginning that stores the current instruction pointer into ECX.\n\nAs explained in this Uninformed article, SafeSEH is a security mechanism introduced with Visual Studio 2003. It works by adding a static list of known good exception handlers in the PE file at compile time. Before executing and exception handler, it is checked against the table. Execution is passed to the handler only if it matches an entry in the table.\n\nSafeSEH only exists in 32 bit applications because 64 bit exception handler are not stored on the stack.\n\nMost articles I have read mention “bypassing SafeSEH” as the reason for using the POP/POP/RET technique.\n\nIn our case, most of the loaded modules, including the main executable where the exception is triggered, are not compiled with the /SAFESEH flag. Therefore, one might think that the “SafeSEH bypass” is not needed here.\n\nLet’s try pointing the exception handler directly to our shellcode and see what happens.\n\nView of the stack after the overflow. The exception handler now points to our shellcode\n\nEverything is lined up correctly but unfortunately, our handler ends up not being used. To understand why, we will inspect the exception handling process more closely.\n\nFrom now on I will be using WinDbg which has the advantage of automatically downloading symbols for Windows default binaries from the Microsoft Symbol Server.\n\nLet’s attach WinDbg and cause the exception. You can view the current exception chain using the command.\n\nFirst of all we want to figure out what Windows functions are involved in the exception handling process. To do so, we setup a breakpoint to trigger whenever 0x0019d104, which is the address of the first record in the chain, is read.\n\n!exchain shows the corrupted SEH chain. After that, our breakpoint gets hit\n\nLooking at the stack trace, we discover what functions are involved in the exception handling process. Understanding them will probably answer all of our questions.\n\nStack trace when the address of the first Exception Registration Record is read\n\nThis Wikipedia article gives an explaination of different prefixes used by Windows NT functions. Here are the ones that matter to us :\n\nAccording to the previous stack trace, the first function being called in the exception dispatching process is KiUserExceptionDispatcher from ntdll.dll. Let’s disassemble it in IDA Pro.\n\nBe careful to pick as this is the one used for 32 bit processes\n\nThis is a very short function which pretty much just calls RtlDispatchException and then checks the return value. If RtlDispatchException returns 0 (ie. the exception was not handled) it then raises the exception again using ZwRaiseException. On the other hand, if the exception was handled correctly, it continues the process using ZwContinue.\n\nMoving on to RtlDispatchException, this one seems a little more interesting :\n\nIt starts by doing of few checks. For instance it uses LdrControlFlowGuardEnforced to determine if Control Flow Guard is on. If it is, it then it calls RtlGuardIsValidStackPointer which checks if ESP is located between the top and the bottom of the stack and aborts if its not.\n\nChecking if Control Flow Guard is enabled and calling RtlGuardIsValidStackPointer if it is\n\nRegardless, in our case, breaking after LdrControlFlowGuardEnforced and checking its return value shows that Control Flow Guard is not enabled.\n\nLdrControlFlowGuardEnforced returns 0 (in the eax register) which means Control Flow Guard is not enabled\n\nNext up, Vectored Exception Handlers are called. This is another exception handling mechanism introduced in Windows XP. They are pretty similar to SEH with a few key differences. We won’t get too much into the details but here is are some quick facts about Vectored Exception Handling :\n• As we just saw, they have priority over SEH.\n• They are explicitly added in the source code using the AddVectoredExceptionHandler function.\n• The main difference with SEH is that they are not tied to a specific function, they handle exceptions for the whole application.\n\nIf the vectored handler successfully handled the exception, RtlDispatchException then returns with the value 1. Otherwise we move on to Structured Exception Handlers.\n\nThis function retrieves the stack’s base (highest address) and limit (lowest address) from the Thread Information Block respectively at FS:[0x04] and FS:[0x08] and stores them on the stack.\n\nIt also makes sure that ebp + 4 lands in between the stack’s base and limit addresses. If the check fails, the function returns 0, otherwise it returns 1.\n\nMoving on, it then calls the QueryInformationProcess function. Breaking on it in WinDbg we can see that it gets passed the argument 0x22 which which is not documented in the Microsoft documentation about this function.\n\nIt turns out this call corresponds to querying the ProcessExecuteFlags. However documentation on those flags is hard to come by. After hours of Googling, I found the following definition for those execution flags :\n\nThe function checks if the 0x40 flag of the returned bitmap is set and if not, it calls RtlpIsValidExceptionChain. This is how SEHOP is enforced.\n\nQueryInformationProcess is called with de 0x22 flag. If the 0x40 flag of the returned bitmap is not set, then SEHOP is enforce\n\nFollowing that, the address of the current Exception Registration Record is loaded and the dispatcher checks that :\n• The exception handler code is not located on the stack (this is the check we failed in our first exploit)\n• The Exception Registration Record is located on the stack\n• The address of the Exception Registration Record is byte aligned\n\nChecks to make sure the exception registration record is on the stack and the exception handler isn’t\n\nSo this is the reason why our previous exploit did not work ! It’s also why the POP/POP/RET technique is necessary even when the program is not compiled with /SAFESEH.\n\nAfter that we finally reach RtlIsValidHandler which is where SafeSEH actually gets enforced. More precisely, RtlIsValidHandler calls RtlpxLookupFunctionTable which performs a search through the registered handlers table.\n\nPart of RtlpxLookupFunctionTable where the search through the resgistered handlers tables is done\n\nHere is the loop in RtlpxLookupFunctionTable that searches through the table of valid exception handlers.\n\nRtlIsValidHandler also performs some other checks such as verifying if DEP is enabled and if so,\n\n making sure that the exception handler is in an executable memory page.\n\nAll this time spent staring at assembly helped us understand why our exploit was failing. It is not because of SafeSEH, but because of an other check done when dispatching exceptions which makes sure that the exception handler code is not located on the stack.\n\nThis is the real reason why the POP/POP/RET technique is used : bouncing to an address outisde of the stack before coming back to the shellcode allow us to bypass the check.\n\nNow let’s wrap up the exploit quicly using the POP/POP/RET technique.\n\nUsing the command to help us locate interesting POP/POP/RET gadgets and we can choose one that is compliant with our badchars requirements such as :\n\nSome ESP adjustments are then needed to end up executing the shellcode on the stack but I won’t go into the details."
    },
    {
        "link": "http://lyscript.lyshark.com/examples/examples-08.html",
        "document": "SafeSEH (Safe Structured Exception Handling) is a security mechanism provided by the Windows operating system to prevent malicious software from exploiting buffer overflow vulnerabilities to attack applications. When an application uses structured exception handling (SEH), its exception handling linked list (ExceptionHandler) can be used by attackers to execute code injection attacks. This is because the exception handling linked list is essentially a pointer array. If an application uses unverified pointers to point to the exception handling function, attackers can construct malicious exception handling modules to overwrite the original handler, forcing the program to execute the code injected by the attacker. This attack technique is called SEH Overwrite.\n\nTo address this issue, the SafeSEH mechanism has been introduced into the Windows operating system. The main idea is to add a SafeSEH table to the import table of the application, which is used to store the address list of SEH processing functions generated by the compiler. During program execution, the Windows operating system checks whether the pointers in the program's SEH linked list exist in the SafeSEH table. If the pointer does not exist in the SafeSEH table, the Windows operating system will terminate the execution of the application. The SafeSEH mechanism can improve the security and reliability of the system, preventing malicious software from exploiting vulnerabilities such as buffer overflow and SEH injection to attack applications.\n\nSearch for the memory address, read the PE file into the memory, verify whether the SEH protection of the program is enabled, and if it is enabled, attempt to output the SEH memory address. In fact, modern code can be summarized as the following examples;\n\n# Do you want to print the switch for SEH Handlers # Connect to the debugger and return an instance of the Debugger object # Get the base address of the PE file header # Obtain the base address of the memory image # Obtain the offset of the PE header # Return the base address of the PE file header # Obtain the value of SafeSEH related flag bits in the PE header # Obtain the number of entries in the SEH table # If the number of entries in the SEH table is greater than 10 # Calculate the address of the SEH table and convert it to a virtual memory address # Get the size of the SEH table # Check if the SEH table is valid # If the switch for printing SEH Handlers is enabled # Get the address of the SEH Handlers table # Get the size of the SEH Handlers table # If the SEH Handlers table address and size are non-zero # Traverse each entry in the SEH Handlers table # Calculate the virtual address of the SEH handler # Print the address of the SEH handler # Obtain the type and detailed information of SEH Handler # Print notification message that SafeSEH protection is not enabled # If the data in the SEH table is less than 0x48 # Get the base address of the PE file header\n\nRunning this code will output all memory address spaces within the current process that have enabled, as shown below;"
    },
    {
        "link": "https://ired.team/offensive-security/code-injection-process-injection/binary-exploitation/seh-based-buffer-overflow",
        "document": "The purpose of this lab is to familiarize how Structured Exception Handler / SEH based buffer overflow exploits work.\n• None Structured exception handling (SEH) is simply code in a program that is meant to handle situations when program throws an exception due to a hardware or software issue. This means catching those situations and doing something to resolve them;\n• None SEH code is located on the program's stack for each code block and each handler has its own stack frame;\n• None SEH is stored in stack as memory structure (also called SEH record) consisting of two 4 byte fields:\n• None pointer to the next SEH record within the SEH chain;\n• None pointer to the exception handler code - the part of the code block. This is the code that attempts to resolve the exception that the program threw;\n• None A program may have multiple SEHs registered that are connected by a linked list, forming a SEH chain;\n• None Once a program throws an exception, the OS runs through the SEH chain and attempts to find an appropriate exception handler;\n• None If no suitable handler is found, a default OS handler is used from the bottom of the SEH chain. All SEH chains always end with a default Windows SEH record. Next SEH Record field point to , which mean's that this is the last SEH record in the chain;\n• None SEH chain is stored in the Thread Environment Block (TEB) memory structure in its first member called Thread Information Block (TIB), that can be accessed via FS segment register ;\n• None 64-bit applications are not vulnerable to SEH overflow as binaries are linked with safe exception handlers embedded in the PE file itself;\n• None 32-bit applications can be linked with flag, which will produce a PE file with a table of safe exception handlers, assuming all modules are compatible with safe execption handling feature.\n\nBelow is a simplified diagram visualising some of the key points outlined above:\n\nLet's explore the key structures around SEH using WinDBG and confirm the key points mentioned in the SEH 101 section.\n\nThread Environment Block is a described in the OS as memory structure and can be inspected in WinDBG like so:\n\nAs seen from the above screenshot, the TEB's first member is (Thread Information Block) memory structure, which can be inspected like so:\n\nAs mentioned earlier, the first member inside the structure is a pointer to memory structure, which is the first SEH record / head of the SEH chain (linked list) and can be inspected like so:\n\nThe first member of is a pointer to the next SEH record and the second member is a pointer to the exception handler that is defined in the memory structure.\n\nWe've learned about a couple of key memory structures, but now let's see how those structures look like when inspecting a real program that has some SEH records defined.\n\nAs noted earlier, SEH are the / code blocks in the program as shown below:\n\nLet's compile the above program as seh-overflow.exe and inspect it with WinDBG again, this time with a command:\n\nWe can see that is located at and that the / head of the SEH chain is located at . From earlier, we said that this value could also be retrieved from the FS segment register , so let's confirm that:\n\nLet's check the start of the SEH chain at like so:\n\nBelow gif demonstrates how we can get the address of the head of the SEH chain with command and by inspecting the . We can then walk through all the registered SEH records in the SEH chain and observe how the last SEH record indicates that the next SEH records is at : (meaning, it is actually the last record and there's no next SEH record in the chain):\n\nNote, however, that these SEH records are the exception handlers defined in the ntdll and not in our compiled binary:\n\nIn order to see the SEH records defined by our program, we need it to execute the / code block that we have in the function. Let's see the CPU instructions at our program's entry point:\n\nAt this point, I do not know what the deal is with all the jmps, but let's try setting a breakpoint at (2nd instruction), right after the first at and continue with execution:\n\nLet's now see where the SEH head is at:\n\nWe can now see that the start of the SEH chain has changed and is at , so let's check the first SEH record:\n\nThe exception handler for the first SEH record is at . Let's see which module it belongs to:\n\nThe above image confirms that is inside our seh-overflow.exe image and we're inspecting the SEH chain from our seh-overflow.exe.\n\nWe can also easily discover SEH records using xdbg by inspecting the SEH tab as shown below:\n\nBelow shows how SEH records 1 to 4 (right) are organized on the program's stack (left):\n\nIf we updated our very first diagram showing where SEH chain is located and how it looks like with actual memory addresses, it would now look like this:\n\nNote that the exception handler at , when we identified it previously using WinDbg after executing the first inside the seh-overflow.exe entry point, was the first SEH record in the chain, however, inspecting the SEH chain in xdbg, we can see that the handler actually belongs to the second SEH record, which suggests that executing the first was not enough to set up the full SEH chain. That, however, does not prevent us from moving this lab further into the exploitation phase, but it's just something to note if you're playing along.\n\nWe're going to be exploiting the R 3.4.4 on a 32-bit Windows 10 system.\n\nLet's open RGUI.exe in xdbg and hit F9 as many times as we need in order to get the program's GUI to show up:\n\nLet's generate some garbage data that we will send to the RGUI in order to confirm we can crash it:\n\nOpen the RGUI configuration editor and paste the garbage data generated into the \"Language for menus and messages\" input box as shown and click OK and then OK once more:\n\nAt this point, looking at xdbg, we can confirm the program crashed and is vulnerable to a classic buffer overflow as we were able to overwrite the EIP register with our AAAA (0x41414141):\n\nMore, importantly, however, we confirm that the program is also vulnerable to the SEH overflow by inspecting the SEH chain tab:\n\nNote from above screenshot that the first SEH record was overwritten in the following manner:\n• None Pointer to the next SEH record was also overwritten (green).\n\nAs the next step, we need to find an offset at which we can overwrite the SEH record.\n\nWhen a user supplied input is sent to a program vulnerable with a buffer overflow vulnerability, the stack is overwritten from lower memory addresses towards higher memory addresses.\n\nWe also know that SEH records are stored on the stack and each one is an 8 byte memory structure that contains:\n• None Pointer to the next SEH record;\n\nBased on the above, in order to confirm the SEH record offset, we should generate a dummy payload that is structured like so:\n\nFollowing the Finding EIP offset technique, we identity that the SEH record offset into the stack is .\n\nBased on all of the above, our payload for testing, if we can correctly overwrite the SEH record (its pointer to the next SEH record and current SEH record's handler), should now look like this:\n\n...and send it to the vulnerable program and see if we can overwrite the SEH record, located at correctly:\n\nFrom the above screenshote we can see that we can overwrite the SEH record correctly:\n• None 43434343 (CCCC) is the exception handler for the current SEH record;\n• None 42424242 (BBBB) is the address of the next SEH record;\n\nNext, we will need to find a memory address in the vulnerable program that contains gadget. Let's see why we need this ROP gadget - hint: so that we can jump to the next SEH record in the chain, that we in fact can control, from which we can jump to the shellcode.\n\nLet's send to the vulnerable program and upon crashing it, inspect the SEH chain:\n\nNote the first SEH record is at address and its handler is at .\n\nLet's set a breakpoint on the handler at , continue execution until that breakpoint is hit, then inspect the SEH chain and the stack's contents:\n\nOnce the breakpoint is hit at , we can see that the address , which is the address of the next SEH record (which we control) is on the stack and it's just 3 values below the top of the stack. This means that if we could overwrite the current SEH record's handler, currently pointing to , to a memory address that contains instructions, we could transfer the program's execution control to (a SEH record that we control) and from there, execute our shellcode. We will test this in a moment.\n\nTo find memory addresses containing instructions, we can search all modules for a bytes pattern that translates to :\n\nThere are multiple results found as shown below. Let's chose the first one that contains executable instructions at and set a breakpoint on it by hitting F2:\n\nWe now know that our payload should look like this:\n\nSo wen can start building our python exploit skeleton as shown below:\n\nExecuting will create with our payload, which when sent to the RGUI, will overflow the SEH record and overwrite it in the following way:\n• None The next SEH record will contain the bytes , representing the string ;\n• None The current SEH handler will point to that contains instructions.\n\nLet's send that payload to the RGUI:\n\nNote from the above gif the key points:\n• None Once the program crashes with an exception and we continue running the program (F9), we hit our breakpoint at that contains the instructions;\n• None Once instructions are executed, instruction pops off the top topmost value from the stack, which is the SEH record we control, and jumps to it;\n• None Once execution jumps to , we see that first four instructions are actually are the bytes that represent our string , which means that at this point we have subverted the code execution flow and can start thinking about executing our shellcode.\n\nWe're now ready to start suplementing our payload with shellcode. Our payload should now look like this:\n\nLet's modify our exploit skeleton to include some shellcode that pops a calculator:\n\n...and send it to RGUI. Observe the crash, continue running the program until the breakpoint at is hit and inspect the memory at , where our SEH record, that we've just overflowed, lives. This is where we will jump to after the instructions will complete at :\n\nFrom the above screenshot, we can derive the following key point - once we land on (red zone), which contains the 4 bytes representing our string , we need to jump over to our shellcode in the blue zone.\n\nWe need to replace the string in our exploit code (which represents the address of the next SEH record) with a simple relative short instruction that jumps 6 bytes further into the code. The instuction can be encoded using the following bytes . Additionally, since the instruction is only 2 bytes, we'd need to supplement it with 2 NOP bytes to ensure the exploit reliability. So, should be replaced with bytes like so:\n\nNote that even though we say we're jumping over 6 bytes into the code, but in fact, we are jumping over 8 bytes, because the instruction itself is 2 bytes, so therefore 2+6=8. Essentially, we are jumping over the SEH record itself after which our shellcode lives.\n\nOur payload visually should now look like this:\n\nLet's see the full updated exploit code now:\n\nLet's send the payload to RGUI and observe the stack once the payload is sent to the program:\n\nFrom above screenshot, note the following key points:\n• None Once we're at , relative short jumps to the start of our sled at ;\n• None The sled takes us to the start of our shellcode at ;\n• None Once we hit F9 to resume execution, the shellcode is successfully executed and the calc is popped.\n\nWe can summarize that SEH overflow exploitation at a high level works as shown in the below diagram:\n• None SEH handler kicks in, which has been overwritten with a memory address in the program that contains instructions;\n• None instructions make the program jump to the next SEH record, which is overwritten with a short relative jump to the shellcode;\n\nWe can update the above diagram with memory addresses that we observed in this lab like so:"
    },
    {
        "link": "https://stackoverflow.com/questions/1610786/find-windows-dlls-not-compiled-with-safeseh",
        "document": "I know this is an ancient question that I'm dredging up from the dead, but there is a programmatic solution.\n\nFirst, parse the PE format. There are all sorts of solutions for this, so I won't go into it. Suffice to say that it's a bigger topic than I can cover here. If you decide to roll your own, be careful of the differences between 32-bit and 64-bit executables.\n\nOnce you've got a PE file parsed, skip the DOS header, NT signature, file header (a.k.a. COFF header), the optional header, and finally get to the Data Directories. Each of these directories has an RVA and a size. Find the RVA and size of the Configuration Directory (the 10th entry in the list).\n\nHere's where we can start doing detection. If the RVA or size is zero, SafeSEH isn't enabled. If the size is anything other than 0x40, it was built with a compiler that was (probably) vulnerable to the MS12-001 SafeSEH bypass bug. Don't trust the size value though - it does not necessarily match up to the size of the data within, because of some quirks with Windows XP - see the previous link for more details.\n\nIf the RVA and size seem sensible, follow the RVA to the Load Configuration structure. Parse that, then read the and values. If the handler table pointer is null (i.e. zero) then SafeSEH is not enabled. If the handler count is zero, there are no handlers registered, even though SafeSEH might be switched on."
    }
]