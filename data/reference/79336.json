[
    {
        "link": "https://stackify.com/java-custom-exceptions",
        "document": "Why, When and How to Implement Custom Exceptions in Java\n\nWe already talked a lot about exception handling on this blog and described the . If you’ve read these posts, you probably recognized a pattern. You should provide detailed information about the situation that caused the exception, and you should not remove anything that might be useful to the caller.\n\nYou often can achieve that by using standard exceptions with good messages. The Java Exception class describes the kind of event, and the message provides detailed information about it. You can take this concept one step further by using a custom exception.\n\nCustom exceptions provide you the flexibility to add attributes and methods that are not part of a standard Java exception. These can store additional information, like an application-specific error code, or provide utility methods that can be used to handle or present the exception to a user.\n\nThere are 4 general best practices that you should follow when you decide to implement a custom exception class. These recommendations make your code and API easier to understand. They also reduce the required amount of documentation. That quickly pays off if multiple developers work on the same application or library, new team members join your project, or a third-party software vendor decides to use your APIs.\n\nThe previously described examples for additional attributes or methods showed the intention of a custom exception. It provides information or functionality that is not part of Java’s standard exceptions.\n\nThat’s the essence of the first and most important recommendation. Otherwise, your exception doesn’t provide any benefit compared to the vast number of exceptions that are already provided by the JDK.\n\nIf you can’t provide any benefits, you should better use one of the standard exceptions, like . All Java developers already know these exceptions. That makes your code and API easier to understand.\n\nWhen you take a look at the exception classes provided by the JDK, you quickly recognize that all of their names end with “Exception”. This general naming convention is used throughout the Java ecosystem. And your custom exception should follow it as well.\n\nWe shouldn’t need to talk about this best practice, but I have seen way too many custom exceptions without any\n\nIt’s a general best practice to document all classes, fields, constructors, and methods of your API. If you ever had to use an undocumented API, you know exactly why. Undocumented APIs are very difficult to use.\n\nException classes might not be the most obvious part of your API, but they are still part of it. As soon as one of your client-facing methods throws an exception, the exception class becomes part of the API. That implies that it requires documentation and a\n\nThe Javadoc should describe the general meaning of the exception and the situations in which it might occur. The goal is to help other developers to understand your API and to avoid common error scenarios.\n\n4. Provide a constructor that sets the cause\n\nQuite often, your code catches a standard exception before you throw your custom exception. You should not hide this fact. The caught exception usually contains essential information that you will need to analyze a production incident.\n\nIn the following example, the provides detailed information about the error. You will lose this information if you don’t set it as the cause of the\n\nand provide constructor methods that accept a which describes the cause of the exception. And your exception should do the same. You should implement at least one constructor that gets the causing as a parameter and sets it on the superclass.\n\nThese are the most important best practices for implementing custom exception. If you’re looking for more tips and recommendations, take a look at my posts featuring\n\nCreating a custom checked exception is simple. You already saw multiple parts of it when I explained the 4 best practices for implementing custom exceptions.\n\nWhen you implement a checked exception, you need to extend the class . That’s the only thing you need to do to create a custom exception class. But as I explained earlier, you should also provide a constructor method that sets the causing exception and provide a benefit compared to the available standard exceptions.\n\nThe following example does all of that. As you can see, I added a Javadoc comment that describes the exception. I also implemented a constructor method that sets the causing exception on the superclass. And to provide a benefit compared to the standard exceptions, uses a custom enumeration to store an error code that identifies the problem. Clients can use the error code to show localized error messages or tell the user to include this code in a support ticket.\n\nThat’s all you need to do to implement a custom checked exception. You can now throw the in your code, specify it as part of your method signature and handle it in a catch clause.\n\nThe implementation of a custom unchecked exception is almost identical to a checked exception. You should follow the same recommendations as I explained at the beginning of this post. The only difference is that an unchecked exception has to extend\n\nYou can use the in the same way as any other unchecked exception. You can throw it in your code and catch it in a catch clause. And you can but don’t need to specify if your method throws it.\n\nAs described in this post, the implementation of a custom exception is easy. You just need to extend\n\nIn addition to that, you should follow a few best practices. They make your code easier to read and your API easier to use. Here are the 4 most important best practices for custom exceptions in Java:\n• None You should only implement a custom exception if it provides a benefit compared to Java’s standard exceptions.\n• None The class name of your exception should end with\n• None If an API method specifies an exception, the exception class becomes part of the API, and you need to document it.\n• None You should provide a constructor which sets the cause of the exception.\n\nWhen using Retrace APM with code profiling, you can directly from Java, without any code changes!"
    },
    {
        "link": "https://j-labs.pl/en/tech-blog/java-exception-handling-strategies-and-best-practices",
        "document": "Exception handling is a critical aspect of Java programming that allows developers to manage errors and unexpected situations gracefully. Proper exception handling enhances the reliability and maintainability of the code. In this article, we will delve into best practices and strategies for effective exception handling in Java.\n\nException handling is the process of dealing with runtime errors, ensuring that applications can gracefully recover from unexpected scenarios. Java’s exception handling mechanism involves try-catch blocks, where the code that might throw an exception is enclosed in a try block, and a possible exception handling code is placed in corresponding catch blocks.\n\nIn Java, exceptions are categorized into three main types based on their origin and behavior: checked exceptions, unchecked exceptions, and errors. This categorization helps developers understand the nature of exceptions and how they should be handled in the code.\n\nThe exception hierarchy in Java is organized into a class hierarchy that inherits from the Throwable class. Here’s a simplified diagram of the exception hierarchy in Java:\n\nHere’s a brief explanation of each level of the hierarchy:\n• Throwable: This is the root class of the exception hierarchy. Both errors and exceptions inherit from this class. It provides methods like getMessage() and printStackTrace().\n• Error: These exceptions are typically thrown by the JVM itself to indicate serious problems that usually cannot be handled by the application code. Examples include OutOfMemoryError and StackOverflowError.\n• Exception: These exceptions are more specific and can be either checked or unchecked. Checked exceptions must be caught or declared using the throws clause in the method signature.\n• Unchecked (RuntimeException): These are exceptions that often arise due to programming errors or unexpected conditions. They are not required to be caught or declared.\n• Checked: These are a subset of exceptions that the compiler requires us to either catch and handle using a try-catch block or declare to be thrown using the throws clause in the method signature. Checked exceptions are typically used to represent exceptional conditions that are recoverable and that the programmer can reasonably anticipate and handle.\n\nThis hierarchy helps in categorizing and organizing exceptions based on their nature and behavior. It’s essential to understand this hierarchy when handling exceptions in Java, as it guides you on how exceptions are related and when they need to be caught or declared.\n\nChecked exceptions are exceptions that are checked at compile-time, meaning the compiler ensures that these exceptions are either caught using a try-catch block or declared to be thrown using the throws keyword in the method signature. These exceptions usually represent conditions that are beyond the control of the programmer and are typically related to external factors, such as I/O operations or network issues.\n• IOException: Raised when there’s an issue with input or output operations, such as reading or writing to files.\n• ClassNotFoundException: Raised when a class is not found during runtime.\n\nUnchecked exceptions, also known as runtime exceptions, do not need to be declared explicitly in the method signature or caught using a try-catch block. They occur due to programming errors and are often preventable through better coding practices. Unchecked exceptions propagate up the call stack until they are caught or the program terminates.\n• NullPointerException: Raised when trying to access an object or method on a null reference.\n• ArrayIndexOutOfBoundsException: Raised when trying to access an array element with an invalid index.\n• IllegalArgumentException: Raised when a method is passed an inappropriate or invalid argument.\n• ArithmeticException: Raised when an arithmetic operation is attempted with illegal or undefined values.\n\nErrors represent exceptional conditions that are beyond the control of the application and typically indicate serious problems that may lead to an abnormal termination of the program. Unlike exceptions, errors are not intended to be caught or handled by the application code.\n• OutOfMemoryError: Raised when the JVM runs out of memory.\n• StackOverflowError: Raised when the call stack of a program exceeds its limit.\n• NoClassDefFoundError: Raised when the JVM cannot find a class definition.\n\nIt’s important to understand these categories of exceptions to write robust and maintainable Java code. Checked exceptions should be handled or declared as appropriate, while unchecked exceptions are usually addressed through better programming practices. Errors are typically not handled by the application code and may require corrective actions at the system level.\n• Use Specific Exception Classes: Handle exceptions at a granular level by catching specific exception classes rather than generic ones.\n• Handle Exceptions at the Right Level: Catch exceptions at the level where they can be effectively dealt with.\n• Avoid Catching Generic Exceptions: Avoid using catch (Exception e) as it might hide underlying issues.\n• Use a Finally Block Sparingly: Use finally only for essential cleanup operations.\n• Logging and Reporting Exceptions: Always log exceptions for troubleshooting and debugging purposes.\n• Avoid Empty Catch Blocks: Empty catch blocks can lead to silent failures; at least log the exception.\n• Fail Fast: Detect issues as early as possible in the development process.\n• Graceful Degradation: Design applications to continue functioning even when exceptions occur.\n• Exception Propagation: Allow exceptions to propagate up the call stack if they cannot be handled locally.\n\nIn this example, we have three methods: method1(), method2(), and method3(). Each method calls the next method in the sequence. In method3(), we intentionally cause an ArithmeticException by dividing an integer by zero.\n\nThe exception propagates from method3() to method2(), then from method2() to method1(), and finally from method1() to the main method. The exception is caught in the main method’s try-catch block, and the program doesn’t terminate abnormally.\n\nThis example demonstrates how exceptions travel up the call stack until they are caught or the program terminates. It also highlights the importance of handling exceptions appropriately to ensure the robustness of your code.\n• Custom Exception Classes: Create custom exception classes for domain-specific errors. Custom exception classes allow you to define your own exception types to represent specific errors or exceptional situations in your application.\n\nIn this example, we have defined a custom exception class InsufficientBalanceException that extends the built-in Exception class. This exception is designed to represent situations where there’s not enough balance in a bank account for a withdrawal.\n\nThe BankAccount class has a withdraw method that throws the InsufficientBalanceException if the withdrawal amount exceeds the account balance.\n\nIn the main method, we create an instance of BankAccount and attempt to withdraw an amount greater than the account balance. Since the withdrawal would lead to an insufficient balance, the InsufficientBalanceException is thrown. We catch this exception and display an error message.\n\nCustom exception classes allow you to encapsulate domain-specific errors and provide meaningful error messages for easier debugging and error handling in your application.\n• Try-With-Resources: Use try-with-resources to automatically close resources like files and connections.\n\nBest Practices for Exception Messages in Java\n\nException messages play a crucial role in understanding and debugging errors in your code. Well-crafted exception messages can significantly improve the clarity and maintainability of your software. Here are some best practices for creating effective exception messages:\n\nException messages should clearly convey what went wrong and why. Use plain language to describe the error in a way that is easy for developers to understand.\n\nInclude context-relevant details in the message. This might include the values of variables, inputs, or conditions that caused the exception. However, avoid exposing sensitive data.\n\nFollow a consistent format for exception messages throughout your codebase. This makes it easier for developers to recognize and handle different types of errors.\n\nPhrase exception messages in the active voice to clearly indicate the cause of the error. For example, “File not found” is more informative than “File was not found.”\n\nWhile you want to provide meaningful information, avoid using technical jargon that might confuse other developers or stakeholders who read the error messages.\n\nSpell out terms instead of using abbreviations or acronyms. This ensures that everyone can understand the message, even those who are not familiar with the abbreviations.\n\nIf possible, suggest potential solutions or actions that the developer can take to resolve the issue. This can help in the troubleshooting process.\n\nException messages are part of your application’s user interface, so use proper punctuation, capitalization, and formatting to make them readable and professional.\n\n9. Keep It Short and Precise\n\nException messages should be concise and to the point. Avoid lengthy messages that might overwhelm the developer or clutter the log.\n\nIf your software is used in different locales, consider providing localized exception messages to cater to users who speak different languages.\n\nWhen logging exceptions, include the stack trace to provide developers with a detailed view of where the exception occurred in the code. This aids in diagnosing the issue.\n\nWhile it’s important to indicate errors, avoid blaming the user directly in the message. Instead, focus on explaining the issue and providing a solution.\n\nRemember that the goal of exception messages is to help developers identify and fix issues quickly. By following these best practices, you can make your error messages more informative, user-friendly, and conducive to effective troubleshooting and debugging.\n\nIn functional programming, the approach to handling exceptions is slightly different from traditional imperative programming. Functional programming emphasizes immutability, pure functions, and avoiding side effects. While exceptions are still used to handle errors, they are typically managed in a way that aligns with the functional programming principles. Here’s how you can handle exceptions in functional programming using Java:\n\nInstead of throwing exceptions, functional programming often uses option types (like Optional in Java). These constructs allow you to represent success or failure explicitly and safely.\n\nFunctional programming promotes composing functions to transform data. When dealing with exceptions, you can chain functions that handle different error cases.\n\nIn functional programming, functions should be side-effect free. This means that functions should not modify the external state. Instead of directly modifying the external state, return updated copies of data.\n\nEffective exception handling is a cornerstone of robust Java applications. By following best practices and adopting appropriate exception handling strategies, developers can build applications that gracefully handle errors, provide meaningful feedback to users, and maintain a high level of reliability.\n\nIn this article, we have discussed essential best practices, strategies, and real-world examples that empower Java developers to master the art of exception handling, enhancing the overall quality of their software projects."
    },
    {
        "link": "https://stackoverflow.com/questions/26984/what-is-the-general-rule-of-thumbs-for-creating-an-exception-in-java",
        "document": "Don't do what the developers at my company did. Somebody created an [sic] InvalidArguementException that parallels java.lang.IllegalArgumentException, and we now use it in (literally) hundreds of classes. Both indicate that a method has been passed an illegal or inappropriate argument. Talk about a waste...\n\nJoshua Bloch covers this in Effective Java Programming Language Guide [my bible of first resort on Best Practices] Chapter 8. Exceptions Item 42: Favor the use of standard exceptions. Here's a bit of what he says,\n\nReusing preexisting exceptions has several benefits. Chief among these, it makes your API easier to learn and use because it matches established conventions with which programmers are already familiar [my emphasis, not Bloch's]. A close second is that programs using your API are easier to read because they aren't cluttered with unfamiliar exceptions. Finally, fewer exception classes mean a smaller memory footprint and less time spent loading classes. The most commonly reused exception is IllegalArgumentException. This is generally the exception to throw when the caller passes in an argument whose value is inappropriate. For example, this would be the exception to throw if the caller passed a negative number in a parameter representing the number of times some action were to be repeated.\n\nThat said, you should never throw Exception itself. Java has a well-chosen, diverse and well-targeted bunch of built-in exceptions that cover most situations AND describe the exception that occurred well enough so that you can remedy the cause.\n\nBe friendly to the programmers who have to maintain your code in the future."
    },
    {
        "link": "https://medium.com/@nweligalla/creating-custom-exceptions-in-java-ea77a61fcaf4",
        "document": "To make your own exception in Java, you typically need to create a custom class that extends the class or one of its subclasses, such as . Before you create any exceptions, it’s a good idea to follow some best practices for creating specially naming your custom exceptions in Java.\n\nHere are some best practices when naming custom exceptions\n\nLet’s walk through the steps of creating a custom exception with a practical example. Let’s say you’re creating a simple Java application allowing users to take money out of their accounts. Here’s the code for\n\nhas 2 properties called and . Along with getters and setters methods and a constructor to create a Bank account, there is also method to take money out of the Account.\n\nIn the code below, Teller.java allows you to create an account with an initial amount of money and withdraw funds from it\n\nSo when we run it we get the following output.\n\nSince we haven’t added any validations in method yet, users can withdraw more money than they have, leading to a negative balance, like the following.\n\nTo prevent this, we can add an exception to the method when someone tries to withdraw more money than the account balance. Let’s name it . For this, create a new file named To turn it into an exception, make it extend the class. In , I’ve created a constructor that takes the as a parameter.\n\nThis is sent to the parent class’s constructor with a concatenated string using . Because you’re overriding the default Java constructor with one that takes an parameter, you can also create another no-args constructor and use it to throw an exception directly. if you want you can call the super() without any parameters.\n\nYou don’t have to only extend the class; you can also extend the for your custom exception. I’ve already covered the differences between and in an article. You can read it here."
    },
    {
        "link": "https://theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Java-Exception-handling-best-practices",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/generics/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nIn any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they'll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.\n\nFortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler's error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don't always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.\n\nGenerics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the Generics tutorial by Gilad Bracha."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/generics/types.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nA generic type is a generic class or interface that is parameterized over types. The following class will be modified to demonstrate the concept.\n\nBegin by examining a non-generic class that operates on objects of any type. It needs only to provide two methods: , which adds an object to the box, and , which retrieves it:\n\nSince its methods accept or return an , you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an in the box and expect to get s out of it, while another part of the code may mistakenly pass in a , resulting in a runtime error.\n\nA generic class is defined with the following format:\n\nThe type parameter section, delimited by angle brackets ( ), follows the class name. It specifies the type parameters (also called type variables) , , ..., and .\n\nTo update the class to use generics, you create a generic type declaration by changing the code \" \" to \" \". This introduces the type variable, , that can be used anywhere inside the class.\n\nWith this change, the class becomes:\n\nAs you can see, all occurrences of are replaced by . A type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.\n\nThis same technique can be applied to create generic interfaces.\n\nBy convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.\n\nThe most commonly used type parameter names are:\n• E - Element (used extensively by the Java Collections Framework)\n\nYou'll see these names used throughout the Java SE API and the rest of this lesson.\n\nTo reference the generic class from within your code, you must perform a generic type invocation, which replaces with some concrete value, such as :\n\nYou can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a type argument — in this case — to the class itself.\n\nType Parameter and Type Argument Terminology: Many developers use the terms \"type parameter\" and \"type argument\" interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the in is a type parameter and the in is a type argument. This lesson observes this definition when using these terms.\n\nLike any other variable declaration, this code does not actually create a new object. It simply declares that will hold a reference to a \" of \", which is how is read.\n\nAn invocation of a generic type is generally known as a parameterized type.\n\nTo instantiate this class, use the keyword, as usual, but place between the class name and the parenthesis:\n\nIn Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (<>) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, <>, is informally called the diamond. For example, you can create an instance of with the following statement:\n\nFor more information on diamond notation and type inference, see Type Inference.\n\nAs mentioned previously, a generic class can have multiple type parameters. For example, the generic class, which implements the generic interface:\n\nThe following statements create two instantiations of the class:\n\nThe code, , instantiates as a and as an . Therefore, the parameter types of 's constructor are and , respectively. Due to autoboxing, it is valid to pass a and an to the class.\n\nAs mentioned in The Diamond, because a Java compiler can infer the and types from the declaration , these statements can be shortened using diamond notation:\n\nTo create a generic interface, follow the same conventions as for creating a generic class.\n\nYou can also substitute a type parameter (that is, or ) with a parameterized type (that is, ). For example, using the example:"
    },
    {
        "link": "https://medium.com/@abhiroop.nray/generics-and-collections-in-java-programming-language-68e93007ccdd",
        "document": "In a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types\n\nGenerics were added in Java version 5.0. This is was implemented with an intention to allow a type (like Strings, Integers, custom objects etc.) or method to operate on different types. Generics also offers compile time safety. It catches invalid or mismatched types at the compilation. For example let us take a look at the code below:\n\nFigure 1: Casting required as no generics is used\n\nFigure 2: No casting required as generics is used\n\nGenerics enables programmers to enable write code to implement generic algorithms to work on different collections or data structures. Generics are not only safe they are also easy to interpret and read the code. The generic method declaration have a place for type parameter sections are written within angular brackets. (< / > ). Generics can be written by comma separated.\n\nBefore going more into generics and collections and their usages we need to have some fair idea on some the common methods requires. These are described below.\n\nThis method belongs to the Object class i.e. the top level class and so this method is available to all the classes in the Java. The implementation of the toString() method in implemented as below:\n\nThe method toString() returns a string representation of the object. he method returns a string that “textually represents” this object. The result is expected to be a concise but informative representation that is easy for a person to read.\n\nAs we can see if we use the toString() method of the object class we will get the class name followed by ‘@’ with some alphanumeric hexadecimal expression of the object’s hashcode. We will get some information but in reality gives very little human readable information. To get some information regarding the object the toString() methods It is recommended that all subclasses override this method.\n\nLet us see the following examples below to see the differences between overridden toString() method and normal Object class toString() method.\n\nThe output of the above code will be something like this: PlayerClass@48987 (The number may vary).\n\nBut if we override the toString() method we will modify the code like below:\n\nThe output of the above code will be:\n\nThe class name is PlayerClass and the player’s name is Lionel Messi. (It will also work similarly for C Ronaldo).\n\nNow we have got some information about the class which are useful to a human person. We can override the toString() method and can as many information as we need to pass.\n\nThus it is important and a good coding style to override the toString() method in a class so that if required some proper, human readable information can be get from the class.\n\nThis method belongs to the object class and is accessible by any class. It provides whether some other object is “equal” or same this one.\n\nFrom javaDoc we see,\n\nThe implementation to the method in the Object class is shown in below:\n\nWe can see here basically, the method is only using the operator “==” check and returns the value. If the reference variable is same or refers to same object it returns true else false. It checks the bits in the variable and returns the Boolean value accordingly i.e. if they are identical true is returned or else it returns false.\n\n“==” are used if we want to know whether two reference variables are equal or not.\n\nequal() method is used on objects to check whether the contents of the two objects are same or not.\n\nSo if we use the Object#equals(Object o) method to check two objects it basically performs the action of “==” operator. The whole objective of the equals(Object o) method gets invalid. So we need to override the method in each class to get the proper result. Let’s see the following codes how with and without overriding the method can change the output.\n\nThe sample class without overriding the equals(Object o):\n\nThe output will be as followed:\n\nNow, let us override the toString method in the SampleClass and run the program again. The code will become as shown below:\n\nThe output will be as followed:\n\nIn the first case as we have not overridden the method equals(Object o) the equals value implemented the Object#toString() method and in reality performed ‘==’ operation. Both the reference variable sample1 and sample2 creates similar objects but are different reference variable. So both the results came as false.\n\nIn the second case we have overridden the equals(Object 0) method which checks the contents of the objects now, instead of the reference variable. So we see the equal(Object o) checks the contents of both the objects and when it was found same it returns true. But still the ‘==’ operator returns false as expected, since both are different reference variable and are not the same.\n\nBut, as we have seen in String class without even overriding the equals(Object o) method we can use them and also get the proper responses. That is because in String class, Java has already overridden method. This is the equals(Object o) method of string class.\n\nBasically the method is checking each characters in the two strings and if all of them are equal i.e. the contents of them are equal it returns true else false.\n\nMany such classes have internal implementation, but not all. So we need to be careful while using .equals(Object o) method on objects to get the required proper value.\n\nIt gives us one important fact: if ‘==’ returns true .equals(Object o) will always be true, but the opposite doesn’t work that way.\n\n· Symmetric: if a.equals(b) is true, b.equal(a) will always be true\n\n· Transitive: if a.equals(b) is true and b.equals(c) is true then a.equals(c) will always be true\n\nConsistent: If not information provided to the classes is changed it will always returns the same, no matter how many time it is called.\n\na.equals(null) will always returns to null.\n\nThis method belongs in the Object class so any class so any class can use and override it. The hashCode() method is used to increase the performance of searching in large quantities of data. Hashcodes are generated using a mathematical or hashcode algorithm and generating a output.\n\nHashcode may not are mostly unique for each object but they may not be unique in certain corner cases. Let’s have a look into it.\n\nConsider we have few names like Alex, Bob, Anil and Nila. We want to implement hashcode algorithm to them. Our algorithm is to assign each letters their respective position number i.e. A=1, B=2, C=3 and so on. Then add those numbers and generate the hashcode.\n\nIn this table, we can see, even though we have 4 different hascodes. But two of them though are different in names have same hashcodes. In real scenarios hashing generally have more than one entry. One i.e. hashcode used to find first, then to use equals(Object o) to find the exact object. But if two objects are equal, their hascodes must always be equal, but the opposite is not true.\n\nHashcodes can return same value for all objects or some objects depending upon its implementation. If a hashCode function is written that it will return a constant value all the time, every objects will have same hashcode even though they are not the same. This makes hashcode not so useful and the equals(Object o) method finally will find out the exact object. This is an inefficient coding. The goal is that two equal objects should have equal hashcodes.\n\nSo to make an efficient program both the methods equals(Object o) and hashCode() should be properly overridden to fetch the exact object and also to make the fetching faster. For example if a hashcode is implemented improperly along with the equal(Object o) method (shown below), it will still be legal but extremely inefficient and improper.\n\n· In single execution the hascodes must be same for same object. But it may vary in another execution of the process.\n\n· If two objects are equals, i.e. equals(Object o) returns true, then their hashcode will definitely be equal.\n\n· If two objects are not equals, i.e. equals(Object o) returns I, still their hashcode can be same.\n\nCollections, Collection and collection, these three words have three completely different interpretation in Java. So let us clear it out, before we dig into them.\n\n1. collection (lower case c): Represents any data structures in which objects are stored, retrieved and iterated over.\n\n2. Collection (Upper case c): It is an interface of java.lang.Collection. Set, Queue and List are extended from it. There is no direct implementation of Collection.\n\n3. Collections (Upper case C and ends with s): It represents a class off java.lang.Collections. It contains a set of utility methods for the use of data structures or collections.\n\n· Add an object to the collection\n\n· Remove an object to the collection\n\n· Find out, if an object is present in the collection\n\n· Retrieve an object from the collection without deleting it.\n\n· Iterating through the collection on each objects\n\nImportant interfaces of the Collections framework and their concrete classes:\n\nEach and every collection doesn’t implement the Collection interface. Utilities and maps have separate super classes. The following image will display the hierarchy structure of the Collections framework.\n\nCollections can be Lists, Queues, Maps or sets. These data structures can be sorted/unsorted or ordered/unordered.\n\nAny above mentioned collections can be of the following three states:\n\nBut it can never be sorted and unordered. Because sorted is a specific type of ordering. When an object is sorted by some parameter it is known as sorted and so automatically it gets ordered in a particular fashion.\n\n· An ordered collections can be iterated in a non-random specific order. Generally by the index of insertion.\n\n· Hastable though internally maintains order is not an ordered collection as multiple calls of iteration can results in different outputs. Though in LinkedHashSet maintains order by insertion. The last element inserted is the last one.\n\n· ArraryList is strictly ordered by the index of the object inserted.\n\n· Some data structures uses natural ordering (like alphabetically or numerically) and they are also sorted.\n\n· A sorted collection is a collection which maintains a order of the objects by some rule or rules known as sorted-rules.\n\n· A sorted collection has nothing to do with the indexes, or the time of insertion, deletion or the position where it is inserted.\n\n· A sorted collection depends on some parameter(s) of the object, to arrange them in an ordered way. It is done on the properties of the object itself.\n\n· Sorting can be done using natural order mostly, but they can also be customized depending upon the requirements.\n\nNow let us have some idea on the different collections used in Java.\n\n· List are ordered collections maintained by indexes. Any list is maintained by indexes. List has a set of index based methods, which are not available in non-list collections.\n\n· The list methods can get, add, remove, and find the index of an object on the basis of indexes specified when specific method is invoked. If no index is mentioned the object gets added to the end of the list.\n\n· There are 3 list implementations: ArrayList, LinkedList and Vector (rarely used now a days, as thread safe coding has imporved).\n\nArrayList is a kind of modern, upgraded and sophisticated array. They have many similarities with arrays and many more features.\n\n· Array list are ordered collections with their indexes naturally but they are not sorted, unless explicitly mentioned.\n\n· When an array is declared the size needs to be mentioned and it can’t grow more than that. ArrayList is kind of growing arrays. While initializing, an ArrayList does not need to specify the size of it. As object gets inserted the size grows and if removed the size decreases by itself.\n\n· ArrayList is faster in iteration and also faster in accessing objects randomly using indexes of course.(it is a list after all)\n\n· With comparison to LinkedList, ArrayList are faster for iteration, but LinkedList performs better in case of insertion.\n\n· LinkedList are ordered collections with their indexes naturally but they are not sorted, unless explicitly mentioned.\n\n· LinkedList is very similar to ArrayList but the objects are doubly linked. So LinkedList can be traversed from beginning to end and vice versa. Same way new objects can be added or deleted.\n\n· Because of being doubly linked, it is a good option for implementing other data structures like stack or queue.\n\n· With comparison to ArrayList it is faster in adding an object but iteration might be relatively slower.\n\n· An old collection, since the inception of Java\n\n· Works same as ArrayList but all methods are synchronized and thread safe and thus slower.\n\n· As thread safe coding can be done in other ways, vector is not much is used now a days.\n\nA set is an interface where only unique objects are allowed to store. No duplication on objects are allowed. The equals(Object o) determines two objects, and if same object is tried to add to it, it won’t allow.\n\n· A HashSet is an unordered and unsorted collection. In different execution of iteration it might give different outputs.\n\n· HashSet is used when there is no need of any orderly addition on objects and duplicity should be prevented.\n\n· HashSet uses hashcode code of objects which in turn checks the equals(Object o) method to while inserting an object. If same object is already there in the set, the insertion is avoided.\n\n· LinkedHashSet is an ordered version of HashSet.\n\n· It maintains a doubly-linked list across all elements.\n\n· Iteration through HashSet is unpredictable but as LinkedHashSet is ordered iteration is maintained in an orderly fashion. So it is recommended to use when Map is required to iterate in orderly fashion.\n\nBoth the above collection requires to override the hashCode() method properly. Map use hascodes of objects to determine delicacy. If the default Object#hashCode() method is used meaningfully equal objects may get added, excluding the main objective of set to keep only unique objects and allows no duplicity.\n\n· TreeeSet is one of the two sorted collections, the other being TreeMap.\n\n· Guarantees that the elements inserted will be in the order of ascending.\n\n· Sorting is done mostly using the natural sorting order\n\n· Sorting can be implemented in custom order as well via the constructor that lets the developer to set the own rule of sorting.\n\nMap implements with unique identifiers but not by unique objects. Unlike Set maps can have duplicate values, but each value will have an unique id. Map uses key to get the objects or the value. It uses equals(Object o) method to check whether two pair of keys are equal or not.\n\n· HashMap is an unsorted and unordered data structure.\n\n· HashMap is useful when the iteration is not required in a particular order.\n\n· Objects are stored based on their hashcodes.\n\n· One null key is allowed, but multiple null values are allowed inside a HashMap\n\n· An old collection of Java, since its inception\n\n· Works exactly like HashMap, but the methods are synchronized and thread-safe.\n\n· No null key or values are allowed in a Hashtable\n\n· LinkedHashMap is ordered collection. Its order is maintained by the indexes.\n\n· Slower in insertion and deletion than HashMap, but performs faster iteration.\n\n· TreeMap is one of the two sorted collection, the other being TreeSet.\n\n· Sorted order is maintained by implementing the natural sorted order.\n\n· Custom sort-order can be applied via the constructor, passing a Comparable or Comparator.\n\nQueue is a collection used to keep a list of objects to be done one by ne or to hold objects of “to-dos”. Typically queues maintains FIFO (First in, First out) rule but this can be customized using priority queue.\n\n· Basic queue collections can be handled using LinkedList which generally uses FIFO rule.\n\n· Priority queue is used to create a priority parameter among the objects that will create a “priority-in, priority-out” queue sequence as opposed to the normal FIFO.\n\n· PriorityQueue objects are ordered by natural ordering, yet they can be customized by passing custom Comparator. In either case the ordering is represented by their priority.\n\nSorting of data is one of them most important task of collections. Data in collections can be sorted or ordered in different ways. For efficient and custom sorting we use can use either Comparable or Comparator interfaces. These interfaces offers ways to compare two objects and sort them with respect to their parameters mentioned. The interfaces are used in Arrays.sort() and Collections.sort() to sort objects.\n\nA comparable object is efficient of comparing it’s own object with another. The class itself must implement the java.lang.Comparable interface in order to be able to compare its instances. Objects can be sorted using single argument sort() method.\n\nA comparator object is in charge of comparing two different objects. The class is not comparing its own instances, but with some other class’s instances. A new class needs to be formed for which implements Comparator. This comparator class must implement the java.util.Comparator interface. Objects can be sorted by passing both the list to be sorted and the comparator object.\n\nLet us see an example of natural sorting. Let us run the below program and check the output.\n\nThe output is as follows:\n\nHere we can see the method Collection.sort() has used natural sorting i.e. sorted the elements in alphabetical order. Similar type of natural sorting also happens for integers.\n\nBut what if we want to tweak the code and add more parameter apart from just name or numbers like ids?\n\nLike the following example, if we have a class which will take players name, his skill, jersey number and matches played before a certain event (here Cricket WC 2003) Collections.sort() method will fail. Rather it will give compilation error.\n\nLet us check the code below:\n\nIn this case the Collection.sort(list) line will give compilation error or in older Java version it might give runtime exception in the main class and it will not let the program run.\n\nCollections has a single argument sort method it can take lists, but not lists of PlayerInfo types. (Why? We will find soon.). There is an argument mismatch here. The java doc in Collections.sort method says that it takes list arguments and which must implements Comparable interface. Thankfully in case of String class Comparable is already implemented and so we can use String lists like in the first example. The PlayerInfo class has no implementation of Comparable interface. Here the compiler does not understand how to sort or which parameter to use to order the items. Natural sorting is not possible here. If we use Comparable or Comparator interface our code should work and also it can be customized.\n\nBoth the overridden methods returns integer and in same way. if,\n\nNegative: this object < other object\n\nZero: this object == other object\n\nPositive: this object > other object\n\nThe Comparable interface: Needs to override compareTo(Object o) method.\n\nComparable Interface: Needs to override the compare(Object o1, Object o2) method.\n\nBy switching the arguments in the invocation of the method we can get inverted results.\n\nNow we can implement Comparable interface to the PlayerInfo class and override the compareTo(PlayerInfo o) method and invoke the Collections.sort(Object o) method without any error. Let us do it and check the output.\n\nIf we run the same program again we get the output as:\n\nNow the Collections.sort objects get to know how to compare objects and make the order.\n\nComparator operator gives the capability to sort a collection in a variety of ways. In Comparable method the class needs to implement the interface. But in Comparator a separate class needs to implement the method which can be passed to the overloaded method of Collection.sort(), which takes both a list and a comparator object. The sort method uses the comparator instance to sort out the given list.\n\nLet us check the following example in which we will consider the older PlayerInfo class without implementing Comparable class. Here we will use Comparator interface in the program which will show the captain’s name first, then the batsmen and then the bowlers. The batsmen and bowlers will also be sorted by the number of matches they played till now and then if not possible in alphabetically.\n\nHere is how we will write our code:\n\nThe Main Class: (Usage of comparable interface removed and Comparator interface usage added)\n\nThe PlayerInfo class: (same as mentioned before)\n\nLet use see the output when this program runs:\n\nThus, here we get a list of unordered unsorted players’ list. But we ca use our own customized Comparator interface and make a list sorted accordingly.\n\nBoth Array and ArrayList are similar but they have lots of differences. ArraList can be said a modern, open-minded, sophisticated implementation of Array. But it is also exactly not like that. In collections we use both of them as per requirement. Both are widely used in different programs. Lets us see a little bit about them.\n\nArrays are data structures which keeps a series of same data types like strings or integers. So, it is also important to order or sort the data in an array.\n\nData in an Array can be sorted by invoking either of the single argument or double argument sort() method of the Array class. The single argument takes the array t sort as a parameter and the double argument along with the array also takes and Comparator object to customize the sorting.\n\nAlso since arrays can contain a lot of primitives, the sort method of Arrays class is overloaded a lot of times to support each of them. The sort() method of both the Arrays and Collections classes are static. So they work on the object passed and invoke on them directly. Of course the elements to be sorted must be mutually comparable.\n\nCollections contains series of data which needs to accessed on time. So searching them is one of the most important task and both Arrays and Collections allows to do that. While searching few rules are followed, they are mentioned below:\n\n1. BinarySeacrh method is used for searching\n\n2. If the search result is succcessful it returns the index of the object searched\n\n3. If the searchresult is unsuccessful if returns an integer value whichrepresents the insertion point. But here is a thing for some fun.\n\n· Returns a negative value as the insertion point. This is because zero itself is a valid insertion point, generally the first element of any collections.\n\n· The actual insertion point returned is represented as below:\n\n( — (insertion point) — 1). Like, if the insertion point is 2 the value returned will be -3.\n\n4..Before searching the collections must be sorted in some kind of order.\n\n6. Searching should be done following the way it was sorted. Natural order for natural sorting, comparator for customized sorting.\n\nTo convert an Array to ArrayList Java API provides as List() method and to convert an list to Array toArray() method can be used. Its simple and very lucid.\n\nLet us see the following code to convert and Array to ArrayList.\n\nThe output will be as follows:\n\nArray is now changed to a list!\n\nSize of ArrayList asList(): 5\n\nChanging array\n\nList value at index 3: The Wolf of wall street\n\nChanging list\n\nList value at index 3: Gangs of New York\n\nArray value at index 3: Gangs of New York\n\nBut, but, but, have you noticed one interesting thing here. Though the array has been changed to a list and each pf them works nicely with their own methods, if we change value of any one of collections, the other one also got changed. Though at index 3 in the list the value was “se7en” as we changed the only the array , the list also got updated. Even though both are different collections, they are joined as a hip.\n\nLet us now change an ArrayList to an Array.\n\nThe output will be as followed:\n\nInteger array list at index: 3\n\nInteger array at index 3: 33\n\nInteger ArrayList at index 3: 3\n\nHere, we can see, even though the value of the array was changed it didn’t affected the value of list. The collections are not conjoined here. But pne thing to notice here, the method toArray() comes in two flavors:\n\n1> It can create a new Object array\n\n2> It can create an array of the type whose destination has been sent. (Like here we created an int[] array)\n\nAs mentioned earlier lists are used to store data in an ordered manner. Lists can be used for FIFO, keep track of objects, their visits by indexes or they may be used with priority value. List can be traversed using loop, enhanced loop of the good old iterator method. Lists are unordered and unsorted unless specifically made like that. As normal loop methods and enhanced loop are quite common we will have an example of iteration here below.\n\nThe out of the program will be:\n\nUsing iterator on list of SampleClass Objects: Satyajit Ray\n\nUsing iterator on list of SampleClass Objects: Ritwik Ghatak\n\nUsing iterator on list of SampleClass Objects: Mrinal Sen\n\nUsing iterator on list of SampleClass Objects: Rituporno Ghosh\n\nUsing iterator on list of SampleClass Objects: Tapan Sinha\n\nAs we can see, we can traverse a list and find ts objects. Two things I feel should be mentioned here. The two methods of the Iterator class.\n\n1> boolean hasNext() -> It returns true if the collection has an object on the next index on which it is pointing. It do not to the next element.\n\n2> Object next() -> This object returns the value of the index on which it is pointed.\n\nSet does not accept duplicate values. But HashSet might have different type of Objects. But since TreeSet is one of the only two sorted collection, it accepts only one type of data type at each instance.\n\nif we run the following porgram:\n\nWe will get an output like this:\n\nBoolean value returned: true\n\nBoolean value returned: false\n\nBoolean value returned: true\n\nBoolean value returned: false\n\nBoolean value returned: true\n\nObjects in set: a\n\nObjects in set: b\n\nObjects in set: c\n\nBut the below program will throw a runtime exception:\n\nException in thread “main” java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\n at java.lang.Integer.compareTo(Integer.java:52)\n\n at java.util.TreeMap.put(TreeMap.java:568)\n\n at java.util.TreeSet.add(TreeSet.java:255)\n\n at com.setpractice.main.SetPracticeMain.main(SetPracticeMain.java:14)\n\nMaps are sued to store values with unique IDs. Thus a map needs to override the hashCode() as well as equals(Object obj) to retrieve an object. The more efficiently an hashcode is implemented the faster the object will get searched. If the value in a map is changed the search will return null. As even though the key might be same, it will fail in the equals(0bject obj) method. Even if the search algorithm finds the proper(previous or current) hash key, it won’t find the object using equals(Object o).\n\nTreeSet and TreeMap are only two collections which are always sorted and hence ordered. Let us check out the following code. This will give us some idea on the collections, their natural sorting process and an idea on some of their important methods: (We will use TreeSet, but same will happen for TreeMap, only in set we cannot have duplicate values, but TreeMap will duplicates)\n\nThe output of the above program will be:\n\nTreeSet poll first: 100\n\nTree Set after poll first: [200, 300, 400, 500, 600, 650, 700, 750, 800, 900]\n\nTreeSet poll first: 900\n\nTree Set after poll last: [200, 300, 400, 500, 600, 650, 700, 750, 800]\n\nWe can see a lot of things here.\n\n1> Even though the original values were not sorted or ordered, the TreeSet by itself used natural sorting and the output came in sorted order\n\n2> We can search and find an object in the collection. Like here we used to display the first and the last object.\n\n3> We used subSet, which took a min value and a max value and returned a subset of the original TreeSet.\n\n4>We used ceiling/floor and higher/lower method with same values but got different outputs. Why? As lower gives the elements less than the given element, whereas floor gives less than or equal to the value of the given element. Similarly higher gives the value grater thean the given element and ceiling returns equal or greater than the given value, whichever is available.\n\n5> We used descending order order iterator. As the name suggest it iterates over the values but in the descending order and returns them.\n\n6> We also used pollFirst() and pollLast() method. Both them returned us the required value but at the same time they also remove the values from the Tree.\n\nTreeMap has similar methods works exactly same, only differences are in some cases the names of them.\n\nSome classes in java.util package supports the concept of “Backed Collection”. Backed collection are not the copy of of the original collection, but a part of it. We can check the below code and get an idea of it.\n\nThe output of the program is:\n\nOriginal map after pollFirstEntry: {b=bat, c=cat, d=dog, e=elephant, f=fling, g=goat, h=hippopotamus, i=igloo, j=jungle, k=karate}\n\nSorted submap after pollFirstEntry on original map: {b=bat, c=cat, d=dog, e=elephant, f=fling, g=goat}\n\nHere we see we have an original TreeMap and a subMap i.e. a part of it. Both displayed their respective values at first. Later we added more values to one of it and it also got reflected in the other one. Thus basically though we have two reference variables and it seems we have two collections, basically it is the same object we are referring to.\n\nSo when one object got changed the other also gives the same output as the Objects are basically same. If a new entry is added to the original which is out of range of the subset we might not see it, but if we increase the range of the subset we can see the change. Backed Collection works this way.\n\nHope this article gives you an idea about Java generics and collections. Feel free to comment if you have and queries or face any issues. So long, good luck and happy coding.\n\nFirst of all my parents, family and friends for their unconditional support\n\n6> My employers and the projects they assigned to me."
    },
    {
        "link": "https://protechtraining.com/bookshelf/java_fundamentals_tutorial/generics_collections",
        "document": "\n• None is the root interface in the collections hierarchy.\n• Primitive types (e.g., ) must be boxed (e.g., Integer) for inclusion in a collection. The Collection interface does not say anything about:\n• whether they can be duplicated\n• whether they can be\n• the types of elements they can contain This interface is typically used to pass collections around and manipulate them in the most generic way.\n• Java provides several classes that implement the List interface.\n• None Two are used most commonly: An ArrayList is usually your best bet for a List if the values remain fairly static once you’ve created the list. It’s more efficient than a LinkedList for random access. A LinkedList provides better performance than an ArrayList if you’re frequently inserting and deleting elements, especially from the middle of the collection. But it’s slower than an ArrayList for random-access. In the following example, notice the use of the static method, which does an in-place sort of the elements in a List: package util; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; /** * This program reads arguments passed to it from the command-line * or the lines from STDIN, sorts them, and writes the result to STDOUT. */ public class Sort { public static void main(String[] args) throws IOException { if (args.length > 0) { Arrays.sort(args); for (int i = 0; i < args.length; i++) { System.out.println(args[i]); } } else { List lines = new ArrayList(); BufferedReader reader = new BufferedReader(new InputStreamReader( System.in)); String line = null; while ((line = reader.readLine()) != null) { lines.add(line); } Collections.sort(lines); for (Iterator i = lines.iterator(); i.hasNext();) { System.out.println(i.next()); } } } }\n• None The Java Collections Framework was designed to handle objects of any type.\n• In Java 1.4 and earlier they used Object as the type for any object added to the collection.\n• None You had to explicitly cast the objects to the desired type when you used them or else you would get compile-time errors.\n• Worse yet, if you were dealing with a collection of objects, say of type Dog, and then accidentally added an object of an incompatible type, say a Cat, your code could eventually try to cast the object to the incompatible type, resulting in a runtime exception. Java arrays actually have a similar polymorphism problem that can result in runtime exceptions: package com.markana.demo; abstract class Animal { abstract public void speak(); public void identify() { System.out.println(\"I'm an animal.\"); } } class Dog extends Animal { @Override public void speak() { System.out.println(\"woof\"); } @Override public void identify() { System.out.println(\"I'm a Dog.\"); } } class Cat extends Animal { @Override public void speak() { System.out.println(\"meow\"); } @Override public void identify() { System.out.println(\"I'm a Cat.\"); } } package com.markana.demo; /** Demonstration that arrays are not completely type-safe * @author Ken Jones * */ public class ArrayTypeError { public static void main(String[] args) { // Create an array of three anonymous dogs Dog[] kennel = { new Dog(), new Dog(), new Dog()}; // Let them all speak for (Dog d: kennel) d.speak(); // Dogs are Objects, so this should work Object[] things = kennel; /* A Cat is an Object, so we should be able to add one to the * things array. Note that the following does NOT cause a * compiler error! Instead it throws a RUNTIME exception, * ArrayStoreException. */ things[0] = new Cat(); } }\n• None What can be confusing about generics when you start to use them is that collections of a type are not polymorphic on the type.\n• That is, you can assign a to a reference variable of type (and by extension, pass a as an argument to a method whose parameter is type ); it results in a compiler error.\n• Why? If allowed, we could then add objects of an incompatible type to the collection through the more “generic” typed reference variable.\n• None So if you define a to accept a parameter typed , you can pass only collections as arguments.\n• Even if Employee is a subclass of Person, a can’t be assigned to a . Here’s an illustration of how type parameters are not polymorphic for collections: package com.markana.demo; import java.util.*; public class GenericsTypeError { public static void main( String[] args) { // Create a List of Dog objects List<Dog> kennel = new ArrayList<Dog>(); // Adding a Dog is no problem kennel.add( new Dog() ); // The following line results in a compiler error List<Object> objs = kennel; // Because if it were allowed, we could do this objs.add( new Cat() ); // And now we've got a Cat in our List of Dogs } }\n• None The type parameter wildcard is interpreted as “type unknown.”\n• So declaring a variable as means that you can assign a List of any type of object to the reference variable.\n• However, once assigned to the variable, you can’t make any assumptions about the type of the objects in the list.\n• None So defining your method as means that it can accept a List of any type.\n• But when invoked, you can’t make any assumptions as to the type of objects that the list contains.\n• At best, you know that everything can be treated as an Object. package com.markana.demo; import java.util.*; public class GenericsWildcardExample1 { public static void main( String[] args) { // Create a List of Dog objects List<Dog> kennel = new ArrayList<Dog>(); // Adding a Dog is no problem kennel.add( new Dog() ); // The following line compiles without error List<?> objs = kennel; /* * But now we can't make any assumptions about the type of * objects in the objs List. In fact, the only thing that * we can safely do with them is treat them as Objects. * For example, implicitly invoking toString() on them. */ for (Object o: objs) { System.out.println(\"String representation: \" + o); } } }\n• None Declaring a variable or parameter as , says that the list can be of all Person objects, or all objects can be of (the same) subclass of Person.\n• So you can access any existing object in the List as a Person.\n• However, you can’t new objects to the List.\n• The list might contain all Person objects… or Employee objects, or Customer objects, or objects of some other subclass of Person. You’d be in trouble if you could add a Customer to a list of Employees.\n• None\n• means a List of objects of type Employee or some supertype of Employee.\n• So the type is “unknown,” but in this case it could be Employee, Person, or Object.\n• Because you don’t know which, for “read” access the best you can do is use only Object methods.\n• But you can add new Employee objects to the list, because polymorphism allows the Employee to be treated as a Person or Object as well.\n• Both and can be combined with the wildcard type. package com.markana.demo; import java.util.*; public class GenericsWildcardExample2 { public static void main( String[] args) { // Create a List of Dog objects List<Dog> kennel = new ArrayList<Dog>(); // Adding a Dog is no problem kennel.add( new Dog() ); /* * We can assign to objs a reference to any List as long * as it contains objects of type Animal or some subclass * of Animal. */ List<? extends Animal> objs = kennel; /* * Now we know that the objects in the objs List are * all Animals or all the same subclass of Animal. So * we can safely access the existing objects as Animals. * For example, invoking identify() on them. */ for (Animal o: objs) { o.identify(); } /* * However, it would be a compilation error to try to * add new objects to the list through objs. We don't know * what type of objects the List contains. They might be * all Dogs, or all Cats, or all \"generic\" Animals. */ } }\n• None A generic method is one implemented to work with a variety of types.\n• The method definition contains one or more type parameters whose values are determined when the method is .\n• Type parameters are listed within after any access modifiers and before the method return type.\n• You can use any identifier for a type parameter, but single letters like are used most often.\n• None\n• In this example, the object and the objects in the collection must all be the same type.\n• You can use type wildcards, , and in generic method definitions as well. package com.markana.demo; import java.util.*; public class GenericsWildcardExample3 { public static <T> void add1( T obj, Collection<? super T> c) { c.add(obj); } public static <U, T extends U> void add2( T obj, Collection<U> c) { c.add(obj); } public static void main( String[] args) { // Create a List of Cat and Dog objects List<Animal> menagerie = new ArrayList<Animal>(); // Add a Cat and a Dog menagerie.add( new Cat() ); menagerie.add( new Dog() ); // And now let's try using our generic methods to add objects add1( new Cat(), menagerie); add2( new Dog(), menagerie); for (Animal o: menagerie) { o.identify(); } } }"
    },
    {
        "link": "https://download.java.net/java/early_access/panama/docs/api/java.base/java/util/doc-files/coll-overview.html",
        "document": "The primary advantages of a collections framework are that it:\n• Reduces programming effort by providing data structures and algorithms so you don't have to write them yourself.\n• Increases performance by providing high-performance implementations of data structures and algorithms. Because the various implementations of each interface are interchangeable, programs can be tuned by switching implementations.\n• Provides interoperability between unrelated APIs by establishing a common language to pass collections back and forth.\n• Reduces the effort required to learn APIs by requiring you to learn multiple ad hoc collection APIs.\n• Reduces the effort required to design and implement APIs by not requiring you to produce ad hoc collections APIs.\n• Fosters software reuse by providing a standard interface for collections and algorithms with which to manipulate them.\n• Collection interfaces. Represent different types of collections, such as sets, lists, and maps. These interfaces form the basis of the framework.\n• Legacy implementations. The collection classes from earlier releases, and , were retrofitted to implement the collection interfaces.\n• Special-purpose implementations. Implementations designed for use in special situations. These implementations display nonstandard performance characteristics, usage restrictions, or behavior.\n• Wrapper implementations. Add functionality, such as synchronization, to other implementations.\n• Abstract implementations. Partial implementations of the collection interfaces to facilitate custom implementations.\n• Algorithms. Static methods that perform useful functions on collections, such as sorting a list.\n• Infrastructure. Interfaces that provide essential support for the collection interfaces.\n• Array Utilities. Utility functions for arrays of primitive types and reference objects. Not, strictly speaking, a part of the collections framework, this feature was added to the Java platform at the same time as the collections framework and relies on some of the same infrastructure.\n\nThe collection interfaces are divided into two groups. The most basic interface, , has the following descendants:\n\nThe other collection interfaces are based on and are not true collections. However, these interfaces contain collection-view operations, which enable them to be manipulated as collections. has the following offspring:\n\nMany of the modification methods in the collection interfaces are labeled optional. Implementations are permitted to not perform one or more of these operations, throwing a runtime exception ( ) if they are attempted. The documentation for each implementation must specify which optional operations are supported. Several terms are introduced to aid in this specification:\n• Collections that do not support modification operations (such as , and ) are referred to as unmodifiable. Collections that are not unmodifiable are modifiable.\n• Collections that additionally guarantee that no change in the object will be visible are referred to as immutable. Collections that are not immutable are mutable.\n• Lists that guarantee that their size remains constant even though the elements can change are referred to as fixed-size. Lists that are not fixed-size are referred to as variable-size.\n• Lists that support fast (generally constant time) indexed element access are known as random access lists. Lists that do not support fast indexed element access are known as sequential access lists. The marker interface enables lists to advertise the fact that they support random access. This enables generic algorithms to change their behavior to provide good performance when applied to either random or sequential access lists.\n\nSome implementations restrict what elements (or in the case of , keys and values) can be stored. Possible restrictions include requiring elements to:\n• Be of a particular type.\n\nAttempting to add an element that violates an implementation's restrictions results in a runtime exception, typically a , an , or a . Attempting to remove or test for the presence of an element that violates an implementation's restrictions can result in an exception. Some restricted collections permit this usage.\n\nClasses that implement the collection interfaces typically have names in the form of <Implementation-style><Interface>. The general purpose implementations are summarized in the following table:\n\nThe general-purpose implementations support all of the optional operations in the collection interfaces and have no restrictions on the elements they may contain. They are unsynchronized, but the class contains static factories called synchronization wrappers that can be used to add synchronization to many unsynchronized collections. All of the new implementations have fail-fast iterators, which detect invalid concurrent modification, and fail quickly and cleanly (rather than behaving erratically).\n\nThe , , , and classes provide basic implementations of the core collection interfaces, to minimize the effort required to implement them. The API documentation for these classes describes precisely how each method is implemented so the implementer knows which methods must be overridden, given the performance of the basic operations of a specific implementation.\n\nApplications that use collections from more than one thread must be carefully programmed. In general, this is known as concurrent programming. The Java platform includes extensive support for concurrent programming. See Java Concurrency Utilities for details.\n\nCollections are so frequently used that various concurrent friendly interfaces and implementations of collections are included in the APIs. These types go beyond the synchronization wrappers discussed previously to provide features that are frequently needed in concurrent programming.\n\nThese concurrent-aware interfaces are available:\n\nThe following concurrent-aware implementation classes are available. See the API documentation for the correct usage of these implementations.\n\nThe main design goal was to produce an API that was small in size and, more importantly, in \"conceptual weight.\" It was critical that the new functionality not seem too different to current Java programmers; it had to augment current facilities, rather than replace them. At the same time, the new API had to be powerful enough to provide all the advantages described previously.\n\nTo keep the number of core interfaces small, the interfaces do not attempt to capture such subtle distinctions as mutability, modifiability, and resizability. Instead, certain calls in the core interfaces are optional, enabling implementations to throw an to indicate that they do not support a specified optional operation. Collection implementers must clearly document which optional operations are supported by an implementation.\n\nTo keep the number of methods in each core interface small, an interface contains a method only if either:\n• It is a truly fundamental operation: a basic operations in terms of which others could be reasonably defined,\n• There is a compelling performance reason why an important implementation would want to override it.\n\nIt was critical that all reasonable representations of collections interoperate well. This included arrays, which cannot be made to implement the interface directly without changing the language. Thus, the framework includes methods to enable collections to be moved into arrays, arrays to be viewed as collections, and maps to be viewed as collections."
    }
]