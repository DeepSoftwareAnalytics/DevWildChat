[
    {
        "link": "https://geeksforgeeks.org/read-a-file-line-by-line-in-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s). In this article, we are going to study reading line by line from a file.\n\nAn iterable object is returned by open() function while opening a file. This final way of reading a file line-by-line includes iterating over a file object in a loop. In doing this we are taking advantage of a built-in Python function that allows us to iterate over the file object implicitly using a for loop in combination with using the iterable object.\n\nA list comprehension consists of brackets containing the expression, which is executed for each element along with the for loop to iterate over each element. Here, we will read the text file and print the raw data including the new line character in another output we removed all the new line characters from the list.\n\nPython readlines() is used to read all the lines at a single go and then return them as each line a string element in a list. This function can be used for small files, as it reads the whole file content to the memory, then split it into separate lines. We can iterate over the list and strip the newline ‘\n\n’ character using strip() function.\n\nUsing Python With statement, the file must be explicitly closed, and forgetting to do so can cause bugs, as changes may not take effect. To prevent this, the statement can be used. It simplifies resource management like file streams, ensuring proper handling and making the code cleaner by automatically closing the file, without needing .\n\nHow to read lines in a file in Python?\n\nHow to read file line by line using while in Python?\n\nHow to read file line by line using while in Python?\n\nWhat does readline() do in Python?\n\nHow to read a specific portion of a file in Python?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://docs.python.org/3/library/csv.html",
        "document": "The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in RFC 4180. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.\n\nThe module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.\n\nThe module’s and objects read and write sequences. Programmers can also read and write data in dictionary form using the and classes.\n\nThe module defines the following functions: Return a reader object that will process lines from the given csvfile. A csvfile must be an iterable of strings, each in the reader’s defined csv format. A csvfile is most commonly a file-like object or list. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed unless the format option is specified (in which case unquoted fields are transformed into floats). Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. csvfile can be any object with a method. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about dialects and formatting parameters, see the Dialects and Formatting Parameters section. To make it as easy as possible to interface with modules which implement the DB API, the value is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a call. All other non-string data are stringified with before being written. Associate dialect with name. name must be a string. The dialect can be specified either by passing a sub-class of , or by fmtparams keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about dialects and formatting parameters, see section Dialects and Formatting Parameters. Delete the dialect associated with name from the dialect registry. An is raised if name is not a registered dialect name. Return the dialect associated with name. An is raised if name is not a registered dialect name. This function returns an immutable . Return the names of all registered dialects. Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes the new limit. The module defines the following classes: Create an object that operates like a regular reader but maps the information in each row to a whose keys are given by the optional fieldnames parameter. The fieldnames parameter is a sequence. If fieldnames is omitted, the values in the first row of file f will be used as the fieldnames and will be omitted from the results. If fieldnames is provided, they will be used and the first row will be included in the results. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering. If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by restkey (which defaults to ). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with the value of restval (which defaults to ). All other optional or keyword arguments are passed to the underlying instance. If the argument passed to fieldnames is an iterator, it will be coerced to a . Changed in version 3.6: Returned rows are now of type . Changed in version 3.8: Returned rows are now of type . Create an object which operates like a regular writer but maps dictionaries onto output rows. The fieldnames parameter is a of keys that identify the order in which values in the dictionary passed to the method are written to file f. The optional restval parameter specifies the value to be written if the dictionary is missing a key in fieldnames. If the dictionary passed to the method contains a key not found in fieldnames, the optional extrasaction parameter indicates what action to take. If it is set to , the default value, a is raised. If it is set to , extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying instance. Note that unlike the class, the fieldnames parameter of the class is not optional. If the argument passed to fieldnames is an iterator, it will be coerced to a . The class is a container class whose attributes contain information for how to handle doublequotes, whitespace, delimiters, etc. Due to the lack of a strict CSV specification, different applications produce subtly different CSV data. instances define how and instances behave. All available names are returned by , and they can be registered with specific and classes through their initializer ( ) functions like this: The class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name . The class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name . The class defines the usual properties of a CSV file generated on UNIX systems, i.e. using as line terminator and quoting all fields. It is registered with the dialect name . The class is used to deduce the format of a CSV file. The class provides two methods: Analyze the given sample and return a subclass reflecting the parameters found. If the optional delimiters parameter is given, it is interpreted as a string containing possible valid delimiter characters. Analyze the sample text (presumed to be in CSV format) and return if the first row appears to be a series of column headers. Inspecting each column, one of two key criteria will be considered to estimate if the sample contains a header:\n• None the second through n-th rows contain numeric values\n• None the second through n-th rows contain strings where at least one value’s length differs from that of the putative header of that column. Twenty rows after the first row are sampled; if more than half of columns + rows meet the criteria, is returned. This method is a rough heuristic and may produce both false positives and negatives. An example for use: The module defines the following constants: Instructs objects to quote all fields. Instructs objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator. Instructs objects to quote all non-numeric fields. Instructs objects to convert all non-quoted fields to type float. Instructs objects to never quote fields. When the current delimiter occurs in output data it is preceded by the current escapechar character. If escapechar is not set, the writer will raise if any characters that require escaping are encountered. Instructs objects to perform no special processing of quote characters. Instructs objects to quote all fields which are not . This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) field as and to otherwise behave as . Instructs objects to always place quotes around fields which are strings. This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) string as and to otherwise behave as . The module defines the following exception: Raised by any of the functions when an error is detected.\n\nTo make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the class containing various attributes describing the format of the CSV file. When creating or objects, the programmer can specify a string or a subclass of the class as the dialect parameter. In addition to, or instead of, the dialect parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the class. A one-character string used to separate fields. It defaults to . Controls how instances of quotechar appearing inside a field should themselves be quoted. When , the character is doubled. When , the escapechar is used as a prefix to the quotechar. It defaults to . On output, if doublequote is and no escapechar is set, is raised if a quotechar is found in a field. A one-character string used by the writer to escape the delimiter if quoting is set to and the quotechar if doublequote is . On reading, the escapechar removes any special meaning from the following character. It defaults to , which disables escaping. Changed in version 3.11: An empty escapechar is not allowed. The string used to terminate lines produced by the . It defaults to . The is hard-coded to recognise either or as end-of-line, and ignores lineterminator. This behavior may change in the future. A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters. It defaults to . Changed in version 3.11: An empty quotechar is not allowed. Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the QUOTE_* constants and defaults to . When , spaces immediately following the delimiter are ignored. The default is . When , raise exception on bad CSV input. The default is .\n\nThe simplest example of reading a CSV file: The corresponding simplest possible writing example is: Since is used to open a CSV file for reading, the file will by default be decoded into unicode using the system default encoding (see ). To decode a file using a different encoding, use the argument of open: The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file. A slightly more advanced use of the reader — catching and reporting errors: And while the module doesn’t directly support parsing strings, it can easily be done:"
    },
    {
        "link": "https://python-automation-book.readthedocs.io/en/1.0/06_file-handling/01_file.html",
        "document": "Working with files in Python is a common task. It’s important to know how to read and manipulate file contents. This guide will start with the basic method and then explore other ways to read and write files.\n\nReading a file in Python lets you access its contents. Here’s the basic method:\n• None Opening the File: Use the function to open a file. In this example, ‘show_version.txt’ is the file you want to read. If the file is in the same directory as your Python script, just provide the filename. The function returns a file object, which we assign to the variable .\n• None Reading the File: After opening the file, use the method to get its contents. Here, we read the entire file as a string and store it in the variable.\n• None Closing the File: It’s important to close the file after reading it using the method. Not closing the file can cause resource leaks and other issues. Although Python can automatically close the file when the script ends, it’s best practice to close it explicitly. By default, the file is opened in (read) mode, which treats it as a text file. If you need a different mode or want to open a file in binary mode, you can specify it as the second argument to the function.\n\nThere are several ways to read a file in Python, each suited to different needs: The method reads one line at a time and moves the file pointer to the next line. You can use a loop to read each line in sequence. If you need to re-read the file, reset the file pointer to the beginning with . The method reads all the lines of a file into a list, with each line as a separate element. You can also loop directly over the file object. This reads the file line by line without needing or . These are the basic and common techniques for reading a file in Python. Choose the method that best fits your needs. Always remember to close the file when you’re done to manage resources properly and avoid issues.\n\nPython not only lets you read files but also create and modify them. Let’s look at how to write to a file in Python, including opening a file for writing, adding content, and what happens when you write to a file. To write to a file in Python, you need to open it in write mode and use the method to add content. Here’s an example: \"This is the 1st line to write... \"This is the 2nd line to write...\n• None Opening the File for Writing: Use the function to open a file in write mode. In this example, ‘show_version.txt’ is the file you want to write to, and “w” specifies write mode. If the file doesn’t exist, it will be created. If it does exist, its previous contents will be overwritten, so be careful when opening an existing file in write mode.\n• None Writing to the File: Use the method to add content to the file. In this case, we add two lines of text, each followed by a newline character ( ) to separate the lines.\n• None Closing the File: It’s important to close the file after writing to it using the method. Not closing the file can result in incomplete or corrupted data. Writing to a file in Python is a destructive operation when you open a file in write mode. If the file already has content, that content will be overwritten. Only the new content you write will remain.\n\nAppending to a file in Python lets you add new content to an existing file without erasing what’s already there. Here’s how to do it: To append to a file, open it in append mode (“a”) instead of write mode (“w”). Here’s an example:\n• None Opening the File in Append Mode: Use the function to open ‘test_file.txt’ in append mode by specifying “a”. Unlike write mode, append mode doesn’t erase the file’s current contents. It places the file pointer at the end, so new content is added after the existing content.\n• None Writing to the File: Use the method to add new content. In this example, “Hello again” followed by a newline character is written to the file, appending it to the end.\n• None Flushing the Buffer (Optional): It’s a good practice to flush the buffer after writing. The method ensures any pending data is immediately written to the file. This isn’t always necessary, but it helps ensure data is written when expected.\n• None Closing the File: Always close the file when you’re done using the method. This saves the file properly and releases system resources. Appending mode is useful for adding new data to files without deleting existing content. It’s great for maintaining a file’s history or continuously updating its contents. In summary, understanding different file modes like “a” for appending is essential when working with files in Python. It lets you add to files while keeping their existing data intact.\n\nPython makes it easy to work with resources like files that need to be opened and closed properly. This is done using context managers, mainly with the “with” keyword. Let’s see how to use them with files. The “with” statement in Python helps manage resources like files. It opens a file, lets you work with it, and then automatically closes it when you’re done, even if there’s an error. Here’s an example of using “with” to read a file:\n• None Opening the File: The “with” statement opens ‘show_version.txt’ in read mode (“r”) and assigns the file object to .\n• None Performing Operations: Inside the “with” block, you can do things with the file. Here, we read the file’s contents into the variable.\n• None Automatic Closure: The “with” statement ensures the file is automatically closed when you exit the block, even if there’s an error. Using the “with” statement has several benefits:\n• None Clean Code: It makes your code cleaner and easier to read by handling resource management for you.\n• None Resource Management: It ensures the file is always closed properly, even if an error occurs.\n• None Improved Safety: It reduces the risk of forgetting to close a file, which can cause problems.\n• None Simplified Error Handling: It makes error handling easier since you don’t have to worry about closing the file yourself. In summary, context managers with the “with” statement are very useful in Python for managing resources like files. They make your code simpler, safer, and more readable by automatically handling resource cleanup. For more detailed information, you can refer to the official Python documentation: The official documentation provides in-depth information on Python’s file handling, context managers, and more."
    },
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    },
    {
        "link": "https://stackoverflow.com/questions/64879570/sort-list-with-information-from-text-file",
        "document": "You most likely have found a solution now. If not, let me suggest something.\n\nFirst, I made a slight modification to your class: I added a string representation that makes prints more readable:\n\nYou don't need that for the following!\n\nApart from renaming some variables I have made the following adjustments:\n• I converted the second part of the strings to an because I think that's what you actually want ( ).\n• After appending all the data to the list it get's sorted. Lists have a method, but in your case you have to give it some hints on how to sort, since the elements are a new class. The hint is the lambda function given to the optional argument of . It returns for every element of the list the tuple . then actually sorts according to this values. Since the age is first, the sorting looks a it first and the result is an increasing age in the final list. For entries with same age the sorting proceeds in alphabetical order on the names."
    },
    {
        "link": "https://realpython.com/python-sort",
        "document": "Sorting in Python is a fundamental task that you can accomplish using and . The function returns a new sorted list from the elements of any iterable, without modifying the original iterable. On the other hand, the method modifies a list in place and doesn’t return a value. Both methods support customization through optional keyword arguments like and .\n\nBy the end of this tutorial, you’ll understand that:\n• You can sort any iterable with the function.\n• The method sorts the list in place.\n• You sort items in descending order by setting the argument to .\n• The argument accepts a function to customize the sort order.\n\nIn this tutorial, you’ll learn how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python. You’ll need a basic understanding of lists and tuples as well as sets. These are the data structures you’ll be using to perform some basic operations.\n\nIn Python, you can sort iterables with the built-in function. To get started, you’ll work with iterables that contain only one data type. You can use to sort a list in Python. In this example, a list of integers is defined, and then is called with the variable as the argument: The output from this code is a new, sorted list. When the original variable is printed, the initial values are unchanged. This example shows four important characteristics of :\n• You don’t have to define the function. It’s a built-in function that’s available in any standard installation of Python.\n• You’re ordering the values in from smallest to largest when you call . When you pass no additional arguments or parameters, orders the values in in ascending order.\n• You don’t change the original variable because provides sorted output and doesn’t update the original value in place.\n• You get an ordered list as a return value when you call . These points mean that can be used on a list, and the output can immediately be assigned to a variable: In this example, a new variable called now stores the output of the function. You can confirm all of these observations by calling on : Help on built-in function sorted in module builtins: Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. You’ll cover the optional arguments and later in the tutorial. The first parameter of is an iterable. That means that you can use on tuples and sets very similarly: Notice how even though the input was a set and a tuple, the output is a list because returns a new list by definition. The returned object can be cast to a new type if it needs to match the input type. Be careful if attempting to cast the resulting list back to a set, as a set by definition is unordered: When you cast the value to a , it’s unordered, as expected. If you’re curious about how sets work in Python, then you can check out the tutorial Sets in Python. Just like lists, tuples, and sets, strings are also iterables. This means you can sort types as well. The example below shows how iterates through each character in the value passed to it and orders them in the output: Just like before, you can use to iterate through each element of the iterable you pass in. In a string, each element means each character, including spaces. Note: Python sorts strings lexicographically by comparing Unicode code points of the individual characters from left to right. That’s why the uppercase appears before the lowercase . To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python. If you want to sort a sentence by words, then you can use Python’s method: In this example, you use to convert the original sentence into a list of words. Afterward, you sort the list instead of individual characters.\n\nWhen sorting objects in Python, you may run into some unexpected behavior or even errors. In this section, you’ll explore some limitations and gotchas to look out for when using Python’s function. There are data types that can’t be compared to each other using because they’re too different. Python will return an error if you attempt to use on a list containing non-comparable data. In the example below, you have and the integer zero ( ) in the same list. Python doesn’t know how to sort these two types because of their incompatibility: : '<' not supported between instances of 'int' and 'NoneType' This error shows why Python can’t sort the values given to it. It’s trying to put the values in order by using the less than operator ( ) to determine which value is lower in sorting order. You can replicate this error by manually comparing the two values: : '<' not supported between instances of 'NoneType' and 'int' The same is thrown when you try to compare two non-comparable values without using . If the values in the list can be compared without raising a , then the list can be sorted. This prevents sorting iterables with intrinsically unorderable values and producing output that may not make sense. Python can implicitly convert a value to another type. Even though elements in a list look different, Python may able to interpret them as integers and compare them to each other using : Python interprets the Boolean as and as . You can verify that Python considers the integers and equal to and by comparing them manually: If you have a look at the ordered list from before, you can spot another important aspect of sorting called sort stability. In Python, when you sort equal values, they’ll retain their original order in the output. Since the integer comes before in the unsorted list, will appear before in the sorted list. In the example above, you were sorting either single characters or different words. When dealing with a list that contains similar strings, Python sorts shorter strings first: Strings that contain identical values will end up being sorted shortest to longest because the shorter strings lack elements to compare against the longer ones. This doesn’t mean that shorter strings always come first: If the first letter is the same, then will use the second character to determine order, and so on. In the example above, is shorter than . But while traversing through the string to determine how to sort compared to , the second letter of is considered larger than the second letter of . That’s because the letter has a larger Unicode than the letter . You can leverage Python’s function to investigate a character’s Unicode: To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python.\n\nWhen using Python’s function, you can optionally pass in values for the keywords and . This enables you to override the default behavior of and customize the order of the output. As the name suggests, the keyword argument let’s you reverse the order of an iterable. The keyword accepts a Boolean value: The default value of is , which results in the ascending order of items. If you set to , then the sorting will be in descending order. One of the most powerful components of is the keyword argument called . This argument expects a function to be passed to it, and that function will be used on each value in the list being sorted to determine the resulting order. To demonstrate a basic example, let’s assume the requirement for ordering a specific list is the length of the strings in the list, from shortest to longest. You can use the function to return the length of a string, along with the argument: The resulting order is a list with a string order of shortest to longest. The length of each element in the list is determined by and then returned in ascending order. By default, sorting in Python is case sensitive. This means that words starting with an uppercase Z will be sorted before those beginning with lowercase letters because of their Unicode values: You can pass in as the value of to sort strings independently of a character’s case: During sorting, the function passed to is called on each element to determine sort order, but the original values remain in the output. Avoiding Pitfalls When Using With a Argument There are two main limitations to look out for when you’re using functions with the argument. First, the number of required arguments in the function passed to must be exactly one: The example above shows the definition of an addition function that takes two arguments. When that function is used in on a list of numbers, it fails because it’s missing a second argument. Each time is called during the sort, it’s only receiving one element from the list at a time. The second limitation of is that the function used with must be able to handle all the values in the iterable. Here, you have a list of numbers represented as strings to be used in , and is going to attempt to convert them to numbers using : However, if a value in the iterable can’t be cast to an integer, then using as the value for will fail: As long as a string contains a numeric value, Python can convert the string to an integer. Since isn’t a numeric value, you receive a when calling with . The functionality is extremely powerful because it allows you to manipulate the output order using almost any function, whether built-in or user-defined. If the ordering requirement is to order an iterable by each string spelled backwards, then you could define a function that reverses a word. In the example below, you define a function named that reverses the string passed to it. Then, you use as the value of when calling : The slice syntax reverses a string. Each element will have applied to it, and the sorting order will be based on the characters in the reversed version of each word. If two words have the same final letter, the next letter is compared, and so on. As a result, the elements in are sorted based on their ending letters, which is why comes before but after . Instead of writing a standalone function, you can shorten the code and leverage the keyword. With , you can create an anonymous function, commonly refered to as a function. By using , you can define a function inline and use it directly as the value of . Instead of defining and calling , you can accomplish the same result with fewer lines of code: In the example above, the is defined as a . The function takes one argument named . Then, is called on each element and reverses the word. That reversed output is then used for sorting, but the original words are still returned.\n\nSo far, you’ve learned about Python’s function. However, you may have come across a method with a similar name—the method: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. At first glance, the description of looks similar to the output of , which you explored earlier. Before taking a look at the similarities between and , it’s important to first understand their differences. Understanding the Differences Between and The method accomplishes more or less the same thing as the function. But there are four critical differences between and :\n• is a method of the class.\n• can only be used with lists.\n• modifies the order of elements in place. As a method, works with the list instance itself. In other words, you don’t explicitly pass in an iterable as an argument. Have a look at the impacts of these differences in code: When you try calling with a tuple, you get an because only exists for lists. Then, there are some other pretty dramatic differences in how operates compared to in this code example:\n• returns , so the assignment to is and not an ordered list.\n• Calling changes the list in place, and the original order is not maintained in any way. These differences in behavior make and absolutely not interchangeable in code, and they can produce wildly unexpected outcomes if one is used in the wrong way. Using Keywords Arguments With and The method has the same and optional keyword arguments that produce the same robust functionality as . Revisit some examples from before, this time using instead of : Just like when you used , if you set to when calling on a list, then the sorting will be in descending order. When you pass in as the value of , you can sort strings independently of a character’s case: During sorting, the function passed to is being called on each element to determine the sort order. If you want to practice using , then try refactoring the examples from earlier sections with . When doing so, keep in mind that only works with lists.\n\nDeciding When to Use vs If you’re sorting an iterable that isn’t a list, then you must use . But if you’re working with a list, then you can use either or . Generally, if you keep the similarities and differences in mind, then you can use either or . However, there can be situations where it’s important to choose the right tool for the task at hand. Let’s say there’s a 5K race coming up and you need to capture and sort the race data. The data that needs to be captured is the runner’s bib number and the number of seconds it took to finish the race. To keep things tidy, you decide to use a named tuple for convenient access: As the runners cross the finish line, each will be added to a list called . In 5K races, not all runners start at the same time, so the first person to cross the finish line might not actually be the fastest person: # Thousands and Thousands of entries later... Each time a runner crosses the finish line, you add their bib number and total duration in seconds to the list. The top five fastest participants are the winners that get prizes, and the remaining runners will be sorted by fastest time. There are no requirements for multiple types of sorting by various attributes. The list is a reasonable size, and there’s no mention of storing the list somewhere. In other words, you need to sort by and grab the five participants with the lowest duration: You use a in the argument to get the attribute from each runner and sort in place using . After is sorted, you store the first five elements in . Mission accomplished—or so you think! The race director now informs you that every forty-second runner to cross the finish line will receive a free gym bag. That’s a problem! By using , you changed irreversibly. There’s no way to recover the original list of runners in the order they finished and find every forty-second person. In hindsight, you should’ve sorted the runners with and used the same : By using , you can keep the original list of runners intact without overwriting it. This means that you can now find every forty-second person that crosses the finish line: You create the list by leveraging the slice syntax on , which still contains the original order of runners who cross the finish line. If you’re working with important data and there’s even a remote possibility that you might need to recover the original order, then using is not the best option. However, if the data is a copy, unimportant information, or data that can be easily re-created, then can be a fine option."
    },
    {
        "link": "http://stackoverflow.com/questions/29675943/sorting-content-of-a-text-file-in-python-3-x",
        "document": "I would like to sort a text file which contains lines like\n\nI want to sort it as (in the order ascending taking the first element before space's numerical value into consideration)\n\nI was wondering what would be the better way to implement it.\n\nI tried the following:\n\nIt would be nice to know if there is a better way to do it..."
    },
    {
        "link": "https://developers.google.com/edu/python/sorting",
        "document": "The easiest way to sort is with the sorted(list) function, which takes a list and returns a new list with those elements in sorted order. The original list is not changed.\n\nIt's most common to pass a list into the sorted() function, but in fact it can take as input any sort of iterable collection. The older list.sort() method is an alternative detailed below. The sorted() function seems easier to use compared to sort(), so I recommend using sorted().\n\nThe sorted() function can be customized through optional arguments. The sorted() optional argument reverse=True, e.g. sorted(list, reverse=True), makes it sort backwards.\n\nFor more complex custom sorting, sorted() takes an optional \"key=\" specifying a \"key\" function that transforms each element before comparison. The key function takes in 1 value and returns 1 value, and the returned \"proxy\" value is used for the comparisons within the sort.\n\nFor example with a list of strings, specifying key=len (the built in len() function) sorts the strings by length, from shortest to longest. The sort calls len() for each string to get the list of proxy length values, and then sorts with those proxy values.\n\nAs another example, specifying \"str.lower\" as the key function is a way to force the sorting to treat uppercase and lowercase the same:\n\nYou can also pass in your own MyFn as the key function, like this:\n\nFor more complex sorting like sorting by last name then by first name, you can use the itemgetter or attrgetter functions like:\n\nAs an alternative to sorted(), the sort() method on a list sorts that list into ascending order, e.g. list.sort(). The sort() method changes the underlying list and returns None, so use it like this:\n\nThe above is a very common misunderstanding with sort() -- it *does not return* the sorted list. The sort() method must be called on a list; it does not work on any enumerable collection (but the sorted() function above works on anything). The sort() method predates the sorted() function, so you will likely see it in older code. The sort() method does not need to create a new list, so it can be a little faster in the case that the elements to sort are already in a list.\n\nA tuple is a fixed size grouping of elements, such as an (x, y) co-ordinate. Tuples are like lists, except they are immutable and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable). Tuples play a sort of \"struct\" role in Python -- a convenient way to pass around a little logical, fixed size bundle of values. A function that needs to return multiple values can just return a tuple of the values. For example, if I wanted to have a list of 3-d coordinates, the natural python representation would be a list of tuples, where each tuple is size 3 holding one (x, y, z) group.\n\nTo create a tuple, just list the values within parenthesis separated by commas. The \"empty\" tuple is just an empty pair of parenthesis. Accessing the elements in a tuple is just like a list -- len(), [ ], for, in, etc. all work the same.\n\nTo create a size-1 tuple, the lone element must be followed by a comma.\n\nIt's a funny case in the syntax, but the comma is necessary to distinguish the tuple from the ordinary case of putting an expression in parentheses. In some cases you can omit the parenthesis and Python will see from the commas that you intend a tuple.\n\nAssigning a tuple to an identically sized tuple of variable names assigns all the corresponding values. If the tuples are not the same size, it throws an error. This feature works for lists too.\n\nList comprehensions are a more advanced feature which is nice for some cases but is not needed for the exercises and is not something you need to learn at first (i.e. you can skip this section). A list comprehension is a compact way to write an expression that expands to a whole list. Suppose we have a list nums [1, 2, 3, 4], here is the list comprehension to compute a list of their squares [1, 4, 9, 16]:\n\nThe syntax is -- the looks like a regular for-loop, but without the colon (:). The expr to its left is evaluated once for each element to give the values for the new list. Here is an example with strings, where each string is changed to upper case with '!!!' appended:\n\nYou can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.\n\nTo practice the material in this section, try later problems in list1.py that use sorting and tuples (in the Basic Exercises)."
    },
    {
        "link": "https://stackoverflow.com/questions/5627425/what-is-a-good-way-to-handle-exceptions-when-trying-to-read-a-file-in-python",
        "document": "I updated Tim Pietzcker answer, because it uses Python 2 which is not maintained anymore.\n\nI tried to edit the answer first, but I got: edit queue is full, so I could not.\n\nYou should check the errno number of your exception, which helps you narrow down the error\n\nYou should write error and log messages into and not into (default for print), because then you can redirect your error messages into a different file.\n\nYou should return a non-zero exit code (documented here) which is a must if you want to make your python code usable in a Unix environment, such as a shell script:"
    },
    {
        "link": "https://geeksforgeeks.org/python-exception-handling",
        "document": "Python Exception Handling handles errors that occur during the execution of a program. Exception handling allows to respond to the error, instead of crashing the running program. It enables you to catch and manage errors, making your code more robust and user-friendly.\n\nExample: Trying to divide a number by zero will cause an exception.\n\nExplanation: In this example, dividing number by 0 raises a ZeroDivisionError. The try block contains the code that might cause an exception and the except block handles the exception, printing an error message instead of stopping the program.\n• Error : Errors are serious issues that a program should not try to handle. They are usually problems in the code’s logic or configuration and need to be fixed by the programmer. Examples include syntax errors and memory errors.\n• Exception : Exceptions are less severe than errors and can be handled by the program. They occur due to situations like invalid input, missing files or network issues.\n\nExplanation: A syntax error is a coding mistake that prevents the code from running. In contrast, an exception like ZeroDivisionError can be managed during the program’s execution using exception handling.\n\nException handling in Python is done using the try, except, else and finally blocks.\n\ntry, except, else and finally Blocks\n• try Block lets us test a block of code for errors. Python will “try” to execute the code in this block. If an exception occurs, execution will immediately jump to the except block.\n• except Block: enables us to handle the error or exception. If the code inside the try block throws an error, Python jumps to the except block and executes it. We can handle specific exceptions or use a general except to catch all exceptions.\n• else Block: is optional and if included, must follow all except blocks. The else block runs only if no exceptions are raised in the try block. This is useful for code that should execute if the try block succeeds.\n• finally Block: always runs, regardless of whether an exception occurred or not. It is typically used for cleanup operations (closing files, releasing resources).\n• try block asks for user input and tries to divide 100 by the input number.\n• else block runs if no exception occurs, displaying the result.\n• finally block runs regardless of the outcome, indicating the completion of execution.\n\nPython has many built-in exceptions, each representing a specific error condition. Some common ones include:\n\nThe base class for all built-in exceptions. The base class for all non-exit exceptions. Base class for all errors related to arithmetic operations. Raised when a division or modulo operation is performed with zero as the divisor. Raised when a numerical operation exceeds the maximum limit of a data type. Raised when an attribute reference or assignment fails. Raised when a sequence subscript is out of range. Raised when a dictionary key is not found. Raised when an operation runs out of memory. Raised when a local or global name is not found. Raised when an operation or function is applied to an object of inappropriate type. Raised when a function receives an argument of the right type but inappropriate value. Raised when an import statement has issues. Raised when a module cannot be found.\n\nWhen working with exceptions in Python, we can handle errors more efficiently by specifying the types of exceptions we expect. This can make code both safer and easier to debug.\n\nCatching specific exceptions makes code to respond to different exception types differently.\n• None The ValueError is caught because the string “str” cannot be converted to an integer.\n• None If x were 0 and conversion successful, the ZeroDivisionError would be caught when attempting to calculate its inverse.\n\nWe can catch multiple exceptions in a single block if we need to handle them in the same way or we can separate them if different types of exceptions require different handling.\n• None The ValueError is caught when trying to convert “twenty” to an integer.\n• None TypeError might occur if the operation was incorrectly applied to non-integer types, but it’s not triggered in this specific setup.\n• None IndexError would be caught if an index outside the range of the list was accessed, but in this scenario, it’s under control.\n\nHere’s a simple calculation that may fail due to various reasons.\n• None An ArithmeticError (more specific like ZeroDivisionError) might be caught if this were a number-to-number division error. However, TypeError is actually triggered here due to attempting to divide a string by a number.\n• catch-all except: is used to catch the TypeError, demonstrating the risk that the programmer might not realize the actual cause of the error (type mismatch) without more detailed error logging.\n\nWe raise an exception in Python using the raise keyword followed by an instance of the exception class that we want to trigger. We can choose from built-in exceptions or define our own custom exceptions by inheriting from Python’s built-in Exception class.\n• None The function set checks if the age is negative. If so, it raises a ValueError with a message explaining the issue.\n• None This ensures that the age attribute cannot be set to an invalid state, thus maintaining the integrity of the data.\n• Improved program reliability : By handling exceptions properly, you can prevent your program from crashing or producing incorrect results due to unexpected errors or input.\n• Simplified error handling : Exception handling allows you to separate error handling code from the main program logic, making it easier to read and maintain your code.\n• Cleaner code: With exception handling, you can avoid using complex conditional statements to check for errors, leading to cleaner and more readable code.\n• Easier debugging : When an exception is raised, the Python interpreter prints a traceback that shows the exact location where the exception occurred, making it easier to debug your code.\n• Performance overhead: Exception handling can be slower than using conditional statements to check for errors, as the interpreter has to perform additional work to catch and handle the exception.\n• Increased code complexity : Exception handling can make your code more complex, especially if you have to handle multiple types of exceptions or implement complex error handling logic.\n• Possible security risks: Improperly handled exceptions can potentially reveal sensitive information or create security vulnerabilities in your code, so it’s important to handle exceptions carefully and avoid exposing too much information about your program."
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://stackoverflow.com/questions/71837032/python3-file-open-write-exception-handling",
        "document": "You should basically never use a blanket ; always spell out which exception(s) exactly you want to handle.\n\nHere is a refactoring using a context handler, so you can avoid the explicit\n\nThere may be more exceptions you should enumerate; I rattled these off off the top of my head."
    }
]