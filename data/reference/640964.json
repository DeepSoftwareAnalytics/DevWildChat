[
    {
        "link": "https://stackoverflow.com/questions/35488774/how-to-validate-an-input-with-a-4-digit-number",
        "document": "I want to write a program that only accepts a 4-digit input from the user. The problem is that I want the program to accept a number like but not a number like (because it´s not a 4 digit number).\n\nHow can I solve this? This is the code that I´ve wrote so far:\n\nBut if I input 7 to it it will just say Good! The number you wrote was 7"
    },
    {
        "link": "https://stackoverflow.com/questions/74603758/how-to-validate-an-integer-with-python-that-needs-to-be-used-in-calculations",
        "document": "I'm trying to validate that a user input int is numbers only. This has been my most recent try:\n\nWith this, I get the following error:\n\n(I entered a \"g\" to test if it was working) Thanks in advance!"
    },
    {
        "link": "https://101computing.net/number-only",
        "document": "In most of your Python programs you will want to interact with the end-user by asking questions and retrieving user inputs.\n\nTo do so you can use the input() function: e.g.\n\nSometimes you will need to retrieve numbers. Whole numbers (numbers with no decimal place) are called integers. To use them as integers you will need to convert the user input into an integer using the int() function. e.g.\n\nThis line of code would work fine as long as the user enters an integer. If, by mistake, they enter letters or punctuation signs, the conversion into an integer will fail and generate an exception (error) and the program would stop running.\n\nTo validate the user entry and ensure that is a number it is possible to catch this exception when it occurs using the try…except….else block as follows:\n\nSee how we can use this approach to define our own function (called inputNumber()) to ask for a number. This new function can then be used instead of an input() function whenever we expect the user to enter a whole number. This function uses the try…except….else block within a while loop so that it keeps asking the user to enter a number till the user gets it right."
    },
    {
        "link": "https://automatetheboringstuff.com/2e/chapter8",
        "document": "Input validation code checks that values entered by the user, such as text from the input() function, are formatted correctly. For example, if you want users to enter their ages, your code shouldn’t accept nonsensical answers such as negative numbers (which are outside the range of acceptable integers) or words (which are the wrong data type). Input validation can also prevent bugs or security vulnerabilities. If you implement a withdrawFromAccount() function that takes an argument for the amount to subtract from an account, you need to ensure the amount is a positive number. If the withdrawFromAccount() function subtracts a negative number from the account, the “withdrawal” will end up adding money!\n\nTypically, we perform input validation by repeatedly asking the user for input until they enter valid text, as in the following example:\n\nwhile True:\n\n print('Enter your age:')\n\n age = input()\n\n try:\n\n age = int(age)\n\n except:\n\n print('Please use numeric digits.')\n\n continue\n\n if age < 1:\n\n print('Please enter a positive number.')\n\n continue\n\n break\n\n\n\n print(f'Your age is {age}.')\n\nWhen you run this program, the output could look like this:\n\nEnter your age:\n\n five\n\n Please use numeric digits.\n\n Enter your age:\n\n -2\n\n Please enter a positive number.\n\n Enter your age:\n\n 30\n\n Your age is 30.\n\nWhen you run this code, you’ll be prompted for your age until you enter a valid one. This ensures that by the time the execution leaves the while loop, the age variable will contain a valid value that won’t crash the program later on.\n\nHowever, writing input validation code for every input() call in your program quickly becomes tedious. Also, you may miss certain cases and allow invalid input to pass through your checks. In this chapter, you’ll learn how to use the third-party PyInputPlus module for input validation.\n\nPyInputPlus contains functions similar to input() for several kinds of data: numbers, dates, email addresses, and more. If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input just like our code in the previous section did. PyInputPlus also has other useful features like a limit for the number of times it reprompts users and a timeout if users are required to respond within a time limit.\n\nPyInputPlus is not a part of the Python Standard Library, so you must install it separately using Pip. To install PyInputPlus, run pip install --user pyinputplus from the command line. Appendix A has complete instructions for installing third-party modules. To check if PyInputPlus installed correctly, import it in the interactive shell:\n\nIf no errors appear when you import the module, it has been successfully installed.\n\nPyInputPlus has several functions for different kinds of input:\n\ninputStr() Is like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation function to it\n\ninputNum() Ensures the user enters a number and returns an int or float, depending on if the number has a decimal point in it\n\ninputChoice() Ensures the user enters one of the provided choices\n\ninputMenu() Is similar to inputChoice(), but provides a menu with numbered or lettered options\n\ninputBool() Is similar to inputYesNo(), but takes a “True” or “False” response and returns a Boolean value\n\ninputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists\n\ninputPassword() Is like the built-in input(), but displays * characters as the user types so that passwords, or other sensitive information, aren’t displayed on the screen\n\nThese functions will automatically reprompt the user for as long as they enter invalid input:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum()\n\n five\n\n 'five' is not a number.\n\n 42\n\n >>> response\n\n 42\n\nThe as pyip code in the import statement saves us from typing pyinputplus each time we want to call a PyInputPlus function. Instead we can use the shorter pyip name. If you take a look at the example, you see that unlike input(), these functions return an int or float value: 42 and 3.14 instead of the strings '42' and '3.14'.\n\nJust as you can pass a string to input() to provide a prompt, you can pass a string to a PyInputPlus function’s prompt keyword argument to display a prompt:\n\n>>> response = input('Enter a number: ')\n\n Enter a number: 42\n\n >>> response\n\n '42'\n\n >>> import pyinputplus as pyip\n\n >>> response = pyip.inputInt(prompt='Enter a number: ')\n\n Enter a number: cat\n\n 'cat' is not an integer.\n\n Enter a number: 42\n\n >>> response\n\n 42\n\nUse Python’s help() function to find out more about each of these functions. For example, help(pyip.inputChoice) displays help information for the inputChoice() function. Complete documentation can be found at https://pyinputplus.readthedocs.io/.\n\nUnlike Python’s built-in input(), PyInputPlus functions have several additional features for input validation, as shown in the next section.\n\nThe inputNum(), inputInt(), and inputFloat() functions, which accept int and float numbers, also have min, max, greaterThan, and lessThan keyword arguments for specifying a range of valid values. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ', min=4)\n\n Enter num:3\n\n Input must be at minimum 4.\n\n Enter num:4\n\n >>> response\n\n 4\n\n >>> response = pyip.inputNum('Enter num: ', greaterThan=4)\n\n Enter num: 4\n\n Input must be greater than 4.\n\n Enter num: 5\n\n >>> response\n\n 5\n\n >>> response = pyip.inputNum('>', min=4, lessThan=6)\n\n Enter num: 6\n\n Input must be less than 6.\n\n Enter num: 3\n\n Input must be at minimum 4.\n\n Enter num: 4\n\n >>> response\n\n 4\n\nThese keyword arguments are optional, but if supplied, the input cannot be less than the min argument or greater than the max argument (though the input can be equal to them). Also, the input must be greater than the greaterThan and less than the lessThan arguments (that is, the input cannot be equal to them).\n\nBy default, blank input isn’t allowed unless the blank keyword argument is set to True:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ')\n\n Enter num:(blank input entered here)\n\n Blank values are not allowed.\n\n Enter num: 42\n\n >>> response\n\n 42\n\n >>> response = pyip.inputNum(blank=True)\n\n (blank input entered here)\n\n >>> response\n\n ''\n\nUse blank=True if you’d like to make input optional so that the user doesn’t need to enter anything.\n\nBy default, the PyInputPlus functions will continue to ask the user for valid input forever (or for as long as the program runs). If you’d like a function to stop asking the user for input after a certain number of tries or a certain amount of time, you can use the limit and timeout keyword arguments. Pass an integer for the limit keyword argument to determine how many attempts a PyInputPlus function will make to receive valid input before giving up, and pass an integer for the timeout keyword argument to determine how many seconds the user has to enter valid input before the PyInputPlus function gives up.\n\nIf the user fails to enter valid input, these keyword arguments will cause the function to raise a RetryLimitException or TimeoutException, respectively. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(limit=2)\n\n blah\n\n 'blah' is not a number.\n\n Enter num: number\n\n 'number' is not a number.\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.RetryLimitException\n\n >>> response = pyip.inputNum(timeout=10)\n\n 42 (entered after 10 seconds of waiting)\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.TimeoutException\n\nWhen you use these keyword arguments and also pass a default keyword argument, the function returns the default value instead of raising an exception. Enter the following into the interactive shell:\n\n>>> response = pyip.inputNum(limit=2, default='N/A')\n\n hello\n\n 'hello' is not a number.\n\n world\n\n 'world' is not a number.\n\n >>> response\n\n 'N/A'\n\nInstead of raising RetryLimitException, the inputNum() function simply returns the string 'N/A'.\n\nYou can also use regular expressions to specify whether an input is allowed or not. The allowRegexes and blockRegexes keyword arguments take a list of regular expression strings to determine what the PyInputPlus function will accept or reject as valid input. For example, enter the following code into the interactive shell so that inputNum() will accept Roman numerals in addition to the usual numbers:\n\nOf course, this regex affects only what letters the inputNum() function will accept from the user; the function will still accept Roman numerals with invalid ordering such as 'XVX' or 'MILLI' because the r'(I|V|X|L|C|D|M)+' regular expression accepts those strings.\n\nYou can also specify a list of regular expression strings that a PyInputPlus function won’t accept by using the blockRegexes keyword argument. Enter the following into the interactive shell so that inputNum() won’t accept even numbers:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(blockRegexes=[r'[02468]$'])\n\n 42\n\n This response is invalid.\n\n 44\n\n This response is invalid.\n\n 43\n\n >>> response\n\n 43\n\nIf you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list. For example, enter the following into the interactive shell, which allows 'caterpillar' and 'category' but blocks anything else that has the word 'cat' in it:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputStr(allowRegexes=[r'caterpillar', 'category'],\n\n blockRegexes=[r'cat'])\n\n cat\n\n This response is invalid.\n\n catastrophe\n\n This response is invalid.\n\n category\n\n >>> response\n\n 'category'\n\nThe PyInputPlus module’s functions can save you from writing tedious input validation code yourself. But there’s more to the PyInputPlus module than what has been detailed here. You can examine its full documentation online at https://pyinputplus.readthedocs.io/.\n\nYou can write a function to perform your own custom validation logic by passing the function to inputCustom(). For example, say you want the user to enter a series of digits that adds up to 10. There is no pyinputplus.inputAddsUpToTen() function, but you can create your own function that:\n• Accepts a single string argument of what the user entered\n• Raises an exception if the string fails validation\n• Returns (or has no statement) if should return the string unchanged\n• Returns a non- value if should return a different string from the one the user entered\n• Is passed as the first argument to\n\nFor example, we can create our own addsUpToTen() function, and then pass it to inputCustom(). Note that the function call looks like inputCustom(addsUpToTen) and not inputCustom(addsUpToTen()) because we are passing the addsUpToTen() function itself to inputCustom(), not calling addsUpToTen() and passing its return value.\n\n>>> import pyinputplus as pyip\n\n >>> def addsUpToTen(numbers):\n\n ... numbersList = list(numbers)\n\n ... for i, digit in enumerate(numbersList):\n\n ... numbersList[i] = int(digit)\n\n ... if sum(numbersList) != 10:\n\n ... raise Exception('The digits must add up to 10, not %s.' %\n\n (sum(numbersList)))\n\n ... return int(numbers) # Return an int form of numbers.\n\n ...\n\n >>> response = pyip.inputCustom(addsUpToTen) # No parentheses after\n\n addsUpToTen here.\n\n 123\n\n The digits must add up to 10, not 6.\n\n 1235\n\n The digits must add up to 10, not 11.\n\n 1234\n\n >>> response # inputStr() returned an int, not a string.\n\n 1234\n\n >>> response = pyip.inputCustom(addsUpToTen)\n\n hello\n\n invalid literal for int() with base 10: 'h'\n\n 55\n\n >>> response\n\nThe inputCustom() function also supports the general PyInputPlus features, such as the blank, limit, timeout, default, allowRegexes, and blockRegexes keyword arguments. Writing your own custom validation function is useful when it’s otherwise difficult or impossible to write a regular expression for valid input, as in the “adds up to 10” example.\n\nProject: How to Keep an Idiot Busy for Hours\n\nLet’s use PyInputPlus to create a simple program that does the following:\n• Ask the user if they’d like to know how to keep an idiot busy for hours.\n• If the user answers no, quit.\n• If the user answers yes, go to Step 1.\n\nOf course, we don’t know if the user will enter something besides “yes” or “no,” so we need to perform input validation. It would also be convenient for the user to be able to enter “y” or “n” instead of the full words. PyInputPlus’s inputYesNo() function will handle this for us and, no matter what case the user enters, return a lowercase 'yes' or 'no' string value.\n\nWhen you run this program, it should look like the following:\n\nWant to know how to keep an idiot busy for hours?\n\n sure\n\n 'sure' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n yes\n\n Want to know how to keep an idiot busy for hours?\n\n y\n\n Want to know how to keep an idiot busy for hours?\n\n Yes\n\n Want to know how to keep an idiot busy for hours?\n\n YES\n\n Want to know how to keep an idiot busy for hours?\n\n YES!!!!!!\n\n 'YES!!!!!!' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.\n\n 'TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n no\n\n Thank you. Have a nice day.\n\nOpen a new file editor tab and save it as idiot.py. Then enter the following code:\n\nThis imports the PyInputPlus module. Since pyinputplus is a bit much to type, we’ll use the name pyip for short.\n\nwhile True:\n\n prompt = 'Want to know how to keep an idiot busy for hours?\n\n'\n\n response = pyip.inputYesNo(prompt)\n\nNext, while True: creates an infinite loop that continues to run until it encounters a break statement. In this loop, we call pyip.inputYesNo() to ensure that this function call won’t return until the user enters a valid answer.\n\nThe pyip.inputYesNo() call is guaranteed to only return either the string yes or the string no. If it returned no, then our program breaks out of the infinite loop and continues to the last line, which thanks the user:\n\nOtherwise, the loop iterates once again.\n\nYou can also make use of the inputYesNo() function in non-English languages by passing yesVal and noVal keyword arguments. For example, the Spanish version of this program would have these two lines:\n\nNow the user can enter either sí or s (in lower- or uppercase) instead of yes or y for an affirmative answer.\n\nPyInputPlus’s features can be useful for creating a timed multiplication quiz. By setting the allowRegexes, blockRegexes, timeout, and limit keyword argument to pyip.inputStr(), you can leave most of the implementation to PyInputPlus. The less code you need to write, the faster you can write your programs. Let’s create a program that poses 10 multiplication problems to the user, where the valid input is the problem’s correct answer. Open a new file editor tab and save the file as multiplicationQuiz.py.\n\nFirst, we’ll import pyinputplus, random, and time. We’ll keep track of how many questions the program asks and how many correct answers the user gives with the variables numberOfQuestions and correctAnswers. A for loop will repeatedly pose a random multiplication problem 10 times:\n\nimport pyinputplus as pyip\n\n import random, time\n\n\n\n numberOfQuestions = 10\n\n correctAnswers = 0\n\n for questionNumber in range(numberOfQuestions):\n\nInside the for loop, the program will pick two single-digit numbers to multiply. We’ll use these numbers to create a #Q: N × N = prompt for the user, where Q is the question number (1 to 10) and N are the two numbers to multiply.\n\nThe pyip.inputStr() function will handle most of the features of this quiz program. The argument we pass for allowRegexes is a list with the regex string '^%s$', where %s is replaced with the correct answer. The ^ and % characters ensure that the answer begins and ends with the correct number, though PyInputPlus trims any whitespace from the start and end of the user’s response first just in case they inadvertently pressed the spacebar before or after their answer. The argument we pass for blocklistRegexes is a list with ('.*', 'Incorrect!'). The first string in the tuple is a regex that matches every possible string. Therefore, if the user response doesn’t match the correct answer, the program will reject any other answer they provide. In that case, the 'Incorrect!' string is displayed and the user is prompted to answer again. Additionally, passing 8 for timeout and 3 for limit will ensure that the user only has 8 seconds and 3 tries to provide a correct answer:\n\ntry:\n\n # Right answers are handled by allowRegexes.\n\n # Wrong answers are handled by blockRegexes, with a custom message.\n\n pyip.inputStr(prompt, allowRegexes=['^%s$' % (num1 * num2)],\n\n blockRegexes=[('.*', 'Incorrect!')],\n\n timeout=8, limit=3)\n\nIf the user answers after the 8-second timeout has expired, even if they answer correctly, pyip.inputStr() raises a TimeoutException exception. If the user answers incorrectly more than 3 times, it raises a RetryLimitException exception. Both of these exception types are in the PyInputPlus module, so pyip. needs to prepend them:\n\nexcept pyip.TimeoutException:\n\n print('Out of time!')\n\n except pyip.RetryLimitException:\n\n print('Out of tries!')\n\nRemember that, just like how else blocks can follow an if or elif block, they can optionally follow the last except block. The code inside the following else block will run if no exception was raised in the try block. In our case, that means the code runs if the user entered the correct answer:\n\nelse:\n\n # This block runs if no exceptions were raised in the try block.\n\n print('Correct!')\n\n correctAnswers += 1\n\nNo matter which of the three messages, “Out of time!”, “Out of tries!”, or “Correct!”, displays, let’s place a 1-second pause at the end of the for loop to give the user time to read it. After the program has asked 10 questions and the for loop continues, let’s show the user how many correct answers they made:\n\ntime.sleep(1) # Brief pause to let user see the result.\n\n print('Score: %s / %s' % (correctAnswers, numberOfQuestions))\n\nPyInputPlus is flexible enough that you can use it in a wide variety of programs that take keyboard input from the user, as demonstrated by the programs in this chapter.\n\nIt’s easy to forget to write input validation code, but without it, your programs will almost certainly have bugs. The values you expect users to enter and the values they actually enter can be completely different, and your programs need to be robust enough to handle these exceptional cases. You can use regular expressions to create your own input validation code, but for common cases, it’s easier to use an existing module, such as PyInputPlus. You can import the module with import pyinputplus as pyip so that you can enter a shorter name when calling the module’s functions.\n\nPyInputPlus has functions for entering a variety of input, including strings, numbers, dates, yes/no, True/False, emails, and files. While input() always returns a string, these functions return the value in an appropriate data type. The inputChoice() function allow you to select one of several pre-selected options, while inputMenu() also adds numbers or letters for quick selection.\n\nAll of these functions have the following standard features: stripping whitespace from the sides, setting timeout and retry limits with the timeout and limit keyword arguments, and passing lists of regular expression strings to allowRegexes or blockRegexes to include or exclude particular responses. You'll no longer need to write your own tedious while loops that check for valid input and reprompt the user.\n\nIf none of the PyInputPlus module’s, functions fit your needs, but you’d still like the other features that PyInputPlus provides, you can call inputCustom() and pass your own custom validation function for PyInputPlus to use. The documentation at https://pyinputplus.readthedocs.io/en/latest/ has a complete listing of PyInputPlus’s functions and additional features. There’s far more in the PyInputPlus online documentation than what was described in this chapter. There’s no use in reinventing the wheel, and learning to use this module will save you from having to write and debug code for yourself.\n\nNow that you have expertise manipulating and validating text, it’s time to learn how to read from and write to files on your computer’s hard drive.\n\n1. Does PyInputPlus come with the Python Standard Library?\n\n2. Why is PyInputPlus commonly imported with import pyinputplus as pyip?\n\n3. What is the difference between inputInt() and inputFloat()?\n\n4. How can you ensure that the user enters a whole number between 0 and 99 using PyInputPlus?\n\n5. What is passed to the allowRegexes and blockRegexes keyword arguments?\n\n6. What does inputStr(limit=3) do if blank input is entered three times?\n\n7. What does inputStr(limit=3, default='hello') do if blank input is entered three times?\n\nFor practice, write programs to do the following tasks.\n\nWrite a program that asks users for their sandwich preferences. The program should use PyInputPlus to ensure that they enter valid input, such as:\n• Using for a bread type: wheat, white, or sourdough.\n• Using for a protein type: chicken, turkey, ham, or tofu.\n• Using to ask if they want cheese.\n• If so, using to ask for a cheese type: cheddar, Swiss, or mozzarella.\n• Using to ask if they want mayo, mustard, lettuce, or tomato.\n• Using to ask how many sandwiches they want. Make sure this number is 1 or more.\n\nCome up with prices for each of these options, and have your program display a total cost after the user enters their selection.\n\nTo see how much PyInputPlus is doing for you, try re-creating the multiplication quiz project on your own without importing it. This program will prompt the user with 10 multiplication questions, ranging from 0 × 0 to 9 × 9. You’ll need to implement the following features:\n• If the user enters the correct answer, the program displays “Correct!” for 1 second and moves on to the next question.\n• The user gets three tries to enter the correct answer before the program moves on to the next question.\n• Eight seconds after first displaying the question, the question is marked as incorrect even if the user enters the correct answer after the 8-second limit.\n\nCompare your code to the code using PyInputPlus in “Project: Multiplication Quiz” on page 196."
    },
    {
        "link": "https://learningdaily.dev/how-to-take-integer-input-in-python-09decb2b129e",
        "document": "Python is an excellent choice for applications because it’s easy to use. In Python programming, one of the fundamental tasks is accepting and processing user inputs, particularly numerical data. A common requirement is to obtain integer inputs that form the basis of many interactive Python applications, from simple calculators to complex data processing systems. This guide explores various scenarios and techniques for effectively capturing integer input in Python, and provides detailed insights to cater to both beginner and experienced programmers.\n\nThe primary technique for recording user inputs, which are inherently read as strings, is the function available in Python. Converting these strings to numbers and ensuring they satisfy specified criteria (such as being positive, falling within a given range, etc.) is an essential skill in Python programming. The function in Python is designed to accept user input, returning whatever the user types as a string. This necessitates the conversion of this string to an integer when numerical input is needed. However, this conversion process can be prone to errors if the input is not a valid integer. This highlights the importance of proper error handling and input validation.\n\nThe foundation of taking integer input in Python starts with understanding the basic process of capturing and converting user input. Imagine a user interacting with a basic calculator application designed to perform arithmetic operations. The application requires the user to input numbers to execute tasks like addition or subtraction. Users might wrongly type a word or a mix of letters and numbers when prompted to enter a number.\n\nThe script below initially captures the input as a string and then attempts to convert it to an integer. If the conversion is successful, the application proceeds with the calculation. This prevents the application from crashing and maintaining a smooth user experience. Such scripts ensure the processing of valid numerical inputs, making them more robust and reliable for everyday use.\n• This line stores the input as a string in the variable .\n• The function is used to convert the string to an integer.\n• This line is wrapped in a block to catch any exceptions that might occur during conversion.\n• This catches a when the conversion fails (e.g., if the input is not a numeric string).\n• Prompt for correct input on error: print(\"This is not an integer. Please enter a valid integer.\")\n• This informs the user of the incorrect input and prompts for a valid integer.\n\nOutput: This is not an integer. Please enter a valid integer.\n\nIn many applications, such as when counting objects, specifying age, or setting up quantities in a transaction, negative numbers or zero may not be valid. One such application might be an educational application designed for young learners to practice math problems. Here, it is required that the input should be a positive integer, as zero or negative numbers would not make sense in this context.\n\nThe provided script is designed to handle such cases. It initially receives the input as a string and then attempts to convert it into an integer. The script checks if the number is positive if this conversion is successful. In the case of a positive integer, the script accepts the input that can be used to allow the app to generate the specified number of math problems.\n\nThis type of script ensures the integrity of user input and maintains the logical flow of the application, enhancing its usability and reliability. These can be used in various applications, such as an educational app.\n• This validates that the entered integer is greater than zero, indicating a positive number.\n• This informs the user if the entered number is not positive and requests a new input.\n• This catches and handles cases where the input is not convertible to an integer.\n\nOutput: This is not an integer. Please enter a valid integer.\n\nCertain applications require input within a specific range, such as setting thresholds, defining age limits, or specifying dimensions within acceptable limits. Consider, for instance, an online registration form for a community sports league. This form might require participants to enter their age to ensure eligibility, with the league being open only to individuals within a certain age range, say 18 to 40 years old. In this scenario, the input must not only be a valid integer but also fall within the specified age range. The script below checks whether the age falls within the 18 to 40 years range. If the age is within this range, the script acknowledges the valid input, allowing the registration process to proceed.\n\nHowever, if the entered age is outside this range or the input is not a valid integer, the script informs the participant of the invalid entry.\n\nThis type of functionality is useful in applications like sports league registration, ensuring that only eligible individuals can register. It helps maintain the specific requirements, enhancing the application’s overall efficiency and user experience.\n\nInput: 5\n\nOutput: Please enter an integer within the range of 18 to 40.\n• This sets the lower and upper boundaries for the input.\n• This validates whether the input exists within the defined range.\n\nOutput: Please enter an integer within the range of 18 to 40.\n\nOutput: This is not an integer. Please enter a valid integer.\n\nCollecting a sequence of integers from the user is necessary in many practical situations. These situations might include conducting surveys, recording measurements, or documenting multiple financial transactions. Each of these integers is crucial in ensuring accurate data collection and processing. Consider the example of a scientific research survey where participants are asked to input three different data points:\n• The number of hours they sleep daily\n• The number of steps they take on average daily\n\nEach of these inputs needs to be an integer to ensure the accuracy and reliability of the data collected for the study. The script provided is tailored to meet such requirements. It begins by setting , indicating that three separate integer inputs are needed. Once a valid integer is entered, it’s appended to the numbers list, and the script moves on to the next input. After all three integers are collected, the script concludes by displaying the entered integers. This method is highly effective in scenarios requiring multiple integer inputs, as it ensures each input is valid before proceeding to the next, therefore maintaining the integrity and accuracy of the data collected.\n\nThis approach may be used in applications like surveys and data entry systems, where precise and valid numerical inputs are required.\n\nOutput: Traceback (most recent call last):\n\n File “/usercode/main.py”, line 7, in <module>\n\n number = int(input())\n\nEOFError: EOF when reading a line\n• This defines how many integers the program should collect.\n• This iterates to capture the specified number of integers.\n\nHandling integer input in Python is critical for creating interactive and user-friendly applications. This blog has thoroughly explored various scenarios, from basic integer input to complex validations such as ensuring positivity, checking ranges, and collecting multiple integers. It is possible to ensure that our Python programs are robust, user-friendly, and capable of properly managing various user input scenarios once we have a solid understanding of these strategies and include them in our programming. In applications that are implemented in the real world, the capability to reliably process and validate user input is mandatory. It ensures that the collected data is accurate. It also enhances the overall user experience by supporting users in overcoming input errors and ensuring that the integrity of the application is maintained.\n\nOur journey as a Python programmer will be considerably facilitated by developing these skills. It will enable us to design more dynamic, efficient, and dependable programs.\n\nFor further advancement in Python programming, explore the array of specialized courses on the Educative platform listed below:\n• Mastering the Art of Programming in Python 3\n\nThese courses are designed to enhance your Python skills, covering a spectrum from basic principles to more intricate concepts. You’ll have the opportunity to deepen your understanding of Python and its diverse applications and gain valuable skills essential for your professional growth. Begin your journey toward Python mastery by enrolling in these Educative courses today!"
    },
    {
        "link": "https://geeksforgeeks.org/what-is-a-modulo-operator-in-python",
        "document": "Modulo operator (%) in Python gives the remainder when one number is divided by another. Python allows both integers and floats as operands, unlike some other languages. It follows the Euclidean division rule, meaning the remainder always has the same sign as the divisor. It is used in finding even/odd numbers, cyclic patterns, and leap year calculations. The divmod(a, b) function can also be used to\n\n10 % 4 gives 2 because 10 divided by 4 leaves a remainder of 2.\n\nHere, a is divided by b, and the remainder of that division is returned.\n\nStores the remainder obtained when dividing a by b, in c\n\nStores the remainder obtained when dividing d by e, in f. For more examples, refer to How to Perform Modulo with Negative Values in Python.\n\nExample using the Modulo Operator\n\nSuppose, we want to calculate the remainder of every number from 1 to n when divided by a fixed number k.\n\nThe only Exception you get with the Python modulo operation is ZeroDivisionError. This happens if the divider operand of the modulo operator becomes zero. That means the right operand can’t be zero. Let’s see the following code to know about this Python exception.\n\nWhat is the Modulo Operator Used For in Python?\n\nHow to Apply the Modulo Operator to Different Data Types in Python?\n\nWhat Are Typical Use Cases for the Modulo Operator in Python?\n\nHow Does the Modulo Operator Handle Negative Numbers?\n\nIs the Modulo Operator Applicable to Floating-Point Numbers in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/39283112/division-modulo-operator",
        "document": "I just started learning how to code, and I've been assigned a problem that I've been stuck on for many hours now and was hoping I could receive some hints at the very least to solve the problem. The main point of this exercise is to practice division and modulus. We can use basic statements, but nothing fancy like conditionals or anything since we haven't gotten to that point.\n\nI need a user to input a # from 1 - 25, and then my program will let them know which unit and row that number is in. I've managed to get the code working for the rows, but I cannot figure out how to get the unit number.\n\nI've tried a lot of things for unit, but none of them worked out, so I left it blank. I would appreciate any hints that anyone can give me. Thank you for any help.\n\nEdit: I realized that I should try and at least show which ideas I've tried. If I do a regular modulo with # % 5, that works for everything but the multiples of 5 all the way on the right. I've also tried implementing the row #'s each # has but haven't gotten anywhere with that either. I've also tried something similar by dividing by a decimal, casting it as an int, then using modulo but failed, etc., etc.\\"
    },
    {
        "link": "https://realpython.com/python-modulo-operator",
        "document": "Python supports a wide range of arithmetic operators that you can use when working with numbers in your code. One of these operators is the modulo operator ( ), which returns the remainder of dividing two numbers.\n• How to use the Python modulo operator with different numeric types\n• How Python calculates the results of a modulo operation\n• How to override in your classes to use them with the modulo operator\n• How to use the Python modulo operator to solve real-world problems\n\nThe Python modulo operator can sometimes be overlooked. But having a good understanding of this operator will give you an invaluable tool in your Python tool belt.\n\nThe term modulo comes from a branch of mathematics called modular arithmetic. Modular arithmetic deals with integer arithmetic on a circular number line that has a fixed set of numbers. All arithmetic operations performed on this number line will wrap around when they reach a certain number called the modulus. A classic example of modulo in modular arithmetic is the twelve-hour clock. A twelve-hour clock has a fixed set of values, from 1 to 12. When counting on a twelve-hour clock, you count up to the modulus 12 and then wrap back to 1. A twelve-hour clock can be classified as “modulo 12,” sometimes shortened to “mod 12.” The modulo operator is used when you want to compare a number with the modulus and get the equivalent number constrained to the range of the modulus. For example, say you want to determine what time it would be nine hours after 8:00 a.m. On a twelve-hour clock, you can’t simply add 9 to 8 because you would get 17. You need to take the result, 17, and use to get its equivalent value in a twelve-hour context: returns . This means that nine hours past 8:00 a.m. is 5:00 p.m. You determined this by taking the number and applying it to a context. Now, if you think about it, and are equivalent in a context. If you were to look at the hour hand at 5:00 and 17:00, it would be in the same position. Modular arithmetic has an equation to describe this relationship: This equation reads “ and are congruent modulo .” This means that and are equivalent in as they have the same remainder when divided by . In the above equation, is the modulus for both and . Using the values and from before, the equation would look like this: This reads “ and are congruent modulo .” and have the same remainder, , when divided by . So in , the numbers and are equivalent. You can confirm this using division: Both of the operations have the same remainder, , so they’re equivalent modulo . Now, this may seem like a lot of math for a Python operator, but having this knowledge will prepare you to use the modulo operator in the examples later in this tutorial. In the next section, you’ll look at the basics of using the Python modulo operator with the numeric types and .\n\nThe modulo operator, like the other arithmetic operators, can be used with the numeric types and . As you’ll see later on, it can also be used with other types like , , and your own classes. Most of the time you’ll use the modulo operator with integers. The modulo operator, when used with two positive integers, will return the remainder of standard Euclidean division: Be careful! Just like with the division operator ( ), Python will return a if you try to use the modulo operator with a divisor of : ZeroDivisionError: integer division or modulo by zero Next, you’ll take a look at using the modulo operator with a . Similar to , the modulo operator used with a will return the remainder of division, but as a value: An alternative to using a with the modulo operator is to use to perform modulo operations on values: The official Python docs suggest using over the Python modulo operator when working with values because of the way calculates the result of the modulo operation. If you’re using a negative operand, then you may see different results between and . You’ll explore using the modulo operator with negative operands in more detail in the next section. Just like other arithmetic operators, the modulo operator and may encounter rounding and precision issues when dealing with floating-point arithmetic: If maintaining floating-point precision is important to your application, then you can use the modulo operator with . You’ll look at this later in this tutorial. All modulo operations you’ve seen up to this point have used two positive operands and returned predictable results. When a negative operand is introduced, things get more complicated. As it turns out, the way that computers determine the result of a modulo operation with a negative operand leaves ambiguity as to whether the remainder should take the sign of the dividend (the number being divided) or the sign of the divisor (the number by which the dividend is divided). Different programming languages handle this differently. For example, in JavaScript, the remainder will take the sign of the dividend: The remainder in this example, , is positive since it takes the sign of the dividend, . In Python and other languages, the remainder will take the sign of the divisor instead: Here you can see that the remainder, , takes the sign of the divisor, . You may be wondering why the remainder in JavaScript is and the remainder in Python is . This has to do with how different languages determine the outcome of a modulo operation. Languages in which the remainder takes the sign of the dividend use the following equation to determine the remainder: There are three variables this equation: in this equation means that it uses truncated division, which will always round a negative number toward zero. For more clarification, see the steps of the modulo operation below using as the dividend and as the divisor: Here you can see how a language like JavaScript gets the remainder . Python and other languages in which the remainder takes the sign of the divisor use the following equation: in this equation means that it uses floor division. With positive numbers, floor division will return the same result as truncated division. But with a negative number, floor division will round the result down, away from zero: Here you can see that the result is . Now that you understand where the difference in the remainder comes from, you may be wondering why this matters if you only use Python. Well, as it turns out, not all modulo operations in Python are the same. While the modulo used with the and types will take the sign of the divisor, other types will not. You can see an example of this when you compare the results of and : takes the sign of the dividend using truncated division, whereas uses the sign of the divisor. Later in this tutorial, you’ll see another Python type that uses the sign of the dividend, . Python has the built-in function , which internally uses the modulo operator. takes two parameters and returns a tuple containing the results of floor division and modulo using the supplied parameters. Below is an example of using with and : You can see that returns the tuple . The is the result of the floor division of and . The is the result of modulo . Below is an example in which the second parameter is a negative number. As discussed in the previous section, when the modulo operator is used with an , the remainder will take the sign of the divisor: -3 # Result has the sign of the divisor Now that you’ve had a chance to see the modulo operator used in several scenarios, it’s important to take a look at how Python determines the precedence of the modulo operator when used with other arithmetic operators. Like other Python operators, there are specific rules for the modulo operator that determine its precedence when evaluating expressions. The modulo operator ( ) shares the same level of precedence as the multiplication ( ), division ( ), and floor division ( ) operators. Take a look at an example of the modulo operator’s precedence below: Both the multiplication and modulo operators have the same level of precedence, so Python will evaluate them from left to right. Here are the steps for the above operation: If you want to override the precedence of other operators, then you can use parentheses to surround the operation you want to be evaluated first: In this example, is evaluated first, followed by and finally , which equals .\n\nNow that you’ve gone through the basics of the Python modulo operator, you’ll look at some examples of using it to solve real-world programming problems. At times, it can be hard to determine when to use the modulo operator in your code. The examples below will give you an idea of the many ways it can be used. How to Check if a Number Is Even or Odd In this section, you’ll see how you can use the modulo operator to determine if a number is even or odd. Using the modulo operator with a modulus of , you can check any number to see if it’s evenly divisible by . If it is evenly divisible, then it’s an even number. Take a look at which checks to see if the parameter is even: Here will equal if is even and if is odd. Checking against will return a Boolean of or based on whether or not is even. Checking for odd numbers is quite similar. To check for an odd number, you invert the equality check: This function will return if does not equal , meaning that there’s a remainder proving is an odd number. Now, you may be wondering if you could use the following function to determine if is an odd number: The answer to this question is yes and no. Technically, this function will work with the way Python calculates modulo with integers. That said, you should avoid comparing the result of a modulo operation with as not all modulo operations in Python will return the same remainder. You can see why in the following examples: In the second example, the remainder takes the sign of the negative divisor and returns . In this case, the Boolean check would return . However, if you compare the modulo operation with , then it doesn’t matter which operand is negative. The result will always be when it’s an even number: If you stick to comparing a Python modulo operation with , then you shouldn’t have any problems checking for even and odd numbers or any other multiples of a number in your code. In the next section, you’ll take a look at how you can use the modulo operator with loops to control the flow of your program. How to Run Code at Specific Intervals in a Loop With the Python modulo operator, you can run code at specific intervals inside a loop. This is done by performing a modulo operation with the current index of the loop and a modulus. The modulus number determines how often the interval-specific code will run in the loop. This code defines , which takes two parameters. is a list of names that should be split into rows. sets a modulus for the operation, effectively determining how many names should be in each row. will loop over and start a new row after it hits the value. Before breaking down the function in more detail, take a look at it in action: As you can see, the list of names has been split into three rows, with a maximum of three names in each row. defaults to , but you can specify any number: Now that you’ve seen the code in action, you can break down what it’s doing. First, it uses to iterate over , assigning the current item in the list to and a count value to . You can see that the optional argument for is set to . This means that the count will start at instead of : Next, inside the loop, the function calls to output to the current row. The parameter for is an empty string ( ) so it won’t output a newline at the end of the string. An f-string is passed to , which uses the string output formatting syntax that Python provides: Without getting into too much detail, the syntax tells to do the following:\n• Output at least characters, even if the string is shorter than 15 characters.\n• Fill any space on the right or left of the string with the hyphen character ( ). Now that the name has been printed to the row, take a look at the main part of : This code takes the current iteration and, using the modulo operator, compares it with . If the result equals , then it can run interval-specific code. In this case, the function calls to add a newline, which starts a new row. The above code is only one example. Using the pattern allows you to run different code at specific intervals in your loops. In the next section, you’ll take this concept a bit further and look at cyclic iteration. Cyclic iteration describes a type of iteration that will reset once it gets to a certain point. Generally, this type of iteration is used to restrict the index of the iteration to a certain range. You can use the modulo operator to create cyclic iteration. Take a look at an example using the library to draw a shape: The above code uses an infinite loop to draw a repeating star shape. After every six iterations, it changes the color of the pen. The pen size increases with each iteration until is reset back to . If you run the code, then you should get something similar to this: The important parts of this code are highlighted below: Each time through the loop, is updated based on the results of . This new value is used to increase the with each iteration. Once reaches , will equal , and will reset back to . You can see the steps of the iteration below for more clarification: When is reset back to , the changes to a new random color as seen below: The code in this section uses as the modulus, but you could set it to any number to adjust how many times the loop will iterate before resetting the value . In this section, you’ll look at how you can use the modulo operator to convert units. The following examples take smaller units and convert them into larger units without using decimals. The modulo operator is used to determine any remainder that may exist when the smaller unit isn’t evenly divisible by the larger unit. In this first example, you’ll convert inches into feet. The modulo operator is used to get the remaining inches that don’t evenly divide into feet. The floor division operator ( ) is used to get the total feet rounded down: Here’s an example of the function in use: As you can see from the output, returns , which is the remaining inches that weren’t evenly divided into feet. The result of is , which is the total number of feet by which the inches were evenly divided. You can take this a bit further in this next example. takes an integer, , representing a number of minutes and outputs the period of time in days, hours, and minutes: Breaking this down, you can see that the function does the following:\n• Determines the total number of evenly divisible days with , where is the number of minutes in a day\n• Calculates any left over with\n• Uses the to get the evenly divisible and any extra You can see how it works below: While the above examples only deal with converting inches to feet and minutes to days, you could use any type of units with the modulo operator to convert a smaller unit into a larger unit. Note: Both of the above examples could be modified to use to make the code more succinct. If you remember, returns a tuple containing the results of floor division and modulo using the supplied parameters. Below, the floor division and modulo operators have been replaced with : As you can see, returns a tuple, which is unpacked into and . If you try this updated function, then you’ll receive the same results as before: You receive the same outcome, but now the code is more concise. You could update as well: Using , the function is easier to read than the previous version and returns the same result: Using isn’t necessary for all situations, but it makes sense here as the unit conversion calculations use both floor division and modulo. Now that you’ve seen how to use the modulo operator to convert units, in the next section you’ll look at how you can use the modulo operator to check for prime numbers. How to Determine if a Number Is a Prime Number In this next example, you’ll take a look at how you can use the Python modulo operator to check whether a number is a prime number. A prime number is any number that contains only two factors, and itself. Some examples of prime numbers are , , , , , , , , and . The code below is an implementation for determining the primality of a number using the modulo operator: must be greater than or equal to 2 to be prime.\" is not prime. It has the following factors: This code defines , which takes the parameter and checks to see if it’s a prime number. If it is, then a message is displayed stating that is a prime number. If it’s not a prime number, then a message is displayed with all the factors of the number. Note: The above code isn’t the most efficient way to check for prime numbers. If you’re interested in digging deeper, then check out the Sieve of Eratosthenes and Sieve of Atkin for examples of more performant algorithms for finding prime numbers. Before you look more closely at the function, here are the results using some different numbers: 44 is not prime. It has the following factors: [(1, 44), (2, 22), (4, 11)] 115 is not prime. It has the following factors: [(1, 115), (5, 23)] Digging into the code, you can see it starts by checking if is less than . Prime numbers can only be greater than or equal to . If is less than , then the function doesn’t need to continue. It will a message and : must be greater than or equal to 2 to be prime.\" If is greater than , then the function checks if is a prime number. To check this, the function iterates over all the numbers between and the square root of to see if any divide evenly into . If one of the numbers divides evenly, then a factor has been found, and can’t be a prime number. Here’s the main part of the function: There’s a lot to unpack here, so let’s take it step by step. First, a list is created with the initial factors, . This list will be used to store any other factors that are found: Next, starting with , the code increments until it reaches the square root of . At each iteration, it compares with to see if it’s evenly divisible. The code only needs to check up to and including the square root of because it wouldn’t contain any factors above this: Instead of trying to determine the square root of , the function uses a loop to see if . As long as , the loop hasn’t reached the square root of . Inside the loop, the modulo operator checks if is evenly divisible by : If is evenly divisible by , then is a factor of , and a tuple of the factors is added to the list. Once the loop is complete, the code checks to see if any additional factors were found: is not prime. It has the following factors: If more than one tuple exists in the list, then can’t be a prime number. For nonprime numbers, the factors are printed out. For prime numbers, the function prints a message stating that is a prime number. The Python modulo operator can be used to create ciphers. A cipher is a type of algorithm for performing encryption and decryption on an input, usually text. In this section, you’ll look at two ciphers, the Caesar cipher and the Vigenère cipher. The first cipher that you’ll look at is the Caesar cipher, named after Julius Caesar, who used it to secretly communicate messages. It’s a substitution cipher that uses letter substitution to encrypt a string of text. The Caesar cipher works by taking a letter to be encrypted and shifting it a certain number of positions to the left or right in the alphabet. Whichever letter is in that position is used as the encrypted character. This same shift value is applied to all characters in the string. For example, if the shift were , then would shift up five letters to become , would become , and so on. Below you can see the encryption process for the text with a shift of : Decrypting the cipher is done by reversing the shift. Both the encryption and decryption processes can be described with the following expressions, where is the index of the character in the alphabet: This cipher uses the modulo operator to make sure that, when shifting a letter, the index will wrap around if the end of the alphabet is reached. Now that you know how this cipher works, take a look at an implementation: \"Text must be ASCII and contain no numbers.\" This code defines a function called , which has two required parameters and one optional parameter:\n• is the text to be encrypted or decrypted.\n• is the number of positions to shift each letter.\n• is a Boolean to set if should be decrypted. is included so that a single function can be used to handle both encryption and decryption. This implementation can handle only alphabetic characters, so the function first checks that is an alphabetic character in the ASCII encoding: \"Text must be ASCII and contain no numbers.\" The function then defines three variables to store the ASCII characters, the ASCII characters, and the results of the encryption or decryption: Next, if the function is being used to decrypt , then it multiplies by to make it shift backward: Finally, loops over the individual characters in and performs the following actions for each :\n• Check if is lowercase or uppercase.\n• Get the of the in either the or ASCII lists.\n• Add a to this to determine the index of the cipher character to use.\n• Use to make sure the shift will wrap back to the start of the alphabet.\n• Append the cipher character to the string. After the loop finishes iterating over the value, the is returned: \"Text must be ASCII and contain no numbers.\" Now run the code in the Python REPL using the text with a shift of : The encrypted result is . Using this encrypted text, you can run the decryption to get the original text: The Caesar cipher is fun to play around with for an introduction to cryptography. While the Caesar cipher is rarely used on its own, it’s the basis for more complex substitution ciphers. In the next section, you’ll look at one of the Caesar cipher’s descendants, the Vigenère cipher. The Vigenère cipher is a polyalphabetic substitution cipher. To perform its encryption, it employs a different Caesar cipher for each letter of the input text. The Vigenère cipher uses a keyword to determine which Caesar cipher should be used to find the cipher letter. You can see an example of the encryption process in the following image. In this example, the input text is encrypted using the keyword : For each letter of the input text, , a letter from the keyword is used to determine which Caesar cipher column should be selected. If the keyword is shorter than the input text, as is the case with , then the letters of the keyword are repeated until all letters of the input text have been encrypted. Below is an implementation of the Vigenère cipher. As you’ll see, the modulo operator is used twice in the function: \"Text must be uppercase ASCII without numbers.\" You may have noticed that the signature for is quite similar to from the previous section: \"Text must be uppercase ASCII without numbers.\" The main difference is that, instead of a parameter, takes a parameter, which is the keyword to be used during encryption and decryption. Another difference is the addition of . Based on this implementation, can only accept input text that is all uppercase. Like , iterates over each letter of the input text to encrypt or decrypt it: In the above code, you can see the function’s first use of the modulo operator: Here, the value is determined based on an index returned from . This index is used to select a letter from the string, such as from . The modulo operator allows you to use any length keyword regardless of the length of the to be encrypted. Once the index , the index of the character currently being encrypted, equals the length of the keyword, it will start over from the beginning of the keyword. For each letter of the input text, several steps determine how to encrypt or decrypt it:\n• Determine the based on the index of inside .\n• Determine the based on the index of inside .\n• Use and to get the index for the encrypted or decrypted character. Take a look at these steps in the code below: You can see that the indices for decryption and encryption are calculated differently. That’s why is used in this function. This way, you can use the function for both encryption and decryption. After the is determined, you find the function’s second use of the modulo operator: ensures that the of the character doesn’t exceed , thus making sure it stays inside the alphabet. With this index, the encrypted or decrypted character is selected from and appended to . Here’s the full code the Vigenère cipher again: \"Text must be uppercase ASCII without numbers.\" Now go ahead and run it in the Python REPL: Nice! You now have a working Vigenère cipher for encrypting text strings.\n\nIn this final section, you’ll take your modulo operator knowledge to the next level by using it with . You’ll also look at how you can add to your custom classes so they can be used with the modulo operator. Using the Python Modulo Operator With Earlier in this tutorial, you saw how you can use the modulo operator with numeric types like and as well as with . You can also use the modulo operator with from the module. You use when you want discrete control of the precision of floating-point arithmetic operations. Here are some examples of using whole integers with and the modulo operator: Here are some floating-point numbers used with and the modulo operator: All modulo operations with return the same results as other numeric types, except when one of the operands is negative. Unlike and , but like , uses the sign of the dividend for the results. Take a look at the examples below comparing the results of using the modulo operator with standard and values and with : Compared with , will have the same sign, but the precision will be different: As you can see from the above examples, working with and the modulo operator is similar to working with other numeric types. You just need to keep in mind how it determines the sign of the result when working with a negative operand. In the next section, you’ll look at how you can override the modulo operator in your classes to customize its behavior. Using the Python Modulo Operator With Custom Classes The Python data model allows to you override the built-in methods in a Python object to customize its behavior. In this section, you’ll look at how to override so that you can use the modulo operator with your own classes. For this example, you’ll be working with a class. This class will track the amount of time a student has studied. Here’s the initial class: The class is initialized with a parameter and starts with an empty list, , which will hold a list of integers representing minutes studied per session. There’s also , which takes a parameter that should be a list of study sessions to add to . Now, if you remember from the converting units section above, used the Python modulo operator to convert into days, hours, and minutes. You’ll now implement a modified version of that method to see how you can use your custom class with the modulo operator: You can use this function with the class to display the total hours a has studied. Combined with the class above, the code will look like this: If you load this module in the Python REPL, then you can use it like this: The above code prints out the total hours studied. This version of the code works, but it requires the extra step of summing to get before calling . Here’s how you can modify the class to simplify the code: By overriding and , you can use a instance with the modulo operator. Calculating the of is included in the class as well. With these modifications, you can use a instance directly in . As is no longer needed, you can remove it: Now, calling the code in the Python REPL, you can see it’s much more succinct: By overriding , you allow your custom classes to behave more like Python’s built-in numeric types."
    },
    {
        "link": "https://runestone.academy/ns/books/published/thinkcspy/SimplePythonData/OperatorsandOperands.html",
        "document": "Operators are special tokens that represent computations like addition, multiplication and division. The values the operator works on are called operands.\n\nThe following are all legal Python expressions whose meaning is more or less clear:\n\nThe tokens , , and , and the use of parenthesis for grouping, mean in Python what they mean in mathematics. The asterisk ( ) is the token for multiplication, and is the token for exponentiation. Addition, subtraction, multiplication, and exponentiation all do what you expect.\n\nWhen a variable name appears in the place of an operand, it is replaced with the value that it refers to before the operation is performed. For example, what if we wanted to convert 645 minutes into hours. In Python 3, division is denoted by the operator token which always evaluates to a floating point result.\n\nWhat if, on the other hand, we had wanted to know how many whole hours there are and how many minutes remain. To help answer this question, Python gives us a second flavor of the division operator. This version, called integer division, uses the token . It always truncates its result down to the next smallest integer (to the left on the number line).\n\nPay particular attention to the first two examples above. Notice that the result of floating point division is but the result of the integer division is simply . Take care that you choose the correct flavor of the division operator. If you’re working with expressions where you need floating point values, use the division operator . If you want an integer result, use .\n\nThe modulus operator, sometimes also called the remainder operator or integer remainder operator works on integers (and integer expressions) and yields the remainder when the first operand is divided by the second. In Python, the modulus operator is a percent sign ( ). The syntax is the same as for other operators.\n\nIn the above example, 7 divided by 3 is 2 when we use integer division and there is a remainder of 1 when we use the modulus operator.\n\nThe modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by another—if is zero, then is divisible by . Also, you can extract the right-most digit or digits from a number. For example, yields the right-most digit of (in base 10). Similarly yields the last two digits.\n\nFinally, returning to our time example, the remainder operator is extremely useful for doing conversions, say from seconds, to hours, minutes and seconds. If we start with a number of seconds, say 7684, the following program uses integer division and remainder to convert to an easier form. Step through it to be sure you understand how the division and remainder operators are being used to compute the correct values."
    },
    {
        "link": "https://stackoverflow.com/questions/56627393/difference-between-modulus-and-floor-division-in-numpy",
        "document": "One way to think of the difference between modulus and floor division is to use an analogy of a clock face\n\nImagine a hand on this clock. It moves around and points at a number. Let's say a cycle starts (and ends) when the hand points at 12. In this context\n• modulus, %, is where the hand is pointing right now\n• floor division is the number of times the hand has completed a cycle\n\nIn the first cycle when the hand points at 4 the modulus is 4 but the floor division is 0.\n\nIn the second cycle when the hand points at 4 the modulus is still 4 but the floor division is now 1"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/1bqp91y/splitting_a_number_into_its_component_digits",
        "document": "Basically what the title says. I need to write a program that splits a given five digit number into the digits that make it up, in the order in which they appear. For example: 54321\n\nI’ve tried a couple of different things and can’t seem to get it right.\n\nMy teacher suggested using // and % to do it but I don’t know how to apply that.\n\nThank you in advance.\n\nEdit: I don’t know the etiquette for editing posts but I wanted to thank everyone that took the time to answer my question. I managed to come up with a solution thanks to all the tips and explanations. Thank you"
    },
    {
        "link": "https://stackoverflow.com/questions/28056906/how-to-split-up-123456789-into-individual-numbers-using-python",
        "document": "One way is to turn the number into a string first and then map each character digit back to an integer:\n\nThis does the following:\n• None applies the function to each character in this string in turn, turning each one back into an integer value.\n• None a list of these integers is returned."
    },
    {
        "link": "https://geeksforgeeks.org/python-split-a-list-having-single-integer",
        "document": "We are given a list containing a single integer, and our task is to split it into separate digits while keeping the list structure intact. For example, if the input is a = [12345], the output should be [1, 2, 3, 4, 5]. Let’s discuss different methods to do this in Python.\n\nWe can convert the integer to a string, iterate through its characters and convert them back to integers.\n• None The list comprehension iterates through each character, converting it back to an integer.\n\nLet’s explore some more ways and see how we can split a list having single integer in Python.\n\nmap() function can apply int() to each character of the string representation of the number.\n\nUsing for Loop and Integer Division\n\nWe can extract digits manually by repeatedly dividing the number by 10.\n• None The loop extracts digits from right to left using num % 10.\n• None num //= 10 removes the last digit after extracting it.\n• None Since digits are added in reverse order, result.reverse() ensures the correct order.\n• None This method does not use string conversion but is slightly slower than string-based methods.\n\nUsing divmod() for Better Integer Division\n• None divmod(num, 10) returns both the quotient and last digit in one step.\n• None This avoids separate division and modulo operations, making the method more efficient than a standard loop."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/10iw55k/how_to_split_int_into_digits",
        "document": "I want to convert 19 into [1, 9]. I tried split but on a '19' but gives me same '19'."
    },
    {
        "link": "https://medium.com/@alopezmartinez/extracting-digits-from-an-integer-in-python-a-step-by-step-guide-96c9ff98db37",
        "document": "When working with integers in programming, there are times when you need to extract specific digits for calculations or data analysis. In Python, this can be accomplished efficiently using a combination of modulo and integer division. In this article, we’ll explore how to extract any digit from an integer and provide a clear formula for doing so.\n\nTo isolate specific digits within an integer, we can utilize two key operations:\n\n1. Modulo Operation ( ): This operation provides the remainder of a division and can be used to remove digits to the left of the desired digit.\n\n2. Integer Division ( ): This operation discards the fractional part of the division and can be used to remove digits to the right of the desired digit.\n\nTo extract the nth digit from the right of a number, we can use the following formula:\n• is the integer from which you want to extract a digit.\n• is the position of the digit from the right (starting from 0).\n\n- Modulo Operation ( ): Removes digits to the left.\n\n- Integer Division ( ): Removes digits to the right.\n\nLet’s consider a practical example to see how we can extract a specific digit using a slightly different but effective approach. Here’s a code snippet:\n\nFor , this gives us the last three digits of , which is .\n\nThis removes the two rightmost digits, leaving us with the desired digit. \n\nIn this case, results in , which is the 3rd digit from the right.\n\nThe combination of modulo and integer division allows us to extract specific digits efficiently:\n• helps us keep only the digits we are interested in, effectively removing the leftmost digits.\n• then isolates the specific digit by removing the unwanted rightmost digits.\n\nThis method is flexible and can be applied to extract any digit simply by changing the value.\n\nLet’s extract the 3rd digit from the right in the number :\n\nBreakdown:\n\n gives us .\n\n results in , which is the 3rd digit from the right.\n\nThe modulo operation with a power of 10 ( ) isolates the last digits of a number. For example:\n• gives the last digit.\n• gives the last two digits.\n• - gives the last three digits\n\nExtracting digits from an integer in Python can be accomplished efficiently using a combination of modulo and integer division. By mastering the formula:\n\nOne can easily isolate any digit from a number based on its position. This technique is not only useful for mathematical operations but also for data manipulation and analysis. With this knowledge, you can enhance your programming skills and tackle a variety of tasks involving digit extraction.\n\nHere’s a simplified explanation of why we use the formula:\n\nto extract the digit from the number :\n\nStep 1: Isolate the Last Four Digits\n• What It Does: This operation isolates the last four digits of the number. For , returns because it’s less than .\n• What It Does: This divides the result by , effectively shifting the decimal point three places to the left. gives , and using integer division ( ) results in .\n\nFinal Result\n\nThe final output is , which is the leftmost digit of\n• Purpose of the Formula: The formula allows us to extract the leftmost digit of a number by isolating the relevant digits and then shifting them down to get the desired value.\n\nFlexibility: You can adjust the powers of in the modulo and division operations to extract different digits from numbers of varying lengths.\n\nThis approach provides a clear and systematic way to extract specific digits from integers in Python."
    }
]