[
    {
        "link": "https://docs.mql4.com",
        "document": "MetaQuotes Language 4 (MQL4) is a built-in language for programming trading strategies. This language is developed by MetaQuotes Ltd. based on their long experience in the creation of online trading platforms. Using this language, you can create your own Expert Advisors that make trading management automated and are perfectly suitable for implementing your own trading strategies. Besides, using MQL4 you can create your own technical indicators (custom indicators), scripts and libraries. MQL4 contains a large number of functions necessary for analyzing current and previously received quotes, and has built-in basic indicators and functions for managing trade orders and controlling them. The MetaEditor (text editor) that highlights different constructions of MQL4 language is used for writing the program code. It helps users to orientate themselves in the expert system text quite easily. The brief guide contains functions, operations, reserved words, and other language constructions divided into categories, and allows finding the description of every used element of the language. Programs written in MetaQuotes Language 4 have different features and purposes:\n• None is a mechanical trading system linked up to a certain chart. An Expert Advisor starts to run when an event happens that can be handled by it: events of initialization and deinitialization, event of a new tick receipt, a timer event, depth of market changing event, chart event and custom events. \n\n An Expert Advisor can both inform you about a possibility to trade and automatically trade on an account sending orders directly to a trade server. Expert Advisors are stored in\n• None is a technical indicator written independently in addition to those already integrated into the client terminal. Like built-in indicators, they cannot trade automatically and are intended for implementing of analytical functions only.\n• None is a program intended for a single execution of some actions. Unlike Expert Advisors, scripts do not process any actions, except for the start event (this requires the OnStart handler function in a script). Scripts are stored in\n• None is a set of custom functions intended for storing and distributing frequently used blocks of custom programs. Libraries cannot start executing by themselves.\n• None is a source text of the most frequently used blocks of custom programs. Such files can be included into the source texts of Expert Advisors, scripts, custom indicators, and libraries at the compiling stage. The use of included files is more preferable than the use of libraries because of additional burden occurring at calling library functions. \n\n Include files can be stored in the same directory as a source file - in this case the #include directive with double quotes is used. Another place to store include files is terminal_directory\\MQL4\\Include, in this case the #include directive is used with angle brackets."
    },
    {
        "link": "https://docs.mql4.com/function_indices",
        "document": ""
    },
    {
        "link": "https://docs.mql4.com/trading",
        "document": "This is the group of functions intended for managing trading activities. Trading functions can be used in Expert Advisors and scripts. OrderSend(), OrderClose(), OrderCloseBy(), OrderModify(), OrderDelete() trading functions changing the state of a trading account can be called only if trading by Expert Advisors is allowed (the \"Allow live trading\" checkbox is enabled in the Expert Advisor or script properties). Trading can be allowed or prohibited depending on various factors described in the Trade Permission section. Closes an opened order by another opposite opened order Returns close price of the currently selected order Returns close time of the currently selected order Returns comment of the currently selected order Returns calculated commission of the currently selected order Returns amount of lots of the selected order Returns an identifying (magic) number of the currently selected order Modification of characteristics of the previously opened or pending orders Returns open price of the currently selected order Returns open time of the currently selected order Prints information about the selected order in the log Returns profit of the currently selected order The function selects an order for further processing The main function used to open an order or place a pending order Returns the number of closed orders in the account history loaded into the terminal Returns stop loss value of the currently selected order Returns the number of market and pending orders Returns swap value of the currently selected order Returns symbol name of the currently selected order Returns take profit value of the currently selected order Returns ticket number of the currently selected order Returns order operation type of the currently selected order Added the functions for working with orders, deals and positions to conduct trading operations. An order is a request to buy or sell. The order execution leads to a deal resulting in opening, modifying or closing a position. If you develop trading robots, pay attention to the new OrderSendAsync function intended for asynchronous trading operations. This function is executed in less than 1 millisecond (it does not wait till the trade server responds to a sent request) and returns control immediately. Low network costs, high Depth of Market refresh rates and asynchronous order sending accelerate trading operations dozens of times. For intraday systems, the speed of trading operations can be a key factor."
    },
    {
        "link": "https://scribd.com/document/379819613/MQL4-Function-Reference",
        "document": "The document provides a quick reference to functions in include files for Expert Advisor programming in MetaTrader 4. It describes classes like CTrade and CCount that contain functions for opening, closing, and managing trades and orders. It also includes non-class functions for calculating stop losses and take profits, checking order prices, and performing money management calculations."
    },
    {
        "link": "https://docs.mql4.com/trading/ordersend",
        "document": "The main function used to open market or place a pending order. [in] Operation type. It can be any of the Trade operation enumeration. [in] Maximum price slippage for buy or sell orders. [in] Order comment text. Last part of the comment may be changed by server. [in] Order magic number. May be used as user defined identifier. [in] Order expiration time (for pending orders only). [in] Color of the opening arrow on the chart. If parameter is missing or has CLR_NONE value opening arrow is not drawn on the chart. Returns number of the ticket assigned to the order by the trade server or -1 if it fails. To get additional error information, one has to call the GetLastError() function. At opening of a market order (OP_SELL or OP_BUY), only the latest prices of Bid (for selling) or Ask (for buying) can be used as open price. If operation is performed with a security differing from the current one, the MarketInfo() function must be used with MODE_BID or MODE_ASK parameter for the latest quotes for this security to be obtained. Calculated or unnormalized price cannot be applied. If there has not been the requested open price in the price thread or it has not been normalized according to the amount of digits after decimal point, the error 129 (ERR_INVALID_PRICE) will be generated. If the requested open price is fully out of date, the error 138 (ERR_REQUOTE) will be generated independently on the slippage parameter. If the requested price is out of date, but present in the thread, the order will be opened at the current price and only if the current price lies within the range of price+-slippage. StopLoss and TakeProfit levels cannot be too close to the market. The minimal distance of stop levels in points can be obtained using the MarketInfo() function with MODE_STOPLEVEL parameter. In the case of erroneous or unnormalized stop levels, the error 130 (ERR_INVALID_STOPS) will be generated. A zero value of MODE_STOPLEVEL means either absence of any restrictions on the minimal distance for Stop Loss/Take Profit or the fact that a trade server utilizes some external mechanisms for dynamic level control, which cannot be translated in the client terminal. In the second case, GetLastError() can return error 130, because MODE_STOPLEVEL is actually \"floating\" here. At placing of a pending order, the open price cannot be too close to the market. The minimal distance of the pending price from the current market one in points can be obtained using the MarketInfo() function with the MODE_STOPLEVEL parameter. In case of false open price of a pending order, the error 130 (ERR_INVALID_STOPS) will be generated. Applying of pending order expiration time can be disabled in some trade servers. In this case, when a non-zero value is specified in the expiration parameter, the error 147 (ERR_TRADE_EXPIRATION_DENIED) will be generated. On some trade servers, the total amount of open and pending orders can be limited. If this limit has been exceeded, no new order will be opened (or no pending order will be placed) and trade server will return error 148 (ERR_TRADE_TOO_MANY_ORDERS). //+------------------------------------------------------------------+\n\n //| Script program start function |\n\n //+------------------------------------------------------------------+\n\n void OnStart()\n\n {\n\n //--- get minimum stop level\n\n double minstoplevel=MarketInfo(Symbol(),MODE_STOPLEVEL);\n\n Print(\"Minimum Stop Level=\",minstoplevel,\" points\");\n\n double price=Ask;\n\n //--- calculated SL and TP prices must be normalized\n\n double stoploss=NormalizeDouble(Bid-minstoplevel*Point,Digits);\n\n double takeprofit=NormalizeDouble(Bid+minstoplevel*Point,Digits);\n\n //--- place market order to buy 1 lot\n\n int ticket=OrderSend(Symbol(),OP_BUY,1,price,3,stoploss,takeprofit,\"My order\",16384,0,clrGreen);\n\n if(ticket<0)\n\n {\n\n Print(\"OrderSend failed with error #\",GetLastError());\n\n }\n\n else\n\n Print(\"OrderSend placed successfully\");\n\n //---\n\n }"
    },
    {
        "link": "https://book.mql4.com/samples/icustom",
        "document": "When creating a trading strategy a developer often faces the necessity to draw graphically in a security window a certain dependence calculated by a user (programmer). For this purpose MQL4 offers the possibility of creating custom indicators. Custom Indicator is an application program coded in MQL4; it is basically intended for graphical displaying of preliminarily calculated dependences. \n\n \n\n \n\n The main principle underlying custom indicators is passing values of indicator arrays to a client terminal (for drawing indicator lines) via exchange buffers. Buffer is a memory area containing numeric values of an indicator array. MQL4 standard implies the possibility of drawing up to eight indicator lines using one custom indicator. One indicator array and one buffer are brought into correspondence with each indicator line. Each buffer has its own index. The index of the first buffer is 0, of the second one - 1, and so on, the last one has the index 7. Fig. 115 shows how the information from a custom indicator is passed via buffers to a client terminal for drawing indicator lines. \n\n Fig. 115. Passing values of indicator arrays via a buffer to a client terminal. \n\n The general order of building indicator lines is the following: 1. Calculations are conducted in a custom indicator; as a result numeric values are assigned to indicator array elements. 2. Values of indicator array elements are sent to a client terminal via buffers. 3. On the bases of value arrays received from buffers a client terminal displays indicator lines. \n\n \n\n Let's analyze a simple custom indicator that shows two lines - one line is build based on maximal bar prices, the second one uses minimal prices. \n\n Let's analyze in details the indicator parts. In any application program written in MQL4 you can indicate setup parameters that provide the correct program servicing by a client terminal. In this example the head program part (see Program Structure) contains several lines with directives #property . The first directive indicates in what window the client terminal should draw the indicator lines: In MQL4 there are two variants of drawing indicator lines: in the main security window and in a separate window. Main window is the window containing a security chart. In this example parameter indicator_chart_window in #property directory indicates that a client terminal should draw indicator lines in the main window. The next line shows the number of buffers used in the indicator: In the analyzed example two indicator lines are drawn. One buffer is assigned to each buffer, so the total number of buffers is two. The next lines describe colors of the indicator lines. Parameters indicator_color1 and indicator_color2 define color setting for corresponding buffers - in this case for buffers with indexes 0 (Blue) and 1 (Red). Note that figures in parameter names indicator_color1 and indicator_color2 are not buffer indexes. These figures are parts of constant names that are set in accordance with buffers. For each constant color can be set at the discretion of a user. In the next line indicator arrays are declared: The indicator is intended for drawing two indicator lines, so we need to declare two global one-dimension arrays, one for each line. Names of indicator arrays are up to user. In this case array names Buf_0[] and Buf_1[] are used, in other cases other names can be used, for example, Line_1[],Alfa[], Integral[] etc. It is necessary to declare arrays on a global level, because array elements values must be preserved between calls of the special function start(). The described custom indicator is built on the basis of two special functions -init() and start(). The function init() contains the part of code used on the program only once (see Special functions). A very important action is performed in the line: Using the function SetIndexBuffer() a necessary buffer (in this case with the index 0) is put into correspondence with an array (in this case Buf_0). It means for constructing the first indicator line a client terminal will accept data contained in the array Buf_0 using the zero buffer for it. Further the line style is defined: For the zero buffer (0) a client terminal should use the following drawing styles: simple line (DRAW_LINE), solid line (STYLE_SOLID), line width 2. The next two lines contain settings for the second line: Thus, according to the code of the special function init() both indicator lines will be drawn in the main security window. The first one will be a solid blue line with the width 2, the second one is a red dotted line ( STYLE_DOT) of a usual width. Indicator lines can be drawn by other styles as well (see Styles of Indicator Lines). \n\n Values of indicator arrays elements are calculated in the special function start(). To understand correctly the contents of start() code pay attention to the order of indexing bars. The section Arrays describes in details the method of indexing arrays-timeseries. According to this method bar indexing starts from zero. The zero bar is a current yet unformed bar. The nearest bar's index is 1. The next one's is 2 and so on. As new bars appear in a security window, indexes of already formed (history) bars are changed. The new (current, just formed, rightmost) bar gets the zero index, the one to the left of him (that has just fully formed) gets the index 1 and values of indexes of all history bars are also increased by one. The described method of indexing bars is the only one possible for the whole on-line trading system MetaTrader, and it is taken into account when drawing lines using both technical and custom indicators. It was said earlier that indicator lines are constructed on the basis of numeric information contained in indicator arrays. An indicator array contains information about dots coordinates upon which an indicator line is drawn. And the Y coordinate of each dot is the value of an indicator array element, and X coordinate is the value of an indicator array element index. In the analyzed example the first indicator line is drawn using maximal values of bars. Fig, 116 shows this indicator line (of blue color) in a security window, it is built on the basis of the indicator array Buf_0. Fig. 116. Correspondence of coordinates of an indicator line to values of an indicator array. Index value of an indicator array is out by a client terminal into correspondence with a bar index - these index values are equal. It must be also taken into account that the process of constructing indicator lines goes on in real time mode under conditions when in a security window new bars appear from time to time. And all history bars are shifted to the left. To have the indicator line drawn correctly (each line dot above its bar) it must also be shifted together with bars. So there is need (technical need) to re-index an indicator array. The fundamental difference of an indicator array from a usual array is the following: At the moment when a new bar is created, index values of indicator array elements are automatically changed by the client terminal, namely - value of each indicator array index is increased by one and the indicator array size is increased by one element (with a zero index). For example, the zero bar in Fig. 116 (timeframe H1) has the opening time 6:00. At 7:00 a new bar will appear in the security window. The bar opened at 6:00 will automatically get the index 1. To have the indicator line drawn correctly on this bar, the client terminal will change the index of the indicator array element corresponding to the bar opened at 6:00. In the table in Fig. 116 this element is written in the first line. Together with that indexes of all array elements will be increased by the client terminal by one. An the index of the array element corresponding to the bar opened at 6:00 will get the value 1 (before that it was equal to 0). The indicator array will become larger by one element. The index of a new added element will be equal to 0, the value of this element will be a new value reflecting coordinate of the indicator line on a zero bar. This value is calculated in the special function start() on each tick. Calculations in the special function start() should be conducted so that no extra actions were performed. Before the indicator is attached to a chart, it does not reflect any indicator lines (because values of indicator arrays are not defined yet). That's why at the first start of the special function start() indicator array values must be calculated for all bars, on which the indicator line should be drawn. In the analyzed example these are all bars present on a chart (the initial calculations can be conducted not for all available bars, but for some last part of history; it is described in further examples). Ar all further starts of the special function start() there is no need to calculate values of indicator array for all bars again. These values are already calculated and are contained in the indicator array. It is necessary to calculate the current value of the indicator line only on each new tick of the zero bar. For the implementation of the described technology there is a very useful standard function in MQL4 - IndicatorCounted() . This function returns the number of bars that have not changed since the last indicator call. If the indicator has never been attached to a chart, at the first start() execution the value of Counted_bars will be equal to zero: It means the indicator array does not contain any element with earlier predefined value, that is why the whole indicator array must be calculated from beginning to end. The indicator array is calculated from the oldest bar to the zero one. Index of the oldest bar, starting from which calculations must be started, is calculated the following way: Suppose at the moment of attaching the indicator there are 300 bars in a chart window. This is the value of the predefined variable Bars. As defined earlier, Counted_bars is equal to 0. So, as a result we obtain that i index of the first uncounted bar (the latest one, starting from which calculations should be conducted) is equal to 299. All values of indicator array elements are calculated in the loop while(): While i is within the range from the first uncounted bar (299) to the current one (0) inclusively, values of indicator array elements are calculated for both indicator lines. Note, missing values of indicator array elements are calculated during one (the first) start of the special function start(). During calculations the client terminal remembers elements, for which values were calculated. The last iteration in while() is performed when i is equal to 0, i.e. values of indicator arrays are calculated for the zero bar. When the loop is over, the special function start() finishes its execution and control is passed to the client terminal. The client terminal in its turn will draw all (in this case two) indicator lines in accordance with the calculated values of array elements. On the next tick start() will be started by the client terminal again. Further actions will depend on the situation (we will continue analyzing the example for 300 bars). Variant 1. A new tick comes during the formation of the current zero bar (the most common situation). \n\n Fig. 117. The processed tick belongs to the current bar. \n\n Fig. 117 shows two ticks received by the terminal at moments of time t 1 and t 2. The analyzed situation will be the same for both ticks. Let's trace the execution of start() that was launched at the moment t 2. During the execution of the function start() the following line will be executed: IndicatorCounted() will return the value 299, i.e. since the last start() call 299 previous bars were not changed. As a result i index value will be equal to 0 (300-299-1): It means in the next while() loop the values of array elements with the zero index will be calculated. In other words, the new position of an indicator line on the zero bar will be calculated. When the cycle is finished, start() will stop executing and will pass control to the client terminal. Variant 2. A new tick is the first tick of a zero bar (happens from time to time). \n\n Fig. 118. The processed tick is the first tick of a new zero bar. \n\n In this case the fact of appearance of a new bar is important. Before control is passed to the special function start(), client terminal will draw again all bars present in the security window and re-index all declared indicator arrays (set in correspondence with buffers). Besides, client terminal will remember that there are already 301 bars, not 300 in a chart window. Fig. 118 contains situation when on the last tick of the previous bar (at the moment t 2) the function start() was successfully started and executed. That's why, though now the first bar (with index 1) finished at the moment t 2 was calculated by the indicator, function IndicatorCounted() will return value that was on the previous bar, i.e. 299: In the next line index i will be calculated, in this case for the first tick of a new bar it will be equal to 1 (301-299-1): It means calculation of indicator array values in while() loop at the appearance of a new bar will be performed both for the last bar and for the new zero bar. A little earlier during re-indexation of indicator arrays the client terminal increased sizes of these arrays. Values of array elements with zero indexes were not defined before the calculations in the loop. During calculations in the loop these elements get some values. When calculations in start() are over, control is returned to the client terminal. After that the client terminal will draw indicator lines on the zero bar based on just calculated values of array elements with zero indexes. Variant 3. A new tick is the first tick of a new zero bar, but the last but one tick is not processed (rare case). \n\n Fig. 119. Not all ticks of the previous bar were processed. \n\n Fig. 119 shows the situation when start() was launched on the first tick of a new bar at the moment t 5. Previous time this function was started at the moment t 2. Tick that came to the terminal at the moment t 3 (red arrow) was not processed by the indicator. This happened because start() execution time t 2 - t 4 is larger than the interval between ticks t 2 - t 3. This fact will be detected by the client terminal during the execution of start() launched at the moment t 5. During calculations in the line: IndicatorCounted() will return the value 299 (!). This value is true - from the moment of the last indicator call 299 bars were not changed after (now already) 301. That is why the calculated index of the first (leftmost) bar, from which calculations of array element values must be started, will be equal to 1 (301-299-1): it means during while() execution two iterations will be performed. During the first one values of array elements with the index i = 1 will be calculated, i.e. Buf_0[1] and Buf_1[1]. Not, by the moment calculations start, bars and indicator arrays are already re-indexed by the client terminal (because a new bar started, between starts of the special function start()). That is why calculations for elements of arrays with index 1 will be calculated on the basis of array-timeseries (maximal and minimal values of a bar price) also with the index 1: During the second iteration of while() values for elements with zero indexes, i.e. for the zero bar, is calculated on the basis of last known values of arrays-timeseries. Using of the described technology for the calculation of custom indicators allows, first, to guarantee calculation of values of all indicator array elements irrespective of the specific nature of tick history, and second, to conduct calculations only for uncounted bars, i.e. use economically calculating resources. Not, a bar is considered uncounted if calculation of element values of an indicator arrays at least for one last tick of the bar is not performed. Starting the custom indicator userindicator.mq4 in a chart window you will see two lines - a thick blue line built upon bar maximums and a dotted red line built upon its minimums (Fig. 120). \n\n Fig. 120. Two indicator lines in a security window, built by the indicator userindicator.mq4. It should be noted, that one can built a custom indicator, indicator lines of which would coincide with the lines of an analogous technical indicator. It can be easily done if as calculation formulas in the custom indicator, the same formulas as in the technical indicator are used. To illustrate this let's improve the program code analyzed in the previous example. Let the indicator draw lines upon average values of maximums and minimums of several last bars. It is easy to conduct necessary calculations: we simply need to find average values of arrays-timeseries elements. For example, value of an indicator array with the index 3 (i.e. indicator line coordinate for the third bar) on the basis of the last five maximums is calculated the following way: Analogous calculations can be performed for an indicator lines built upon minimums. Example of a simple custom indicator averagevalue.mq4. Indicator lines are built upon average minimal and maximal values of N bars. In this example there is an external variable Aver_Bars. Using this variable a user can indicate the number of bars, for which an average value is calculated. In start()this value is used for the calculation of an average value. In the loop 'for' the sum of maximal and minimal values is calculated for the number of bars corresponding to the value of the variable Aver_Bars. In the next two program lines values of indicator array elements are calculated for indicator lines corresponding to minimal and maximal values. The averaging method used here is also applied for calculations in the technical indicator Moving Average. If we attach the analyzed custom indicator averagevalue.mq4 and the technical indicator Moving Average, we will see three indicator lines. If the same period of averaging is set up for both indicators, Moving Average line will coincide with one of the custom indicator lines (for this purpose parameters described in Fig. 121 must be specified in the technical indicator settings). Thus, using technical indicator a user can construct the reflection of any regularities necessary in practical work. \n\n \n\n MQL4 offers a large service for constructing custom indicators which makes using them very convenient. In particular, indicator lines can be drawn in a separate window. This is convenient when absolute values of the indicator line amplitude is substantially smaller (or larger) than security prices. For example, if we are interested in the difference between average values of bar maximums and minimums in a certain historic interval, depending on timeframe this value will be equal to approximately from 0 to 50 points (for example, for M15). It is not difficult to build an indicator line, but in a security window this line will be drawn in the range 0 - 50 points of a security price, i.e. substantially lower than the chart area reflected on the screen. It is very inconvenient. To draw indicator lines in a separate window (which is in the lower part of a security window), in the directive #property (at the program beginning) parameter indicator_separate_window must be specified: At the moment when such an indicator is attached to a security window, client terminal creates a separate window below a chart, in which indicator lines calculated in the indicator will be drawn. Depending on color settings and types of indicator lines they will be drawn in this or that style. \n\n In most cases indicator lines contain useful information only in the most recent history. The part of indicator lines built upon old bars (for example, 1 month old minute timeframe) can hardly be considered useful for making trade decisions. Besides, if there are a lot of bars in a chart window, time invested into the calculation and drawing of indicator lines is unreasonably large. This may be critical in program debugging, when a program is often compiled and then started. That is why it is necessary to conduct calculations not for the whole history, but for the limited part of the most recent bar history. For this purpose an external variable history is used in the following program. Value of this variable is taken into account when calculating index of the first (leftmost) bar, starting from which elements of indicator arrays must be calculated. Further calculations in while() loop will be conducted for the number of recent history bars not larger than History value. Note, the analyzed method of limiting a calculation history concerns only the part of calculations that are conducted in the first start of the special function start(). Further, when new bars appear, new parts of indicator lines will be added in the right part, while the image in the left part will be preserved. Thus the indicator line length will be increased during the whole indicator operation time. Common value of History parameter is considered approximately 5000 bars. \n\n Example of a simple custom indicator separatewindow.mq4. Indicator lines are drawn in a separate window. Similar calculation of an indicator line is performed in the technical indicator AverageTrue Range. Fig. 122 shows an indicator line constructed by the custom indicator separatewindow.mq4 in a separate window and an indicator line constructed by ATR in another window. In this case lines are fully identical because period of averaging is the same for both indicators - 5. If this parameter is changed in any of the indicators, the corresponding indicator line will also change. \n\n Fig. 122. drawing a custom indicator line in a separate window.\n\n Identical lines of a technical indicator (ATR) and a custom indicator (separatewindow.mq4). \n\n It is also evident that custom indicator line is constructed not for the whole screen width, but for 50 latest bars as specified in the external variable History. If a trader needs to use larger history interval, value of the external variable can be easily changed via the custom indicator settings window. Fig. 123 shows a security window, in which the indicator line us drawn in another style - as a histogram. For getting such a result one line was changed in the program code separatewindow.mq4 - other line styles are indicated: All other code parts are unchanged. \n\n Fig. 123. Drawing custom indicator line in a separate window (histogram).\n\n Similarity of drawings of a technical indicator (ATR) and a custom indicator (separatewindow.mq4). \n\n \n\n In some cases it is necessary to shift an indicator line. It can be easily done by MQL4 means. Let's analyze an example, in which position of indicator lines in a security window are calculated in accordance with values specified by a user. Example of a custom indicator displacement.mq4. Shifting indicator lines horizontally and vertically. For adjusting lines shift in a chart, there are two external variables - Left_Right for horizontal shift of all lines and Up_Down for shifting two dotted lines vertically. The algorithm used for calculating values of corresponding array elements is based on very simple rules:\n• for shifting a line horizontally, assign the calculated value to an array element, the index of which is larger by Left_Right (for shifting to the right and less for shifting to the right) than the index of a bar, for which calculations are conducted;\n• for shifting a line vertically, Up_Down*Point must be added (for shifting upwards or detracted for shifting downwards) to each value of an indicator array characterizing initial line position; In the analyzed example indexes are calculated in the line: Here i is the index of a bar, for which calculations are performed, k is an index of an indicator array element. Red indicator line displayed by the client terminal based on the indicator array Line_0[] is shifted to the left by 5 bars (according to custom settings, see Fig. 124) from the initial line. In this case the initial line is a Moving Average with the period of averaging equal to 5; the formula of MA calculation is (High[i]+Low[i])/2 . In this example the position of the red line is the basis for the calculation of indicator array values for two other lines, i.e. their position on the chart. Dotted lines are calculated this way: Use of index k for elements of all indicator arrays allows to perform calculations for elements of arrays Line_1[], Line_2[] on the same bar as used for calculating values of the corresponding basic array Line_0[]. As a result dotted lines are shifted relative to the red line by the value specified in the indicator settings window, in this case by 30 points (Fig. 124). \n\n Fig. 124. Red indicator line is shifted to the left by 5 bars.\n\n Dotted indicator lines are shifted relative to the red line by 30 points. \n\n There are some limitations in MQL4 that should be taken into account in the programming of custom indicators. There is a group of functions that can be used only in custom indicators and cannot be used in Expert Advisors and scripts: IndicatorBuffers(), IndicatorCounted (), IndicatorDigits(), IndicatorShortName(), SetIndexArrow(), SetIndexBuffer(), SetIndexDrawBegin(), SetIndexEmptyValue(), SetIndexLabel(), SetIndexShift(), SetIndexStyle(), SetLevelStyle(), SetLevelValue(). On the other hand, trade functions cannot be used in indicators: OrderSend(), OrderClose(), OrderCloseBy(), OrderDelete() and OrderModify(). This is because indicators operate in the interface flow (as distinct from Expert Advisors and scripts that operate in their own flow). This is also why algorithms based on looping cannot be used in custom indicators. Start of a custom indicator containing an endless loop (in terms of actual execution time) can result in client terminal hanging up with further necessity to restart a computer. The general comparative characteristics of Expert Advisors, scripts and indicators is contained in Table 2."
    },
    {
        "link": "https://cashbackforex.com/article/preparing-custom-indicators",
        "document": "We earn commissions from some affiliate partners at no extra cost to users (partners are listed on our ‘About Us’ page in the ‘Partners’ section). Despite these affiliations, our content remains unbiased and independent. We generate revenue through banner advertising and affiliate partnerships, which do not influence our impartial reviews or content integrity. Our editorial and marketing teams operate independently, ensuring the accuracy and objectivity of our financial insights.\n\nAn incredible advantage in using MT4 is the use and integration of hundreds of custom indicators available online. Many can easily use a custom indicator by dragging and dropping it from the custom indicators window into your chart. Learn in this MQL4 iCustom Indicator EA article how to program the Expert Advisor to trade using a custom indicators or oscillators.\n\nIn order to use a custom indicator for an expert advisor, there are a few things you need to know.\n\nThe custom indicator that you are wanting to use for your EA must be located in the indicators directory (C:\\Program Files\\MetaTrader 4\\experts\\indicators for standard installations of MT4). When an EA is executed, it looks for the compiled indicators (.ex4 file) in the indicators directory.\n\n\n\nThere is a built-in function for working with custom indicators called the iCustom(). The iCustom() is a MQL4 function that enables you to use external indicators in your expert advisor or custom indicator code without re-writing the code from scratch.\n\nThe syntax of the function is as follows:\n\nOf the six parameters above, the easiest to figure out are the first three and last. We have already discussed symbol and timeframe in previous articles. The name of the indicator is also rather easy: it is the name of the indicator as it appears in the Custom Indicator’s list in the Navigator window, surrounded by quotation markets. Example: If you see that the indicator is called NonLagMA in the window, you will write it as “NonLagMA” in the indicator name parameter.\n\nWe have also already discussed in previous articles the last parameter, the Shift, but here is a recap. Shift indicates the bar that the indicator is being calculated upon. Bars are numbered 0, 1, 2, 3, 4, 5….as you go back in time on the chart. Changing the shift option is similar to moving the indicator line into the future or the past. Shift of 1 obtains the value of the previous bar. Shift of 0 obtains the value of the current bar.\n• shift = 0 to get the indicator’s value of the current bar (still forming)\n• shift = 1 value on the previous bar\n• shift = 2 value in a bar before the previous bar\n\nThe third parameter, Indicator Parameters, and the fourth parameter, Mode, can be tricky to discover and implement within an EA.\n\nFirst, let us examine how to discover the custom Indicator Parameters. Most of the time the custom indicator might use 1 or 2 indicator parameters, but there are some that use 3 or more, making the discovery process more difficult. The custom indicator NonLagMA is an example of a more complex indicator that uses 9 indicator parameters. \n\n\n\nNote: Parameters are all inputs that change the value of the indicators; they are the variables that you play with to get the best set up for your custom indicator.\n\nIf you go to the Inputs tab in the Custom Indicator Properties window, it will show you the parameters for the NonLagMA custom indicator:\n\nThough you can see 6 inputs in the above picture, there are actually 9 inputs or indicator parameters. There are 9 indicator parameters with different inputs you can change the value of to get the best setup, one of which is essential to the formation of the indicator (Length).\n\nAn even better method of discovering the indicator parameters is to copy and paste them from the source code. If you right click on the custom indicator and click Modify, you can see the source code of the indicator in the MetaEditor. If the indicator is grayed out it means you do not have the mq4 code, just the ex4, and you have to figure out a way to decompile it, or you can deduce the parameters from the properties window using the method above. \n\n\n\nIf you have the mq4 code and can open it, you are in luck. Now, check the extern variables at the beginning of the indicator source code. The indicator parameters, data types and default values, will be listed here, and you can simply copy and paste the extern code to the extern variables section of your expert advisor.\n\nWith the NonLagMA indicator, you will see the following extern variables:\n\n//—- input parameters\n\nextern int Price = 0;\n\nextern int Length = 9; //Period of NonLagMA\n\nextern int Displace = 0; //DispLace or Shift\n\nextern double PctFilter = 0; //Dynamic filter in decimal\n\nextern int Color = 1; //Switch of Color mode (1-color)\n\nextern int ColorBarBack = 1; //Bar back for color mode\n\nextern double Deviation = 0; //Up/down deviation\n\nextern int AlertMode = 0; //Sound Alert switch (0-off,1-on)\n\nextern int WarningMode = 0; //Sound Warning switch(0-off,1-on)\n\nBear in mind that though there are 9 parameters, only one, Length, will change the essential nature of the indicator. The others can be left at their default values, which in most cases other than Color, is 0. If we also put in 0 as the default for the last two parameters, mode and shift, we can construct our iCustom NonLagMA indicator with the above identifiers:\n\nFor the purposes of optimization, only one of the nine parameters above, Length, is the one that you will change or optimize in order to find the best NonLagMA for your currency symbol and timeframe. The others will remain at their default values. It is often the case that if you see length as a parameter in your custom indicator, it will be the one that will become the most essential to the formation of your strategy, and thus most essential for further manipulation.\n\n\n\nThe above custom indicator should compile effectively, but in order to put it in a strategy you must know how to work with the last two parameters, mode and shift.\n\nMode is a line index that ranges from 0 to 7. MT4 allows up to 8 indicator lines (buffers) per custom indicator. These lines (buffers) must correspond with the index used by one of SetIndexBuffer lines from within the code of the indicator.\n\nIt is helpful to visual this: Your indicator has up to 8 lines/signals (or arrows) with different colors. Each line gives you an output, and each line has a value. With mode you select the line (signal) that you need for your EA (just one out of eight). Most of the time, indicators have only one line/signal so mode=0 should be used.\n\nNote on Mode: Because MT4’s index goes from 0 to 7, mode takes values from 0 to 7. So the first signal has a mode=0 (and not 1). If your indicator has three indicator lines/signals and you want to get the value for the first line, you use mode=0, the value for the second line/signal is obtained with mode=1, and mode=2 will get the value for the third signal.\n\nOk, then, how do you identify the mode to use for your EA?\n\nThe mystery of the mode lies within the Indicator Buffers.\n\nBasically, you have to look for the buffers in the code and these will become the lines of your mode. Lets say that you have 3 buffers:\n\nIf you wish to have values of 3 buffers of current bar you will write :\n\nOk, fine, let us see an example of this buffer syntax and where it is located in the code.\n\nJust under the initialization function of the NonLagMA indicator, you will see a number of indicator buffers that look like this:\n\nSetIndexStyle tells us that there are three lines (DRAW_LINE). Underneath, SetIndexBuffer tells us the mode number and name of those three lines. It is these lines that begin with SetIndexBuffer that are the key to finding your mode. Specifically, the contents in parenthesis indicate the number of the mode and its name (0=MA, 1=UP, 2=Dn). There is a fourth signal (mode 3, trend) that does not have a line and is called trend. You can ignore the two buffers relating to delete (4,Del) and (5, AvgDel) as they are not signals.\n\nHere are the 4 lines (buffers) and their signal names put into a table for you to see:\n\nNow that we know the number and names of the lines (signals) of our mode parameter, how do we find out what they do?\n\nOne way, of course, is to have a look at the source code. However, as we have not as yet discussed the construction of indicators, I am going to assume that the code appears Greek to you.\n\nThe other method is to visually deduce the function of the lines /signals.\n\nYou need to apply your indicator to the chart and open up the data window (View /Data Window or Ctr +D). At the bottom of your data window you will see many of the signals pertaining to your indicator, along with their corresponding data values, depending on the bar your mouse is hovering over.\n\nThe data table that I highlighted in red provides the clue for deducing the function of the modes (lines / signals). The NonLagMA is the first mode (mode = 0), and we can deduce that it is the line itself. If you hover your mouse over any bar it gives you the data reading of the NonLagMA row for that bar. Up is the second mode (mode =1) and we can deduce that it is the blue line. \n\n\n\nIf you hover your mouse over any bar that has a blue line underneath it, you will see that it gives you a data reading for the Up row and no data reading for the Dn row. Dn is the third mode (mode = 2), and we can deduce that it is the red line. If you hover your mouse over any bar that a red line over it, you will see that it gives you a data reading for the Dn row and no data reading for the Up row.\n\nThe fourth mode of Trend (mode = 3) does not appear in the data window, though I know from looking at the code that reads like this: if current trend signal == 1, the trend is long, and if current trend signal == -1, the trend is short.\n\nNow what you roughly know the four modes of the NonLagMA custom indicator, you can create at least three types of EA conditions:\n• EA that works with the MA line itself, as in a crossover (Mode=0);\n• EA that works with the Up (Blue) and Dn (Red) signals, taking buys when the NonLagMA turns blue and taking sells when it turns red (Mode=1 and Mode=2).\n• EA that works with the Trend signal, buy when trend is up, sell when trend is down (Mode=3).\n\nWe will examine each of these EA combinations in the next article: Building Strategies with Custom Indicators"
    },
    {
        "link": "https://topforextrade.medium.com/forex-custom-indicators-and-expert-advisors-eas-a-full-guide-a48c470ce9b3",
        "document": "If you’re looking to take your trading to the next level, custom indicators and Expert Advisors (EAs) on MetaTrader 4 (MT4) and MetaTrader 5 (MT5) are powerful tools to enhance your strategies. These tools, designed with MetaQuotes Language (MQL4/5), allow traders to customize their charting experience and automate their trades. While both platforms offer these features, MT5 brings more advanced capabilities, including a wider range of chart types, timeframes, and the ability to trade a variety of instruments. In this article, we’ll explore the benefits and differences between custom indicators and EAs, helping you understand how to leverage these tools to improve your trading performance.\n\nCustom indicators are tools designed in MetaQuotes Language (MQL4/5) that allow traders to display advanced technical calculations on their charts. While both MT4 and MT5 support custom indicators, MT5 offers more features and flexibility, including additional chart types and timeframe options.\n• Pivot Point Indicator: This tool calculates and displays key support and resistance levels, which are critical for identifying price levels that could cause reversals.\n• Moving Average Crossover: This custom indicator combines multiple moving averages (e.g., 50-day and 200-day) to identify trend changes. A cross above suggests a potential buy, and a cross below signals a sell.\n\n→More about how to use Moving Averages in CFD trading.\n• ADX (Average Directional Index): ADX measures the strength of a trend. Traders combine it with other indicators like moving averages to confirm whether a trend is strong enough to follow.\n• MACD (Moving Average Convergence Divergence): Available on both MT4 and MT5, MACD helps determine the momentum of a price move and is one of the most popular indicators for traders.\n• MT4: Primarily for forex trading, MT4 offers a simpler, more straightforward interface with support for custom indicators and basic charting tools.\n• MT5: An upgraded version, MT5 offers more timeframes, chart types (like ticks), and the ability to trade other instruments like stocks and commodities. Custom indicators on MT5 can also be more complex and handle more data points.\n\nMT5 provides more processing power, making it ideal for traders who want to use more advanced strategies and indicators without the limitations of MT4.\n\nExpert Advisors (EAs) are automated trading robots coded in MQL4/5 that follow a set of predefined rules to open and close trades automatically. They help traders by executing trades with speed and accuracy, reducing emotional decision-making and allowing for 24/7 trading.\n• Scalping EAs: These execute multiple small trades in a short period, capitalizing on small price movements.\n• News trading EAs: These EAs react to high-impact economic news releases like NFP (Non-Farm Payroll) by opening or closing positions based on expected volatility.\n• Breakout EAs: They place trades when the price breaks through established levels of support or resistance.\n• Hedging EAs: These open both buy and sell positions to manage risk during market fluctuations.\n\nSome examples include the Meet Algo Breakout EA, which automatically places trades during breakouts, and the Dark Venus EA, which uses trend-following strategies to enter trades at the right moment.\n• MT4: Known for its reliability and being user-friendly for forex traders, MT4 supports EAs that focus on trading currencies.\n• MT5: In addition to forex, MT5 supports a broader range of instruments, including stocks and commodities, making it ideal for those who want to diversify their trading portfolio. MT5 also supports multi-currency EAs, which is helpful for traders who trade multiple instruments simultaneously.\n\nMT5 EAs benefit from improved speed, more robust features, and greater flexibility. For example, in MT5, you can use multi-currency strategies, allowing the EA to open positions in several currencies at once based on market conditions.\n\nWhere to find and use EAs for FX trading\n\nYou can easily find and download EAs in several places:\n• MetaTrader Market: Directly from the MT4 or MT5 platform, where you can purchase or download free EAs.\n• ForexFactory: A popular forum where traders share and discuss EAs, often for free.\n• Fiverr/Upwork: If you want something custom-tailored to your specific needs, you can hire a developer to create an EA just for you.\n\nHow to install and use EAs on MT4 & MT5:\n• Download or buy the EA: Make sure you’re getting it from a trusted source like the MetaTrader Market or ForexFactory.\n• Place the EA in the “Experts” folder: Navigate to your MT4 or MT5 directory, find the “Experts” folder, and place the EA in it.\n• Enable live trading: In MT4/MT5, go to the “Navigator” panel, drag the EA onto a chart, and allow live trading. Make sure you’ve enabled DLL imports if required.\n• Adjust EA settings: Customize settings such as stop loss, take profit, risk level, lot size, and other parameters according to your trading strategy.\n\nPro tip: Always test your EA on demo accounts of trusted brokers to ensure it works as expected before using it in a live account.\n\nBacktesting is crucial for evaluating how well your EA would have performed in the past based on historical price data. Both MT4 and MT5 feature backtesting tools, but MT5’s Strategy Tester offers more advanced functionality, including multi-currency and multi-timeframe testing.\n• Open the strategy tester: In MT4, press Ctrl+R, and in MT5, go to View > Strategy Tester.\n• Select your EA: Choose the EA you want to backtest.\n• Set parameters: Pick the currency pair, timeframe, and date range you want to test.\n• Start backtesting: Hit the “Start” button and let the platform run the test. MT5 also allows you to test multiple EAs simultaneously.\n• Review results: Analyze the backtest report to see profitability, drawdowns, and performance under different market conditions.\n• MT5’s backtesting engine supports multi-currency testing and allows for a more realistic evaluation of your strategy’s performance by simulating trades with multiple instruments at the same time.\n\nTracking and analyzing the performance of your custom indicators and EAs is critical for improving your strategy. One effective way to do this is by maintaining a trading journal. Here’s how you can make it work for you:\n\nBest practices for your trading journal\n• Choose a format: Use a physical notebook, Excel sheet, or an online tool like Evernote to keep track of your trades.\n• Define categories: Include details like entry/exit points, stop loss, take profit, position size, and the market conditions when the trade was executed.\n• Record all trades: Track every trade, including modifications to your strategy or EA settings during the process.\n• Analyze performance: Regularly review your trading journal to identify patterns and refine your strategies accordingly.\n• Monitor emotions: Track your emotional state during trades — whether you felt confident, fearful, or impatient. This helps identify emotional biases that could impact decision-making.\n• Review & adjust: Use your journal to improve strategy, adapt to market conditions, and optimize your custom indicators and EAs…\n\nHow to use custom indicators and EAs to automate your trading on MetaTrader"
    },
    {
        "link": "https://book.mql4.com/samples/shared",
        "document": "It was said earlier that according to MQL4 rules trade functions cannot be used in custom indicators, that is why for automated trading Expert Advisors or scripts should be used. However, the resource-saving technology used for calculations in indicators (see Creation of Custom Indicators) is widely used when creating trading programs. In most cases in custom indicators one can efficiently calculate values of indicator array elements necessary for the formation of trading criteria and making of trading decisions in Expert Advisors. Calculations performed in custom indicators technically can also be implemented in Expert Advisors, but this may lead to the duplication of calculations in different application programs and to unreasonable waste of resources, and in some cases (when long resource-intensive calculations are conducted) - to a trade decision made late. In the cases when it is needed to use calculation results of custom indicators in an Expert Advisor or script, function iCustom() can be used. Calculation of the given custom indicator. The custom indicator must be compiled (.ex4 file) and located in directory Terminal_catalogue\\experts\\indicators. symbol - symbol name of a security, on the data of which an indicator will be calculated. NULL indicates the current symbol. timeframe - period. Can be one of chart periods. 0 means the period of the current chart. name - name of the custom indicator. ... - List of parameters (if needed). Passed parameters must correspond with the order of declaring and the type of external variables of a custom indicator. mode - Index of an indicator line. Can be from - to 7 and must correspond to the index used by any of SetIndexBar functions. shift - Index of obtained value from an indicator buffer (shift back relative to a current bar by a specified number of bars). \n\n Let's consider how iCustom() can be used in practice. Let us solve the following problem: Problem 30. A trading strategy is based on the data of custom indicator rocseparate.mq4. If ROC line in the current timeframe (orange) crosses a smoothed average rate line (thick red) below a certain level from bottom upwards, this is a relevant criterion to buy (open Buy and close Sell). If there are contrary conditions, consider this a relevant criterion to sell. Write a code implementing this strategy. The principle of construction of the custom indicator rocseparate.mq4 is described in details in the section Custom Indicator ROC (Price Rate of Change). Fig. 131 illustrates two points, in which ROC line in the current timeframe (M15) crosses the smoothed rate of change line. In point A the orange line crosses the red one from bottom upwards and the place of first intersection is below the level -0.001. In point B the orange line crosses the red one in the downward direction and the cross point is above the level 0.001. The fact of this crossing must be detected in the Expert Advisor and be considered as a signal to buy (point A - close Sell and open Buy) or to sell (point B - close Buy and open Sell). \n\n Fig. 131. Crossing of custom indicator lines is considered as a trading criterion. When solving such problems a ready Expert Advisor can be used, changing the order of calculation trading criteria in it. In this case we can take as a basis the Expert Advisor tradingexpert.mq4 described in the section Simple Expert Advisor. The EA shared.mq4 calculating trading criteria on the basis of a custom indicator will look loke this: \n\n\n\n\n\n\n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n Not enough bars in the window. EA doesn't work. \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n Trade server is busy. Trying once again.. \n\n \n\n Price changed. Trying once again.. \n\n \n\n No prices. Waiting for a new tick.. \n\n \n\n \n\n Broker is busy. Trying once again.. \n\n \n\n Trading subsystem is busy. Trying once again.. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Not enough money to execute operation. \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Let us analyze what amendments were made in the source code (tradingexpert.mq4). The main part of the Expert Advisor used as basic has not changed. Changes have been made in two blocks - block 1-2- and block 5-6. In the block 5-6 trading criteria are calculated. In the described EA a trading strategy is based on two trading criteria - criterion to open Buy and criterion to open Sell. The strategy used in the Expert Advisor allows the presence of only one opened market order, pending orders are not allowed. The strategy also presupposes closing an opposite order when a criterion for opening triggers; for example, if criterion to open a Buy order is relevant, it means that a Sell order must be closed. For using in the EA shared.mq4 results of calculations performed in the custom indicator rocseparate.mq4, function iCustom() must be executed: In this case formal parameters specified in iCustom() call denote the following: NULL - calculations in the indicator are performed based on data of the current security; in this case the EA is attached to EURUSD window, so data of EURUSD will be used (see Fig. 131); 0 - in calculations data of the current timeframe are used; in this case the current timeframe is M15, so data corresponding to M15 will be used; \"rocseparate\" -name of a custom indicator, in which calculations will be made. H,P,B,A - list of adjustable parameters. In this case the custom indicator rocseparate.mq4 has adjustable parameters (block 2-3 of rocseparate.mq4 code). For a user to be able to set up values of these parameters from the EA, they are specified in the list of passed parameters of the function iCustom(). In the Expert Advisor values of these parameters can differ from those specified in the indicator. In such a case during calculations in the indicator exactly these passed values will be used. These parameters denote the following: (the meaning of these parameters is explained in details in the section Custom Indicator ROC (Price Rate of Change). 1 ( 5 ) - index line of the indicator. In the custom indicator rocseparate.mq4 6 indicator arrays are used. ROC line in the current timeframe (orange) is constructed on the basis of Line_1[] values, for which buffer with index 1 is used. Smoothed average rate line is based on values of Line_5[] array elements, index of the used buffer is 5. 0 - index of value obtained from an indicator buffer (shift back relative to a current bar by the specified number of periods). In this case values of indicator lines on the zero bar are used, that is why index 0 is specified. For a user to be able to change the adjustable indicator parameters in the EA manually, external variables are specified in block 1a-1b (of the Expert Advisor). In block 5-5a values of these parameters are assigned to other variables with shorter names - this is done for convenience of code presentation in block 5a-5b. Thus a user can specify in shared.mq4 parameters, with which calculations in the custom indicator rocseparate.mq4 will be conducted. After execution iCustom() function will return value corresponding to a specified element value of specified indicator array calculated in the indicator using specified values of adjustable parameters. During practical operation it is convenient to see in a security window lines of the indicator, array elements of which are used in the Expert Advisor (see Fig. 131). At the same time execution of iCustom() is not connected with the presence of the indicator in the security window, as well as with the values of its adjustable parameters. The execution of iCustom() does not require the attachment of a corresponding indicator to a security window. As well as the call of iCustom() from any application program does not result in the attachment of a corresponding indicator to a security window. Attachment of a technical indicator to a security window also does not lead to the call of iCustom in any application program. Trading criteria in the EA (block 5-6) are calculated on the basis of array element values obtained using iCustom() function. For example a criterion for opening Buy and closing Sell are calculated the following way: If the last known value of a smoothed average rate line (L_5) is less than the specified level (value of the adjustable parameter Level = 0.001) and the last known value of ROC line in the current timeframe (L_1) is larger than the smoothed average rate line (L_5), the criterion for opening a Buy order and closing a Sell order is considered relevant. For the confirmation of relevance of opposite criteria reflecting conditions are used. Trading criteria accepted in this example are used for educational purpose only and must not be considered as a guideline when trading on a real account."
    },
    {
        "link": "https://stackoverflow.com/questions/45594271/how-to-get-a-variable-value-from-a-custom-indicator-in-mql4-in-expert-adviser",
        "document": "is a primary interface between EA and Custom Indicators\n\nThere is no reason, why would a call to not return a value, given the compilation was successful and the constructed Custom Indicator is principally correct in its internal workings ( do not hesistate to post the MCVE-code example to prove or dis-prove this ).\n\nNext step:\n\n publish an update of your post, to include an MCVE-code so as to review the root-cause of the actual state of such call:\n\nFormal interface is a bit tricky, but a discipline can help a lot:\n\nThe following method is robust for both EA-side and Indicator-side teams to smoothly and safely share evolving ideas and for maintaining all the versions of EA-side call-interface clean and safe plus creating the calling-interface a way more readable ( with -ed human-readable names for meaningful and coherent line#-identifications ).\n\nThese sections are maintained by the Custom Indicator developers, during the whole life-cycle of a Custom Indicator and EA-teams just these as a self-explanatory template once any version is being used inside EA.\n\nAny other approaches were historically proven to be more painfull or more risky.\n\nUsing call(s) is not a robust use-case for this problem-domain, as many side-effects are to be expected and such code-value-integration is prone to stop working without EA-being able to detect such ( semantic ) failure.\n\nUsing a Custom Indicator logic \"inside\" EA is possible, but at a cost of a complete re-design of the logic, as EA code-execution unit behaves way different from the Custom Indicator code-execution unit in the MetaTrader4 Terminal code-execution environment. It is fair to note, that due to MQL4-language-( and Terminal )-revisions, it makes sense just for an HFT-grade Project, or for extremely latency-sensitive implementations to carefully decide cons and pros before going into this direction."
    }
]