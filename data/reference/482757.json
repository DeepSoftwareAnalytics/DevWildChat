[
    {
        "link": "https://introcs.cs.princeton.edu/97data/FFT.java.html",
        "document": "Below is the syntax highlighted version of FFT.java from §9.7 Optimization."
    },
    {
        "link": "https://stackoverflow.com/questions/53366791/how-i-should-create-complex-number-from-image-data-for-fast-fourier-transform-f",
        "document": "Fill real part of complex array with you data, and imaginary part - with zero (picture is pure real data).\n\nAfter FFT you'll have complex array (symmetrical because of pure real source). Both real and im. parts of result are important. For example, you can use both parts to calculate magnitude of spectrum, or to perform some treatment in frequency domain and make inverse FFT to get treated picture.\n\nWhat to do with RGB - depends on your needs. Sometimes one needs to perform FFT on every channel separately. Sometimes one needs to work with brightness - in this case channels are joined using some law."
    },
    {
        "link": "https://rosettacode.org/wiki/Fast_Fourier_transform",
        "document": "Calculate the FFT ( ast ourier ransform) of an input sequence.\n\nThe most general case allows for complex numbers at the input and results in a sequence of equal length, again of complex numbers. If you need to restrict yourself to real numbers, the output should be the magnitude (i.e.: sqrt(re2 + im2)) of the complex result.\n\nThe classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that. Further optimizations are possible but not required. \n\n\n\n\n\nThe FFT function is defined as a generic function, instantiated upon a user instance of Ada.Numerics.Generic_Complex_Arrays.\n\nInplace FFT with O(n) memory usage. Note: array size is assumed to be power of 2 and not checked by code; you can just pad it with 0 otherwise.\n\n* for given number of bits * e.g. 011 with 3 bits is reversed to 110 */ * assumes no of points provided are a power of 2 */ // The above section of the code is incorrect and does not work correctly and has two bugs. // The bug is that when you reach and index that was swapped previously it does swap it again // Ex. binary value n = 0010 and Bits = 4 as input to BitReverse routine and returns 4. The code section above // swaps it. Cells 2 and 4 are swapped. just fine. // now binary value n = 0010 and Bits = 4 as input to BitReverse routine and returns 2. The code Section // swap it. Cells 4 and 2 are swapped. WROOOOONG // The code works on the half section of the cells. In the case of Bits = 4 it means that we are having 16 cells // The code works on half the cells for (int j = 1; j < buffer.Length / 2; j++) buffer.Length returns 16 // and divide by 2 makes 8, so j goes from 1 to 7. This covers almost everything but what happened to 1011 value // which must be swap with 1101. and this is the second bug. // use the following corrected section of the code. I have seen this bug in other languages that uses bit // First the full length is used and 1011 value is swapped with 1101. Second if new swapPos is less than j // then it means that swap was happen when j was the swapPos.\n\nAs the longer standing solution below didn't work out for me and I don't find it very nice, I want to give another one, that's not just a plain translation. Of course it could be optimized in several ways. The function uses some non ASCII symbols for better readability and condenses also the inverse part, by a keyword.\n\nFrom here on the old solution.\n\nFrink has a built-in FFT function that can produce results based on different conventions. The following is not the default convention, but matches many of the other results in this page.\n\nBased on j:Essays/FFT, with some simplifications -- sacrificing accuracy, optimizations and convenience which are not relevant to the task requirements, for clarity:\n\nExample (first row of result is sine, second row of result is fft of the first row, (**+)&.+. cleans an irrelevant least significant bit of precision from the result so that it displays nicely):\n\nHere is a representation of an example which appears in some of the other implementations, here:\n\nNote that Re and Im are not functions of 1 and 0 but are functions of the complete sequence.\n\nAlso note that J uses a different character for negative sign than for subtraction, to eliminate ambiguity (is this a single list of numbers or are lists being subtracted?).\n\nComplex fourier transform & it's inverse reimplemented from the C++ & Python variants on this page.\n\nVery very basic Complex number that provides only the components required by the code above.\n\nCurrently jq has no support for complex numbers, so the following implementation uses [x,y] to represent the complex number x+iy.\n\nAn implementation of the radix-2 algorithm, which works for any vector for length that is a power of 2:\n\nMaple has a built-in package DiscreteTransforms, and FourierTransform and InverseFourierTransform are in the commands available from that package. The FourierTransform command offers an FFT method by default.\n\nOptionally, the FFT may be performed inplace on a Vector of hardware double-precision complex floats.\n\nMathematica has a built-in FFT function which uses a proprietary algorithm developed at Wolfram Research. It also has an option to tune the algorithm for specific applications. The options shown below, while not default, produce output that is consistent with most other FFT routines.\n\nHere is a user-space definition for good measure.\n\nThis is a simple implementation of the Cooley-Tukey pseudo-code\n\nNaive implementation, using the same testcase as Ada:\n\ndifferently, and even with \"graphics\"\n\nComplex Fourier transform the inverse reimplemented from the C++, Python & JavaScript variants on this page.\n\nNote: Similar algorithmically to the python example.\n\nThe function \"fft\" is readily available in R\n\nFor the fun of it, here is a purely functional version:\n\nThis REXX program is modeled after the Run BASIC version and is a radix-2 DIC (decimation-in-time) \n\nform of the Cooley-Turkey FFT algorithm, and as such, this simplified form assumes that the number of \n\ndata points is equal to an exact power of two.\n\nNote that the REXX language doesn't have any higher math functions, such as the functions COS and R2R \n\n(cosine and reduce radians to a unit circle).\n\nA normalization of radians function (r2r) has been included here, as well as the constant pi.\n\nThis REXX program also adds zero values if the number of data points in the list doesn't exactly equal to a \n\npower of two. This is known as zero-padding.\n\nProgramming note: the numeric precision (decimal digits) is only restricted by the number of decimal digits in the \n\npi variable (which is defined in the penultimate assignment statement in the REXX program.\n\nSee the fft function in Mata help, and in the FAQ: How can I calculate the Fourier coefficients of a discretely sampled function in Stata?.\n\nStata can also compute FFT using the undocumented fft command. Here is an example showing its syntax. A time variable must have been set prior to calling this command. Notice that in order to get the same result as Mata's fft() function, in both the input and the output variables the imaginary part must be passed first.\n\nDifferently from the java implementation I have not implemented a complex type. I think it would worth only if the simulators supported operator overloading, since it is not the case I prefer to expand the complex operations, that are trivial for any electrical engineer to understand :D\n\nI could have written a more beautiful code by using non-blocking assignments in the bit_reverse_order function, but it could not be coded in a function, so FFT could not be implemented as a function as well.\n\nBy running the sanity test it outputs the following\n\nGiving some indication that the test is correct.\n\nA more reliable test is to implement the Discrete Fourier Transform by its definition and compare the results obtained by FFT and by definition evaluation. For that let's create a class with a random data vector, and each time the vector is randomized the FFT is calculated and the output is compared by the result obtained by the definition.\n\nNow let's create a code that tests the FFT with random inputs for different sizes. Uses a generate block since the number of samples is a parameter and must be defined at compile time.\n\nSimulating the fft_test_by_definition we get the following output:\n\nAs expected the error is small and it increases with the number of terms in the FFT.\n\nThe library is callable from Ursala using the syntax for a one dimensional forward discrete Fourier transform operating on a list of complex numbers. Ordinarily the results are scaled so that the forward and reverse transforms are inverses of each other, but additional scaling can be performed as shown below to conform to convention.\n\nWritten and tested in Microsoft Visual Basic for Applications 7.1 under Office 365 Excel; but is probably useable under any recent version of VBA."
    },
    {
        "link": "https://reddit.com/r/java/comments/bbzvl1/i_wrote_a_library_that_makes_fourier_transforms",
        "document": "I recently began a project to build LED lights that synchronize to music and quickly realized I needed a way to use a Fourier Transform to compute the frequency spectrum for a song before I could do anything interesting with the lights. Unfortunately, I didn't have any prior exposure to signal processing or working with digital audio in Java so it took me a while to figure all the concepts out.\n\nUltimately, I wanted a way to convert an audio file into a frequency spectrum over time without having to worry reading byte streams, applying window smoothing functions, and making sense of raw FFT (Fast Fourier Transform) output. I thought it would be useful to create a small library that abstracts away the complicated details of a Fourier transform, allowing its computation in as little as one line of Java code.\n\nThe library is named QuiFFT, a combination between the words quick + FFT. If you've ever used the Fourier Transform before or are interested in playing around with it, I invite you to take a look at the library and let me know your thoughts.\n\nHere's a link to the project on Github: https://github.com/mileshenrichs/QuiFFT\n\nPlease let me know what you think!"
    },
    {
        "link": "https://gist.github.com/VictorTaelin/5776ede998d0039ad1cc9b12fd96811c",
        "document": "In this article, I'll explain why implementing numbers with just algebraic datatypes is desirable. I'll then talk about common implementations of FFT (Fast Fourier Transform) and why they hide inherent inefficiencies. I'll then show how to implement integers and complex numbers with just algebraic datatypes, in a way that is extremely simple and elegant. I'll conclude by deriving a pure functional implementation of complex FFT with just datatypes, no floats.\n\nFor most programmers, \"real numbers\" are a given: they just use floats and call it a day. But, in some cases, it doesn't work well, and I'm not talking about precision issues. When trying to prove statements on real numbers in proof assistants like Coq, we can't use doubles, we must formalize reals using datatypes, which can be very hard. For me, the real issue arises when I'm trying to implement optimal algorithms on HVM. To do that, I need functions to fuse, which is a fancy way of saying that \"morphs into\" during execution - yet, machine floats block that mechanism. Because of that, I've been trying to come up with an elegant way to implement numbers with just datatypes. For natural numbers, it is easy: we can just implement them as bitstrings:\n\nThe program above implements addition by repeated increment, and is the simplest numerical example where fusion makes a big difference, being exponential on Haskell and linear on HVM. But this isn't useful in practice, as we already have fast addition algorithms like add-carry. The question, then, becomes: is it possible to explore optimality to implement numeric algorithms that actually beat existing ones in practice? The idea is that we could implement numbers with datatypes, which are, usually, much slower than floats, but, if the resulting asymptotics are improved, then this would easily pay off. One of the most successful numeric algorithms ever is the FFT. How would an \"optimal FFT\" look like? Let's find out!\n\nDesigning optimal functions is extremely tricky, because it takes very little to interrupt fusion and get an exponential slowdown. For example, if we change the Haskell function above to let the Nat grow in size:\n\nThen, the fact we're now using the \"I\" constructor twice will prevent us from fusing the corresponding function on the HVM. A single character will downgrade it from linear to exponential! There are bazillion ways to ruin fusion. Passing a state as an argument, placing a lambda in the wrong location, using an argument more than once... in fact, it feels like anything that detours from a \"direct linear recursion\" will refuse to fuse. With that in mind, let's examine the textbook FFT:\n\nNote: you do not need to understand FFT to read this article - just view this as a random snippet we want to optimize.\n\nSo, what is wrong with this? Well, when it comes to optimality, everything. First, it traverses the list just to compute its length. Then, it copies the entire list 2 more times to split even/odd indices. Then, it traverses the odds list twice. Then it copies it. Then it re-generates the same twiddle factors over and over. Then it traverses everything a few more times with zips. All these things block fusion, and, if that wasn't bad enough, it performs arithmetic on machine floats on its its inner loop, which removes any remaining hope we could have. So, how can it be improved?\n\nThe first insight is to replace lists by balanced binary trees, and store elements on nodes such that, by starting from any element of the tree, walking up to the root, and annotating the branches we passed through as 0 for left and 1 for right, we'll get the binary representation of the index. For example:\n\nIf we start from , and move up until the root, we'll pass through right ( ), right ( ) and left ( ) branches of a node, which agrees with the fact is in binary.\n\nStoring elements that way has two benefits. First, we can now split a tree into even/odd indices in O(1) by just taking the left/right branches, removing the no need to call the \"split\" function, which is O(N), on every recursive call. For example, by taking the left branch of that tree, we get:\n\nWhich corresponds to the list , i.e., the even indices of the original list. And if we take the left branch again, we get:\n\nWhich corresponds to the list , which is, once again, the even indices of the list above. The second benefit is that we're now able to replace the 3 calls to by a single call to , which combines , and the twiddle factors in a single pass. Here is the improved version:\n\nThe way it works is similar, with all unnecessary work removed. The function receives a tree with coefficients, and calls itself recursively on the left and right branches, which corresponds to even and odd coefficients on the original polynomial. Then, it combines the set of recursive points in a single pass by calling the function. Finally, it doesn't generate a list of twiddle factors. Instead, it stores an angle (as a natural number, ranging from to , where is the number of points) which is then used to generate the twiddle factor at the bottom of the recursion.\n\nWhile this algorithm is less pedagogical and readable, it is fully linear and way less contrived for the runtime. It is in a healthy shape for optimality, but there is still a problem: it represents complex numbers using floats, thus requires machine numbers that don't fuse. Of course, we could perform FFT over other fields, but in some cases we really need complex FFT.\n\nOur ultimate goal is to come up with an implementation of that can be used on FFT, and that is based purely on ADTs, i.e., no native floats, in such a way that is simple and direct enough to possibly fuse. Let's begin with a simpler goal: integers. Let's recall how we implemented and :\n\nSo, what about ? We could try implementing it by using a and a sign:\n\nBut this is actually a bad idea since, by pattern-matching on the boolean to treat cases separately we inhibit fusion. Also, calling makes it non-linear, which also inhibits fusion. In general, this is exactly the shape of code that does not fuse. We're looking for something more uniform, that doesn't separate the sign.\n\nFortunatelly, there is a pretty elegant way to do it: balanced ternary. It is similar to ternary numbers, expect its digits are not , but . The digit is usually written as , so, for example, the string represents , which is . Amazingly, all integers can be uniquely represented in this system. Let's count:\n\nBeautiful, isn't it? Its symmetric proporties and simple arithmetic are quite important for fusion. Here is an implementation of and :\n\nAs you can imagine, this representation of , and its arithmetic operations, can be implemented on HVM in a way that fuses nicely, solving part of the problem. But what about real and complex numbers?\n\nSadly, it took me a long time to figure out the proper way to do , which is astronomically simpler than these. Just to think of the complexity of floats (which include sign, mantissa, exponent, NaNs...), Dedekind Cuts, Cauchy Sequences and the like would give us the feeling we'll never find a representation of real numbers that is as nice and uniform as the type above. Yet, for the sake of FFT, there is some light at the end of the tunnel.\n\nThe insight is that we don't actually need all complex numbers; we just need enough of them to represent roots of unity. In fact, if we wanted to perform FFT on lists of 2 elements, integers would be enough for us, since we only need to evaluate polynomials on 2 complex points, , which are both just ints!\n\nBut what if there were 4 elements? In this case, we would actually need 4 points: ... which is beyond the set of integers. But there is an common extension of integers that could help: Gaussian Integers, which add the square root of , , to . It forms sort of a quantized grid over the complex plane, as follows:\n\nWe could implement that type as follows:\n\nThis would give us 4 roots of unity, and, thus, the ability to perform FFT on lists of 4 elements!\n\nWhat about 8 elements though? Well, the idea here is to simply keep going, and add a new constant, , which is the square root of . Once we do that, we need 4 ints to represent a number; that's because is also part of the set, so any number can be represented as . We can implement this extended Gaussian Integer as:\n\nThis would give us 8 roots of unity, and, thus, the ability to perform FFT on lists of 8 elements.\n\nAnd it would allow us to represent \"fractional\" complex numbers with just integers. For example, the number can be approximated as , which can be constructed as:\n\nAs you can see, we can keep going and generalize this to make the set , with being Integers, being Gaussian Integers, being Extended Gaussian Integers, and so on. To implement it, we can use a tree:\n\nFor , we have 16 roots of unity, and can perform FFT on lists of 16 elements:\n\nTo add two complex numbers of , we just do so pairwise:\n\nBut what about multiplication? A very elegant algorithm, found by T6 on HOC's discord, allows us to multiply a GN number by bases like , , , etc., with just rotations and negation:\n\nThis simple function, if applied on a element, will multiply it by its smallest base. So, for example, on , rot performs multiplication by . On , it multiplies by . On , it multiplies by . On , which is just a scalar, it negates the number. Very nice! We can use to multiply two elements as follows (once again, thanks T6):\n\nWhich is, again, very elegant. But, for the sake of FFT, we don't actually need to perform multiplication of two arbitrary numbers during the algorithm; we just need to multiply by twiddle factors on the upper side of the unit circle. As such, we can use this simplified algorithm, which receives an angle on the unit circle, represented by a Nat, and multiplies it by the respective point:\n\nSo, for example, will multiply by , which is approximately . This completely removes the need for computing , , , and the like, simplifying the computation from:\n\nIn other words, all the complex floating point arithmetic, including trigonometric and exponentiation functions, are replaced by the function above, which is just a simple recursive pass over the tree structure!\n\nAfter all this, we're finally able to implement a complete FFT algorithm, in 40 lines of Haskell code, with just plain ADTs:\n\nYes, this the a complete implementation! Note in this version I'm actually using the primitive Haskell , but, as we've stablished, it can be implemented with just ADTs via balanced ternary. Here is a complete Haskell file which performs FFT using GNs, with some helper functions to convert it from and to lists of normal complex numbers, for visualization.\n\nSo, how does this behave on the HVM? I don't know. I've just finished implementing it on Haskell and will spend some time trying to adjust it for the HVM in the future. There are many things to tweak. For example, isn't necessary and can easily be removed; Nat angles can be replaced by a twiddle multiplier; could be simplified, perhaps. But, as is, this gets rid of most of the inefficiencies with common FFT, and, as far as I know, is the cleanest version of FFT in a pure functional sense. If you like it, feel encouraged to join the Higher Order Community to talk about it and ask any questions. Thanks for reading!\n\nEdit: read the comments below for a cool surprise :)"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/lang/Math.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://bito.ai/resources/java-math-class-api-java-explained",
        "document": "The Java Math Class API provides a powerful set of functions and constants that can be used to perform common math calculations. Many of the most commonly used functions in Java, such as random numbers, sines, cosines, logarithms, and other typically math-related operations are all included in this API. This article will provide a comprehensive overview of the Java Math Class, its various functions and constants, benefits of using it, and best practices for working with it.\n\nThe Java Math Class is part of the Java Development Kit (JDK), and is a set of classes and functions designed to provide a range of math-related operations. It offers classes such as and , which allow for a wide variety of math-related operations. This article will focus on the class, its capabilities, and how to use it with Java programming.\n\nThe Math class provides a wide range of mathematical operations, including trigonometric functions, exponential functions, and logarithmic functions. It also provides methods for calculating the square root, absolute value, and rounding of numbers. Additionally, the Math class provides methods for generating random numbers, which can be used for a variety of purposes.\n\nIn order to use the Java Math Class, its functions must be imported into the program. This can be done with the following code:\n\nOnce the class has been imported, it is ready to use. The class offers a variety of different techniques for manipulating numbers and other mathematical calculations. The class also provides constants such as , which stores the value of Pi in the program.\n\nThe Java Math Class also provides a range of methods for performing basic mathematical operations such as addition, subtraction, multiplication, and division. These methods can be used to perform calculations on numbers, and can be used to create complex mathematical equations. Additionally, the class also provides methods for calculating the square root, logarithm, and trigonometric functions.\n\nBenefits of Using the Java Math Class\n\nThe main benefit of using the Java Math Class is its ability to quickly and accurately perform a wide range of math-related operations. The class is designed to handle operations such as sines, cosines, logarithmic calculations, random number generation, and more. In addition to this, the class is highly compatible with a variety of programming languages and can be used in native Java code as well as mobile applications or web-based development.\n\nThe Java Math Class also provides a number of useful methods for manipulating numbers, such as rounding, truncating, and converting between different numerical formats. This makes it an ideal choice for developers who need to perform complex calculations or manipulate data in a variety of ways. Furthermore, the class is designed to be highly efficient, meaning that it can be used to perform calculations quickly and accurately without taking up too much of the system’s resources.\n\nBest Practices for Working with the Java Math Class\n\nWhen working with the Java Math Class, there are several best practices that should be followed. First, all calculations should have their limits specified in the code. Second, use the constants provided by the class where possible for more accurate results. Third, always test your code before deploying it in any production environment to ensure that it works correctly. Lastly, always keep a close eye on any data passed into calculations and make sure it is correctly formatted for use in the math-related operations.\n\nAdditionally, it is important to be aware of the potential for overflow errors when working with the Java Math Class. Overflow errors can occur when the result of a calculation exceeds the maximum value that can be stored in the data type being used. To avoid this, it is important to use the appropriate data types for calculations and to check the results of calculations for potential overflow errors.\n\nCommonly Used Functions of the Java Math Class\n\nThe Java Math Class contains several commonly used functions that can be used to perform math-related operations. These functions include methods like , , , , , , and more. Each of these functions have a specific purpose, and understanding them is integral in utilizing the Java Math Class.\n\nIn addition to the functions mentioned above, the Java Math Class also contains several other useful functions such as , , , , and . These functions can be used to perform various mathematical operations, such as rounding numbers, generating random numbers, and calculating the sine of an angle. Knowing how to use these functions is essential for any programmer who wants to make use of the Java Math Class.\n\nUnderstanding the Parameters of the Java Math Class\n\nWhen making calls to various functions provided by the Java Math Class, understanding what parameters they require is extremely important. Many of these functions are overloaded, meaning that they can be called with different sets of parameters depending on the type and complexity of the math operation being performed. For example, has eight different versions depending on the number of parameters passed in.\n\nIt is important to note that the parameters passed into the Java Math Class functions must be of the correct type. For example, if a function requires an integer, passing in a string will result in an error. Additionally, some of the functions require specific ranges of values for the parameters, so it is important to check the documentation for the function before using it.\n\nOne of the most commonly used functions in the Java Math Class is the random number generator. It allows for quick and easy generation of random numbers between two given bounds. This can be done with a single line of code like this:\n\nThis generates a random integer between the two specified bounds (inclusive). It should be noted that these bounds should always be specified when calling the random number generator.\n\nIt is also important to note that the random number generator is not cryptographically secure, and should not be used for any applications that require secure random numbers. Additionally, the random number generator is not thread-safe, so it should not be used in multi-threaded applications.\n\nWhen working with the Java Math Class, there are bound to be some issues that come up. One of the most common issues is incorrect formatting or data types used in calculations. When these occur, it’s important to ensure that all data passed into any math functions has the correct format and type for the calculation being performed. Another common issue is not specifying limits when calling the randomly number generator.\n\nHow to Use the Java Math Class for Complex Calculations\n\nThe Java Math Class can be used for more complex mathematics operations like solving equations, finding roots and integrals, and more. To use these more complex calculations, an understanding of how the class and its functions work is necessary. For example, one might need to use , , or other advanced methods to get the desired result.\n\nAt its core, understanding how to use the Java Math Class effectively requires a good foundational knowledge of mathematics and the language’s specific syntax when working with it. Taking the time to understand this class can lead to more efficient coding and better performance in applications that rely heavily on mathematical computations."
    },
    {
        "link": "https://jenkov.com/tutorials/java/math-operators-and-math-class.html",
        "document": "Java contains a set of built-in math operators for performing simple math operations on Java variables. The Java math operators are reasonably simple. Therefore Java also contains the Java Math class which contains methods for performing more advanced math calculations in Java. This Java math tutorial will take a closer look at both Java's math operators as well as the Java Math class.\n\nLet me first explain you the four basic math operators in Java. The Java math operators are:\n\nEach of these math operators will be explained in more detail in the following sections.\n\nThe operator performs an addition of two values. This can be an addition of two constants, a constant and a variable, or a variable and a variable. Here are a few Java addition examples:\n\nThe operator will replace the two values with the sum of the two values at runtime. So at the place where the expression is written, at runtime this will be replaced with the sum of the value of and the constant value .\n\nYou can of course create longer chains of additions and thus add more than two numbers. Here is a en example of adding 3 or more values together:\n\nA commonly used math operation on variables is to set the variable equal to its own value plus another value. Here is how that looks:\n\nThe second line of this example sets the variable equals to its own value (before being assigned the new value) + 20. Which means 10 + 20.\n\nSince adding a value to a variable is a very common operation, Java contains a built-in operator for that specific purpose. It is the operator. Here is the example above rewritten to use the operator:\n\nThe second line in this example adds 20 to the variable . This equivalent to the code\n\nThe operator performs subtraction of one value from another. This can be a subtraction of a constant value from another constant value, a constant value from a variable, or a variable from a variable. Here are a few Java subtraction examples:\n\nThe operator will replace the two values with the difference between the two values, just like with the operator.\n\nYou can create longer chains of subtractions and thus subtract more values from each other. Here is an example of subtracting two values from another in a single Java statement:\n\nThis works for variables too.\n\nRemember, minus minus equals plus, just like in normal math. Here is an example of that:\n\nAfter executing this math expression the variable will contain the value because is equal to according to standard math rules.\n\nJust like with addition, Java contains an operator specifically targeted at subtracting a value from a variable, and assigning the result to the variable. Here is first how that would look in Java without this operator:\n\nHere is how the same math operation looks with the operator:\n\nThe operator performs multiplication of two values. The values can be either two constant values, a variable and a constant value, or two variables. Here are a few Java multiplication examples:\n\nThe operator will replace the multiplication math expression with the product of the two values at runtime.\n\nYou can create longer chains of multiplication using the operator. Here is an example of multiplying 3 values with each other:\n\nMultiplying a variable with a value and assigning the value back to the variable is a common math operation in Java applications. Therefore Java contains an explicit operator for this operation. The operator. Here is first how the calculation would look without the operator:\n\nThe second line of this example multiplies the value of the variable (before being assigned the result of this calculation) with 20 and assigns the value back to the variable.\n\nHere is how the same math operation looks with the operator:\n\nThe operator performs division of one value by another. This can be dividing one constant with another, dividing a variable with a constant, or dividing one variable by another variable. Here are a few Java division examples:\n\nYou can chain multiple values for division, but because of the Java math operator precedence (explained later) you have to pay attention to how you chain the values. Look at this division example:\n\nAfter executing this math expression the variable will contain the value 5. That is the result because the math expression was calculated by first dividing 100 by 10 (= 10) and then 10 by 2 (=5). But, what if you had wanted to first divide the 10 by 2 (=5), and then divide the 100 by 5 (=20) ? You would have had to use parentheses to achieve that, like this:\n\nYou will learn more about operator precedence and parentheses later in this Java math tutorial.\n\nJava also contains a shortcut operator for dividing the value of a variable by another value, and assigning that value back to the variable. The operator. Here is first how that math operation looks in Java without the operator:\n\nThe second line of this example divides the value of the variable (the value it had before being assigned the result of this calculation) by 5, and assigns the result back to the variable.\n\nHere is how the same math operation looks with the operator:\n\nThe remainder math operation performs an integer division of one value by another and returns the remained of that division. The remainder operation is also called the modulo operation. The operator for the remainder / modulo operation is the (percentage) character. Here is a module operation example:\n\n100 divided by 9 is 11 with a remainder of 1 (11 times 9 is 99). Thus, the variable is assigned the value 1.\n\nJava also contains a shortcut operator for dividing a variable by another value and assigning the remainder of that division to the variable. The operator. Here is an example:\n\nThe second line of this example will assign the value 1 to the variable. 1 is the result of 100 % 9.\n\nOnce you start combining the Java math operators in math expressions it becomes important to control what calculations are to be executed when, in order to get the desired result. The Java math operators have a natural operator precedence which is similar to the precedence of standard math operators.\n\nThe math operators and for multiplication and division takes precedence over the and operators. That means, that multiplications and divisions are evaluated before addition and subtraction in math expressions. In case there are multiple and operators they will be calculated from left to right. Look at this Java math expression:\n\nFirst the multiplications and divisions are executed. There are two groups of three multiplications and divisions. Each group is executed from left to right:\n\nAfter calculating the multiplications and divisions the math expression looks like this:\n\nNow the additions and subtractions are executed. The value assigned to the variable is thus .\n\nYou can control the operator precedence and sequence of calculations in math expressions in Java using parentheses. Math expressions inside parentheses have higher precedence than any other operator. Therefore expressions inside parentheses are calculated first. Inside parentheses the normal operator precedence applies. Here is the math expression from earlier, but with parentheses inserted which change the calculation:\n\nThe value 100 is still multiplied by 100 (= 10,000), but now it is divided by 5 + 200 (=205) instead of 5. After this division the result is multiplied by 3 and then divided by 2. The result of executing this math expression in Java is 72 (rounding of calculations affect the result).\n\nMath operations performed on Java integer types ( , , and ) behaves slightly different from how normal math operations work. Since Java integer types cannot contain fractions, each calculation involving one or more integer types have all fractions in the result cut off. Look at this math expression:\n\nThe result of this division would be 12.5 , but since the two numbers are integers, the .5 fraction is cut off. The result is therefore just 12.\n\nThe rounding also occurs in subresults of larger calculations, as you will learn in the next section about Java floating point math.\n\nJava contains the two floating point data types and . These floating point types are capable of containing fractions in the numbers. If you need fractions in your math expressions you should use one of these data types. Here is a Java floating point math expression example:\n\nEven though the variable is now a floating point type ( ), the final result is still just 12 instead of 12.5 . The reason for that is that the two values in the math expression (100 and 8) are both integers. Thus, the result of dividing one by the other is first converted to an integer (12) before being assigned to the variable.\n\nTo avoid rounding of calculations in math expressions in Java you must make sure that all data types involved in the math expression are floating point types. For instance, you could first assign the values to floating point variables like this:\n\nNow the variable would end up with the value 12.5.\n\nJava has a way to force all numbers in a calculation to be floating point variables. You suffix the numbers with either a capital F or D. Here is an example:\n\nNotice the uppercase Ds after each number. This uppercase D tells Java that these numbers are to be interpreted as floating point numbers, and thus the division is supposed to be a floating point division which keeps fractions instead of cutting them off.\n\nYou can actually also force a number to be a by suffixing the number with an uppercase L, but is still an integer type, so it will still not keep the fractions in calculations.\n\nJava floating point data types are not 100% precise. You can experience situations where numbers with many fractions on do not add up to the number you expected. If a floating point calculation results in a number with more fractions than a or a can handle, fractions may be cut off. Granted, the given precision may still more than enough for many types of calculations, but keep in mind that fractions may actually get cut off.\n\nLook at this Java floating point math code:\n\nThe output printed when executing this code with Java 8 is:\n\nThe first statement correctly prints the value , which is the start value of the the variable.\n\nThe second statement however prints a somewhat strange result. Adding the value 0.01 to 0 a total of 100 times should result in the value 1.0, right? But somehow the final result is . As you can see, somehow something goes wrong way down in the fractions.\n\nUsually the Java floating point imprecision is insignificant, but it is still important to be aware of it.\n\nThe Java class provides more advanced mathematical calculations than what the basic Java math operators provide. The class contains methods for finding the maximum or minimum of two values, rounding values, logarithmic functions, square root, and trigonometric functions (sin, cos, tan etc.).\n\nThe is located in the package, and not in the package. Thus, the fully qualified class name of the class is .\n\nSince many of the functions of the class are independent from each other, each method will be explained in its own section below.\n\nThe contains a set of basic math functions for obtaining the absolute value, highest and lowest of two values, rounding of values, random values etc. These basic math functions of the Java class will be covered in the following sections.\n\nThe function returns the absolute value of the parameter passed to it. The absolute value is the positive value of the parameter. If the parameter value is negative, the negative sign is removed and the positive value corresponding to the negative value without sign is returned. Here are two method examples:\n\nThe absolute value of 10 is 10. The absolute value of -20 is 20.\n\nThe method is overloaded in 4 versions:\n\nWhich of these methods are called depends on the type of the parameter passed to the method.\n\nThe function rounds a floating point value up to the nearest integer value. The rounded value is returned as a . Here is a Java example:\n\nAfter executing this Java code the variable will contain the value .\n\nThe function rounds a floating point value down to the nearest integer value. The rounded value is returned as a . Here is a Java example:\n\nAfter executing this Java code the variable will contain the value .\n\nThe method divides one integer ( or ) by another, and rounds the result down to the nearest integer value. If the result is positive, the effect is the same as using the Java division operator described earlier in this text.\n\nIf the result is negative, however, the result is not the same. With the division operator the fractions are simply truncated. For positive numbers this corresponds to rounding down. For negative numbers though, truncating the fractions correspond to rounding up. The method rounds down to the nearest negative integer, instead of the rounding up that would occur with fraction truncation.\n\nHere is a Java example:\n\nThe output printed from this Java code is:\n\nThis shows the difference between the division operator and .\n\nThe method returns the smallest of two values passed to it as parameter. Here is a Java example:\n\nAfter executing this code the variable will contain the value 10.\n\nThe method returns the largest of two values passed to it as parameter. Here is a Java example:\n\nAfter executing this code the variable will contain the value 20.\n\nThe method rounds a or to the nearest integer using normal math round rules (either up or down). Here is a Java example:\n\nAfter executing these two Java statements the variable will contain the value , and the variable will contain the value .\n\nThe method returns a random floating point number between 0 and 1. Of course the number is not fully random, but the result of some calculation which is supposed to make it as unpredictable as possible. Here is a Java example:\n\nTo get a random value between 0 and e.g. 100, multiply the value returned by with the maximum number (e.g. 100). Here is an example of how that might look:\n\nIf you need an integer value, use the , or method.\n\nThe Java class also contains a set of functions intended for exponential and logarithmic calculations. I will cover some of these math functions in the following sections.\n\nThe function returns e (Euler's number) raised to the power of the value provided as parameter. Here is a Java example:\n\nWhen this Java math code is executed it will print this output:\n\nThe method provides the logarithm of the given parameter. The base for the logarithm is i (Euler's number). Thus, provides the reverse function of . Here is a Java example:\n\nThe output from this example is:\n\nThe method works like the method except is uses 10 as is base for calculating the logarithm instead of e (Euler's Number). Here is a Java example:\n\nThe output printed from this Java example would be:\n\nThe function takes two parameters. The method returns the value of the first parameter raised to the power of the second parameter. Here is a Java example:\n\nThe output from this example would be:\n\nIn other words, the example calculate the values of 22 and 2 which are 4 and 256.\n\nThe method calculates the square root of the parameter given to it. Here are a few Java example:\n\nThe output printed from these Java examples would be:\n\nThe Java class contains a set of trigonometric functions. These functions can calculate values used in trigonometry, like sine, cosine, tangens etc. I will cover the most used trigonometry functions in the following sections. If you are looking for a trigonometric function and you cannot find it here, check the JavaDoc for the Java class. The class just might have the function you are looking for, even if I have not described it here.\n\nThe constant is a with a value that is very close to the value of PI - the mathematical definition of PI. You will often need the field when making trigonometric calculations.\n\nThe method calculates the sine value of some angle value in radians. Here is a Java example:\n\nThe method calculates the cosine value of some angle value in radians. Here is a Java example:\n\nThe method calculates the tangens value of some angle value in radians. Here is a Java example:\n\nThe method calculates the arc sine value of a value between 1 and -1. Here is a Java example:\n\nThe method calculates the arc cosine value of a value between 1 and -1. Here is a Java example:\n\nThe method calculates the arc tangens value of a value between 1 and -1. Here is a Java example:\n\nI am not exactly sure what method does mathematically. Here is what the JavaDoc says:\n\n\"Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta)\".\n\nIf you need this method, please read the JavaDoc. But now you know at least that it exists.\n\nThe method calculates the hyperbolic sine value of a value between 1 and -1. Here is a Java example:\n\nThe method calculates the hyperbolic cosine value of a value between 1 and -1. Here is a Java example:\n\nThe method calculates the hyperbolic tangens value of a value between 1 and -1. Here is a Java example:\n\nThe method converts an angle in radians to degrees. Here is a Java example:\n\nThe method converts an angle in degrees to radians. Here is a Java example:"
    },
    {
        "link": "https://baeldung.com/java-complex-numbers",
        "document": "In this tutorial, we’ll examine arithmetic operations on complex numbers. Specifically, we’ll explore how to perform addition, subtraction, multiplication, and division of two complex numbers in Java.\n\nComplex numbers are expressed using a combination of real and imaginary parts. They are generally denoted as a+bi, where a and b are real numbers and i represents the imaginary unit equivalent to the square root of -1. In formal mathematical notation, a is the real part of the complex number, and the term bi is the imaginary component. Complex numbers, although initially confusing for newcomers, play a crucial role in various practical applications, such as physics and mathematics, including fields like quantum mechanics, signal processing, and economics.\n\nLike real numbers, we can perform arithmetic operations such as addition, subtraction, multiplication, and division. Performing arithmetic operations on complex numbers introduces complexities due to the combination of real and imaginary parts. However, specific formulas exist for each of these operations, which streamline them and ensure accurate results.\n\nWe can set up the required foundational code before implementing the arithmetic operations on complex numbers. Let’s start with defining a class for representing complex numbers:\n\nThe above class defines the real and imaginary parts of a complex number. We utilized the record keyword to define the class to represent the complex number. Moreover, we defined the toString() method to return the complex number in the typical format of a+bi.\n\nAdditionally, the fromString() method is overridden to parse a string representation of a complex number into the ComplexNumber record. We utilized regular expression groups to extract the real and imaginary parts from the string.\n\nIn the subsequent sections, we can enhance this record by adding methods to perform various arithmetic operations.\n\nNow that the basic setup is ready, let’s implement the method for adding two complex numbers. Complex number addition involves adding the real and imaginary parts of two numbers separately to obtain the resultant number. To provide a clearer understanding, let’s establish the addition formula. Let’s look at the formula for addition of two complex numbers:\n\nLet’s translate this formula into Java code and incorporate it into the ComplexNumber record:\n\nWe can directly access the real and imaginary components from the record and combine them with the given complex number within the method.\n\nSubtracting two complex numbers involves subtracting their real and imaginary parts separately. When subtracting complex numbers a+bi and c+di, we subtract the real parts (a and c) and the imaginary parts (b and d) separately, resulting in a new complex number with the real part as the difference of the original real parts and the imaginary part as the difference of the original imaginary parts. Here is the formula for the subtraction operation:\n\nLet’s implement the method for subtraction in Java:\n\nThis implements the subtraction using the formula (a-c)+(b-d)i.\n\nUnlike addition and subtraction, multiplication of two complex numbers is not so straightforward. Let’s look at the formula for the multiplication:\n\nWe can translate this formula into Java code and add the method to multiply two complex numbers:\n\nThe above method implements the algorithm for the complex number multiplication.\n\nDivision of two complex numbers is even more complicated than multiplication. It involves a more complex formula:\n\nThe above method effectively divides two complex numbers. It incorporates error handling to prevent division by zero and provides a clear error message in such cases.\n\nNow that we have implemented the arithmetic operations on two complex numbers, let’s write test cases for each method. Complex numbers can have various forms, including those with only a real part, only an imaginary part, or both. To guarantee a robust implementation, we must thoroughly test our implementations across all these scenarios. For comprehensive coverage, we can utilize the parameterized tests from JUnit to test different inputs.\n\nTo maintain conciseness within this article, we will focus on a single test case demonstrating complex number division:\n\nIn the above implementation, we created a comprehensive test suite using @CsvSource to cover many complex number divisions. A custom utility method, isSame(), is implemented to compare the test results effectively. Similarly, we can implement the tests for other arithmetic operations with the same test parameters.\n\nAdditionally, we can also write an individual test to verify the divide-by-zero scenario:\n\nHere, we create a complex number where the real and imaginary parts are zero and then attempt to divide by it. Using assertThrows(), the test ensures an exception is thrown with the expected error message.\n\nIn this article, we implemented arithmetic operations on two complex numbers in Java. We explored addition, subtraction, multiplication, and division of complex numbers, implementing robust functionality through extensive test coverage. This includes utilizing parameterized tests to ensure the code functions correctly across various input values.\n\nAs always, the sample code used in this article is available over on GitHub."
    }
]