[
    {
        "link": "https://github.com/gin-gonic/gin",
        "document": "Gin is a web framework written in Go. It features a martini-like API with performance that is up to 40 times faster thanks to httprouter. If you need performance and good productivity, you will love Gin.\n\nGin requires Go version 1.23 or above.\n\nWith Go's module support, automatically fetches the necessary dependencies when you add the import in your code:\n\nTo run the code, use the command, like:\n\nThen visit in your browser to see the response!\n\nLearn and practice with the Gin Quick Start, which includes API examples and builds tag.\n\nA number of ready-to-run examples demonstrating various use cases of Gin are available in the Gin examples repository.\n\nSee the API documentation on go.dev.\n\nThe documentation is also available on gin-gonic.com in several languages:\n• Tutorial: Developing a RESTful API with Go and Gin\n\nGin uses a custom version of HttpRouter, see all benchmarks.\n• (4): Average Allocations per Repetition (allocs/op), lower is better\n\nYou can find many useful Gin middlewares at gin-contrib.\n\nHere are some awesome projects that are using the Gin web framework.\n\nGin is the work of hundreds of contributors. We appreciate your help!\n\nPlease see CONTRIBUTING.md for details on submitting patches and the contribution workflow."
    },
    {
        "link": "https://gin-gonic.com/docs",
        "document": "Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API, but with performance up to 40 times faster than Martini. If you need smashing performance, get yourself some Gin.\n\nHow to use Gin?\n\nWe provide API usage examples and list some publicly known Gin users.\n\nHow to contribute to Gin?\n• Help people on the discussion forums\n• Tell us your success stories using Gin\n• Tell us how we can improve Gin and help us do it"
    },
    {
        "link": "https://pkg.go.dev/github.com/gin-gonic/gin",
        "document": "See https://gin-gonic.com/ for more information about gin.\n\nEnvGinMode indicates environment name for gin mode.\n\nContextKey is the key that a Context returns itself for.\n\nAuthUserKey is the cookie name for user credential in basic auth.\n\nAuthProxyUserKey is the cookie name for proxy_user credential in basic auth for proxy.\n\nContent-Type MIME of the most common data formats.\n\nDefaultWriter is the default io.Writer used by Gin for debug output and middleware output like Logger() or Recovery(). Note that both Logger and Recovery provides custom ways to configure their output io.Writer. To support coloring in Windows use:\n\nDefaultErrorWriter is the default io.Writer used by Gin to debug errors\n\nIsDebugging returns true if the framework is running in debug mode. Use SetMode(gin.ReleaseMode) to disable debug mode.\n\nEnableJsonDecoderUseNumber sets true for binding.EnableDecoderUseNumber to call the UseNumber method on the JSON Decoder instance.\n\nEnableJsonDecoderDisallowUnknownFields sets true for binding.EnableDecoderDisallowUnknownFields to call the DisallowUnknownFields method on the JSON Decoder instance.\n\nDir returns a http.FileSystem that can be used by http.FileServer(). It is used internally in router.Static(). if listDirectory == true, then it works the same as http.Dir() otherwise it returns a filesystem that prevents http.FileServer() to list the directory files.\n\nContext is the most important part of gin. It allows us to pass variables between middleware, manage the flow, validate the JSON of a request and render a JSON response for example. CreateTestContextOnly returns a fresh context base on the engine for testing purposes Abort prevents pending handlers from being called. Note that this will not stop the current handler. Let's say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers for this request are not called. AbortWithError calls `AbortWithStatus()` and `Error()` internally. This method stops the chain, writes the status code and pushes the specified error to `c.Errors`. See Context.Error() for more details. AbortWithStatus calls `Abort()` and writes the headers with the specified status code. For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401). AbortWithStatusJSON calls `Abort()` and then `JSON` internally. This method stops the chain, writes the status code and return a JSON body. It also sets the Content-Type as \"application/json\". AddParam adds param to context and replaces path param key with given value for e2e testing purposes Example Route: \"/user/:id\" AddParam(\"id\", 1) Result: \"/user/1\" AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string. It also sets the Content-Type as \"application/json\". Bind checks the Method and Content-Type to select a binding engine automatically, Depending on the \"Content-Type\" header different bindings are used, for example: It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input. It decodes the json payload into the struct specified as a pointer. It writes a 400 error and sets Content-Type header \"text/plain\" in the response if input is not valid. BindUri binds the passed struct pointer using binding.Uri. It will abort the request with HTTP 400 if any error occurs. BindWith binds the passed struct pointer using the specified binding engine. See the binding package. ClientIP implements one best effort algorithm to return the real client IP. It calls c.RemoteIP() under the hood, to check if the remote IP is a trusted proxy or not. If it is it will then try to parse the headers defined in Engine.RemoteIPHeaders (defaulting to [X-Forwarded-For, X-Real-Ip]). If the headers are not syntactically valid OR the remote IP does not correspond to a trusted proxy, the remote IP (coming from Request.RemoteAddr) is returned. ContentType returns the Content-Type header of the request. Cookie returns the named cookie provided in the request or ErrNoCookie if not found. And return the named cookie is unescaped. If multiple cookies match the given name, only one cookie will be returned. Copy returns a copy of the current context that can be safely used outside the request's scope. This has to be used when the context has to be passed to a goroutine. Data writes some data into the body stream and updates the HTTP code. DataFromReader writes the specified reader into the body stream and updates the HTTP code. Deadline returns that there is no deadline (ok==false) when c.Request has no Context. DefaultPostForm returns the specified key from a POST urlencoded form or multipart form when it exists, otherwise it returns the specified defaultValue string. See: PostForm() and GetPostForm() for further information. DefaultQuery returns the keyed url query value if it exists, otherwise it returns the specified defaultValue string. See: Query() and GetQuery() for further information. GET /?name=Manu&lastname= c.DefaultQuery(\"name\", \"unknown\") == \"Manu\" c.DefaultQuery(\"id\", \"none\") == \"none\" c.DefaultQuery(\"lastname\", \"none\") == \"\" Done returns nil (chan which will wait forever) when c.Request has no Context. Err returns nil when c.Request has no Context. Error attaches an error to the current context. The error is pushed to a list of errors. It's a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil. File writes the specified file into the body stream in an efficient way. FileAttachment writes the specified file into the body stream in an efficient way On the client side, the file will typically be downloaded with the given filename FileFromFS writes the specified file from http.FileSystem into the body stream in an efficient way. FormFile returns the first file for the provided form key. FullPath returns a matched route full path. For not found routes returns an empty string. func (c *Context) Get(key string) (value any, exists bool) Get returns the value for the given key, ie: (value, true). If the value does not exist it returns (nil, false) GetBool returns the value associated with the key as a boolean. GetDuration returns the value associated with the key as a duration. GetFloat64 returns the value associated with the key as a float64. GetInt returns the value associated with the key as an integer. GetInt64 returns the value associated with the key as an integer. GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded form or multipart form when it exists `(value, true)` (even when the value is an empty string), otherwise it returns (\"\", false). For example, during a PATCH request to update the user's email: email=mail@example.com --> (\"mail@example.com\", true) := GetPostForm(\"email\") // set email to \"mail@example.com\" email= --> (\"\", true) := GetPostForm(\"email\") // set email to \"\" --> (\"\", false) := GetPostForm(\"email\") // do nothing with email GetPostFormArray returns a slice of strings for a given form key, plus a boolean value whether at least one value exists for the given key. GetPostFormMap returns a map for a given form key, plus a boolean value whether at least one value exists for the given key. GetQuery is like Query(), it returns the keyed url query value if it exists `(value, true)` (even when the value is an empty string), otherwise it returns `(\"\", false)`. It is shortcut for `c.Request.URL.Query().Get(key)` GetQueryArray returns a slice of strings for a given query key, plus a boolean value whether at least one value exists for the given key. GetQueryMap returns a map for a given query key, plus a boolean value whether at least one value exists for the given key. GetString returns the value associated with the key as a string. GetStringMap returns the value associated with the key as a map of interfaces. GetStringMapString returns the value associated with the key as a map of strings. GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings. GetStringSlice returns the value associated with the key as a slice of strings. GetTime returns the value associated with the key as time. GetUint returns the value associated with the key as an unsigned integer. GetUint64 returns the value associated with the key as an unsigned integer. func (c *Context) HTML(code int, name string, obj any) HTML renders the HTTP template specified by its file name. It also updates the HTTP code and sets the Content-Type as \"text/html\". See http://golang.org/doc/articles/wiki/ HandlerName returns the main handler's name. For example if the handler is \"handleGetUsers()\", this function will return \"main.handleGetUsers\". HandlerNames returns a list of all registered handlers for this context in descending order, following the semantics of HandlerName() Header is an intelligent shortcut for c.Writer.Header().Set(key, value). It writes a header in the response. If value == \"\", this method removes the header `c.Writer.Header().Del(key)` IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body. It also sets the Content-Type as \"application/json\". WARNING: we recommend using this only for development purposes since printing pretty JSON is more CPU and bandwidth consuming. Use Context.JSON() instead. IsAborted returns true if the current context was aborted. IsWebsocket returns true if the request headers indicate that a websocket handshake is being initiated by the client. JSON serializes the given struct as JSON into the response body. It also sets the Content-Type as \"application/json\". JSONP serializes the given struct as JSON into the response body. It adds padding to response body to request data from a server residing in a different domain than the client. It also sets the Content-Type as \"application/javascript\". MustBindWith binds the passed struct pointer using the specified binding engine. It will abort the request with HTTP 400 if any error occurs. See the binding package. MustGet returns the value for the given key if it exists, otherwise it panics. Negotiate calls different Render according to acceptable Accept format. Next should be used only inside middleware. It executes the pending handlers in the chain inside the calling handler. See example in GitHub. Param returns the value of the URL param. It is a shortcut for c.Params.ByName(key) router.GET(\"/user/:id\", func(c *gin.Context) { // a GET request to /user/john id := c.Param(\"id\") // id == \"john\" // a GET request to /user/john/ id := c.Param(\"id\") // id == \"/john/\" }) PostForm returns the specified key from a POST urlencoded form or multipart form when it exists, otherwise it returns an empty string `(\"\")`. PostFormArray returns a slice of strings for a given form key. The length of the slice depends on the number of params with the given key. ProtoBuf serializes the given struct as ProtoBuf into the response body. PureJSON serializes the given struct as JSON into the response body. PureJSON, unlike JSON, does not replace special html characters with their unicode entities. Query returns the keyed url query value if it exists, otherwise it returns an empty string `(\"\")`. It is shortcut for `c.Request.URL.Query().Get(key)` QueryArray returns a slice of strings for a given query key. The length of the slice depends on the number of params with the given key. Redirect returns an HTTP redirect to the specific location. RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port). Render writes the response headers and calls render.Render to render data. SecureJSON serializes the given struct as Secure JSON into the response body. Default prepends \"while(1),\" to response body if the given struct is array values. It also sets the Content-Type as \"application/json\". func (c *Context) Set(key string, value any) Set is used to store a new key/value pair exclusively for this context. It also lazy initializes c.Keys if it was not used previously. SetCookie adds a Set-Cookie header to the ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped. ShouldBind checks the Method and Content-Type to select a binding engine automatically, Depending on the \"Content-Type\" header different bindings are used, for example: It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input. It decodes the json payload into the struct specified as a pointer. Like c.Bind() but this method does not set the response status code to 400 or abort if input is not valid. ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request body into the context, and reuse when it is called again. NOTE: This method reads the body before binding. So you should use ShouldBindWith for better performance if you need to call only once. ShouldBindUri binds the passed struct pointer using the specified binding engine. ShouldBindWith binds the passed struct pointer using the specified binding engine. See the binding package. Stream sends a streaming response and returns a boolean indicates \"Is client disconnected in middle of stream\" String writes the given string into the response body. TOML serializes the given struct as TOML into the response body. func (c *Context) Value(key any) any Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result. XML serializes the given struct as XML into the response body. It also sets the Content-Type as \"application/xml\". YAML serializes the given struct as YAML into the response body.\n\nEngine is the framework's instance, it contains the muxer, middleware and configuration settings. Create an instance of Engine, by using New() or Default() Default returns an Engine instance with the Logger and Recovery middleware already attached. New returns a new blank Engine instance without any middleware attached. By default, the configuration is: - RedirectTrailingSlash: true - RedirectFixedPath: false - HandleMethodNotAllowed: false - ForwardedByClientIP: true - UseRawPath: false - UnescapePathValues: true Delims sets template left and right delims and returns an Engine instance. HandleContext re-enters a context that has been rewritten. This can be done by setting c.Request.URL.Path to your new target. Disclaimer: You can loop yourself to deal with this, use wisely. LoadHTMLFiles loads a slice of HTML files and associates the result with HTML renderer. LoadHTMLGlob loads HTML files identified by glob pattern and associates the result with HTML renderer. NoRoute adds handlers for NoRoute. It returns a 404 code by default. Routes returns a slice of registered routes, including some useful information, such as: the http method, path and the handler name. Run attaches the router to a http.Server and starts listening and serving HTTP requests. It is a shortcut for http.ListenAndServe(addr, router) Note: this method will block the calling goroutine indefinitely unless an error happens. RunFd attaches the router to a http.Server and starts listening and serving HTTP requests through the specified file descriptor. Note: this method will block the calling goroutine indefinitely unless an error happens. RunListener attaches the router to a http.Server and starts listening and serving HTTP requests through the specified net.Listener RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests. It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router) Note: this method will block the calling goroutine indefinitely unless an error happens. RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests through the specified unix socket (i.e. a file). Note: this method will block the calling goroutine indefinitely unless an error happens. SecureJsonPrefix sets the secureJSONPrefix used in Context.SecureJSON. SetFuncMap sets the FuncMap used for template.FuncMap. SetTrustedProxies set a list of network origins (IPv4 addresses, IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs) from which to trust request's headers that contain alternative client IP when `(*gin.Engine).ForwardedByClientIP` is `true`. `TrustedProxies` feature is enabled by default, and it also trusts all proxies by default. If you want to disable this feature, use Engine.SetTrustedProxies(nil), then Context.ClientIP() will return the remote address directly. Use attaches a global middleware to the router. i.e. the middleware attached through Use() will be included in the handlers chain for every single request. Even 404, 405, static files... For example, this is the right place for a logger or error management middleware. With returns a new Engine instance with the provided options.\n\nRouterGroup is used internally to configure router, a RouterGroup is associated with a prefix and an array of handlers (middleware). Any registers a route that matches all the HTTP methods. GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE. BasePath returns the base path of router group. For example, if v := router.Group(\"/rest/n/v1/api\"), v.BasePath() is \"/rest/n/v1/api\". GET is a shortcut for router.Handle(\"GET\", path, handlers). Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. For example, all the routes that use a common middleware for authorization could be grouped. Handle registers a new request handle and middleware with the given path and method. The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes. See the example code in GitHub. For GET, POST, PUT, PATCH and DELETE requests the respective shortcut functions can be used. This function is intended for bulk loading and to allow the usage of less frequently used, non-standardized or custom methods (e.g. for internal communication with a proxy). Match registers a route that matches the specified methods that you declared. Static serves files from the given file system root. Internally a http.FileServer is used, therefore http.NotFound is used instead of the Router's NotFound handler. To use the operating system's file system implementation, use : StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead. Gin by default uses: gin.Dir() StaticFile registers a single route in order to serve a single file of the local filesystem. router.StaticFile(\"favicon.ico\", \"./resources/favicon.ico\") StaticFileFS works just like `StaticFile` but a custom `http.FileSystem` can be used instead.. router.StaticFileFS(\"favicon.ico\", \"./resources/favicon.ico\", Dir{\".\", false}) Gin by default uses: gin.Dir() Use adds middleware to the group, see example code in GitHub."
    },
    {
        "link": "https://pkg.go.dev/github.com/gin-gonic/Gin",
        "document": "Gin is a web framework written in Go (Golang). It features a martini-like API with much better performance, up to 40 times faster thanks to httprouter. If you need performance and good productivity, you will love Gin.\n• API Examples\n• Try to bind body into different structs\n\nTo install Gin package, you need to install Go and set your Go workspace first.\n• Import it in your code:\n• (Optional) Import . This is required for example if using constants such as .\n\nNow Gin requires Go 1.6 or later and Go 1.7 will be required soon.\n• (4): Average Allocations per Repetition (allocs/op), lower is better\n• Still the fastest http router and framework. From routing to writing.\n• API frozen, new releases will not break your code.\n\nGin use as default json package but you can change to jsoniter by build from other tags.\n\nUsing GET, POST, PUT, PATCH, DELETE and OPTIONS\n\nSee the detail example code.\n\nTo bind a request body into a type, use model binding. We currently support binding of JSON, XML and standard form values (foo=bar&boo=baz).\n\nGin uses go-playground/validator.v8 for validation. Check the full docs on tags usage here.\n\nNote that you need to set the corresponding binding tag on all fields you want to bind. For example, when binding from JSON, set .\n\nAlso, Gin provides two sets of methods for binding:\n• Type - Must bind\n• Behavior - These methods use under the hood. If there is a binding error, the request is aborted with . This sets the response status code to 400 and the header is set to . Note that if you try to set the response code after this, it will result in a warning [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422 . If you wish to have greater control over the behavior, consider using the equivalent method.\n• Type - Should bind\n• Behavior - These methods use under the hood. If there is a binding error, the error is returned and it is the developer's responsibility to handle the request and error appropriately.\n\nWhen using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use or .\n\nYou can also specify that specific fields are required. If a field is decorated with and has a empty value when binding, an error will be returned.\n\nWhen running the above example using the above the command, it returns error. Because the example use for . If use for , then it will not return error when running the above example again.\n\nIt is also possible to register custom validators. See the example code.\n\nStruct level validations can also be registed this way. See the struct-lvl-validation example to learn more.\n\nfunction only binds the query params and not the post data. See the detail information.\n\nUsing SecureJSON to prevent json hijacking. Default prepends to response body if the given struct is array values.\n\nUsing JSONP to request data from a server in a different domain. Add callback to response body if the query parameter callback exists.\n\nUsing AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII chracters.\n\nUsing templates with same name in different directories\n\nYou can also use your own html template render\n\nYou may use custom delims\n\nSee the detail example code.\n\nGin allow by default use only one html.Template. Check a multitemplate render for using features like go 1.6 .\n\nIssuing a HTTP redirect is easy. Both internal and external locations are supported.\n\nIssuing a Router redirect, use like below.\n\nWhen starting new Goroutines inside a middleware or handler, you SHOULD NOT use the original context inside it, you have to use a read-only copy.\n\nUse directly, like this:\n\nSee the question and try the following example:\n\nDo you want to graceful restart or stop your web server? There are some ways this can be done.\n\nWe can use fvbock/endless to replace the default . Refer issue #296 for more details.\n• manners: A polite Go HTTP server that shuts down gracefully.\n• graceful: Graceful is a Go package enabling graceful shutdown of an http.Handler server.\n• grace: Graceful restart & zero downtime deploy for Go servers.\n\nIf you are using Go 1.8, you may not need to use this library! Consider using http.Server's built-in Shutdown() method for graceful shutdowns. See the full graceful-shutdown example with gin.\n\nYou can build a server into a single binary containing templates by using go-assets.\n\nSee a complete example in the directory.\n\nThe follow example using custom struct:\n\nIn a word, only support nested custom struct which have no now.\n\nTry to bind body into different structs\n\nThe normal methods for binding request body consumes and they cannot be called multiple times.\n\nFor this, you can use .\n• stores body into the context before binding. This has a slight impact to performance, so you should not use this method if you are enough to call binding at once.\n• This feature is only needed for some formats -- , , , . For other formats, , , , , can be called by multiple times without any damage to performance (See #1341).\n\nhttp.Pusher is supported only go1.8+. See the golang blog for detail information.\n\nThe package is preferable way for HTTP testing.\n\nTest for code example above:\n• drone: Drone is a Continuous Delivery platform built on Docker, written in Go"
    },
    {
        "link": "https://github.com/gin-gonic/gin/blob/master/docs/doc.md",
        "document": "\n• API Examples\n• Using GET, POST, PUT, PATCH, DELETE and OPTIONS\n• Bind default value if none provided\n• Try to bind body into different structs\n• Define format for the log of routes\n\nGin uses as default json package but you can change it by build from other tags.\n\nsonic (you have to ensure that your cpu support avx instruction.)\n\nGin enables rendering feature by default. But you can disable this feature by specifying build tag.\n\nThis is useful to reduce the binary size of executable files. See the detail information.\n\nYou can find a number of ready-to-run examples at Gin examples repository.\n\nSHOULD NOT be trusted. See on MDN and #1693\n\nSee the detail example code.\n\nBy default, logs output on console should be colorized depending on the detected TTY.\n\nTo bind a request body into a type, use model binding. We currently support binding of JSON, XML, YAML, TOML and standard form values (foo=bar&boo=baz).\n\nGin uses go-playground/validator/v10 for validation. Check the full docs on tags usage here.\n\nNote that you need to set the corresponding binding tag on all fields you want to bind. For example, when binding from JSON, set .\n\nAlso, Gin provides two sets of methods for binding:\n• Type - Must bind\n• Behavior - These methods use under the hood. If there is a binding error, the request is aborted with . This sets the response status code to 400 and the header is set to . Note that if you try to set the response code after this, it will result in a warning [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422 . If you wish to have greater control over the behavior, consider using the equivalent method.\n• Type - Should bind\n• Behavior - These methods use under the hood. If there is a binding error, the error is returned and it is the developer's responsibility to handle the request and error appropriately.\n\nWhen using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use or .\n\nYou can also specify that specific fields are required. If a field is decorated with and has an empty value when binding, an error will be returned.\n\nSkip validate: when running the above example using the above the command, it returns error. Because the example use for . If use for , then it will not return error when running the above example again.\n\nIt is also possible to register custom validators. See the example code.\n\nStruct level validations can also be registered this way. See the struct-lvl-validation example to learn more.\n\nfunction only binds the query params and not the post data. See the detail information.\n\nIf the server should bind a default value to a field when the client does not provide one, specify the default value using the key within the tag:\n\nNOTE: For default collection values, the following rules apply:\n• Since commas are used to delimit tag options, they are not supported within a default value and will result in undefined behavior\n• For the collection formats \"multi\" and \"csv\", a semicolon should be used in place of a comma to delimited default values\n• Since semicolons are used to delimit default values for \"multi\" and \"csv\", they are not supported within a default value for \"multi\" and \"csv\"\n\nUsing SecureJSON to prevent json hijacking. Default prepends to response body if the given struct is array values.\n\nUsing JSONP to request data from a server in a different domain. Add callback to response body if the query parameter callback exists.\n\nUsing AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII characters.\n\nNormally, JSON replaces special HTML characters with their unicode entities, e.g. becomes . If you want to encode such characters literally, you can use PureJSON instead. This feature is unavailable in Go 1.6 and lower.\n\nUsing templates with same name in different directories\n\nYou can also use your own html template render\n\nYou may use custom delims\n\nSee the detail example code.\n\nGin allow by default use only one html.Template. Check a multitemplate render for using features like go 1.6 .\n\nIssuing a HTTP redirect is easy. Both internal and external locations are supported.\n\nIssuing a Router redirect, use like below.\n\nWhen starting new Goroutines inside a middleware or handler, you SHOULD NOT use the original context inside it, you have to use a read-only copy.\n\nUse directly, like this:\n\nSee the question and try the following example:\n\nThere are a few approaches you can use to perform a graceful shutdown or restart. You can make use of third-party packages specifically built for that, or you can manually do the same with the functions and methods from the built-in packages.\n\nWe can use fvbock/endless to replace the default . Refer to issue #296 for more details.\n• grace: Graceful restart & zero downtime deploy for Go servers.\n• graceful: Graceful is a Go package enabling graceful shutdown of an http.Handler server.\n• manners: A polite Go HTTP server that shuts down gracefully.\n\nIn case you are using Go 1.8 or a later version, you may not need to use those libraries. Consider using 's built-in Shutdown() method for graceful shutdowns. The example below describes its usage, and we've got more examples using gin here.\n\nYou can build a server into a single binary containing templates by using the embed package.\n\nSee a complete example in the directory.\n\nThe follow example using custom struct:\n\nThe normal methods for binding request body consumes and they cannot be called multiple times.\n\nFor this, you can use or shortcuts.\n• stores body into the context before binding. This has a slight impact to performance, so you should not use this method if you are enough to call binding at once.\n• This feature is only needed for some formats -- , , , . For other formats, , , , , can be called by multiple times without any damage to performance (See #1341).\n\nhttp.Pusher is supported only go1.8+. See the golang blog for detail information.\n\nThe default log of routes is:\n\nIf you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with . In the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.\n\nGin lets you specify which headers to hold the real client IP (if any), as well as specifying which proxies (or direct clients) you trust to specify one of these headers.\n\nUse function on your to specify network addresses or network CIDRs from where clients which their request headers related to client IP can be trusted. They can be IPv4 addresses, IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs.\n\nAttention: Gin trust all proxies by default if you don't specify a trusted proxy using the function above, this is NOT safe. At the same time, if you don't use any proxy, you can disable this feature by using , then will return the remote address directly to avoid some unnecessary computation.\n\nNotice: If you are using a CDN service, you can set the to skip TrustedProxies check, it has a higher priority than TrustedProxies. Look at the example below:\n\nThe package is preferable way for HTTP testing.\n\nTest for code example above:"
    },
    {
        "link": "https://medium.com/@romulo.gatto/master-advanced-error-handling-logging-in-go-7d951d12e4a2",
        "document": "In Go, errors are treated as values returned from functions or methods that may deal with failure conditions.\n\nGo’s philosophy encourages developers to handle errors explicitly without using exceptions or try-catch blocks, which makes your code simpler but can require more discipline.\n\nCreating custom error types gives you more flexibility by attaching additional context about your errors.\n\nHere’s how you might define a custom error:\n\nYou can now use this type throughout your application for better diagnostics based on specific codes.\n\nGo 1.13 introduced enhanced support for wrapping errors using . This allows you to preserve original errors while providing additional context:\n\nThis technique is pivotal when you’re dealing with nested operations where multiple layers of functionality exist.\n\nThe built-in package provides functions like , , and other tools designed for more sophisticated handling and inspection of wrapped errors:\n\nThese methodologies allow powerful variations when filtering through different forms of potential failures throughout your application stack.\n\nUtilize third-party libraries such as , which offers a way to include stack traces along with the contextual information about an operation's success/failure state:\n\nThis will capture not just what went wrong but also where — adding vital debugging assistance when tracing back through logs during troubleshooting sessions.\n\nOnce we have proper control over our error-handling strategy set up; it’s equally important to ensure clear visibility into our processes via logging frameworks like .\n\nStructured logging helps maintain organization within logs even at scale enabling teams to identify patterns regarding specific problematic states quickly!\n\nBest Practices for Error Handling and Logging\n• Do Not Ignore Errors: Always check returned values from function calls that may fail.\n• Wrap Errors Meaningfully: When an operation fails deeper down the call chain wrap it correctly preserving its context instead of losing important details.\n• Use Context Wisely: Capture relevant request IDs or correlation IDs along processing chains so trends correlate directly against users/actions/events instigating uncertainty within service behaviors!\n• Avoid Logger Overheads on Performance Critical Paths: Be wary of executing heavy logging calls amid high throughput areas; prefer guard clauses around these segments ( ) whenever possible!\n\nBy following these guidelines alongside utilizing the advanced techniques above you’ll transform how your applications manage failures turning them from obscure issues into manageable metrics that foster system resilience overall!"
    },
    {
        "link": "https://withcodeexample.com/mastering-error-handling-logging-go-guide",
        "document": "Error handling is an essential aspect of writing reliable and robust software applications. In any programming language, errors are inevitable, and how you handle them can greatly impact the quality and stability of your code. In this article, we’ll explore the world of error handling in Go, understanding its importance, the concept of error values and types, and common error scenarios that programmers encounter.\n\nIn the world of software development, errors are bound to occur. Whether it’s a network failure, a file not found, or an unexpected input, your program needs to be equipped to deal with such situations. Proper error handling ensures that your application provides meaningful feedback to users, avoids crashes, and allows for graceful recovery from unexpected events.\n\nThe Importance of Handling Errors in Software Development\n• User Experience: When errors occur, users expect clear and informative error messages. Handling errors gracefully enhances the user experience by providing understandable explanations and guidance on how to proceed.\n• Stability: Unhandled errors can lead to program crashes or unexpected behavior, potentially compromising the stability of your application.\n• Debugging: Properly handled errors provide developers with valuable insights into what went wrong. This information can be crucial for debugging and fixing issues.\n• Maintainability: Code that handles errors effectively is easier to maintain and extend. It’s more resilient to changes and less prone to introducing new bugs.\n\nThe Importance of Logging in Application Development\n\nLogging provides insights into the behavior of your application, helping you identify issues, monitor performance, and track user interactions. It plays a crucial role in diagnosing errors, understanding application flow, and improving overall software quality.\n\nLog levels categorize log messages based on their severity. Common log levels include:\n\n – : General informational messages.\n\n – : Alerts about potential issues that don’t halt execution.\n\n – : Reports errors that impact the application’s functionality.\n\n – : Detailed information for debugging purposes, typically disabled in production.\n\nThe Concept of Error Values and Error Types in Go\n\nIn Go, errors are represented using the interface. This interface has a single method, , which returns a string describing the error. Go’s simplicity and elegance are reflected in its error handling approach. Instead of relying on exceptions or complex error hierarchies, Go uses simple values and interfaces.\n• File Operations: When working with files, errors can occur due to file not found, permissions issues, or disk full situations.\n• Network Operations: Network errors, like connection timeouts or refused connections, are common when communicating with remote servers or services.\n• User Input: Handling unexpected or invalid user input, such as incorrect format in a form, requires proper error handling.\n• Resource Depletion: Errors can arise from resource limitations, like running out of memory or exceeding maximum file descriptors.\n• Concurrency: In concurrent programs, race conditions and synchronization issues can lead to errors.\n\nError checking is an integral aspect of programming that ensures your code gracefully handles unexpected situations and maintains the reliability of your software. In this article, we will delve into the art of error checking, exploring the techniques, patterns, and best practices to effectively manage errors in your code.\n\nUsing Conditional Statements to Check for Errors\n\nConditional statements play a pivotal role in error checking. By evaluating whether an error has occurred, you can decide how to proceed in your code. Let’s examine a basic example:\n\nIn this example, the function returns an error when attempting to divide by zero. The function uses the pattern to check for an error and respond accordingly. By doing so, your code gracefully handles the potential error scenario.\n\nThe pattern is a common practice in Go for checking errors. It allows you to determine if a function call returned an error value and take appropriate action. Consider another example involving reading a file:\n\nHere, the function returns both the file content and an error. By using the pattern, you ensure that errors are handled and reported.\n\nError checking becomes more powerful when you handle different error cases based on the nature of the error. Consider the following example involving network connectivity:\n\nIn this scenario, the code checks if the error is of type and if it’s a timeout error using the method. Differentiating between error types allows you to provide specific responses and handling for each case.\n\nDefer and panic are two powerful mechanisms in Go that can significantly influence how your code handles unexpected situations and ensures resource management. In this article, we will explore the intricacies of defer, the panic function, and the panic-recover mechanism, along with the best practices for utilizing them effectively.\n\nThe statement in Go allows you to schedule a function call to be executed just before the surrounding function returns, whether it returns normally or due to a panic. This feature is particularly valuable for cleanup tasks, such as closing files or releasing resources.\n\nIn this example, the statement is deferred until after the statement is executed. The deferred task ensures that cleanup actions occur before the function exits.\n\nIn Go, is a built-in function that stops the normal flow of a program and initiates a panic. A panic typically indicates a run-time error, and it propagates up the call stack until it reaches a function that can handle it using the function.\n\nIn this example, the function uses the function to catch and handle a panic. The in the function triggers the panic, and the function recovers from it, allowing the program to continue execution.\n\nWhen to Use Panic and When to Avoid It\n\nPanic should be reserved for exceptional scenarios where continuing execution would be unsafe. It’s not suitable for regular error handling. Instead, you should use error values and the pattern for handling expected errors.\n• You encounter an unrecoverable error, such as a corrupted data file or a missing critical component.\n• You want to signal a developer mistake, like using an uninitialized variable.\n• The program is in an inconsistent state, and continuing would lead to unpredictable behavior.\n• You’re dealing with expected errors, like user input validation or network timeouts. Use proper error handling techniques for these cases.\n• You’re handling recoverable errors that can be addressed without interrupting program execution.\n• You’re trying to handle normal control flow or user interactions. Using panic for these situations would lead to poor user experience.\n\nError wrapping and context are advanced techniques in error handling that empower you to provide rich and informative error messages, making debugging and understanding errors significantly easier. In this article, we’ll delve into the art of error wrapping and context in Go, exploring how to add context to errors and leverage the package for enhanced error handling.\n\nAdding context to errors involves providing additional information about the circumstances in which an error occurred. The function allows you to wrap existing error messages with more context, creating a more informative error.\n\nIn this example, the verb in is used to wrap the original error with additional context. The resulting error message includes both the original error and the context.\n\nUsing the Package for Error Wrapping\n\nThe package, introduced in Go 1.13, provides more powerful error handling features. It includes functions for creating and manipulating errors, allowing for error wrapping with additional context and even stack traces.\n\nIn this example, the function is used to wrap an existing error with additional context. This results in an error message that includes the original error message as well as the context provided by the function.\n\nDetailed error messages provide developers with crucial information about what went wrong and where the error occurred. Instead of generic messages, strive to include specifics such as function names, input values, and relevant details.\n\nIn this example, the error message “empty data slice” provides a clear understanding of the error and why it occurred.\n\nHandling Errors with the Package in Go\n\nThe package introduced in Go 1.13 revolutionized error handling by providing a powerful set of tools to enhance the quality and clarity of error messages. In this article, we’ll explore the capabilities of the package, focusing on its features, the process of wrapping and formatting errors, and how to extract meaningful error messages and details for effective debugging.\n\nThe package enriches the error handling landscape in Go with the following features:\n• Wrapping Errors: The package enables you to wrap an existing error with additional context. This creates an error chain that preserves the original error while providing more context about the error’s occurrence.\n• Formatting Errors: By using formatting verbs similar to , you can create detailed error messages that include both the original error’s message and the added context.\n• Stack Traces: With the verb, the package can generate stack traces along with error messages. This helps pinpoint where the error originated.\n• Error Types: The package introduces the function that combines the functionality of and , allowing you to create formatted error messages with ease.\n\nThe primary function for wrapping errors in the package is . It combines formatting capabilities with the verb to wrap errors and add context.\n\nIn this example, the contains both the original error and the added context, creating a meaningful and informative error message.\n\nTo extract error messages and details from errors created with the package, you can use the function to retrieve the original error.\n\nIn this code, extracts the original error, allowing you to access the initial error message. By using , you can also access the stack trace, aiding in locating the error’s origin.\n\nError monitoring and tracking are paramount in ensuring the reliability and performance of your applications. Sentry, a powerful error tracking and monitoring platform, offers a seamless solution to capture, analyze, and respond to errors. In this article, we will delve into the significance of error monitoring, introduce Sentry as a comprehensive error tracking platform, and highlight the benefits of using Sentry for logging errors.\n\nError monitoring is a critical practice that involves actively monitoring your application for errors and exceptions. By identifying errors early and responding swiftly, you can prevent user frustration, improve application stability, and optimize user experience. Error monitoring provides insights into the health of your application, enabling you to address issues proactively and ensure uninterrupted service.\n\nOverview of Sentry as an Error Tracking and Monitoring Platform\n\nSentry is a leading error tracking and monitoring platform designed to help developers monitor, identify, and resolve errors in real time. It provides a comprehensive suite of tools that enable you to capture errors across various platforms, analyze error data, and collaborate effectively to resolve issues.\n\nBenefits of Using Sentry for Logging Errors\n• Real-time Error Capture: Sentry captures errors in real time, ensuring that you are alerted as soon as issues arise. This immediate feedback allows you to respond promptly and prevent prolonged downtimes.\n• Detailed Error Reports: Sentry provides detailed error reports that include information about the error’s context, stack trace, user information, and more. This rich data assists in diagnosing and fixing issues quickly.\n• Cross-Platform Support: Sentry supports multiple programming languages and platforms, including Go, JavaScript, Python, and more. This versatility makes it suitable for projects with diverse tech stacks.\n• Integration with Frameworks and Libraries: Sentry integrates seamlessly with popular frameworks and libraries, such as Angular, React, Django, and Flask. Integration is straightforward, enhancing your error tracking capabilities without extensive effort.\n• Issue Management and Collaboration: Sentry offers features for managing issues, assigning tasks, and collaborating with team members. This streamlined workflow facilitates efficient communication and resolution.\n• Customizable Alerting: You can set up custom alerts to receive notifications when specific errors occur. This proactive approach enables you to address issues before they impact users.\n\nLogging Errors to Sentry: Example with Go\n\nIntegrating Sentry into your application for error logging is straightforward. Here’s an example using Go and the client library:\n\nIn this example, the application initializes Sentry using the provided DSN, captures an error using , and ensures that any remaining data is sent to Sentry before the program exits.\n\nLogging is a fundamental practice in application development that empowers developers to monitor, troubleshoot, and enhance software applications. In this comprehensive guide, we’ll cover the importance of logging, introduce different log levels, explore logging libraries in Go, and dive into the specifics of logging to files. By the end of this article, you’ll have a strong understanding of effective logging practices and how to implement logging to files in your Go applications.\n\nOverview of Different Logging Libraries in Go\n\nGo offers various logging libraries, each catering to different needs. Some popular libraries include , , and . Choosing the right library depends on your project requirements and desired features.\n\nOverview of the Standard Package in Go\n\nGo’s standard library includes a basic logging package named . It provides a simple way to output log messages to the console.\n\nThe standard package doesn’t provide built-in log levels. However, you can control log levels by using conditional statements based on your requirements.\n\nThird-party logging libraries offer enhanced features compared to the standard package. Two popular choices are and .\n\nStructured logging formats log entries as JSON, making it easier to parse and analyze logs.\n\nBoth and allow you to customize log formatting and output destinations. For example, you can output logs to files.\n\nUsing third-party libraries like or allows you to implement log rotation to manage log files efficiently.\n\nYou can use a combination of log levels and log rotation to create effective file-based logging strategies that balance storage usage and retention.\n\nIn this comprehensive guide, we’ve embarked on a journey through the realm of error handling, logging, and monitoring in the context of Go programming. By understanding error handling mechanisms, leveraging advanced logging techniques, and integrating with error tracking platforms like Sentry, you’ll be equipped to build more resilient, maintainable, and user-friendly applications.\n\nHandling errors is not just about addressing unforeseen issues; it’s about enhancing user experience, maintaining application stability, and facilitating efficient debugging. By recognizing the importance of handling errors gracefully, you’re laying the foundation for robust software development."
    },
    {
        "link": "https://stackoverflow.com/questions/16963298/go-error-handling-techniques",
        "document": "I would agree with jnml's answer that they are both idiomatic code, and add the following:\n\nYour first example:\n\nis more idiomatic when dealing with more than one return value. for example:\n\nYour second example is nice shorthand when only dealing with the value. This applies if the function only returns an , or if you deliberately ignore the returned values other than the . As an example, this is sometimes used with the and functions that return an of the number of bytes written (sometimes unnecessary information) and an :\n\nThe second form is referred to as using an if initialization statement.\n\nSo with regards to best practices, as far as I know (except for using the \"errors\" package to create new errors when you need them) you've covered pretty much everything you need to know abut errors in Go!\n\nEDIT: If you find you really can't live without exceptions, you can mimic them with , & ."
    },
    {
        "link": "https://reddit.com/r/golang/comments/193uk0m/whats_the_best_way_to_handle_error_in_go",
        "document": "I am newbie to this lang and i was trying to create an endpoint through which i can upload a file and my code looked this...\n\nAs you can see i have four error checking if blocks and I realized that there might be better way to handle the error as i was writing the same code for 4 different time. i did google and found there is no try-catch and ChatGpt told me to write a handler func for the if block and use it four time. 😐😐😐. Anyway, Thank you for taking time to read this. please comment your thoughts on this, Thanks again!\n\nEdit: why do we not have a try-catch in golang ? Edit2:got my answer here https://m.youtube.com/watch?si=lVxsPrFRaMoMJhY2&v=YZhwOWvoR3I&feature=youtu.be Thanks everyone!"
    },
    {
        "link": "https://twilio.com/en-us/blog/error-handling-go-6-effective-approaches",
        "document": "Opinions expressed by Twilio contributors are their own\n\nOpinions expressed by Twilio contributors are their own\n\nIn languages like Java and C# error handling is primarily managed through the try-catch mechanism. When an error occurs within a try block, the catch block intercepts it, allowing the program to handle the error gracefully. This approach provides a structured way to deal with exceptions, ensuring that applications can respond to errors without crashing. However, Go takes a fundamentally different approach to error handling. Instead of using exceptions, Go treats errors as values that can be returned from functions. This means that instead of catching exceptions, Go programs check for errors after calling a function and then decide how to handle them. This approach emphasizes explicit error handling over implicit exception handling, leading to clearer code and better error management practices. In this article, we’ll take a look at some error handling techniques to help simplify how you manage errors in your code. Before going any further, ensure you have the following:\n• Go installed on your system. You can download it from the official website\n• A text editor or IDE of your choice to write and edit your Go code Go's built-in error type is foundational to its error-handling mechanism. This type is defined as an interface with a single method: , which returns a string describing the error. Any type that implements this method satisfies the error interface, allowing you to create custom error types easily. This simplicity and flexibility make the error type both powerful and easy to use, as it fits seamlessly into Go's overall design philosophy of straightforward, readable code. Here’s how to implement the error type:\n\nThe built-in errors package provides a straightforward way to create error instances using the function. This function takes a string and returns an error with that message. This simplicity encourages you to create meaningful error messages that can be easily understood and acted upon. Using the type often involves checking for errors immediately after a function call. This approach ensures that errors are handled at the point of occurrence, preventing them from propagating and causing more significant issues later in the execution flow. Below is an example illustrating how to implement error handling for a division operation, specifically addressing the scenario of division by zero. In the tutorial's project directory, create a new file named main.go. In that file, paste the code below.\n\nWhen you create and utilize custom error types, you can guarantee that errors are not merely managed but also conveyed distinctly to users. This strategy contributes to the development of more resilient and user-centric applications, as errors are more enlightening and comprehensible. Logging errors is an essential practice for debugging and monitoring applications. The package in Go offers a simple yet effective means to log errors and other messages. Logging errors enables you to monitor issues as they arise, comprehend the application's state, and spot patterns that might signal deeper problems. This practice is vital for sustaining an application's health and performance, particularly in production environments. Let’s look at another example that will demonstrate how to log errors. Replace the code in the main.go with the following code:\n\nWhen you consistently log errors, you maintain a transparent record of occurrences, aiding in troubleshooting and enhancing application reliability. Logging errors also helps in proactive monitoring and alerting. Through log analysis, you can discern patterns and trends indicative of impending issues, allowing for timely intervention and resolution, minimizing downtime, and improving the user experience. While Go's primary error handling mechanism relies on returning errors as values, the language also introduces panic and recover for exceptional conditions that cannot be addressed through regular error handling. Panics are used for situations where the program encounters an unrecoverable error and cannot proceed normally. This mechanism is typically reserved for serious issues, such as programming bugs or critical failures. However, Go also provides the ability to recover from panics, allowing the program to regain control and potentially continue execution in a controlled manner. How to use panic A panic in Go is a built-in function that stops the ordinary flow of control. When a function panics, it immediately stops execution and starts unwinding the stack, executing any deferred functions along the way. If a panic is not recovered, the program will terminate and produce a stack trace, which is useful for debugging. Here's an example of how to use panic in a Go program. Replace the code in main.go with the following code\n\nWhen to use panic and recover Panic is best used for unrecoverable errors that indicate a program bug, such as out-of-bounds array access, nil pointer dereference, or other conditions that should never occur in correct code. Avoid using for regular error handling. You can use to handle panics in situations where you need to clean up resources, log the error, or continue running the program despite a critical failure. Recover should be used in deferred functions to ensure that it captures panics effectively. That's the essentials of error handling in Go In this tutorial, we examined Go‘s approach to error handling by examining different error handling techniques. We also examined Go's panic and recovery mechanism in situations where exceptional conditions cannot be addressed through regular error handling. Explicit error handling promotes clarity and reliability, helping you build maintainable applications in Go. By following these techniques, you are well on your way to handling errors effectively and ensuring your application is resilient to unexpected conditions. Temitope Taiwo Oyedele is a software engineer and technical writer. He likes to write about things he’s learned and experienced."
    }
]