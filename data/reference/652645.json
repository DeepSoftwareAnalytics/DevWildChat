[
    {
        "link": "https://stackoverflow.com/questions/76608458/best-practice-for-managing-dynamic-allocated-memory-in-c",
        "document": "Qt has its own way of dealing with memory with QObjects, (QGraphicsScene inherits QObject). You passed as a parent, and we don't know which parent is referred to with , but if the parent ( ) outlives the QGraphicsScene you created you are fine. Because Qt will properly delete your QGraphicsScene when gets deleted. Qt world is a bit more complex than C++ world and allocating new objects on the heap there is the way to go without dealing with their deletion. However don't forget to delete any memory you allocated outside of Qt's world. Happy coding :)\n\nEdit: To go further and as a more general C++ advice, I'll add that your function is definitely a class method as you are allowed to use . If you want to manage the memory by yourself within this class, then you should store this pointer as a class attribute. Then in any other method could you delete this pointer. Even better, if the object you allocate is supposed to live exactly the same amount of time as your class referenced to as make it a non-pointer (plain instead of ) and initialize it as your class gets constructed and let the destruction automatically be handled by the compiler. But that's not always what you want with QObject-derived classes. Another powerfull C++ tool is to make use of RAII and allocate your pointer in the class constructor and delete it in the class destructor so that you still allocate it on the heap (if it's a large object or a large array for example - but for large arrays use really) and make sure you delete it properly no matter what."
    },
    {
        "link": "https://stackoverflow.com/questions/48243519/how-to-allocate-a-large-dynamic-array-in-c",
        "document": "You should be using 64-bit CPU and OS at this point, allocating huge contiguous chunk of memory should not be a problem, unless you are actually running out of memory. It is possible that you are building 32-bit program. In this case you won't be able to allocate more than 4 GB. You should build 64-bit application.\n\nIf you want something better than plain , then your question is OS-specific. Look at API provided by your OS: on POSIX system you should look for and for on Windows.\n\nThere are multiple problems with large allocations:\n• For security reasons OS kernel never gives you pages filled with garbage values, instead all new memory will be zero initialized. This means you don't have to initialize that memory as long as zeroes are exactly what you want.\n• OS gives you real memory lazily on first access. If you are processing large array, you might waste a lot of time taking page faults. To avoid this you can use on Linux. On Windows you can try (but I am not sure if it can do the job). This should make init allocation slower, but should decrease total time spent in kernel.\n• Working with large chunks of memory wastes slots in Translation Lookaside Buffer (TLB). Depending on you memory access pattern, this can cause noticeable slowdown. To avoid this you can try using large pages ( with , , on Linux, and ). Using large pages is not easy, as they are usually not available by default. They also cannot be swapped out (always \"locked in memory\"), so using them requires privileges.\n\nIf you don't want to use OS-specific functions, the best you can find in C++ is . Unlike or it returns zero initialized memory so you can probably avoid wasting time initializing that memory. Other than that, there is nothing special about that function. But this is the closest you can get while staying withing standard C++.\n\nThere are no standard containers designed to handle large allocations, moreover, all standard container are really really bad at handling those situations.\n\nSome OSes (like Linux) overcommit memory, others (like Windows) do not. Windows might refuse to give you memory if it knows it won't be able to satisfy your request later. To avoid this you might want to increase your page file. Windows needs to reserve that space on disk beforehand, but it does not mean it will use it (start swapping). As actual memory is given to programs lazily, there are might be a lot of memory reserved for applications that will never be actually given to them.\n\nIf increasing page file is too inconvenient, you can try creating large file and map it into memory. That file will serve as a \"page file\" for your memory. See and ."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-dynamically-allocate-an-array-in-cpp",
        "document": "How to Dynamically Allocate an Array in C++?\n\nIn C++, dynamic memory allocation allows us to allocate memory during runtime. Dynamic allocation in an array is particularly useful when the size of an array is not known at compile time and needs to be specified during runtime. In this article, we will learn how to dynamically allocate an array in C++.\n\nDynamic Allocation of Arrays in C++\n\nIn C++, we use the for . To allocate an dynamically,\n• None that will store the base address of the allocated array.\n• None Next, use the new operator to reserve memory space to accommodate an array of a particular data type.\n• None When making this allocation specify the size of the array that indicates how many elements it can contain. This specified size determines the amount of memory to be allocated.\n\nBelow is the general syntax for dynamically allocating an array in C++.\n• None is the type of data that we want to store in the array.\n• None is a keyword used for dynamic memory allocation.\n• None is the size of the array we want to allocate.\n\nC++ Program to Dynamically Allocate an Array\n\nThe below program demonstrates the dynamic array allocation in C++.\n\nTime Complexity: O(1)\n\nAuxilliary Space: O(n), where n is the size of the dynamically allocated array."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/zxs3fu/when_to_use_dynamic_memory_allocation",
        "document": "I notice that lots of std containers (e.g. vector) internally use a dynamically allocated array on the heap for storing elements. Initially, I don't get the motivations behind this design\n\nUnlike C, C++ does not support variable length arrays, so before creating any kind of object, the compiler first needs to figure out the size that is needed for that object, regardless of whether it is going to be allocated on heap or stack. Once an object is created, its memory is **fixed** and cannot be further enlarged\n\nAs a result, the only way to work around this is to dynamically allocate an array that allows the size to be determined at runtime\n\nSo is it a safe assertion to say that if we want to create any kind of data structure where the number of elements it can hold is not known ahead of time, ultimately we have to rely on some form of a dynamic array?\n\nI'm asking this because I was told that in modern C++ development dynamic memory allocation should be avoided at all costs. But I still think there must be some valid use cases"
    },
    {
        "link": "https://quora.com/How-can-you-dynamically-allocate-memory-for-an-array-in-C-and-what-is-the-significance-of-the-delete-operator-when-using-dynamic-arrays",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_files.asp",
        "document": "The library allows us to work with files.\n\nTo use the library, include both the standard AND the header file:\n\nThere are three classes included in the library, which are used to create, write or read files:\n\nTo create a file, use either the or class, and specify the name of the file.\n\nTo write to the file, use the insertion operator ( ).\n\n#include <iostream>\n\n#include <fstream>\n\nusing namespace std;\n\n\n\n int main() {\n\n // Create and open a text file\n\n ofstream MyFile(\"filename.txt\");\n\n\n\n // Write to the file\n\n MyFile << \"Files can be tricky, but it is fun enough!\";\n\n\n\n // Close the file\n\n MyFile.close();\n\n}\n\nTo read from a file, use either the or class, and the name of the file.\n\nNote that we also use a loop together with the function (which belongs to the class) to read the file line by line, and to print the content of the file:\n\nFor a complete reference of <fstream> classes and functions, go to our C++ fstream Reference."
    },
    {
        "link": "https://stackoverflow.com/questions/63766474/how-to-use-instream-and-ofstream-to-read-and-output-a-text-file",
        "document": "Put those definitions of and inside . Don't create global variables unless you absolutely have to.\n\nThe code loops through the input, and overwrites the contents of each time through the loop. When it reaches the end of the input, it writes out the first character in . It should either display what it read each time through the loop, or add each string that it reads into a container. If it's the former, the code would look like this:\n\nNote that the original code didn't use , so I left it out here. Also, when is an auto object (i.e., defined inside ), when returns it gets destroyed. One of the things that the destructor does is close the file, so there is no need to call .\n\nIf you want to put the input into some kind of collection, that's a straightforward change:\n\nIf you want to write the text to an output file, just do it:\n\nThat will write each word from the input onto a separate line in the output file. If you just want to copy the file unchanged, that's even easier:"
    },
    {
        "link": "https://cprogramming.com/tutorial/lesson10.html",
        "document": "This is a slightly more advanced topic than what I have covered so far, but I think that it is useful. File I/O is reading from and writing to files. This lesson will only cover text files, that is, files that are composed only of ASCII text. \n\n\n\n C++ has two basic classes to handle files, ifstream and ofstream. To use them, include the header file fstream. Ifstream handles file input (reading from files), and ofstream handles file output (writing to files). The way to declare an instance of the ifstream or ofstream class is: or \n\n\n\n The constructor for both classes will actually open the file if you pass the name as an argument. As well, both classes have an open command (a_file.open()) and a close command (a_file.close()). You aren't required to use the close command as it will automatically be called when the program terminates, but if you need to close the file long before the program ends, it is useful. \n\n\n\n The beauty of the C++ method of handling files rests in the simplicity of the actual functions used in basic input and output operations. Because C++ supports overloading operators, it is possible to use << and >> in front of the instance of the class as if it were cout or cin. In fact, file streams can be used exactly the same as cout and cin after they are opened. \n\n\n\n For example: The default mode for opening a file with ofstream's constructor is to create it if it does not exist, or delete everything in it if something does exist in it. If necessary, you can give a second argument that specifies how the file should be handled. They are listed below: For example: This will open the file without destroying the current contents and allow you to append new data. When opening files, be very careful not to use them if the file could not be opened. This can be tested for very easily: \n\n\n\n Want to level up your game? Check this C++ IDE, from our sponsor \n\n\n\n \n\nQuiz yourself \n\nPrevious: Strings \n\nNext: Typecasting \n\nBack to C++ Tutorial Index \n\n\n\n This is a slightly more advanced topic than what I have covered so far, but I think that it is useful. File I/O is reading from and writing to files. This lesson will only cover text files, that is, files that are composed only of ASCII text.C++ has two basic classes to handle files, ifstream and ofstream. To use them, include the header file fstream. Ifstream handles file input (reading from files), and ofstream handles file output (writing to files). The way to declare an instance of the ifstream or ofstream class is:orThe constructor for both classes will actually open the file if you pass the name as an argument. As well, both classes have an open command (a_file.open()) and a close command (a_file.close()). You aren't required to use the close command as it will automatically be called when the program terminates, but if you need to close the file long before the program ends, it is useful.The beauty of the C++ method of handling files rests in the simplicity of the actual functions used in basic input and output operations. Because C++ supports overloading operators, it is possible to use << and >> in front of the instance of the class as if it were cout or cin. In fact, file streams can be used exactly the same as cout and cin after they are opened.For example:The default mode for opening a file with ofstream's constructor is to create it if it does not exist, or delete everything in it if something does exist in it. If necessary, you can give a second argument that specifies how the file should be handled. They are listed below:For example:This will open the file without destroying the current contents and allow you to append new data. When opening files, be very careful not to use them if the file could not be opened. This can be tested for very easily:"
    }
]