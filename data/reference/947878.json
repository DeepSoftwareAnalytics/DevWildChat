[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to",
        "document": "How to write .NET objects as JSON (serialize)\n\nThis article shows how to use the System.Text.Json namespace to serialize to JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nTo write JSON to a string or to a file, call the JsonSerializer.Serialize method.\n\nThe following example creates JSON as a string:\n\nThe JSON output is minified (whitespace, indentation, and new-line characters are removed) by default.\n\nThe following example uses synchronous code to create a JSON file:\n\nThe following example uses asynchronous code to create a JSON file:\n\nThe preceding examples use type inference for the type being serialized. An overload of takes a generic type parameter:\n\nYou can also use GitHub Copilot to generate serialization code for you. For instructions, see the Use GitHub Copilot section in this article.\n• By default, all public properties are serialized. You can specify properties to ignore. You can also include private members.\n• The default encoder escapes non-ASCII characters, HTML-sensitive characters within the ASCII-range, and characters that must be escaped according to the RFC 8259 JSON spec.\n• By default, JSON is minified. You can pretty-print the JSON.\n• By default, casing of JSON names matches the .NET names. You can customize JSON name casing.\n• By default, circular references are detected and exceptions thrown. You can preserve references and handle circular references.\n• By default, fields are ignored. You can include fields.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n• None .NET primitives that map to JavaScript primitives, such as numeric types, strings, and Boolean.\n• None Collections and dictionaries from the following namespaces: For more information, see Supported types in System.Text.Json.\n\nYou can implement custom converters to handle additional types or to provide functionality that isn't supported by the built-in converters.\n\nHere's an example showing how a class that contains collection properties and a user-defined type is serialized:\n\nIt's 5-10% faster to serialize to a UTF-8 byte array than to use the string-based methods. That's because the bytes (as UTF-8) don't need to be converted to strings (UTF-16).\n\nTo serialize to a UTF-8 byte array, call the JsonSerializer.SerializeToUtf8Bytes method:\n\nA Serialize overload that takes a Utf8JsonWriter is also available.\n\nTo pretty-print the JSON output, set JsonSerializerOptions.WriteIndented to :\n\nStarting in .NET 9, you can also customize the indent character and size using IndentCharacter and IndentSize.\n\nUse GitHub Copilot to serialize to JSON\n\nYou can use GitHub Copilot in your IDE to generate code that uses to serialize to JSON. You can customize the prompt to use object fields that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview",
        "document": "The System.Text.Json namespace provides functionality for serializing to and deserializing from (or marshalling and unmarshalling) JavaScript Object Notation (JSON). Serialization is the process of converting the state of an object, that is, the values of its properties, into a form that can be stored or transmitted. The serialized form doesn't include any information about an object's associated methods. Deserialization reconstructs an object from the serialized form.\n\nThe library design emphasizes high performance and low memory allocation over an extensive feature set. Built-in UTF-8 support optimizes the process of reading and writing JSON text encoded as UTF-8, which is the most prevalent encoding for data on the web and files on disk.\n\nThe library also provides classes for working with an in-memory document object model (DOM). This feature enables random access to the elements in a JSON file or string.\n\nFor Visual Basic, there are some limitations on what parts of the library you can use. For more information, see Visual Basic support.\n\nHow to get the library\n\nThe library is built-in as part of the shared framework for .NET Core 3.0 and later versions. The source generation feature is built-in as part of the shared framework for .NET 6 and later versions.\n\nFor framework versions earlier than .NET Core 3.0, install the System.Text.Json NuGet package. The package supports:\n• The System.Text.Json namespace contains all the entry points and the main types.\n• The System.Text.Json.Serialization namespace contains attributes and APIs for advanced scenarios and customization specific to serialization and deserialization.\n• The System.Net.Http.Json namespace contains extension methods for serializing and deserializing JSON payloads from the network.\n\nBy default, gathers the metadata it needs to access properties of objects for serialization and deserialization at run time using reflection. As an alternative, can use the C# source generation feature to improve performance, reduce private memory usage, and facilitate assembly trimming, which reduces app size.\n\nFor more information, see Reflection versus source generation.\n\nFor information about security threats that were considered when designing JsonSerializer, and how they can be mitigated, see Threat Model.\n\nThe serializer was designed with thread safety in mind. Practically, this means that once locked, JsonSerializerOptions instances can be safely shared across multiple threads. JsonDocument provides an immutable, and in .NET 8 and later versions, thread-safe, DOM representation for JSON values.\n• How to use the library"
    },
    {
        "link": "https://dev.to/karenpayneoregon/c-systemtextjson-37m1",
        "document": "C# different way to do a proof of concept\n\nC# Excel read/write on the cheap\n\nGet SQL-Server Stored Procedures with C#\n\nGentle introduction to Generic Repository Pattern with C#\n\nUsing FluentScheduler with C#\n\nC# Different way to join string array\n\nTips on interacting with a database with C#\n\nWorking with the using directive in C#\n\nWorking with .zip files in C#\n\nWhen working with json using strong typed classes and perfect json using System.Text.Json functionality for the most part is easy although there can be roadblocks which this article will address.\n\nMicrosoft has documented working with json in the following two links, serialize and deserialize json which is well worth taking some time to review.\n\nUsing these two links is where things started for the following topics. Even with great documentation there are still things that need to be drill down into.\n\nJsonSerializerOptions is a class that provides a way to specify various serialization and deserialization behaviors.\n\nBoth of the above will be discussed later.\n\nIn the code sample provided, some samples will have options defined in the method for ease of working things out while others will use options from a class.\n\nExample with options in the method\n\nWhile the proper way would be\n\nJsonHelpers is a class in a separate class project with several predefined configurations.\n\nAnd for desktop typically set up at class level as a static read-only property.\n\nMost times when deserializing json property names are in the following format, Id, FirstName, LastName,BirthDate etc but what if json is id, firstname, lastname, birthdate?\n\nFor this we are working with the following model\n\nAnd are receiving the following json.\n• DeserializeLowerCasing method deserializes the json above and display the json to a console window\n\nImportant\n\n The deserialization option must, in this case match the same options as when serialized but let's look at it as matching the options from an external source.\n\nIts common place to use an Enum to represent options for a property, for this there is the JsonStringEnumConverter class which converts enumeration values to and from strings.\n\nExample using the following model.\n\nOption for this is in the class JsonHelpers.\n\nNote, if deserialization is missing the options a runtime exception is thrown.\n\nIf options are not defined for serialization the numeric values are provided, not the actual Enum member.\n\nWith ASP.NET Core and Razor Pages using the same model we can serialize and deserialize as done with desktop.\n\nOr use the method in JsonHelpers class\n\nTo get the following.\n\nThe other option is through adding options through WebApplicationBuilder in Program.cs\n\nThen alter the last method.\n\nIn this case, in index.cshtml.cs we setup the options using dependency injection.\n\nThere may be cases were json data has properties with spaces.\n\nFor this, specify the property name from json with JsonPropertyNameAttribute as shown below.\n\nC# Code (from provided code in a GitHub repository)\n\nFor more details on this and more like hyphens in property names see the following well written Microsoft documentation.\n\nThere may be cases were a json file is provided with your model expects an int.\n\nModel where Id is an int but in json a string.\n\nFor this, use in desktop projects or see below for another option using an attribute on the Id property.\n\nJsonSerializerOptions.NumberHandling indicates that gets or sets an object that specifies how number types should be handled when serializing or deserializing.\n\nJsonHelpers.WebOptions uses JsonSerializerDefaults.Web with the default to string quoted numbers as numeric.\n\nAnother method is to set an attribute for desktop or web.\n\nGiven the following created using Bogus Nuget package.\n\nThis is done using a custom converter as follows.\n\nCode which in this case gets a list and saves to a json file which produces the output above.\n\nSince the property UnitPrice is stored as a string we use the same technique already shown by setting NumberHandling = JsonNumberHandling.AllowReadingFromString.\n\nThere may be times when a property should not be included in serialization or deserialization.\n\nUse JsonIgnore attribute, here BirthDate will be ignored.\n\nWhich can be controlled with JsonIgnoreCondition Enum\n\nBy default, System.Text.Json uses the default public parameterless constructor. However, you can tell it to use a parameterized constructor, which makes it possible to deserialize an immutable class or struct.\n\nThe following demonstrates deserializing a struct where the constructor is decelerated with JsonConstructor attribute.\n\nYou can ignore properties on serialization and deserialization using JsonIgnoreCondition Enum.\n\nSuppose json data has an primary key which should be ignored when populating a database table using EF Core or that a gender property is not needed at all. The following first shows not ignoring properties Id and Gender while the second ignores Id and Gender.\n\nIn this sample data is read from a Microsoft NorthWind database table Employees to a dictionary with the key as first and last name and the value as the primary key. Dapper is used for the read operation.\n\nImportant Before running this code create the database and populate with populate.sql in the script folder of the project ReadOddJsonApp.\n\nMicrosoft's docs indicate: If you use JsonSerializerOptions repeatedly with the same options, don't create a new JsonSerializerOptions instance each time you use it. Reuse the same instance for every call.\n\nIn much of the code provided here violates the above as they are standalone code samples, best to follow above for applications.\n\nThis article provides information to handle unusual json formats and normal formatting as a resources with code samples located in a GitHub repository.\n• How to write custom converters for JSON serialization\n• What’s new in System.Text.Json in .NET 8"
    },
    {
        "link": "https://stackoverflow.com/questions/58331479/how-to-globally-set-default-options-for-system-text-json-jsonserializer",
        "document": "Instead of this:\n\nI would like to do something like this:\n\nThe hope is to not have to pass an instance of for our most common cases, and override for the exception, not the rule.\n\nAs indicated in this q & a, this is a useful feature of Json.Net. I looked in the documentation for as well as this GitHub repo for .NET Core. And this one.\n\nThere doesn't seem to be an analog for managing JSON serialization defaults in .NET Core 3. Or am I overlooking it?\n• None UPDATE [2020-07-18]: See this answer for a nuget package with convenience methods that honor default settings.\n• None UPDATE [2019-12-23]: Due in part to vocal community input this issue has been added to the roadmap for .NET 5.0.\n• None UPDATE [2019-10-10]: If interested in seeing this behavior implemented for head on over to the open GitHub issue pointed out by Chris Yungmann and weigh in."
    },
    {
        "link": "https://madhawapolkotuwa.medium.com/mastering-json-serialization-in-c-with-system-text-json-01f4cec0440d",
        "document": "Import the necessary namespaces. This includes for JSON processing and for handling advanced options like converters and reference handling.\" Define a simple class, which includes properties like , , , , and . This class represents the objects that will be serialized into JSON. public class Product\n\n{\n\n public int ID {get; set;}\n\n public string ProductName {get; set;}\n\n public string Category {get; set;}\n\n public decimal Price {get; set;}\n\n public DateTime PurchasedDate {get; set;}\n\n} Now, Let’s create a list of objects with some sample data. This data will demonstrate how JSON serialization handles different data types, including strings, numbers, and dates. One of the products has a value for the , which will help us showcase how deals with null values. List<Product> products = new List<Product>\n\n{\n\n new Product { ID = 2, ProductName = \"Harry Potter\", Category = \"Books\", Price = 24.99m, PurchasedDate = new DateTime(2024,09,24,10,20,30) },\n\n new Product { ID = 3, ProductName = \"Console\", Category = \"Electronics\", Price = 199.99m, PurchasedDate = new DateTime(2024,09,25,12,22,45) },\n\n new Product { ID = 4, ProductName = \"Pen\", Category = null, Price = 10.0m, PurchasedDate = new DateTime(2024,09,25,06,10,15) }, // Category is null\n\n new Product { ID = 5, ProductName = \"TShirt\", Category = \"Clothing\", Price = 49.99m, PurchasedDate = new DateTime(2024,09,27,08,12,20) },\n\n new Product { ID = 1, ProductName = \"Laptop\", Category = \"Electronics\", Price = 299.99m, PurchasedDate = DateTime.Now }\n\n};\n\nLet’s start by serializing the list of products using the default settings. This will convert the object graph into a JSON string, automatically handling types like strings, decimals, and dates [\n\n {\n\n \"ID\": 2,\n\n \"PrductName\": \"Harry Potter\",\n\n \"Category\": \"Books\",\n\n \"Price\": 24.99,\n\n \"PurchasedDate\": \"2024-09-24T10:20:30\"\n\n },\n\n {\n\n \"ID\": 3,\n\n \"PrductName\": \"Console\",\n\n \"Category\": \"Electronics\",\n\n \"Price\": 199.99,\n\n \"PurchasedDate\": \"2024-09-25T12:22:45\"\n\n },\n\n {\n\n \"ID\": 4,\n\n \"PrductName\": \"Pen\", /* In this case Category is null so it won't appear in the JSON output. */\n\n \"Price\": 10.0,\n\n \"PurchasedDate\": \"2024-09-25T06:10:15\"\n\n },\n\n {\n\n \"ID\": 5,\n\n \"PrductName\": \"TShirt\",\n\n \"Category\": \"Clothing\",\n\n \"Price\": 49.99,\n\n \"PurchasedDate\": \"2024-09-27T08:12:20\"\n\n },\n\n {\n\n \"ID\": 1,\n\n \"PrductName\": \"Laptop\",\n\n \"Category\": \"Electronics\",\n\n \"Price\": 299.99,\n\n \"PurchasedDate\": \"2024-09-27T09:55:51.3731903+09:00\"\n\n }\n\n] Change the property naming policy, such as using CamelCase or keeping original names. You can also implement a custom if you need more control over the transformation of dictionary keys. public class UpperCaseNamingPolicy : JsonNamingPolicy\n\n{\n\n public override string ConvertName(string name)\n\n {\n\n return name.ToUpper(); // Convert keys to uppercase\n\n }\n\n}\n\n\n\noptions = new JsonSerializerOptions\n\n{\n\n WriteIndented = true,\n\n PropertyNamingPolicy = new UpperCaseNamingPolicy()\n\n};\n\njson = JsonSerializer.Serialize(products, options);\n\njson A custom converter class is used to control how specific types are serialized and deserialized. You inherit from , where is the type you want to customize. public class CustomDateTimeConverter : JsonConverter<DateTime>\n\n{\n\n public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\n {\n\n return DateTime.ParseExact(reader.GetString(), \"yyyy-MM-dd\", null);\n\n }\n\n\n\n public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\n\n {\n\n writer.WriteStringValue(value.ToString(\"yyyy-MM-dd\"));\n\n }\n\n}\n\n\n\noptions = new JsonSerializerOptions\n\n{\n\n WriteIndented = true,\n\n};\n\noptions.Converters.Add(new CustomDateTimeConverter()); // you can add multiple converters\n\n\n\njson = JsonSerializer.Serialize(products, options);\n\njson In this example the custom converter for that formats dates in format.\n\nHandling case sensitivity in JSON serialization and deserialization is an important aspect when dealing with JSON data where property names might differ in casing. In C#, you can control case sensitivity using the property. By default, is case-sensitive, meaning that property names in the JSON must exactly match the property names in the C# class. public class Person\n\n{\n\n public string FirstName { get; set; }\n\n public string LastName { get; set; }\n\n}\n\n// JSON with property names that don't match C# class case exactly\n\njson = \"{\\\"firstname\\\": \\\"Ron\\\", \\\"lastname\\\": \\\"Weasley\\\"}\";\n\n\n\n// Deserialize without setting case-insensitivity (default behavior is case-sensitive)\n\nvar person = JsonSerializer.Deserialize<Person>(json);\n\nperson Since the property names in the JSON (“firstname” and “lastname”) are all lowercase, and the Person class has properties with FirstName and LastName using PascalCase, deserialization failsto map the JSON properties to the class fields, leaving them as null. You can enable case-insensitive property name matching during deserialization by setting in . This makes the deserialization process ignore case differences between JSON property names and C# property names. In this case, even though the JSON uses lowercase for the property names,deserialization succeeds because case sensitivity has been disabled.\n\nYou can use the option to enable reference handling in JSON serialization. This will handle circular references by using special and properties in the JSON. Consider two classes, and , where each can reference the other, creating a cyclic reference. public class Person\n\n{\n\n public string Name { get; set; }\n\n public Address Address { get; set; }\n\n}\n\n\n\npublic class Address\n\n{\n\n public string City { get; set; }\n\n public Person Resident { get; set; } // Circular reference back to Person\n\n}\n\n\n\nvar person = new Person { Name = \"Ron Weasley\" };\n\nvar address = new Address { City = \"Hogwarts Gryffindor\", Resident = person };\n\nperson.Address = address;\n\n\n\n// Set up JsonSerializerOptions with ReferenceHandler.Preserve\n\noptions = new JsonSerializerOptions\n\n{\n\n ReferenceHandler = ReferenceHandler.Preserve, // Enable reference handling\n\n WriteIndented = true // Format the JSON for readability\n\n};\n\n\n\n// Serialize the object graph with cyclic references\n\njson = JsonSerializer.Serialize(person, options);\n\njson The and properties are used to manage cyclic references. In this case\n• means the object's property refers back to the same object with , resolving the circular reference. If you want to ignore cyclic references during serialization (i.e., not serialize the properties that would cause a cycle), you can use the option. // Set up JsonSerializerOptions with ReferenceHandler.IgnoreCycles\n\nvar options = new JsonSerializerOptions\n\n{\n\n ReferenceHandler = ReferenceHandler.IgnoreCycles, // Ignore circular references\n\n WriteIndented = true // Format the JSON for readability\n\n};\n\n\n\n // Serialize the object graph ignoring cyclic references\n\njson = JsonSerializer.Serialize(person, options);\n\njson You can also manually prevent cyclic references by using the attribute on properties that would cause a cycle. public class Person\n\n{\n\n public string Name { get; set; }\n\n public Address Address { get; set; }\n\n}\n\n\n\npublic class Address\n\n{\n\n public string City { get; set; }\n\n\n\n [JsonIgnore] // Ignore the cyclic reference during serialization\n\n public Person Resident { get; set; }\n\n}\n\n\n\n\n\nvar person = new Person { Name = \"Ron Weasley\" };\n\nvar address = new Address { City = \"Hogwarts Gryffindor\", Resident = person };\n\nperson.Address = address;\n\n\n\n// Serialize the object graph with the [JsonIgnore] attribute\n\njson = JsonSerializer.Serialize(person, new JsonSerializerOptions { WriteIndented = true });\n\njson\n• The attribute prevents the property from being serialized, thus avoiding the cyclic reference.\n• This is a simple way to manually control which properties should be excluded from the serialization process."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/extensions/logging",
        "document": "Logging in C# and .NET\n\n.NET supports high performance, structured logging via the ILogger API to help monitor application behavior and diagnose issues. Logs can be written to different destinations by configuring different logging providers. Basic logging providers are built-in and there are many third-party providers available as well.\n\nThis first example shows the basics, but it's only suitable for a trivial console app. This sample console app relies on the following NuGet packages:\n\nIn the next section you see how to improve the code considering scale, performance, configuration and typical programming patterns.\n• Creates an ILoggerFactory. The stores all the configuration that determines where log messages are sent. In this case, you configure the console logging provider so that log messages are written to the console.\n• Creates an ILogger with a category named \"Program\". The category is a that is associated with each message logged by the object. It's used to group log messages from the same class (or category) together when searching or filtering logs.\n• Calls LogInformation to log a message at the level. The log level indicates the severity of the logged event and is used to filter out less important log messages. The log entry also includes a message template and a key-value pair . The key name (or placeholder) comes from the word inside the curly braces in the template and the value comes from the remaining method argument.\n\nThis project file for this example includes two NuGet packages:\n\nThere are several changes you should consider making to the previous example when logging in a less trivial scenario:\n• None If your application is using Dependency Injection (DI) or a host such as ASP.NET's WebApplication or Generic Host then you should use and objects from their respective DI containers rather than creating them directly. For more information, see Integration with DI and Hosts.\n• None Logging compile-time source generation is usually a better alternative to extension methods like . Logging source generation offers better performance, stronger typing, and avoids spreading constants throughout your methods. The tradeoff is that using this technique requires a bit more code.\n• The recommended practice for log category names is to use the fully qualified name of the class that's creating the log message. This helps relate log messages back to the code which produced them and offers a good level of control when filtering logs. CreateLogger accepts a to make this naming easy to do.\n• If you don't use console logs as your sole production monitoring solution, add the logging providers you plan to use. For example, you could use OpenTelemetry to send logs over OTLP (OpenTelemetry protocol):\n\nIf your application is using Dependency Injection (DI) or a host such as ASP.NET's WebApplication or Generic Host then you should use and objects from the DI container rather than creating them directly.\n\nGet an ILogger from DI\n\nThis example gets an ILogger object in a hosted app using ASP.NET Minimal APIs:\n• Created a singleton service called and mapped incoming web requests to run the function.\n• Line 12 defines a primary constructor for the ExampleHandler, a feature added in C# 12. Using the older style C# constructor would work equally well but is a little more verbose.\n• The constructor defines a parameter of type . ILogger<TCategoryName> derives from ILogger and indicates which category the object has. The DI container locates an with the correct category and supplies it as the constructor argument. If no with that category exists yet, the DI container automatically creates it from the in the service provider.\n• The parameter received in the constructor was used for logging in the function.\n\nHost builders initialize default configuration, then add a configured object to the host's DI container when the host is built. Before the host is built you can adjust the logging configuration via HostApplicationBuilder.Logging, WebApplicationBuilder.Logging, or similar APIs on other hosts. Hosts also apply logging configuration from default configuration sources as appsettings.json and environment variables. For more information, see Configuration in .NET.\n\nThis example expands on the previous one to customize the provided by . It adds OpenTelemetry as a logging provider transmitting the logs over OTLP (OpenTelemetry protocol):\n\nIf you're using a DI container without a host, use AddLogging to configure and add to the container.\n• Created a DI service container containing an configured to write to the console\n• Created an instance of the from the DI container which also automatically created an to use as the constructor argument.\n• Invoked which used the to log a message to the console.\n\nLogging configuration is set in code or via external sources, such as config files and environment variables. Using external configuration is beneficial when possible because it can be changed without rebuilding the application. However, some tasks, such as setting logging providers, can only be configured from code.\n\nFor apps that use a host, logging configuration is commonly provided by the section of appsettings .json files. For apps that don't use a host, external configuration sources are set up explicitly or configured in code instead.\n\nThe following appsettings.Development.json file is generated by the .NET Worker service templates:\n• The , , and log level categories are specified.\n• The value is applied to all categories that aren't otherwise specified, effectively making all default values for all categories . You can override this behavior by specifying a value for a category.\n• The category applies to all categories that start with .\n• The category logs at a log level of and higher.\n• The category is more specific than the category, so the category logs at log level and higher.\n• A specific log provider is not specified, so applies to all the enabled logging providers except for the Windows EventLog.\n\nThe property can have LogLevel and log provider properties. The specifies the minimum level to log for selected categories. In the preceding JSON, and log levels are specified. indicates the severity of the log and ranges from 0 to 6:\n\nWhen a is specified, logging is enabled for messages at the specified level and higher. In the preceding JSON, the category is logged for and higher. For example, , , , and messages are logged. If no is specified, logging defaults to the level. For more information, see Log levels.\n\nA provider property can specify a property. under a provider specifies levels to log for that provider, and overrides the non-provider log settings. Consider the following appsettings.json file:\n\nSettings in override settings in . In the preceding JSON, the provider's default log level is set to :\n\nThe preceding setting specifies the log level for every category except . When a specific category is listed, the specific category overrides the default category. In the preceding JSON, the categories and override the settings in\n\nThe minimum log level can be specified for any of:\n• All providers and all categories:\n\nAny logs below the minimum level are not:\n\nTo suppress all logs, specify LogLevel.None. has a value of 6, which is higher than (5).\n\nIf a provider supports log scopes, indicates whether they're enabled. For more information, see log scopes.\n\nThe following appsettings.json file contains settings for all of the built-in providers:\n• The categories and levels are not suggested values. The sample is provided to show all the default providers.\n• Settings in override settings in . For example, the level in overrides the level in .\n• Each provider's alias is used. Each provider defines an alias that can be used in configuration in place of the fully qualified type name. The built-in providers' aliases are:\n\nSet log level by command line, environment variables, and other configuration\n\nLog level can be set by any of the configuration providers. For example, you can create a persisted environment variable named with a value of .\n\nThe preceding environment setting is persisted in the environment. To test the settings when using an app created with the .NET Worker service templates, use the command in the project directory after the environment variable is assigned.\n\nOn Azure App Service, select New application setting on the Settings > Configuration page. Azure App Service application settings are:\n• Encrypted at rest and transmitted over an encrypted channel.\n\nFor more information on setting .NET configuration values using environment variables, see environment variables.\n\nTo configure logging in code, use the ILoggingBuilder API. This can be accessed from different places:\n• When creating the directly, configure in LoggerFactory.Create.\n• When using DI without a host, configure in LoggingServiceCollectionExtensions.AddLogging.\n• When using a host, configure with HostApplicationBuilder.Logging, WebApplicationBuilder.Logging or other host specific APIs.\n\nThis example shows setting the console logging provider and several filters.\n\nIn the preceding example AddFilter is used to adjust the log level that's enabled for various categories. AddConsole is used to add the console logging provider. By default, logs with severity aren't enabled, but because the configuration adjusted the filters, the debug message \"Hello Everyone\" is displayed on the console.\n\nWhen an ILogger<TCategoryName> object is created, the ILoggerFactory object selects a single rule per provider to apply to that logger. All messages written by an instance are filtered based on the selected rules. The most specific rule for each provider and category pair is selected from the available rules.\n\nThe following algorithm is used for each provider when an is created for a given category:\n• Select all rules that match the provider or its alias. If no match is found, select all rules with an empty provider.\n• From the result of the preceding step, select rules with longest matching category prefix. If no match is found, select all rules that don't specify a category.\n• If multiple rules are selected, take the last one.\n• If no rules are selected, use LoggingBuilderExtensions.SetMinimumLevel(ILoggingBuilder, LogLevel) to specify the minimum logging level.\n\nWhen an object is created, a category is specified. That category is included with each log message created by that instance of . The category string is arbitrary, but the convention is to use the fully qualified class name. For example, in an application with a service defined like the following object, the category might be :\n\nIf further categorization is desired, the convention is to use a hierarchical name by appending a subcategory to the fully qualified class name, and explicitly specify the category using LoggerFactory.CreateLogger:\n\nCalling with a fixed name can be useful when used in multiple classes/types so the events can be organized by category.\n\nis equivalent to calling with the fully qualified type name of .\n\nThe following table lists the LogLevel values, the convenience extension method, and the suggested usage:\n\nIn the previous table, the is listed from lowest to highest severity.\n\nThe Log method's first parameter, LogLevel, indicates the severity of the log. Rather than calling , most developers call the Log{LogLevel} extension methods. The extension methods call the method and specify the . For example, the following two logging calls are functionally equivalent and produce the same log:\n\nis the event ID, and is implicitly represented by a constant Int32 value. is a class that exposes various named identifier constants and is displayed in the Log event ID section.\n\nThe following code creates and logs:\n\nIn the preceding code, the first parameter, , is the Log event ID. The second parameter is a message template with placeholders for argument values provided by the remaining method parameters. The method parameters are explained in the message template section later in this article.\n\nConfigure the appropriate log level and call the correct methods to control how much log output is written to a particular storage medium. For example:\n• In production:\n• Logging at the or levels produces a high-volume of detailed log messages. To control costs and not exceed data storage limits, log and level messages to a high-volume, low-cost data store. Consider limiting and to specific categories.\n• Logging at through levels should produce few log messages.\n• Few logs allow more flexibility in data store choices.\n• In development:\n• Add or messages when troubleshooting. To limit output, set or only for the categories under investigation.\n\nEach log can specify an event identifier, the EventId is a structure with an and optional readonly properties. The sample source code uses the class to define event IDs:\n\nAn event ID associates a set of events. For example, all logs related to reading values from a repository might be .\n\nThe logging provider may log the event ID in an ID field, in the logging message, or not at all. The Debug provider doesn't show event IDs. The console provider shows event IDs in brackets after the category:\n\nSome logging providers store the event ID in a field, which allows for filtering on the ID.\n\nEach log API uses a message template. The message template can contain placeholders for which arguments are provided. Use names for the placeholders, not numbers. The order of placeholders, not their names, determines which parameters are used to provide their values. In the following code, the parameter names are out of sequence in the message template:\n\nThe preceding code creates a log message with the parameter values in sequence:\n\nThis approach allows logging providers to implement semantic or structured logging. The arguments themselves are passed to the logging system, not just the formatted message template. This enables logging providers to store the parameter values as fields. Consider the following logger method:\n\nFor example, when logging to Azure Table Storage:\n• Each Azure Table entity can have and properties.\n• Tables with properties simplify queries on logged data. For example, a query can find all logs within a particular range without having to parse the time out of the text message.\n\nLog message templates support placeholder formatting. Templates are free to specify any valid format for the given type argument. For example, consider the following logger message template:\n\nIn the preceding example, the instance is the type that corresponds to the in the logger message template. This name can be anything as the values are ordinal-based. The format is valid for the type.\n\nFor more information on and formatting, see Custom date and time format strings.\n\nThe following examples show how to format a message template using the placeholder syntax. Additionally, an example of escaping the placeholder syntax is shown with its output. Finally, string interpolation with templating placeholders is also shown:\n\nThe logger methods have overloads that take an exception parameter:\n\nIf the default log level is not set, the default log level value is .\n\nFor example, consider the following worker service app:\n\nWith the preceding setup, navigating to the privacy or home page produces many , , and messages with in the category name.\n\nThe following code sets the default log level when the default log level is not set in configuration:\n\nA filter function is invoked for all providers and categories that don't have rules assigned to them by configuration or code:\n\nThe preceding code displays console logs when the category contains or and the log level is or higher.\n\nA scope groups a set of logical operations. This grouping can be used to attach the same data to each log that's created as part of a set. For example, every log created as part of processing a transaction can include the transaction ID.\n• Is an IDisposable type that's returned by the BeginScope method.\n\nUse a scope by wrapping logger calls in a block:\n\nThe following JSON enables scopes for the console provider:\n\nThe following code enables scopes for the console provider:\n\nThe following code logs in by getting an instance from DI after building the host:\n\nThe preceding code relies on two NuGet packages:\n\nIts project file would look similar to the following:\n\nLogging should be so fast that it isn't worth the performance cost of asynchronous code. If a logging datastore is slow, don't write to it directly. Consider writing the log messages to a fast store initially, then moving them to the slow store later. For example, when logging to SQL Server, don't do so directly in a method, since the methods are synchronous. Instead, synchronously add log messages to an in-memory queue and have a background worker pull the messages out of the queue to do the asynchronous work of pushing data to SQL Server.\n\nThe Logging API doesn't include a scenario to change log levels while an app is running. However, some configuration providers are capable of reloading configuration, which takes immediate effect on logging configuration. For example, the File Configuration Provider reloads logging configuration by default. If the configuration is changed in code while an app is running, the app can call IConfigurationRoot.Reload to update the app's logging configuration.\n\nThe ILogger<TCategoryName> and ILoggerFactory interfaces and implementations are included in most .NET SDKs as implicit package reference. They're also available explicitly in the following NuGet packages when not otherwise implicitly referenced:\n• The interfaces are in Microsoft.Extensions.Logging.Abstractions.\n• The default implementations are in Microsoft.Extensions.Logging.\n\nFor more information about which .NET SDK includes implicit package references, see .NET SDK: table to implicit namespace.\n• Logging bugs should be created in the github.com/dotnet/runtime repo"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging?view=aspnetcore-9.0",
        "document": ""
    },
    {
        "link": "https://medium.com/@deewakar.kmr/comprehensive-logging-in-net-core-best-practices-and-implementation-3a3425e9f76d",
        "document": "Logging is a critical aspect of application development in .NET Core, enabling developers to track the flow of execution, diagnose issues, and monitor application performance. .NET Core provides a built-in logging framework that is flexible, extensible, and easy to integrate with various logging providers. Here’s an overview of logging in .NET Core, along with best practices and implementation examples.\n• ILogger Interface: At the core of .NET Core’s logging framework is the interface, which provides methods to log messages at different levels (e.g., , , ).\n• Logging Levels: .NET Core supports several logging levels to categorize the severity of log messages:\n• Trace: Logs that contain the most detailed messages. These logs are typically only enabled during development.\n• Debug: Logs that are used for interactive investigation during development.\n• Information: Logs that track the general flow of the application. These logs should have long-term value.\n• Warning: Logs that highlight an abnormal or unexpected event in the application flow but do not cause the application to stop.\n• Error: Logs that highlight when the current flow of execution is stopped due to a failure."
    },
    {
        "link": "https://stackoverflow.com/questions/72134225/console-logging-in-net-core-6",
        "document": "Using .NET 6 Core for a console app and I can't get debug logging working (nothing is displayed). And, I have added to the project.\n\nYou'll see two ways below that I've attempted to get a reference to the logger.\n\nNotice that does work, but does not.\n\nQuestion: How do I get working?"
    },
    {
        "link": "https://reddit.com/r/dotnet/comments/1f8587i/logging_best_practices_in_aspnet_core",
        "document": "Logging is an essential aspect of any application, especially in a production environment. Logging provides crucial insights into the behavior of your application, helping to diagnose issues, track the flow of execution, and monitor performance.\n\nIn this blog post, I will share with you my experience on what are the best practices for implementing logging in ASP.NET Core applications."
    },
    {
        "link": "https://github.com/roflmuffin/CounterStrikeSharp",
        "document": "CounterStrikeSharp is a server side modding framework for Counter-Strike 2. This project implements a .NET 8 scripting layer on top of a Metamod Source Plugin, allowing developers to create plugins that interact with the game server in a modern language (C#) to facilitate the creation of maintainable and testable code.\n\nCome and join our Discord\n\nDownload the latest build from here. (Download the with runtime version if this is your first time installing).\n\nDetailed installation instructions can be found in the docs.\n\nThese features are the core of the platform and work pretty well/have a low risk of causing issues.\n• Fake Console Variables (commands which mimic ConVar behaviour as these have not been fully reverse engineered)\n• Read the docs: Getting started guide, hello world plugin example\n\nYou can view the example Warcraft plugin migrated from the previous VSP.NET project to give you an idea of the kind of power this scripting runtime is capable of. This plugin shows how you can hook events, create commands, use third party libraries (SQLite) and do basic entity manipulation.\n\nA lot of code has been borrowed from SourceMod as well as Source.Python, two pioneering source engine plugin frameworks which this project lends a lot of its credit to. I've also used the scripting context & native system that is implemented in FiveM for GTA5. Also shoutout to the CS2Fixes project for providing good reverse-engineering information so shortly after CS2 release.\n\nCounterStrikeSharp is licensed under the GNU General Public License version 3. A special exemption is outlined regarding published plugins, which you can find in the LICENSE file."
    },
    {
        "link": "https://github.com/roflmuffin/CounterStrikeSharp/blob/main/managed/TestPlugin/TestPlugin.cs",
        "document": "// You can use `ModuleDirectory` to get the directory of the plugin (for storing config files, saving database files etc.)\n\n// This value is asserted against the native code that points to the same function.\n\n// Listens for any client use of the command `jointeam`."
    },
    {
        "link": "https://docs.cssharp.dev",
        "document": ""
    },
    {
        "link": "https://developer.valvesoftware.com/wiki/Counter-Strike_2_Workshop_Tools/Particles",
        "document": "The particle editor is disabled in CS2 by default. To enable the particle editor, \"game/bin/sdkenginetools.txt\" and \"game/bin/assettypes_common.txt\" must both be edited.\n\nIn sdkenginetools.txt, delete the lines from \"m_ExcludeFromMods = \" to \"]\" inclusive from pet:\n\nAnd in assettypes_common.txt, delete the lines from \"m_HideForRetailMods = \" to \"]\" inclusive from the particle asset:"
    },
    {
        "link": "https://nuget.org/packages/CounterStrikeSharp.API",
        "document": "CS2MenuManager CS2MenuManager is a flexible and user-friendly menu system developed for Counter-Strike 2 using the CounterStrikeSharp library. This project provides server administrators and developers with the ability to create customisable menus. It is easy to use for players and easy to configure and extend for administrators."
    }
]