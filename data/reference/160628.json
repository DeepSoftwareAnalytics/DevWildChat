[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation",
        "document": "It is important to ensure all required form controls are filled out, in the correct format, before submitting user entered form data to the server. This client-side form validation helps ensure data entered matches the requirements set forth in the various form controls. This article leads you through basic concepts and examples of client-side form validation. To understand what client-side form validation is, why it's important, and how to apply various techniques to implement it. Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away. If it gets to the server and is then rejected, a noticeable delay is caused by a round trip to the server and then back to the client-side to tell the user to fix their data. However, client-side validation should not be considered an exhaustive security measure! Your apps should always perform validation, including security checks, on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server. Note: Read Website security for an idea of what could happen; implementing server-side validation is somewhat beyond the scope of this module, but you should bear it in mind.\n\nGo to any popular site with a registration form, and you will notice that they provide feedback when you don't enter your data in the format they are expecting. You'll get messages such as:\n• \"This field is required\" (You can't leave this field blank).\n• \"Please enter your phone number in the format xxx-xxxx\" (A specific data format is required for it to be considered valid).\n• \"Please enter a valid email address\" (the data you entered is not in the right format).\n• \"Your password needs to be between 8 and 30 characters long and contain one uppercase letter, one symbol, and a number.\" (A very specific data format is required for your data). This is called form validation. When you enter data, the browser (and the web server) will check to see that the data is in the correct format and within the constraints set by the application. Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation. In this chapter we are focusing on client-side validation. If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; if the information isn't correctly formatted, it gives the user an error message explaining what needs to be corrected, and lets them try again. We want to make filling out web forms as easy as possible. So why do we insist on validating our forms? There are three main reasons:\n• We want to get the right data, in the right format. Our applications won't work properly if our users' data is stored in the wrong format, is incorrect, or is omitted altogether.\n• We want to protect our users' data. Forcing our users to enter secure passwords makes it easier to protect their account information.\n• We want to protect ourselves. There are many ways that malicious users can misuse unprotected forms to damage the application. See Website security. Warning: Never trust data passed to your server from the client. Even if your form is validating correctly and preventing malformed input on the client-side, a malicious user can still alter the network request.\n\nA common HTML validation feature is the attribute. Add this attribute to an input to make an element mandatory. When this attribute is set, the element matches the UI pseudo-class and the form won't submit, displaying an error message on submission, if the input is empty. While empty, the input will also be considered invalid, matching the UI pseudo-class. If any radio button in a same-named group has the attribute, one of the radio buttons in that group must be checked for the group to be valid; the checked radio doesn't have to be the one with the attribute set. Note: Only require users to input data you need: For example, is it really necessary to know someone's gender or title? Add a attribute to your input, as shown below. We added \"(required)\" to the to inform the user that the is required. Indicating to the user when form fields are required is not only good user experience, it is required by WCAG accessibility guidelines. We include CSS styles that are applied based on whether the element is required, valid, and invalid: This CSS causes the input to have a red dashed border when it is invalid and a more subtle solid black border when valid. We also added a background gradient when the input is required and invalid. Try out the new behavior in the example below: Try submitting the form from the live example without a value. Note how the invalid input gets focus, a default error message (\"Please fill out this field\") appears, and the form is prevented from being sent. You can also see the source code on GitHub.\n\nAnother useful validation feature is the attribute, which expects a Regular Expression as its value. A regular expression (regexp) is a pattern that can be used to match character combinations in text strings, so regexps are ideal for form validation and serve a variety of other uses in JavaScript. Regexps are quite complex, and we don't intend to teach you them exhaustively in this article. Below are some examples to give you a basic idea of how they work.\n• — Matches one character that is (not , not , and so on).\n• — Matches , followed by , followed by .\n• — Matches , optionally followed by a single , followed by . ( or )\n• — Matches , optionally followed by any number of s, followed by . ( , , , and so on).\n• — Matches one character that is or .\n• — Matches exactly or exactly (but not or or , and so on). There are many more possibilities that we don't cover here. For a complete list and many examples, consult our Regular expression documentation. Let's implement an example. Update your HTML to add a attribute like this: This gives us the following update — try it out: You can find this example live on GitHub along with the source code. In this example, the element accepts one of four possible values: the strings \"banana\", \"Banana\", \"cherry\", or \"Cherry\". Regular expressions are case-sensitive, but we've made it support capitalized as well as lower-case versions using an extra \"Aa\" pattern nested inside square brackets. At this point, try changing the value inside the attribute to equal some of the examples you saw earlier, and look at how that affects the values you can enter to make the input value valid. Try writing some of your own, and see how it goes. Make them fruit-related where possible so that your examples make sense! If a non-empty value of the doesn't match the regular expression's pattern, the will match the pseudo-class. If empty, and the element is not required, it is not considered invalid. Some element types don't need a attribute to be validated against a regular expression. For example, specifying the type validates the inputs value against a well-formed email address pattern or a pattern matching a comma-separated list of email addresses if it has the attribute.\n\nThe Constraint Validation API consists of a set of methods and properties available on the following form element DOM interfaces: The Constraint Validation API makes the following properties available on the above elements.\n• : Returns a localized message describing the validation constraints that the control doesn't satisfy (if any). If the control is not a candidate for constraint validation ( is ) or the element's value satisfies its constraints (is valid), this will return an empty string.\n• : Returns a object that contains several properties describing the validity state of the element. You can find full details of all the available properties in the reference page; below is listed a few of the more common ones:\n• : Returns if the value does not match the specified , and if it does match. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is longer than the maximum length specified by the attribute, or if it is shorter than or equal to the maximum. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is shorter than the minimum length specified by the attribute, or if it is greater than or equal to the minimum. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is greater than the maximum specified by the attribute, or if it is less than or equal to the maximum. If true, the element matches the and CSS pseudo-classes.\n• : Returns if the value is less than the minimum specified by the attribute, or if it is greater than or equal to the minimum. If true, the element matches the and CSS pseudo-classes.\n• : Returns if the value is not in the required syntax (when is or ), or if the syntax is correct. If , the element matches the CSS pseudo-class.\n• : Returns if the element meets all its validation constraints, and is therefore considered to be valid, or if it fails any constraint. If true, the element matches the CSS pseudo-class; the CSS pseudo-class otherwise.\n• : Returns if the element has a attribute, but no value, or otherwise. If true, the element matches the CSS pseudo-class.\n• : Returns if the element will be validated when the form is submitted; otherwise. The Constraint Validation API also makes the following methods available on the above elements and the element.\n• : Returns if the element's value has no validity problems; otherwise. If the element is invalid, this method also fires an event on the element.\n• : Reports invalid field(s) using events. This method is useful in combination with in an event handler.\n• : Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid, and the specified error is displayed. This lets you use JavaScript code to establish a validation failure other than those offered by the standard HTML validation constraints. The message is shown to the user when reporting the problem. As you saw in the HTML validation constraint examples earlier, each time a user tries to submit an invalid form, the browser displays an error message. The way this message is displayed depends on the browser. These automated messages have two drawbacks:\n• There is no standard way to change their look and feel with CSS.\n• They depend on the browser locale, which means that you can have a page in one language but an error message displayed in another language, as seen in the following Firefox screenshot. Customizing these error messages is one of the most common use cases of the Constraint Validation API. Let's work through an example of how to do this. We'll start with some HTML (feel free to put this in a blank HTML file; use a fresh copy of fruit-start.html as a basis, if you like): <form> <label for=\"mail\"> I would like you to provide me with an email address: </label> <input type=\"email\" id=\"mail\" name=\"mail\" /> <button>Submit</button> </form> Add the following JavaScript to the page: const email = document.getElementById(\"mail\"); email.addEventListener(\"input\", (event) => { if (email.validity.typeMismatch) { email.setCustomValidity(\"I am expecting an email address!\"); } else { email.setCustomValidity(\"\"); } }); Here we store a reference to the email input, then add an event listener to it that runs the contained code each time the value inside the input is changed. Inside the contained code, we check whether the email input's property returns , meaning that the contained value doesn't match the pattern for a well-formed email address. If so, we call the method with a custom message. This renders the input invalid, so that when you try to submit the form, submission fails and the custom error message is displayed. If the property returns , we call the method with an empty string. This renders the input valid, so the form will submit. During validation, if any form control has a that is not the empty string, form submission is blocked. You can try it out below: You can find this example live on GitHub as custom-error-message.html, along with the source code. The previous example showed how you can add a customized message for a particular type of error ( ). It is also possible to use all of the built in form validation, and then add to it using . Here we demonstrate how you can extend the built in validation to only accept addresses with the domain. We start with the HTML below. The validation code is shown below. In the event of any new input the code first resets the custom validity message by calling . It then uses to check if the entered address is invalid and if so, returns from the event handler. This ensures that all the normal built-in validation checks are run while the entered text is not a valid email address. Once the email address is valid, the code adds a custom constraint, calling with an error message if the address does not end with . const email = document.getElementById(\"mail\"); email.addEventListener(\"input\", (event) => { // Validate with the built-in constraints email.setCustomValidity(\"\"); if (!email.validity.valid) { return; } // Extend with a custom constraints if (!email.value.endsWith(\"@example.com\")) { email.setCustomValidity(\"Please enter an email address of @example.com\"); } }); You can try this example in the page at the Live sample demo link. Try submitting an invalid email address, a valid email address that doesn't end in , and one that does end in . Now that we've seen a really basic example, let's see how we can use this API to build some slightly more complex custom validation. First, the HTML. Again, feel free to build this along with us: This form uses the attribute to turn off the browser's automatic validation. Setting the attribute on the form stops the form from showing its own error message bubbles, and allows us to instead display the custom error messages in the DOM in some manner of our own choosing. However, this doesn't disable support for the constraint validation API nor the application of CSS pseudo-classes like , etc. That means that even though the browser doesn't automatically check the validity of the form before sending its data, you can still do it yourself and style the form accordingly. Our input to validate is an , which is , and has a of 8 characters. Let's check these using our own code, and show a custom error message for each one. We are aiming to show the error messages inside a element. The attribute is set on that to make sure that our custom error message will be presented to everyone, including it being read out to screen reader users. Now onto some basic CSS to improve the look of the form slightly, and provide some visual feedback when the input data is invalid: Now let's look at the JavaScript that implements the custom error validation. There are many ways to pick a DOM node; here we get the form itself and the email input box, as well as the span element into which we will place the error message. Using event handlers, we check if the form fields are valid each time the user types something. If there is an error, we show it. If there is no error, we remove any error messaging. const form = document.querySelector(\"form\"); const email = document.getElementById(\"mail\"); const emailError = document.querySelector(\"#mail + span.error\"); email.addEventListener(\"input\", (event) => { if (email.validity.valid) { emailError.textContent = \"\"; // Remove the message content emailError.className = \"error\"; // Removes the `active` class } else { // If there is still an error, show the correct error showError(); } }); form.addEventListener(\"submit\", (event) => { // if the email field is invalid if (!email.validity.valid) { // display an appropriate error message showError(); // prevent form submission event.preventDefault(); } }); function showError() { if (email.validity.valueMissing) { // If empty emailError.textContent = \"You need to enter an email address.\"; } else if (email.validity.typeMismatch) { // If it's not an email address, emailError.textContent = \"Entered value needs to be an email address.\"; } else if (email.validity.tooShort) { // If the value is too short, emailError.textContent = `Email should be at least ${email.minLength} characters; you entered ${email.value.length}.`; } // Add the `active` class emailError.className = \"error active\"; } Every time we change the value of the input, we check to see if it contains valid data. If it has then we remove any error message being shown. If the data is not valid, we run to show the appropriate error. Every time we try to submit the form, we again check to see if the data is valid. If so, we let the form submit. If not, we run to show the appropriate error, and stop the form submitting with . The function uses various properties of the input's object to determine what the error is, and then displays an error message as appropriate. You can find this example live on GitHub as detailed-custom-validation.html along with the source code. The constraint validation API gives you a powerful tool to handle form validation, letting you have enormous control over the user interface above and beyond what you can do with HTML and CSS alone.\n\nIn some cases, such as custom controls, you won't be able to or won't want to use the Constraint Validation API. You're still able to use JavaScript to validate your form, but you'll just have to write your own. To validate a form, ask yourself a few questions: What kind of validation should I perform? You need to determine how to validate your data: string operations, type conversion, regular expressions, and so on. It's up to you. This is clearly a UI matter. You have to decide how the form will behave. Does the form send the data anyway? Should you highlight the fields that are in error? Should you display error messages? How can I help the user to correct invalid data? In order to reduce the user's frustration, it's very important to provide as much helpful information as possible in order to guide them in correcting their inputs. You should offer up-front suggestions so they know what's expected, as well as clear error messages. If you want to dig into form validation UI requirements, here are some useful articles you should read:\n• Help users enter the right data in forms\n• How to Report Errors in Forms: 10 Design Guidelines An example that doesn't use the constraint validation API In order to illustrate this, the following is a simplified version of the previous example without the Constraint Validation API. The HTML is almost the same; we just removed the HTML validation features. Similarly, the CSS doesn't need to change very much; we've just turned the CSS pseudo-class into a real class and avoided using the attribute selector. body { font: 1em sans-serif; width: 200px; padding: 0; margin: 0 auto; } form { max-width: 200px; } p * { display: block; } input { appearance: none; width: 100%; border: 1px solid #333; margin: 0; font-family: inherit; font-size: 90%; box-sizing: border-box; } /* invalid fields */ input.invalid { border: 2px solid #900; background-color: #fdd; } input:focus.invalid { outline: none; /* make sure keyboard-only users see a change when focusing */ border-style: dashed; } /* error messages */ #error { width: 100%; font-size: 80%; color: white; background-color: #900; border-radius: 0 0 5px 5px; box-sizing: border-box; } .active { padding: 0.3rem; } The big changes are in the JavaScript code, which needs to do much more heavy lifting. const form = document.querySelector(\"form\"); const email = document.getElementById(\"mail\"); const error = document.getElementById(\"error\"); // Regular expression for email validation as per HTML specification const emailRegExp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/; // Check if the email is valid const isValidEmail = () => { const validity = email.value.length !== 0 && emailRegExp.test(email.value); return validity; }; // Update email input class based on validity const setEmailClass = (isValid) => { email.className = isValid ? \"valid\" : \"invalid\"; }; // Update error message and visibility const updateError = (isValidInput) => { if (isValidInput) { error.textContent = \"\"; error.removeAttribute(\"class\"); } else { error.textContent = \"I expect an email, darling!\"; error.setAttribute(\"class\", \"active\"); } }; // Initialize email validity on page load const initializeValidation = () => { const emailInput = isValidEmail(); setEmailClass(emailInput); }; // Handle input event to update email validity const handleInput = () => { const emailInput = isValidEmail(); setEmailClass(emailInput); updateError(emailInput); }; // Handle form submission to show error if email is invalid const handleSubmit = (event) => { event.preventDefault(); const emailInput = isValidEmail(); setEmailClass(emailInput); updateError(emailInput); }; // Now we can rebuild our validation constraint // Because we do not rely on CSS pseudo-class, we have to // explicitly set the valid/invalid class on our email field window.addEventListener(\"load\", initializeValidation); // This defines what happens when the user types in the field email.addEventListener(\"input\", handleInput); // This defines what happens when the user tries to submit the data form.addEventListener(\"submit\", handleSubmit); The result looks like this: As you can see, it's not that hard to build a validation system on your own. The difficult part is to make it generic enough to use both cross-platform and on any form you might create. There are many libraries available to perform form validation, such as Validate.js."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/HTML5_input_types",
        "document": "In the previous article we looked at the element, covering the original values of the attribute available since the early days of HTML. Now we'll look in detail at the functionality of some input types that were added later. To understand the newer input type values available to create native form controls, and how to implement them using HTML. Because HTML form control appearance may be quite different from a designer's specifications, web developers sometimes build their own custom form controls. We cover this in an advanced tutorial: How to build custom form widgets.\n\nThis type of field is set using the value for the attribute: When this is used, the value must be an email address to be valid. Any other content causes the browser to display an error when the form is submitted. You can see this in action in the screenshot below. You can use the attribute in combination with the input type to allow several comma-separated email addresses to be entered in the same input: On some devices — notably, touch devices with dynamic keyboards like smartphones — a different virtual keypad might be presented that is more suitable for entering email addresses, including the key: Note: You can find examples of the basic text input types at basic input examples (see the source code also). This is another good reason for using these newer input types, improving the user experience for users of these devices.\n\nAs you can see above, — along with other newer types — provides built-in client-side error validation, performed by the browser before the data gets sent to the server. It is a helpful aid to guide users to fill out a form accurately, and it can save time: it is useful to know that your data is not correct immediately, rather than having to wait for a round trip to the server. But it should not be considered an exhaustive security measure! Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to turn off, so malicious users can still easily send bad data through to your server. Read Website security for an idea of what could happen; implementing server-side validation is somewhat beyond the scope of this module, but you should bear it in mind. Note that is a valid email address according to the default provided constraints. This is because the input type allows intranet email addresses by default. To implement different validation behavior, you can use the attribute. You can also customize the error messages. We'll talk about how to use these features in the Client-side form validation article later on. Note: If the data entered is not an email address, the pseudo-class will match, and the property will return .\n\nSearch fields are intended to be used to create search boxes on pages and apps. This type of field is set by using the value for the attribute: The main difference between a field and a field is how the browser styles its appearance. In some browsers, fields are rendered with rounded corners. In some browsers, an \"Ⓧ\" clear icon is displayed, which clears the field of any value when clicked. This clear icon only appears if the field has a value, and, apart from Safari, it is only displayed when the field is focused. Additionally, on devices with dynamic keyboards, the keyboard's enter key may read \"search\", or display a magnifying glass icon. Another worth-noting feature is that the values of a field can be automatically saved and re-used to offer auto-completion across multiple pages of the same website; this tends to happen automatically in most modern browsers.\n\nA special field for filling in phone numbers can be created using as the value of the attribute: When accessed via a touch device with a dynamic keyboard, most devices will display a numeric keypad when is encountered, meaning this type is useful whenever a numeric keypad is useful, and doesn't just have to be used for telephone numbers. Due to the wide variety of phone number formats around the world, this type of field does not enforce any constraints on the value entered by a user (this means it may include letters, etc.). As we mentioned earlier, the attribute can be used to enforce constraints, which you'll learn about in Client-side form validation.\n\nControls for entering numbers can be created with an of . This control looks like a text field but allows only floating-point numbers, and usually provides buttons in the form of a spinner to increase and decrease the value of the control. On devices with dynamic keyboards, the numeric keyboard is generally displayed. With the input type, you can constrain the minimum and maximum values allowed by setting the and attributes. You can also use the attribute to set the increment increase and decrease caused by pressing the spinner buttons. By default, the number input type only validates if the number is an integer, as the attribute defaults to . To allow float numbers, specify or a specific value, like to restrict the floating point. If omitted, as the value defaults to , only whole numbers are valid. Let's look at some examples: This example creates a number control whose valid value is restricted to an odd value between and . The increase and decrease buttons change the value by , starting with the value. <label for=\"number\">Enter an odd number between 1 and 10:</label><br /> This example creates a number control whose value is restricted to any value between and inclusive, and whose increase and decrease buttons change its value by . The input type makes sense when the range of valid values is limited, such as a person's age or height. If the range is too large for incremental increases to make sense (such as USA ZIP codes, which range from to ), the type might be a better option; it provides the numeric keypad while forgoing the number's spinner UI feature.\n\nAnother way to pick a number is to use a slider. You see these quite often on sites like shopping sites where you want to set a maximum property price to filter by. Let's look at a live example to illustrate this: Usage-wise, sliders are less accurate than text fields. Therefore, they are used to pick a number whose precise value is not necessarily important. A slider is created using the with its attribute set to the value . The slider-thumb can be moved via mouse or touch, or with the arrows of the keypad. It's important to properly configure your slider. To that end, it's highly recommended that you set the , , and attributes which set the minimum, maximum, and increment values, respectively. Let's look at the code behind the above example, so you can see how it's done. First of all, the basic HTML: This example creates a slider whose value may range between and , which increments/decrements by 1000 at a time. We've given it a default value of , using the attribute. One problem with sliders is that they don't offer any kind of visual feedback as to what the current value is. This is why we've included an element to contain the current value. You could display an input value or the output of a calculation inside any element, but is special — like — and it can take a attribute that allows you to associate it with the element or elements that the output value came from. To actually display the current value, and update it as it changes, you must use JavaScript, which can be accomplished with a few statements: Here we store references to the input and the in two variables. Then we immediately set the 's to the current of the input. Finally, an event listener is set to ensure that whenever the range slider is moved, the 's is updated to the new value.\n\nGenerally, for a good user experience when gathering date and time values, it is important to provide a calendar selection UI. These enable users to select dates without needing to context switch to a native calendar application or potentially entering them in differing formats that are hard to parse. The last minute of the previous millennium can be expressed in the following different ways: , , or . HTML date controls are available to handle this specific kind of data, providing calendar widgets and making the data uniform. A date and time control is created using the element and an appropriate value for the attribute, depending on whether you wish to collect dates, times, or both. Here's a live example: Let's look at the different available types in brief. Note that the usage of these types is quite complex, especially considering browser support (see below); to find out the full details, follow the links below to the reference pages for each type, including detailed examples."
    },
    {
        "link": "https://blog.pixelfreestudio.com/best-practices-for-html5-form-validation",
        "document": "Forms are a crucial part of any website. They help gather information from users, whether it’s for signing up, logging in, or submitting feedback. However, to ensure the data collected is accurate and useful, proper validation is essential. HTML5 introduces powerful form validation features that make this task easier and more efficient. In this guide, we’ll explore the best practices for HTML5 form validation to help you create user-friendly and secure forms.\n\nHTML5 form validation provides a way to ensure that user input matches certain criteria before the form is submitted. This can be done using built-in attributes and methods, which offer a simple yet effective way to validate user input without relying on JavaScript for basic validation tasks.\n\nHTML5 comes with several built-in validation attributes that you can use to enforce rules on user input. These attributes include , , , , , , , and .\n\nUsing these attributes, you can set various constraints on form fields.\n\nIn this example, the attribute ensures that the fields are not left empty. The and attributes set limits on the number of characters for the username.\n\nThe ensures that the email address is in the correct format, and the and attributes set age constraints.\n\nOne of the key advantages of HTML5 form validation is providing real-time feedback to users. This immediate response can guide users to correct their input before submitting the form, leading to a smoother and more pleasant experience.\n\nIn this example, as the user types their password, real-time feedback is provided if the password does not meet the required pattern.\n\nWhile the default validation messages provided by browsers are functional, customizing these messages can improve user experience by providing more specific guidance.\n\nThis script provides custom feedback based on the user’s input, making the validation messages more informative and helpful.\n\nThe attribute allows you to define a regular expression that the input field’s value must match. This is particularly useful for fields like phone numbers, postal codes, and custom formats.\n\nExample of Using the Attribute\n\nIn this example, the attribute ensures that the phone number entered matches the specified format.\n\nWhile HTML5 validation handles many scenarios, some complex validations require JavaScript. For instance, checking that two password fields match or ensuring a username is available can’t be done with HTML5 alone.\n\nThis example checks if the password and confirm password fields match and provides real-time feedback to the user.\n\nConditional validation is useful when the requirements for a field depend on the value of another field. For example, additional fields might be required if a specific option is selected from a dropdown menu.\n\nIn this example, the employer name field is required only if the user selects “Employed” as their employment status.\n\nCSS can be used to style form fields based on their validation state, providing visual feedback to users. You can use the and pseudo-classes to apply styles.\n\nHere, valid fields have a green border, while invalid fields have a red border, giving users immediate visual feedback.\n\nThe Constraint Validation API provides methods and properties to customize and control form validation. You can use it to check the validity of form fields and display custom validation messages.\n\nExample of Using the Constraint Validation API\n\nThis example uses the Constraint Validation API to provide custom validation messages and ensure form fields meet the specified criteria.\n\nWhile client-side validation improves user experience by providing immediate feedback, it’s crucial to implement server-side validation as well. This ensures that data is validated regardless of the client’s capabilities or actions and protects against malicious inputs.\n\nExample of Server-Side Validation (Node.js and Express)\n\nThis example demonstrates how to validate form data on the server using Node.js and Express. It checks the username length and the email format before accepting the submission.\n\nBest Practices for Form Design and Validation\n\nA simple and focused form is easier for users to complete. Avoid unnecessary fields and break long forms into smaller sections if needed.\n\nEnsure that all form fields have clear labels and instructions. Use real-time feedback to guide users as they fill out the form.\n\nMake sure your forms are accessible to all users, including those using assistive technologies. Use proper HTML semantics and ARIA attributes where necessary.\n\nTest your forms across different browsers and devices to ensure they work correctly for all users. This includes testing both client-side and server-side validation.\n\nProtect your forms against common security threats such as cross-site scripting (XSS) and SQL injection. Use server-side validation and sanitize user inputs.\n\nReal-time feedback and error handling can significantly enhance the user experience by guiding users through the form completion process. Implementing these features ensures users understand exactly what is required and can correct errors immediately.\n\nExample of Real-Time Feedback with Custom Messages\n\nThis example provides immediate feedback to the user as they input their email and phone number, ensuring the data format is correct before submission.\n\nJavaScript can handle complex validation scenarios that go beyond what HTML5 attributes can manage. This is useful for custom validation rules, dynamic form changes, and cross-field validation.\n\nThis example checks if the password and confirm password fields match, providing real-time feedback and preventing form submission if the passwords do not match.\n\nWhile client-side validation enhances user experience by providing instant feedback, it should not replace server-side validation. Combining both ensures robust security and data integrity.\n\nExample of Combined Client-Side and Server-Side Validation (PHP)\n\nIn this example, the client-side script validates the form before submission, and the server-side script revalidates the data for security.\n\nAccessibility is critical to ensure that all users, including those with disabilities, can use your forms. Use ARIA attributes and accessible error messages to improve usability.\n\nThis example uses ARIA attributes to make error messages accessible, ensuring that screen readers can announce them to users.\n\nHTML5 introduces new input types for dates and times, such as , , , , and . These types offer built-in validation and user-friendly interfaces, but they also require specific handling to ensure compatibility across different browsers.\n\nExample of Date and Time Input Validation\n\nIn this example, the form ensures that users provide valid date and time inputs. The JavaScript script further checks the validity of each field before submission.\n\nFile inputs require special validation to ensure that users upload the correct type and size of files. HTML5 provides the attribute to specify the types of files allowed, but additional JavaScript validation is often needed.\n\nThis example validates that the uploaded file is of the correct type and size, providing immediate feedback to the user if the file does not meet the criteria.\n\nMulti-step forms break down long forms into smaller, more manageable sections. Each step should be validated before moving on to the next to ensure that users provide complete and accurate information.\n\nThis example demonstrates a multi-step form where each step is validated before moving to the next, ensuring users provide all required information incrementally.\n\nFor applications targeting a global audience, localizing validation messages is crucial. You can provide custom validation messages in multiple languages using JavaScript.\n\nThis example provides validation messages in both English and Spanish, switching the language by changing the variable.\n\nWhile HTML5 provides robust validation tools, third-party libraries can offer additional features and flexibility. Libraries like or enhance form validation with more options and ease of use.\n\nExample of Using Parsley.js\n\nParsley.js makes it easy to add client-side form validation with minimal setup. It supports various validation rules and provides a straightforward way to enhance your forms.\n\nCAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) is an effective tool to prevent automated bots from submitting your forms.\n\nIt adds an extra layer of security by requiring users to complete a challenge.\n\nThis example integrates Google reCAPTCHA into the form, providing an extra layer of security to ensure that submissions are made by real users.\n\nModern browsers come with built-in capabilities that can enhance form validation and user experience. Ensuring compatibility across different browsers and utilizing their native features can save time and effort.\n\nExample of Using Browser-Specific Features\n\nIn this example, the and input types leverage browser capabilities to ensure proper formatting and validation.\n\nPlaceholder text can guide users on what to input, improving form completion rates and accuracy. However, it’s important to ensure placeholders are not used as a substitute for proper labels.\n\nExample of Using Placeholder Text\n\nAuto-complete attributes help users fill out forms more quickly by suggesting previously entered values. This feature enhances usability and reduces input errors.\n\nExample of Using Auto-Complete\n\nContextual help can assist users in filling out forms correctly by providing additional information or examples. This can be achieved using tooltips, hints, or help icons.\n\nExample of Providing Contextual Help\n\nReducing the number of form fields can significantly improve form completion rates. Only ask for information that is necessary and consider breaking long forms into multi-step processes.\n\nWith the increasing use of mobile devices, ensuring your forms are mobile-friendly is essential. Use responsive design techniques to make forms easy to complete on smaller screens.\n\nProgressive disclosure involves showing only a few fields initially and revealing additional fields as needed. This technique helps prevent users from feeling overwhelmed.\n\nAfter form submission, providing a clear confirmation message reassures users that their information has been received. This can be a thank you message, a summary of their submission, or a confirmation email.\n\nA/B testing involves creating multiple versions of your form to see which performs better. This can help you optimize form fields, design, and validation messages to improve conversion rates.\n\nExample of Setting Up A/B Testing\n\nUsing AJAX, you can validate form data in real-time against server-side logic without requiring a page refresh. This is particularly useful for checking data like usernames or email addresses for availability.\n\nThis example uses an AJAX request to check if a username is already taken when the input field loses focus.\n\nIn some forms, the validity of one field might depend on another. For instance, a “State” field should be required only if the “Country” field is set to a specific value.\n\nThis example shows or hides the “State” field based on the selected country, dynamically adjusting its required attribute.\n\nRegular expressions (regex) are powerful tools for validating complex patterns such as serial numbers, license keys, or specific formats that built-in HTML5 validation can’t handle.\n\nExample of Using Regular Expressions for Validation\n\nIn this example, the attribute uses a regex to ensure the serial number matches the specified format.\n\nSometimes, users might encounter edge cases that are not covered by standard validation rules. Preparing for these cases ensures a smooth user experience.\n\nThis example ensures that the phone number is exactly 10 digits long, providing custom feedback if it is not.\n\nHidden fields can be used to pass additional data to the server without displaying it to the user. This is useful for tracking, session management, or including metadata.\n\nExample of Using Hidden Fields\n\nIn this example, a hidden field is used to pass a session ID along with the form data.\n\nSometimes, integrating third-party APIs can enhance the validation process by verifying data like addresses, phone numbers, or credit card information.\n\nExample of Using a Third-Party API for Address Validation\n\nThis example validates an address using a third-party API when the input field loses focus.\n\nEffective HTML5 form validation is essential for creating user-friendly and secure web applications. By utilizing built-in validation attributes, JavaScript for advanced scenarios, real-time feedback with AJAX, and integrating third-party APIs, you can ensure accurate data collection while enhancing user experience.\n\nImplementing best practices like mobile-friendly design, progressive disclosure, and providing contextual help further optimizes the user journey. These strategies together make your forms robust, accessible, and efficient, ensuring data integrity and user satisfaction.\n• How to Use CSS Grid for Complex Layouts\n• The Importance of Code Reviews in Frontend Development"
    },
    {
        "link": "https://medium.com/@greennolgaa/html-input-types-best-practices-and-tips-6939251e8d70",
        "document": "HTML, or HyperText Markup Language, is the standard markup language used to create web pages. HTML input types are the various types of form controls that can be used to collect information from users on web pages. There are many different HTML input types available, each with its own unique features and use cases.\n\nIn this article, we will take a closer look at some of the most common HTML input types and how they can be used to create effective web forms.\n\nText input is one of the most common input types HTML5. It allows users to enter text into a form field, such as their name or email address. The following is an example of a basic text input field:\n\nThe attribute is used to specify the name of the input field, while the attribute provides a hint or example of the type of information the user should enter.\n\nPassword input is another common HTML input type. It is used to collect sensitive information, such as passwords or PINs. The following is an example of a basic password input field:\n\nThe attribute is set to \"password\", which masks the characters entered by the user. This helps to protect sensitive information from being viewed by others.\n\nRadio buttons are used to present users with a set of options, of which only one can be selected. The following is an example of a basic radio button group:\n\nThe attribute is used to group the radio buttons together, while the attribute is used to specify the value of the selected option.\n\nCheckboxes are similar to radio buttons, but they allow users to select multiple options. The following is an example of a basic checkbox group:\n\nThe attribute is used to group the checkboxes together, while the attribute is used to specify the value of the selected options.\n\nSelect dropdowns are used to present users with a list of options, of which only one can be selected. The following is an example of a basic select dropdown:\n\nThe attribute is used to specify the name of the input field, while the tags are used to define the options in the dropdown list.\n\nTextarea is used to allow users to enter a larger amount of text, such as a comment or message. The following is an example of a basic textarea input:\n\nThe attribute is used to specify the name of the input field, while the attribute provides a hint or example of the type of information the user should enter.\n\nThe color input type allows users to select a color using a color picker. The value returned is a hexadecimal color code.\n\nThe range input type creates a slider control that allows users to select a value within a specified range. It is commonly used for volume controls, brightness controls, and other similar applications.\n\nThe date and time input types allow users to select a date or time using a graphical calendar or clock interface. These input types also allow developers to specify the minimum and maximum values for the date and time that can be selected.\n\nThe search input type creates a text box that is specifically designed for search input. It typically includes a magnifying glass icon that triggers the search when clicked.\n\nThe URL and Email input types are designed to specifically handle URLs and email addresses respectively. They include validation to ensure that the input entered is in the correct format.\n\nThese are just a few of the less commonly used input types available in HTML. By using these input types appropriately, HTML developer can improve the usability and functionality of their web applications.\n\nHTML input types provide a range of options for developers to collect various types of user input on web pages. However, it’s important to use them properly and follow the best practices to ensure a smooth and user-friendly experience. In this section, we’ll cover some of the best practices for using HTML input types.\n• Use the right type for the input: It’s important to choose the right HTML input type for each field to ensure that users can enter the correct type of data. For example, use the “email” input type for email addresses, “tel” for phone numbers, “number” for numeric input, and “date” for date fields.\n• Use labels: Always include labels for input fields to provide context and improve accessibility. Use the “for” attribute to link the label to the input field for users who click on the label to focus on the input field.\n• Use placeholders sparingly: Placeholders can be useful to provide examples of the type of data expected in the input field. However, it’s important not to rely on them too much as they disappear as soon as users start typing. Additionally, screen readers may not read placeholders, so it’s important to include labels as well.\n• Use autocomplete: Setting autocomplete values for input fields can help users fill out forms quickly and easily. Use the “autocomplete” attribute to specify the type of data that should be suggested for the field.\n• Use validation: HTML input types can provide some basic validation, but it’s important to add additional validation on the server-side to ensure that the data is accurate and secure. Use regular expressions or JavaScript to validate user input and provide appropriate error messages if necessary.\n• Use radio buttons and checkboxes for multiple selections: When there are multiple options for users to choose from, use radio buttons for single selections and checkboxes for multiple selections. This provides a clear and easy-to-use interface for users.\n• Use range inputs for slider controls: Range inputs provide a slider control that users can drag to select a value within a range. This can be a useful way to collect data for things like price ranges or quantities.\n• Use file inputs for uploading files: Use the “file” input type to allow users to upload files. This can be useful for things like resumes, images, or documents.\n• Use date and time inputs appropriately: Date and time inputs can be useful for collecting data on events, appointments, and other time-related information. However, it’s important to use them properly and follow best practices to ensure that they are user-friendly and accessible.\n\nIn conclusion, using the right HTML input types and following best practices can greatly improve the user experience and usability of web forms. By keeping these tips in mind, html developers can ensure that their forms are easy to use, accessible, and provide accurate and secure data.\n\nIn conclusion, HTML input types are essential elements of any web development project. The various input types allow developers to create forms that are user-friendly and provide a better user experience. Knowing the different input types and how to use them correctly is crucial for creating high-quality web applications.\n\nWhen working with HTML input types, it’s important to follow best practices such as using appropriate labels and placeholders, providing clear instructions, and validating user input. By doing so, developers can ensure that their forms are accessible, usable, and provide a smooth user experience.\n\nIf you’re looking for expert HTML developers to help you with your web development projects, CronJ is a great choice. With a team of experienced developers, we can help you create user-friendly, high-quality web applications that meet your specific needs. Contact us today to learn more.\n• Web App Development in 2023: Everything You Need to Know"
    },
    {
        "link": "https://dhiwise.com/post/html-form-validation-techniques-tips-and-tools",
        "document": "Writes code, blogs, and product docs. She loves a good meal, a great playlist, and a clean commit history. When she’s not debugging, she’s probably experimenting with a new recipe.\n\nForm validation is critical in web forms to ensure that the data entered by users meets the specific requirements before it is sent to a web server. By implementing form validation, you can prevent the submission of incorrect or incomplete data, thereby enhancing the user experience and maintaining data integrity.\n\nWhen users submit forms with errors, form validation provides error messages that guide them to correct their entries, helping prevent frustration and confusion.\n\nHTML form validation primarily involves checking the data entered into form elements to ensure it conforms to specific rules before the form is submitted. This process of validation uses a mix of HTML5 attributes, JavaScript code, and server-side validation to ensure comprehensive data validation.\n\nWhile client-side validation provides immediate feedback and helps reduce the load on the server, server-side validation is crucial as it acts as a second layer of defense against invalid data that might slip through client-side checks. This is especially important for security reasons, as client-side validation can be bypassed by malicious users.\n\nForm validation is the process of checking the data entered by users in form fields against specific criteria before submitting it to the server. This validation process ensures that the input data is both complete and formatted correctly according to predefined rules.\n\nThe primary goal of form validation is to ensure that invalid data does not get processed, which can lead to erroneous operations, security risks, and a degraded user experience.\n\nThe Role of HTML5 in Form Validation\n\nHTML5 has significantly enhanced the capabilities of form validation with the introduction of new input types and attributes that support different kinds of data input, such as dates, email addresses, numbers, and more.\n\nThese built-in features allow developers to implement form validation directly in the HTML, reducing the need for extensive JavaScript code and improving the performance and user experience of web forms.\n• Input Types: HTML5 introduces specific input types that automatically validate user input to match the expected data format. For example, using input type=\"email\" ensures that the user enters a valid email format.\n• Attributes for Validation: HTML5 provides several attributes that help in defining the rules for validation directly in the HTML markup. These include:\n• required: Ensures the form field must be filled out before submitting the form.\n• pattern: Uses regular expressions to define a pattern that the input must match.​\n• Security: Server-side validation is performed on the server, making it secure against client-side manipulations.\n• Data Integrity: It ensures that the data conforms to business rules before being processed or stored, which is crucial for maintaining data integrity.\n• Fallback: Acts as a fallback for client-side validation, ensuring validation occurs even if JavaScript is disabled on the client side.\n• Increased Server Load: Every form submission requires server resources to validate the input, which can increase load and affect performance.\n• Slower User Feedback: Users only receive feedback after the page has been submitted to the server and reloaded, which can slow down the interaction.\n\nImportance of Using Both for Robust Validation\n\nUsing both client-side and server-side validation ensures a robust and secure implementation. While client-side validation improves the user experience with quick feedback, server-side validation acts as a crucial checkpoint for data integrity and security, which is especially important in environments where critical data handling and transactions occur.\n\nWhen to Use:\n• When you need more complex validations that HTML5 attributes cannot handle alone, such as checking password strength or validating that two passwords match.\n• When dynamic validation feedback is required, such as updating the user interface without a full page refresh.\n• Flexibility: JavaScript validation allows for more complex, custom validation logic beyond what HTML5 attributes can offer.\n• Enhanced User Experience: Provides dynamic feedback and interactive elements without needing to reload the page, making the experience smoother for the user.\n\nHTML5 provides a variety of built-in attributes that can enhance form validation directly in the markup, simplifying the process and reducing the need for additional JavaScript. Here’s a detailed look at some key HTML5 attributes and how to use them effectively.\n\nThe required attribute is a straightforward way to enforce that a form element must be filled out before the form can be submitted. It works with input types like text, email, select, and more.\n\nThe type attribute specifies the kind of data the input field should accept, providing automatic validation for several common data types:\n• email: Validates that the entry is a properly formatted email address.\n• number: Ensures the input is a number and allows for further specification with attributes like min, max, and step.\n\nThe pattern attribute uses regular expressions to define a custom format that the input data must match. It’s particularly useful for formatting entries like phone numbers, zip codes, or custom identifiers.\n\nThe min and max attributes specify the minimum and maximum values for input types such as number and date, which is essential for setting boundaries on acceptable input.\n\nThese attributes define the maximum and minimum lengths of characters that the input can accept. They are critical for inputs like passwords and personal messages, where length requirements might be a part of security protocols or data handling standards.\n\nStyling form inputs based on their validation status is crucial for providing visual feedback to users. This can enhance the user experience by clearly indicating which fields are correctly filled and which require attention. CSS pseudo-classes related to form validation offer a powerful way to apply styles conditionally based on the state of form elements.\n\nThe :valid pseudo-class applies styles to form elements that contain valid data. It's a great way to visually communicate to users that their input meets the required criteria.\n\nThe :invalid pseudo-class targets form elements with invalid data. This allows you to style these elements in a way that makes the validation errors obvious to users.\n\nThe :required pseudo-class can be used to style elements that have the required attribute, highlighting mandatory fields even before any data is entered.\n\nConversely, the :optional pseudo-class applies to form elements without the required attribute. This can be used to indicate optional fields differently from required ones.\n• Contrast and Color: Use contrasting colors to differentiate between valid and invalid inputs. For instance, green for valid and red for invalid inputs are common conventions that intuitively signal success and error.\n• Icons and Symbols: Incorporate icons or symbols next to the inputs to indicate their status. A check mark for valid inputs and an exclamation mark for invalid ones can enhance clarity.\n• Real-time Feedback: Apply these styles as the user types or moves between fields, rather than only after submitting the form. This immediate feedback helps in correcting errors in real-time.\n• Accessible Messaging: Beyond visual changes, provide textual feedback or error messages that explain why an input is invalid. This is crucial for users who might not perceive color changes (e.g., colorblind users).\n• Subtle Animations: Use mild animations like fades or transitions when changing styles. This draws attention to the changes without being too distracting.\n• Consistency: Maintain consistent styling rules across all forms within your application to avoid confusing users. Consistency helps in building a predictable and easy-to-understand interface.\n\nCustom validation messages are an essential aspect of enhancing the user experience in form handling. They provide specific, understandable feedback that helps users correct their inputs effectively. HTML5's Constraint Validation API includes the setCustomValidity() method, which allows you to set custom error messages for form elements, offering a more flexible and user-friendly approach to displaying validation errors.\n\nThe setCustomValidity() method is part of the Constraint Validation API and is used to provide custom validation messages. This method can be applied to any form element that is subject to validation, such as , , and . When you call this method with a non-empty string, the form element is considered invalid, and the provided string is displayed as the error message. If the string is empty, the element is considered valid.\n• Clarity and Conciseness: Keep the messages clear and concise, explaining exactly what the issue is and how to fix it.\n• Tone: Use a friendly and helpful tone rather than a commanding or negative tone, which can enhance the user's experience.\n• Relevance: Ensure that the message is directly relevant to the validation rule it corresponds to. Avoid generic or confusing statements that could lead to further user errors.\n• Dynamic Updates: Update validation messages dynamically as the user corrects the input, ensuring that the guidance evolves as the user interacts with the form.\n\nIn web forms, certain input types frequently require specific validation patterns to ensure data integrity and user compliance with formatting standards. Here, we'll explore common validation patterns for email addresses, password strength, and phone numbers, including practical regex examples for each.\n\nEmail validation is crucial to ensure that the user inputs a properly formatted email address, which is essential for communication and user identification.\n\nThis pattern ensures that the email has one \"@\" symbol, followed by a domain and a domain extension, without spaces.\n\nStrong passwords are vital for security. A common requirement is that passwords should include a mix of uppercase letters, lowercase letters, numbers, and special characters, and be of a certain length.\n\nThis pattern checks for at least one lowercase letter, one uppercase letter, one digit, one special character, and a minimum length of 8 characters.\n\nPhone number validation often requires specific country codes and a set number of digits. This example will assume a US phone number format.\n\nThis pattern matches a US phone number format with an optional country code (+1), area code in parentheses, and a dash separating the three-digit and four-digit sections.\n• Use the ‘title' attribute: Provide a description of the required pattern using the title attribute in your HTML elements to give users hints on the expected format.\n• Test your regex: Always test your regular expressions with various inputs to ensure they accurately capture the correct formats and exclude invalid ones.\n• Provide clear error messages: Use the setCustomValidity() method in JavaScript to provide specific, helpful error messages when the user's input does not match the expected pattern.\n\nSeveral JavaScript libraries and tools can be employed to streamline and enhance the form validation process.\n• jQuery Validation Plugin: This library is widely used for quick and easy validation that is customizable and supports a variety of validation scenarios. It is easy to implement with jQuery-based projects.\n• Parsley.js: Known for its flexibility and extensibility, Parsley.js allows developers to perform front-end validation without writing a lot of JavaScript code. It supports localization and custom validators.\n• validate.js: Another lightweight JavaScript library that provides powerful declarative validation capabilities and doesn't depend on other libraries.\n• Browser Developer Tools: Use built-in browser tools to test and debug JavaScript and form behavior directly within the browser.\n• Postman: Useful for testing server-side validations by sending requests to the backend and verifying the responses without using the UI.\n• Jest: For unit testing JavaScript code, Jest can be used to test validation functions independently of the user interface.\n\nEffective HTML form validation is crucial for ensuring data accuracy, security, and a great user experience in any web application. We've explored essential techniques like HTML5 validation attributes, CSS styling for visual feedback, and JavaScript for dynamic behaviors.\n\nUsing these tools and best practices, you can create robust, user-friendly, and accessible forms. The proper implementation helps protect data quality and enhances the overall interaction, making the process of filling out forms intuitive and efficient for all users.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date",
        "document": "elements of create input fields that let the user enter a date. The appearance of the date picker input UI varies based on the browser and operating system. The value is normalized to the format . The resulting value includes the year, month, and day, but not the time. The time and datetime-local input types support time and date+time input.\n\nA string representing the date entered in the input. The date is formatted according to Date strings format. You can set a default value for the input with a date inside the attribute, like so: Note: The displayed date format will differ from the actual — the displayed date is formatted based on the locale of the user's browser, but the parsed is always formatted . You can get and set the date value in JavaScript with the and properties. For example: This code finds the first element whose is , and sets its value to (June 1st, 2017). It then reads that value back in string and number formats.\n\nThe latest date to accept. If the entered into the element occurs afterward, the element fails constraint validation. If the value of the attribute isn't a possible date string in the format , then the element has no maximum date value. If both the and attributes are set, this value must be a date string later than or equal to the one in the attribute.\n\nThe earliest date to accept. If the entered into the element occurs beforehand, the element fails constraint validation. If the value of the attribute isn't a possible date string in the format , then the element has no minimum date value. If both the and attributes are set, this value must be a date string earlier than or equal to the one in the attribute.\n\nThe attribute is a number that specifies the granularity that the value must adhere to, or the special value , which is described below. Only values which are equal to the basis for stepping ( if specified, otherwise, and an appropriate default value if neither of those is provided) are valid. A string value of means that no stepping is implied, and any value is allowed (barring other constraints, such as and ). Note: When the data entered by the user doesn't adhere to the stepping configuration, the user agent may round to the nearest valid value, preferring numbers in the positive direction when there are two equally close options. For inputs, the value of is given in days; and is treated as a number of milliseconds equal to 86,400,000 times the value (the underlying numeric value is in milliseconds). The default value of is 1, indicating 1 day. Note: Specifying as the value for has the same effect as for inputs.\n\nYou can use the and attributes to restrict the dates that can be chosen by the user. In the following example, we set a minimum date of and a maximum date of : The result is that only days in April 2017 can be selected — the month and year parts of the textbox will be uneditable, and dates outside April 2017 can't be selected in the picker widget. You can use the attribute to vary the number of days jumped each time the date is incremented (e.g. to only make Saturdays selectable).\n\nBy default, doesn't validate the entered value beyond its format. The interfaces generally don't let you enter anything that isn't a date — which is helpful. If you use and to restrict the available dates (see Setting maximum and minimum dates), the form control disables invalid dates, and will display an error if you try to submit a date that is out of bounds. You can also use the attribute to make filling in the date mandatory — an error will be displayed if you try to submit an empty date field. Let's look at an example of minimum and maximum dates, and also made a field required: If you try to submit the form with an incomplete date (or with a date outside the set bounds), the browser displays an error. Try playing with the example now: Here's the CSS used in the above example. We make use of the and pseudo-elements to add an icon next to the input, based on whether the current value is valid. We had to put the icon on a next to the input, not on the input itself, because in Chrome at least the input's generated content is placed inside the form control, and can't be styled or shown effectively. Warning: Client-side form validation is not a substitute for validating on the server. It's easy for someone to modify the HTML, or bypass your HTML entirely and submit the data directly to your server. If your server fails to validate the received data, disaster could strike with data that is badly-formatted, too large, of the wrong type, etc."
    },
    {
        "link": "https://stackoverflow.com/questions/33837591/using-datepicker-for-html-form-element",
        "document": "I'm making a asp.net mvc website and I'm trying to add a Date time picker for one of my model attributes in a form in my view. At the moment a datepicker displays but when I pick a date and submit the form the data is not saved. Before I tried adding a date picker the information saved so I believe the date picker is causing my problem. How exactly should a date picker be added to an HTML Form and should I use the jQuery UI datepicker or one of the many other ones available online? I've no experience with jQuery so it may be that I don't understand how datepicker works or haven't got the right js scripts. Thanks!!\n\nMy controller method, which is invoked when the form is submitted, looks like this"
    },
    {
        "link": "https://w3schools.com/tags/att_input_type_date.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/14946091/are-there-any-style-options-for-the-html5-date-picker",
        "document": "Currently, there is no cross browser, script-free way of styling a native date picker.\n\nAs for what's going on inside WHATWG/W3C... If this functionality does emerge, it will likely be under the CSS-UI standard or some Shadow DOM-related standard. The CSS4-UI wiki page lists a few appearance-related things that were dropped from CSS3-UI, but to be honest, there doesn't seem to be a great deal of interest in the CSS-UI module.\n\nI think your best bet for cross browser development right now, is to implement pretty controls with JavaScript based interface, and then disable the HTML5 native UI and replace it. I think in the future, maybe there will be better native control styling, but perhaps more likely will be the ability to swap out a native control for your own Shadow DOM \"widget\".\n\nIt is annoying that this isn't available, and petitioning for standard support is always worthwhile. Though it does seem like jQuery UI's lead has tried and was unsuccessful.\n\nWhile this is all very discouraging, it's also worth considering the advantages of the HTML5 date picker, and also why custom styles are difficult and perhaps should be avoided. On some platforms, the datepicker looks extremely different and I personally can't think of any generic way of styling the native datepicker."
    },
    {
        "link": "https://flowbite.com/docs/components/datepicker",
        "document": "Start receiving date and time data from your users using this free datepicker element based on Tailwind utility-classes and vanilla JavaScript\n\nThe Tailwind CSS datepicker component developed by Flowbite is built with vanilla JavaScript and using the utility-first classes from Tailwind. The datepicker features both inline and a date range picker functionality and some extra options such as autohide, custom format, positioning, and more. Check out the timepicker component to select time alongside dates.\n\nIf you want to use the datepicker component from Flowbite you have to include the Flowbite JavaScript file either via NPM or CDN. For versions before please continue using the dedicated CDN and component.\n\nFollow the quickstart guide and then include the following JavaScript file:\n\nAlternatively you can also use CDN to include the datepicker JavaScript.\n\nAlso make sure that you add the source files for Tailwind in your main CSS file:\n\nIf you’d like to manually be able to manipulate the datepicker component using JavaScript then you should install the component using NPM and include it into your JavaScript code.\n\nUse the following example of an input element to create a datepicker component. All you need to do is to add the data attribute to any element.\n\nUse the and data attributes to initialize and set the default date for an inline datepicker inside a block element such as a .\n\nUse the data attribute and the following markup to initialize two datepickers as a range.\n\nLearn more about the options that you can use with the Tailwind datepicker to enable features such as autohide, action buttons, date format, orientation, and more based on the vanilla JavaScript from Flowbite.\n\nUse the data attribute to make the datepicker disappear right after selecting a date.\n\nBy adding the data attribute you will enable the and buttons:\n• clicking on the button will browse back to the current day/month/year\n• clicking on the button will reset all selections\n\nIf you want the button to additionally select today’s date, add data attribute.\n\nIf you want to use a custom format such as then you can use the data attribute to change it.\n\nUse the and to set the minimum and maximum dates that can be selected inside the datepicker.\n\nYou can override the default positioning algorithm by using the data attributes. You can even combine right with bottom or left with top.\n\nYou can also add a title to the datepicker by using the data attribute.\n\nYou can set the color class which is by default set to blue to add your own colors.\n\nWe are working on the API to provide language support for the datepicker.\n\nUntil then, please refer to this solution from GitHub.\n\nUse the native browser timepicker input field to select a time alongside the datepicker. Check out more examples on the timepicker component page from Flowbite.\n\nIf you would like to enable dark mode for the datepicker please follow the dark mode guide on Flowbite and enable it either manually or by using a dark mode switcher.\n\nUse the Tailwind CSS Datepicker component from Flowbite to select a date or range of dates based on the Datepicker API and configure the component using the methods and options that you can pass when creating the object using JavaScript.\n\nUse the object parameters from the Datepicker component to set the datepicker parent input element and the options associated with it when creating a new instance.\n\nUse these optional options for the Datepicker object to set options such as the date format, orientation, max and min dates, custom buttons, callback functions and more.\n\nUse the following methods of the Datepicker object to programmatically manipulate the behaviour.\n\nCheck out the following examples to learn how to use a basic HTML markup together with the Flowbite Datepicker API JS.\n\nFirst of all, you need to select the datepicker element (it can be an input field or div for inline datepickers) and set up the options object.\n\nNext step is to create a new instance of a Datepicker object using the parameters we have set above.\n\nUse the following methods to show and hide the datepicker, set or get the currently selected date and get access to the instance.\n\nHere is an example of the HTML markup that you can use for the JavaScript example above.\n\nIf you’re using the TypeScript configuration from Flowbite then you can import the types for the Datepicker object, parameters and its options.\n\nHere’s an example that applies the types from Flowbite to the code above:\n\nIf you want to directly use the main Datepicker component instance you can either install it via NPM and import it or use the method using our Instance Manager to call all of the extra options and methods from the parent plugin library:\n\nAfter you’ve installed the NPM library, you will need to import the module:\n\nInitialize a new element using the constructor and optionally add your own options based on your needs:\n\nIf you want to use the Tailwind Date Range Picker you have to import the module:\n\nThen in the same fashion you can initialize a date range picker component by using the constructor:\n\nOne of our community members built the React version of the Flowbite Datepicker and you can learn more about it on this repository on GitHub.\n\nIn order to support turbo load from Ruby on Rails 7, you have to include the file either from NPM or CDN into your project.\n\nFollow the quickstart guide and then include the following JavaScript file:\n\nDon’t forget to also import it inside your file:"
    }
]