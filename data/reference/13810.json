[
    {
        "link": "https://freecodecamp.org/news/solid-principles-for-programming-and-software-design",
        "document": "The SOLID principles of object-oriented programming help make object-oriented designs more understandable, flexible, and maintainable.\n\nThey also make it easy to create readable and testable code that many developers can collaboratively work with anywhere and anytime. And they make you aware of the best way to write code üí™.\n\nSOLID is a mnemonic acronym that stands for the five design principles of Object-Oriented class design. These principles are:\n\nIn this article, you will learn what these principles stand for and how they work using JavaScript examples. The examples should be fine even if you are not fully conversant with JavaScript, because they apply to other programming languages as well.\n\nWhat is the Single-Responsibility Principle (SRP)?\n\nThe Single-responsibility Principle, or SRP, states that a class should only have one reason to change. This means that a class should have only one job and do one thing.\n\nLet‚Äôs take a look at a proper example. You‚Äôll always be tempted to put similar classes together ‚Äì but unfortunately, this goes against the Single-responsibility principle. Why?\n\nThe object below has three methods: two validation methods, ( and ), and a method.\n\nThe method goes against the SRP because the goal is that a class should have only one job and do one thing. The class does two jobs ‚Äì it validates the person‚Äôs name and age and then displays some information.\n\nThe way to avoid this problem is to separate code that supports different actions and jobs so that each class only performs one job and has one reason to change.\n\nThis means that the class will only be responsible for validating a user, as seen below:\n\nWhile the new class will now be responsible for displaying a person, as you can see in the code block below:\n\nWith this, you will have fulfilled the single-responsibility principle, meaning our classes now have just one reason to change. If you want to change the class, it won‚Äôt affect the class.\n\nWhat is the Open-Closed Principle?\n\nThe open-closed principle can be confusing because it's a two-direction principle. According to Bertrand Meyer's definition on Wikipedia, the open-closed principle (OCP) states that software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\n\nThis definition can be confusing, but an example and further clarification will help you understand.\n\nThere are two primary attributes in the OCP:\n‚Ä¢ None It is open for extension ‚Äî This means you can extend what the module can do.\n‚Ä¢ None It is closed for modification ‚Äî This means you cannot change the source code, even though you can extend the behavior of a module or entity.\n\nOCP means that a class, module, function, and other entities can extend their behavior without modifying their source code. In other words, an entity should be extendable without modifying the entity itself. How?\n\nFor example, suppose you have an array of , which contains a list of possible flavors. In the class, a method will check if a particular flavor exists and logs a message.\n\nThe code above fails the OCP principle. Why? Well, because the code above is not open to an extension, meaning for you to add new flavors, you would need to directly edit the array. This means that the code is no longer closed to modification. Haha (that's a lot).\n\nTo fix this, you would need an extra class or entity to handle addition, so you no longer need to modify the code directly to make any extension.\n\nHere, we've added a new class ‚Äî ‚Äì to handle addition to the array using the method. This means your code is closed to modification but open to an extension because you can add new flavors without directly affecting the array.\n\nAlso, notice that SRP is in place because you created a new class. üòä\n\nWhat is the Liskov Substitution Principle?\n\nIn 1987, the Liskov Substitution Principle (LSP) was introduced by Barbara Liskov in her conference keynote ‚ÄúData abstraction‚Äù. A few years later, she defined the principle like this:\n\nTo be honest, that definition is not what many software developers want to see üòÇ ‚Äî so let me break it down into an OOP-related definition.\n\nThe principle defines that in an inheritance, objects of a superclass (or parent class) should be substitutable with objects of its subclasses (or child class) without breaking the application or causing any error.\n\nIn very plain terms, you want the objects of your subclasses to behave the same way as the objects of your superclass.\n\nA very common example is the rectangle, square scenario. It‚Äôs clear that all squares are rectangles because they are quadrilaterals with all four angles being right angles. But not every rectangle is a square. To be a square, its sides must have the same length.\n\nBearing this in mind, suppose you have a rectangle class to calculate the area of a rectangle and perform other operations like set color:\n\nKnowing fully well that all squares are rectangles, you can inherit the properties of the rectangle. Since the width and height has to be the same, then you can adjust it:\n\nTaking a look at the example, it should work properly:\n\nIn the above, you will notice that a rectangle is created, and the width and height are set. Then you can calculate the correct area.\n\nBut according to the LSP, you want the objects of your subclasses to behave the same way as the objects of your superclass. Meaning if you replace the with , everything should still work well:\n\nYou should get 100, because the is supposed to set both the width and height to 10. But because of the , this will return 25.\n\nThis breaks the LSP. To fix this, there should be a general class for all shapes that will hold all generic methods that you want the objects of your subclasses to have access to. Then for individual methods, you create an individual class for rectangle and square.\n\nThis way, you can set the color and get the color using either the super or subclasses:\n\nWhat is the Interface Segregation Principle?\n\nThe Interface Segregation Principle (ISP) states that ‚Äúa client should never be forced to implement an interface that it doesn‚Äôt use, or clients shouldn‚Äôt be forced to depend on methods they do not use‚Äù. What does this mean?\n\nJust as the term segregation means ‚Äî this is all about keeping things separated, meaning separating the interfaces.\n\nNote: By default, JavaScript does not have interfaces, but this principle still applies. So let‚Äôs explore this as if the interface exists, so you will know how it works for other programming languages like Java.\n\nA typical interface will contain methods and properties. When you implement this interface into any class, then the class needs to define all its methods. For example, suppose you have an interface that defines methods to draw specific shapes.\n\nWhen any class implements this interface, all the methods must be defined even if you won't use them or if they don‚Äôt apply to that class.\n\nLooking at the example above, you will notice that you cannot calculate the volume of a square or rectangle. Because the class implements the interface, you need to define all methods, even the ones you won‚Äôt use or need.\n\nTo fix this, you would need to segregate the interface.\n\nYou can now implement the specific interface that works with each class.\n\nWhat is the Dependency Inversion Principle?\n\nThis principle is targeted towards loosely coupling software modules so that high-level modules (which provide complex logic) are easily reusable and unaffected by changes in low-level modules (which provide utility features).\n\nAccording to Wikipedia, this principle states that:\n‚Ä¢ None High-level modules should not import anything from low-level modules. Both should depend on abstractions (for example, interfaces).\n‚Ä¢ None Abstractions should be independent of details. Details (concrete implementations) should depend on abstractions.\n\nIn plain terms, this principle states that your classes should depend upon interfaces or abstract classes instead of concrete classes and functions. This makes your classes open to extension, following the open-closed principle.\n\nLet's look at an example. When building a store, you would want your store to make use of a payment gateway like stripe or any other preferred payment method. You might write your code tightly coupled to that API without thinking of the future.\n\nBut then what if you discover another payment gateway that offers far better service, let‚Äôs say PayPal? Then it becomes a struggle to switch from Stripe to Paypal, which should not be an issue in programming and software design.\n\nConsidering the example above, you'll notice that if you change the payment gateway, you won't just need to add the class ‚Äì you'll also need to make changes to the class. This does not just go against the Dependency Inversion Principle but also against the open-closed principle.\n\nTo fix this, you must ensure that your classes depend upon interfaces or abstract classes instead of concrete classes and functions. For this example, this interface will contain all the behavior you want your API to have and doesn't depend on anything. It serves as an intermediary between the high-level and low-level modules.\n\nIn the code above, you will notice that the class is an interface between the class and the class. In a situation where you need to make use of PayPal, all you have to do is create a which would work with the class, and everything will work without affecting the class.\n\nYou will also notice that this follows the Liskov Substitution Principle because you can replace it with other implementations of the same interface without breaking your application.\n\nIt's been an adventureüôÉ. I hope you noticed that each of these principles are related to the others in some way.\n\nIn an attempt to correct one principle, say the dependency inversion principle, you indirectly ensure that your classes are open to extension but closed to modification, for example.\n\nYou should keep these principles in mind when writing code, because they make it easier for many people to collaborate on your project. They simplify the process of extending, modifying, testing, and refactoring your code. So make sure you understand their definitions, what they do, and why you need them beyond OOP.\n\nFor more understanding, you can watch this video by Beau Carnes on the freeCodeCamp YouTube channel or read this article by Yiƒüit Kemal Erin√ß.\n\nYou can access over 200 of my articles by visiting my website. You can also use the search field to see if I've written a specific article."
    },
    {
        "link": "https://digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design",
        "document": "SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle Bob).\n\nThese principles establish practices for developing software with considerations for maintaining and extending it as the project grows. Adopting these practices can also help avoid code smells, refactor code, and develop Agile or Adaptive software.\n\nIn this article, you will be introduced to each principle individually to understand how SOLID can help make you a better developer.\n\nFor example, consider an application that takes a collection of shapes‚Äîcircles and squares‚Äîand calculates the sum of the area of all the shapes in the collection.\n\nFirst, create the shape classes and have the constructors set up the required parameters.\n\nFor squares, you will need to know the of a side:\n\nFor circles, you will need to know the :\n\nNext, create the class and write the logic to sum up the areas of all provided shapes. The area of a square is calculated by length squared, and the area of a circle is calculated by pi times radius squared.\n\nTo use the class, you will need to instantiate it, pass in an array of shapes, and display the output at the bottom of the page.\n\nHere is an example with a collection of three shapes:\n‚Ä¢ a second square with a length of 6\n\nThe problem with the output method is that the handles the logic to output the data.\n\nConsider a scenario where the output should be converted to another format like JSON.\n\nThe class would handle all of the logic, violating the single responsibility principle. The class should only be concerned with the sum of the areas of provided shapes. It should not care whether the user wants JSON or HTML.\n\nTo address this, you can create a separate class and use that new class to handle the logic you need to output the data to the user:\n\nThe class would work like this:\n\nThe class handles the logic needed to output the data to the user.\n\nThis means that a class should be extendable without modifying the class itself.\n\nLet‚Äôs revisit the class and focus on the method:\n\nConsider a scenario where the user would like the of additional shapes like triangles, pentagons, hexagons, etc. You would have to constantly edit this file and add more / blocks. That would violate the open-closed principle.\n\nA way you can make this method better is to remove the logic to calculate the area of each shape out of the class method and attach it to each shape‚Äôs class.\n\nHere is the method defined in :\n\nAnd here is the method defined in :\n\nThe method for can then be rewritten as:\n\nNow, you can create another shape class and pass it in when calculating the sum without breaking the code.\n\nHowever, another problem arises. How do you know that the object passed into the is actually a shape or if the shape has a method named ?\n\nCoding to an interface is an integral part of SOLID.\n\nModify your shape classes to the .\n\nHere is the update to :\n\nAnd here is the update to :\n\nIn the method for , you can check if the shapes provided are actually instances of the ; otherwise, throw an exception:\n\nThis means that every subclass or derived class should be substitutable for their base or parent class.\n\nBuilding off the example class, consider a new class that extends the class:\n\nRecall that the class resembles this:\n\nIf you tried to run an example like this:\n\nWhen you call the method on the object, you will get an error, informing you of an array-to-string conversion.\n\nTo fix this, instead of returning an array from the class sum method, return :\n\nThe can be a float, double or integer.\n\nStill building from the previous example, you will need to support the new three-dimensional shapes of and , and these shapes will need to also calculate .\n\nLet‚Äôs consider what would happen if you were to modify the to add another contract:\n\nNow, any shape you create must implement the method, but you know that squares are flat shapes and that they do not have volumes, so this interface would force the class to implement a method that it has no use of.\n\nThis would violate the interface segregation principle. Instead, you could create another interface called that has the contract, and three-dimensional shapes can implement this interface:\n\nThis is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces. Instead of using a or a , you can create another interface, maybe , and implement it on both the flat and three-dimensional shapes.\n\nThis way, you can have a single API for managing the shapes:\n\nNow in class, you can replace the call to the method with and also check if the object is an instance of the and not the .\n\nThis principle allows for decoupling.\n\nHere is an example of a that connects to a MySQL database:\n\nFirst, the is the low-level module while the is high level, but according to the definition of D in SOLID, which states to Depend on abstraction, not on concretions. This snippet above violates this principle as the class is being forced to depend on the class.\n\nLater, if you were to change the database engine, you would also have to edit the class, which would violate the .\n\nThe class should not care what database your application uses. To address these issues, you can code to an interface since high-level and low-level modules should depend on abstraction:\n\nThe interface has a connect method, and the class implements this interface. Also, instead of directly type-hinting the class in the constructor of the , you type-hint the . No matter the type of database your application uses, the class can connect to the database without any problems, and the open-close principle is not violated.\n\nThis code establishes that both the high-level and low-level modules depend on abstraction.\n\nThis article introduced the five principles of the SOLID Code. Projects that adhere to these principles can be shared with collaborators, extended, modified, tested, and refactored with fewer complications.\n\nContinue your learning by reading about other practices for Agile and Adaptive software development."
    },
    {
        "link": "https://stackoverflow.blog/2021/11/01/why-solid-principles-are-still-the-foundation-for-modern-software-architecture",
        "document": "The SOLID principles are a time-tested rubric for creating quality software. But in a world of multi-paradigm programming and cloud computing, do they still stack up? I'm going to explore what SOLID stands for (literally and figuratively), explain why it still makes sense, and share some examples of how it can be adapted for modern computing.\n\nSOLID is a set of principles distilled from the writings of Robert C. Martin in the early 2000s. It was proposed as a way to think specifically about the quality of object-oriented (OO) programming. As a whole, the SOLID principles make arguments for how code should be split up, which parts should be internal or exposed, and how code should use other code. I'll dive into each letter below and explain its original meaning, as well as an expanded meaning that can apply outside of OO programming.\n\nIn the early 2000's, Java and C++ were king. Certainly in my university classes, Java was our language of choice and most of our exercises and lessons used it. The popularity of Java spawned a cottage industry of books, conferences, courses, and other material to get people from writing code to writing good code.\n\nSince then, the changes in the software industry have been profound. A few notable ones:\n‚Ä¢ Dynamically-typed languages such as Python, Ruby, and especially JavaScript have become just as popular as Java‚Äîovertaking it in some industries and types of companies.\n‚Ä¢ Non-object-oriented paradigms, most notably functional programming (FP), are also more common in these new languages. Even Java itself introduced lambdas! Techniques such as metaprogramming (adding and changing methods and features of objects) have gained popularity as well. There are also \"softer\" OO flavors such as Go, which has static typing but not inheritance. All this means that classes and inheritance are less important in modern software than in the past.\n‚Ä¢ Open-source software has proliferated. Whereas earlier, the most common practice would be to write closed-source compiled software to be used by customers, nowadays it's much more common for your dependencies to be open-source. Because of this, the kind of logic and data hiding that used to be imperative when writing a library is no longer as important.\n‚Ä¢ Microservices and software as a service exploded onto the scene. Rather than deploying an application as a big executable that links all its dependencies together, it's much more common to deploy a small service that talks to other services, either your own or powered by a third party.\n\nTaken as a whole, many of the things that SOLID really cared about‚Äîsuch as classes and interfaces, data hiding, and polymorphism‚Äîare no longer things that programmers deal with every day.\n\nThe industry is different in many ways now, but there are some things that haven't changed and likely won't. These include:\n‚Ä¢ Code is written and modified by people. Code is written once and read many, many times. There will always be a need for well-documented code, particularly well-documented APIs, whether internal or external.\n‚Ä¢ Code is organized into modules. In some languages, these are classes. In others, they may be individual source files. In JavaScript, they may be exported objects. Regardless, there exists some way of separating and organizing code into distinct, bounded units. Therefore, there will always be a need to decide how best to group code together.\n‚Ä¢ Code can be internal or external. Some code is written to be used by yourself or your team. Other code is written to be used by other teams or even by external customers (through an API). This means there needs to be some way to decide what code is \"visible\" and what is \"hidden.\"\n\nIn the following sections, I will restate each of the five SOLID principles to a more general statement that can apply to OO, FP, or multi-paradigm programming and provide examples. In many cases, these principles can even apply to whole services or systems!\n\nNote that I will use the word module in the following paragraphs to refer to a grouping of code. This could be a class, a module, a file, etc.\n\nOriginal definition: \"There should never be more than one reason for a class to change.\"\n\nIf you write a class with many concerns, or \"reasons to change\", then you need to change the same code whenever any of those concerns has to change. This increases the likelihood that a change to one feature will accidentally break a different feature.\n\nAs an example, here's a franken-class that should never make it to production:\n\nNew definition: \"Each module should do one thing and do it well.\"\n\nThis principle is closely related to the topic of high cohesion. Essentially, your code should not mix multiple roles or purposes together.\n\nHere's an FP version of this same example using JavaScript:\n\nThis could also apply in microservice design; if you have a single service that handles all three of these functions, it's trying to do too much.\n\nOriginal definition: \"Software entities should be open for extension, but closed for modification.\"\n\nThis is part of the design of languages like Java‚Äîyou can create classes and extend them (by creating a subclass), but you can't modify the original class.\n\nOne reason for making things \"open for extension\" is to limit the dependency on the author of the class‚Äîif you need a change to the class, you'd constantly need to ask the original author to change it for you, or you'd need to dive into it to change it yourself. What's more, the class would start to incorporate many different concerns, which breaks the single responsibility principle.\n\nThe reason for closing classes for modification is that we may not trust any and all downstream consumers to understand all the \"private\" code we use to get our feature working, and we want to protect it from unskilled hands.\n\nNew definition: \"You should be able to use and add to a module without rewriting it.\"\n\nThis comes for free in OO-land. In an FP world, your code has to define explicit \"hook points\" to allow modification. Here's an example where not only before and after hooks are allowed, but even the base behavior can be overridden by passing a function to your function:\n\nOriginal definition: \"If S is asubtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program.\"\n\nThis is a basic attribute of OO languages. It means that you should be able to use any subclass in place of their parent class. This allows for confidence in your contract‚Äîyou can safely depend on any object that \"is a\" type T to continue to behave like a T. Here it is in practice:\n\nNew definition: You should be able to substitute one thing for another if those things are declared to behave the same way.\n\nIn dynamic languages, the important thing to take from this is that if your program \"promises\" to do something (such as implement an interface or a function), you need to keep to your promise and not surprise your clients.\n\nMany dynamic languages use duck typing to accomplish this. Essentially, your function either formally or informally declares that it expects its input to behave a particular way and proceeds on that assumption.\n\nHere's an example using Ruby:\n\nIn this case, the function doesn't care what type input is‚Äîonly that it has a to_s function that behaves the way all to_s functions are supposed to behave, i.e. it turns the input into a string. Many dynamic languages don't have a way to force this behavior, so this becomes more of a discipline issue than a formalized technique.\n\nHere's an FP example using TypeScript. In this case, a higher-order function takes in a filter function which expects a single numeric input and returns a boolean value:\n\nOriginal Definition: \"Many client-specific interfaces are better than one general-purpose interface.\"\n\nIn OO, you can think of this as providing a \"view\" into your class. Rather than giving your full implementation to all your clients, you create interfaces on top of them with just the methods relevant to that client, and ask your clients to use those interfaces.\n\nAs with the single responsibility principle, this decreases coupling between systems, and ensures that a client doesn't need to know about, or depend on, features that it has no intention of using.\n\nHere's an example that passes the SRP test:\n\nThis code will generally have only one \"reason to change\"‚Äîit's all related to print requests, which are all part of the same domain, and all three methods will likely change the same state. However, it's not likely that the same client that's creating requests is the one that's working on requests. It makes more sense to separate these interfaces out:\n\nNew Definition: \"Don't show your clients more than they need to see\".\n\nOnly document what your client needs to know. This might mean using documentation generators to only output \"public\" functions or routes and leave \"private\" ones un-emitted.\n\nIn the microservice world, you can either use documentation or true separation to enforce clarity. For example, your external customers may only be able to log in as a user, but your internal services might need to get lists of users or additional attributes. You could either create a separate \"external only\" user service that calls your main service, or you could output specific documentation just for external users that hides the internal routes.\n\nIn OO, this means that clients should depend on interfaces rather than concrete classes as much as possible. This ensures that code is relying on the smallest possible surface area‚Äîin fact, it doesn't depend on code at all, just a contract defining how that code should behave. As with other principles, this reduces the risk of a breakage in one place causing breakages elsewhere accidentally. Here's a simplified example:\n\nIf you're writing code that needs a logger, you don't want to limit yourself to writing to files, because you don't care. You just call the write method and let the concrete class sort it out.\n\nNew definition: \"Depend upon abstractions, not concretions.\"\n\nYep, in this case I'd leave the definition as is! The idea of keeping things abstract where possible is still an important one, even if the mechanism of abstracting in modern code is not as strong as it is in a strict OO world.\n\nPractically, this is almost identical to the Liskov substitution principle discussed above. The main difference is that here, there is no default implementation. Because of this, the discussion involving duck typing and hook functions in that section equally applies to dependency inversion.\n\nYou can also apply abstraction to the microservice world. For example, you can replace direct communication between services with a message bus or queue platform such as Kafka or RabbitMQ. Doing this allows the services to send messages to a single generic place, without caring which specific service will pick those messages up and perform its task.\n\nTo restate \"modern SOLID\" one more time:\n‚Ä¢ Don't surprise the people who read your code.\n‚Ä¢ Don't surprise the people who use your code.\n‚Ä¢ Don't overwhelm the people who read your code.\n‚Ä¢ Use sane boundaries for your code.\n‚Ä¢ Use the right level of coupling‚Äîkeep things together that belong together, and keep them apart if they belong apart.\n\nGood code is good code‚Äîthat's not going to change, and SOLID is a, well, solid basis to practice that!"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/447532/when-to-not-use-solid-principles",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://bmc.com/blogs/solid-design-principles",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/48648255/how-does-the-solid-open-closed-principle-fit-in-with-dependency-injection-and-de",
        "document": "\n‚Ä¢ When we say that code is \"available for extension\" that doesn't automatically mean that we inherit from it or add new methods to existing interfaces. Inheritance is only one way to \"extend\" behavior.\n‚Ä¢ When we apply the Dependency Inversion Principle we don't depend directly on other concrete classes, so we don't need to change those implementations if we need them to do something different. And classes that depend on abstractions are extensible because substituting implementations of abstractions gets new behavior from existing classes without modifying them.\n\nExamining this sentence may help to shed some light on the question:\n\nThis may sound like it's splitting hairs, but a method never needs to return anything. Methods aren't like people who have something to say and need to say it. The \"need\" rests with the caller of the method. The caller needs what the method returns.\n\nIf the caller was passing and receiving , but now it needs to receive , then it is the need of the caller that has changed, not the need of the method being called.\n\nIf the need of the caller has changed, does it follow that the needs of all callers have changed? If you change what the method returns to meet the needs of one caller, other callers might be adversely affected. That's why you might create something new that meets the need of one particular caller while leaving the existing method or class unchanged. In that sense the existing code is \"closed\" while at the same time its behavior is open to extension.\n\nAlso, extending existing code doesn't necessarily mean modifying a class, adding a method to an interface, or inheriting. It just means that it incorporates the existing code while providing something extra.\n\nLet's go back to the class you started with.\n\nNow you have a need for a class that includes the functionality of this class but does something different. It could look like this. (In this example it looks like overkill, but in real-world example it wouldn't.)\n\nIn this case the new class happens to implement the same interface, so now you've got two implementations of the same interface. But it doesn't need to. It could be this:\n\nYou could also \"extend\" the behavior of the original class through inheritance:\n\nAll of these examples extend existing code without modifying it. In practice at times it may be beneficial to add existing properties and methods to new classes, but even then we'd like to avoid modifying the parts that are already doing their jobs. And if we're writing simple classes with single responsibilities then we're less likely to find ourselves throwing the kitchen sink into an existing class.\n\nWhat does that have to do with the Dependency Inversion Principle, or depending on abstractions? Nothing directly, but applying the Dependency Inversion Principle can help us to apply the Open/Closed Principle.\n\nWhere practical, the abstractions that our classes depend on should be designed for the use of those classes. We're not just taking whatever interface someone else has created and sticking it into our central classes. We're designing the interface that meets our needs and then adapting other classes to fulfill those needs.\n\nFor example, suppose and are in your class library, I happen to need something that formats numbers a certain way, and your class looks like it does what I need. I'm not just going to inject into my class. I'm going to write an interface that does what I want:\n\nThen I'm going to write an implementation of that interface that uses your class, like:\n\nIf I wasn't applying the Dependency Inversion principle and I depended directly on then I'd have to figure out how to change your class to do what I need. But because I'm depending on an abstraction that I created to meet my needs, automatically I'm thinking of how to incorporate the behavior of your class, not change it. And once I do that, I obviously wouldn't want the behavior of your class to change unexpectedly.\n\nI could also depend on your interface - - and create my own implementation. But creating my own also helps me adhere to the Interface Segregation Principle. The interface I depend on was created for me, so it won't have anything I don't need. Yours might have other stuff I don't need, or you could add more in later.\n\nRealistically we're at times just going to use abstractions that were given to us, like . But hopefully that's later when we're writing specific implementation details. When it comes to the primary behaviors of the application (if you're doing DDD, the \"domain\") it's better to define the interfaces our classes will depend on and then adapt outside classes to them.\n\nFinally, classes that depend on abstractions are also more extensible because we can substitute their dependencies - in effect altering (extending) their behavior without any change to the classes themselves. We can extend them instead of modifying them."
    },
    {
        "link": "https://linkedin.com/advice/0/how-does-dependency-injection-relate-solid-zwobe",
        "document": ""
    },
    {
        "link": "https://artemasemenov.medium.com/mastering-dependency-injection-in-c-best-practices-pitfalls-and-future-trends-61189ad97f25",
        "document": "When crafting elegant and scalable software in C#, a keen understanding of Dependency Injection (DI) is more than a luxury ‚Äî it‚Äôs a necessity. It‚Äôs a design pattern that underpins many modern .NET applications, providing a solid foundation for managing dependencies between classes. In its most basic form, Dependency Injection promotes loose coupling, simplifying the maintenance and testing of applications.\n\nThis article will explore the best practices for Dependency Injection in C#, shedding light on common pitfalls and demonstrating how to harness the full power of this vital technique. As we journey through this in-depth examination, we‚Äôll unpack the history and importance of Dependency Injection, delve into its implementation, and scrutinize real-world applications.\n\nBy the end of this article, you‚Äôll be equipped to integrate Dependency Injection into your C# applications effectively, optimizing code quality and enhancing scalability. Whether you‚Äôre a seasoned C# veteran seeking a fresh perspective or a novice programmer looking to deepen your understanding, this comprehensive guide will serve as an invaluable resource in your coding toolkit.\n\nTo fully appreciate Dependency Injection in C# and understand its potential, we need to delve into its historical context and explore the essence of its necessity in modern software development.\n\nThe roots of Dependency Injection stretch back to the advent of object-oriented programming, a paradigm that favors the creation of cohesive and loosely coupled modules. However, the official term ‚ÄúDependency Injection‚Äù wasn‚Äôt coined until the early 2000s when Martin Fowler, a British software engineer, gave this powerful technique a name. Fowler highlighted Dependency Injection as a form of Inversion of Control (IoC), a broader principle that shifts the control of objects or portions of a program to a container or a framework.\n\nSince Fowler‚Äôs introduction, Dependency Injection has gained significant traction across programming languages, but it has shown particular effectiveness within the .NET framework, more specifically in C#. Its wide adoption can be attributed to the development of various DI frameworks and libraries that simplify the implementation of this pattern.\n\nWhy Dependency Injection is Necessary in C#\n\nWhile C# is a flexible and powerful language, like any tool, its power can be both an asset and a liability. Without proper management, dependencies between classes can result in tightly-coupled code, making it difficult to modify, scale, and test applications.\n\nEnter Dependency Injection. This pattern seeks to mitigate these issues, contributing to more maintainable and scalable C# code. It provides a systematic way to assemble classes from loosely-coupled components, ultimately improving the reusability and testability of the code.\n\nMoreover, with the advent of .NET Core and the built-in support for Dependency Injection, the technique has become even more critical in creating robust and efficient applications.\n\nHaving touched on the historical and practical reasons for Dependency Injection‚Äôs relevance, let‚Äôs move on to understanding this pattern‚Äôs core concepts and how they‚Äôre implemented in C#.\n\nBefore we delve into the intricacies of employing Dependency Injection in C#, we need to understand its core concepts and its relationship with the broader principle of Inversion of Control.\n\nThe concept of Dependency Injection revolves around the idea of ‚Äúdependencies.‚Äù In the context of programming, a dependency is when one object relies on another to perform its function. Traditionally, an object would create or find its dependencies internally, but this leads to a tightly-coupled design that‚Äôs hard to manage and test.\n\nDependency Injection addresses this by having dependencies provided to the object (or ‚Äúinjected‚Äù), typically through the object‚Äôs constructor, a method, or a property. This way, the object isn‚Äôt responsible for finding or creating its dependencies, leading to a more modular and flexible design.\n\nThe three primary types of Dependency Injection are:\n‚Ä¢ Constructor Injection: The dependencies are provided through a class constructor. This is the most commonly used and the most recommended form of dependency injection.\n\nIn this example, is dependent on . The dependency is injected via the constructor and can be easily replaced with any class that implements the interface.\n\n2. Setter Injection: The client exposes a setter method that the injector uses to inject the dependency.\n\nIn this example, the dependency is injected via the property.\n\n3. Interface Injection: The dependency provides an injector method that will inject the dependency.\n\nInterface injection requires the dependent class to implement an interface that will be used to provide the dependency.\n\nIn this example, implements the interface to allow dependency injection.\n\nEach of these types has its uses, which we will explore further in the implementation section.\n\nInversion of Control (IoC) is a broader design principle that Dependency Injection falls under. It involves inverting the flow of control in a system, meaning that the framework or container calls the custom, user-written code, rather than the other way around.\n\nIn the context of Dependency Injection, IoC means inverting the control of managing dependencies. Instead of each object controlling its dependencies, this responsibility is given to an external entity (an IoC container). This external entity creates and wires up dependencies where they are needed.\n\nBy adhering to the principle of IoC, Dependency Injection allows for a much cleaner and modular codebase, making it easier to manage complexity, particularly in large-scale applications.\n\nWith a basic understanding of Dependency Injection and its relationship with Inversion of Control in place, we can proceed to explore the actual implementation of Dependency Injection in C# programming.\n\nNow that we‚Äôve grasped the core concepts of Dependency Injection and seen them in action through illustrative C# code snippets, it‚Äôs time to dive into the implementation process. This includes understanding standard practices and exploring Dependency Injection Containers in C#, which aid in managing dependencies.\n\nThe implementation of Dependency Injection in C# aligns with several standard practices. The examples previously given demonstrated how dependencies are injected through constructors, setters, or interfaces. However, there are further aspects to consider:\n‚Ä¢ High-level modules should not depend on low-level modules: Both should depend on abstractions. This principle, one of the SOLID principles for object-oriented programming, encourages us to design systems in a way that reduces the dependencies between modules.\n‚Ä¢ Abstraction should not depend on details: Details should depend on abstractions. This principle suggests that the overall strategy of a system should dictate the low-level tactics, not the other way around.\n\nSuppose we have a class which is a high-level module in our application. This class depends on a class which is a low-level module for sending notifications.\n\nIn the above code, is tightly coupled with . This isn't an ideal situation, because if we decide to change our notification method from email to something else like SMS or push notifications, would have to change too.\n\nWe can solve this by depending on an abstraction rather than depending directly on . Let's define an interface , and let the implement this interface.\n\nNow, depends on the abstraction , not on the low-level module . If we need to change our notification method, we just need to create a new class implementing , for example, , and inject it into . The class itself doesn't need to change, which adheres to the Open/Closed Principle‚Äîanother SOLID principle. This decouples the high-level module from the low-level module and makes the system more modular and flexible.\n\nAdhering to these principles results in an application structure that is modular, scalable, and easy to understand and maintain.\n\nA Dependency Injection Container, also known as an IoC (Inversion of Control) Container, is a framework for implementing automatic dependency injection. It manages object creation and injects dependencies when required, making it easier to implement Dependency Injection in a consistent manner throughout an application.\n\n.NET Core has built-in support for Dependency Injection and comes with its own lightweight IoC container. However, if you need more features, there are other more powerful containers available like Autofac, Ninject, and Unity.\n\nHere‚Äôs an example of how to use the built-in IoC container in .NET Core:\n\nIn this example, the class has a method. This is where you configure the application's services. In the method, a is registered as a service that can fulfil the dependency whenever it's required. The method specifies that a new instance should be created each time the service is requested.\n\nWith a fundamental understanding of implementing Dependency Injection in C# under our belt, we‚Äôre ready to explore the best practices to follow when incorporating this design pattern into your applications.\n\nUnderstanding the mechanism of Dependency Injection and its implementation in C# is half the battle. Equally crucial is understanding the best practices that ensure its benefits are fully harnessed. These practices not only improve code maintainability and readability, but they also enhance the flexibility and scalability of your applications.\n\nWhile there are various types of Dependency Injection, Constructor Injection is generally preferred. By using the constructor to inject dependencies, you guarantee the class has all it needs to be fully operational. This promotes immutability and enhances thread-safety, as the dependencies can‚Äôt be changed once they‚Äôre set.\n\nService Locator is often considered an anti-pattern as it hides class dependencies, making code harder to understand and maintain. It can also make code harder to test because it couples your code to specific dependencies, making it less flexible. While there can be use cases where a Service Locator may seem beneficial, using Dependency Injection will generally result in more maintainable and testable code.\n\nA key principle of Dependency Injection is to ‚Äúdepend upon abstractions, not concretions.‚Äù This means that your classes should depend on interfaces or abstract classes, not on concrete classes. This makes the system more modular and flexible, as you can easily swap one implementation for another.\n\nIn C#, different Dependency Injection lifetimes such as Transient, Scoped, and Singleton can be specified. Understanding their differences is critical. For example, a Singleton service lives for the duration of the application and all consumers share the same instance. A Transient service, on the other hand, is created each time it‚Äôs requested. Choosing the wrong lifetime can lead to issues like unintended sharing of state between requests.\n\nThe constructor should be used to assign dependencies to fields or properties, but nothing more. Heavy computation or logic that could throw exceptions should be avoided in constructors. The reason for this is that if a service‚Äôs instantiation fails, it might cause the entire Dependency Injection framework to fail, which can be hard to debug.\n\n6. Don‚Äôt Try to Resolve Everything with Dependency Injection\n\nDependency Injection is a tool, not a solution to every problem. There are cases where it‚Äôs not necessary and could even over-complicate things. If a class is not a shared dependency or doesn‚Äôt need to be substituted for testing or different implementations, it might not need to be injected.\n\nAdhering to these best practices while implementing Dependency Injection in C# can lead to more robust, testable, and maintainable code. It‚Äôs an essential tool in a developer‚Äôs toolkit, making software development a more manageable and enjoyable task.\n\nAs potent as Dependency Injection is, it‚Äôs not a silver bullet. Like any approach, it has its share of problems that developers should be aware of. Here, we will address a few common challenges associated with Dependency Injection in C# and provide recommendations to overcome them.\n\nOne of the most common pitfalls developers fall into is overusing Dependency Injection, which can lead to an overcomplicated system. This usually happens when developers try to apply Dependency Injection to classes that don‚Äôt have dependencies or don‚Äôt need to be interchangeable.\n\nSolution: Remember, Dependency Injection is a tool and should only be used when it solves a problem. If a class doesn‚Äôt have dependencies or doesn‚Äôt need to have different implementations, it might be best not to inject it.\n\nMisunderstanding or incorrectly managing Dependency Injection lifetimes can lead to severe issues such as state bleeding between requests or memory leaks.\n\nSolution: Take the time to understand the differences between Transient, Scoped, and Singleton lifetimes, and choose the appropriate one based on the needs of your application.\n\nWhen working with deep class hierarchies, managing dependencies can become problematic. It‚Äôs common to see constructors bloated with dependencies, which can make the code harder to read and maintain.\n\nSolution: If a class starts to have too many dependencies, it might be a sign that the class is doing too much and violating the Single Responsibility Principle. Consider refactoring the class and splitting its responsibilities among several smaller, more focused classes.\n\nWhile Dependency Injection is a boon for unit testing, it can cause difficulties if not implemented correctly. Dependencies that aren‚Äôt properly abstracted can make it hard to replace them with mock implementations for testing.\n\nSolution: Always depend on abstractions, not on concrete implementations. Make sure to abstract dependencies using interfaces or abstract classes, which allows for easy substitution with mock implementations during testing.\n\nThe use of Dependency Injection can increase the startup time of an application as the container needs to resolve all the dependencies at the start.\n\nSolution: To minimize the impact on startup time, keep your constructors lean, and avoid any heavy computation or I/O operations in the constructors. All the heavy operations should be deferred until they are really needed.\n\nBy being aware of these common challenges and knowing how to address them, you can ensure that Dependency Injection serves as a net positive for your C# applications.\n\nDependency Injection (DI) has been a staple in software design for a while, but as with any technology or approach, it continues to evolve. Let‚Äôs explore some of the innovative ideas and trends influencing the use of Dependency Injection in C# and .NET:\n\nContainerless Dependency Injection, also known as ‚ÄúPure DI‚Äù, refers to using the principles of Dependency Injection without a DI container. In this approach, dependencies are wired up manually in the ‚Äúcomposition root‚Äù of the application.\n\nThis method tends to be simpler, more explicit, and can lead to better design as it requires the developer to pay more attention to the dependency graph of an application. However, it can also be more tedious and error-prone, particularly for larger applications.\n\nOne of the recent trends is the auto-registration of dependencies, where the DI container automatically scans assemblies and registers services and their implementations. This can greatly reduce the amount of boilerplate code and make the process of adding new services much smoother.\n\nHowever, it‚Äôs important to use this feature judiciously as it can make the code less explicit, potentially hiding errors until runtime.\n\nAs functional programming paradigms are increasingly adopted in C#, some developers are exploring ways to integrate Dependency Injection with functional programming concepts. This can involve using monads, partial application, and other functional constructs to manage dependencies.\n\nAs more and more applications move to microservices architectures, Dependency Injection is playing a crucial role in managing the complexity of these systems. By helping to keep services decoupled and modular, DI can make it easier to develop, test, and maintain microservices.\n\nAspect-Oriented Programming involves separating cross-cutting concerns from the main business logic of the application. With DI, AOP can be implemented more easily, allowing developers to add behavior like logging, caching, and transaction management to their applications in a modular way.\n\nNavigating the world of Dependency Injection in C# is a journey that can significantly elevate your software design, promoting modularity, testability, and maintainability. It‚Äôs an approach that aligns with the principles of modern software development, advocating for loosely coupled and highly cohesive systems.\n\nWe‚Äôve delved into the concept of Dependency Injection, its types, and how to implement it in C#. We‚Äôve explored the best practices and addressed common problems that arise while working with Dependency Injection. Finally, we‚Äôve touched upon the innovative ideas and trends shaping the landscape of Dependency Injection.\n\nIt‚Äôs worth noting that while Dependency Injection provides numerous benefits, it isn‚Äôt without its challenges. Overuse can lead to overcomplication, and improper management of object lifetimes can lead to bugs. It‚Äôs crucial to understand these potential issues and follow the best practices to mitigate them.\n\nAs you continue to hone your skills in C#, remember to keep the principles of Dependency Injection in mind. They will not only help you create better software but also guide you to be a better developer. Keep exploring, keep learning, and remember: technology is constantly evolving, and so should we."
    },
    {
        "link": "https://stackoverflow.com/questions/38457179/confused-with-solid-and-dependecy-injection",
        "document": "\"High level\" and \"low level\" are terms associated with dependency inversion which has a relation to dependency injection but is a different concept. They both have the initials \"DI\", and the \"D\" in both stands for \"dependency,\" so they can create some confusion.\n\nBut in my opinion the terminology used when defining dependency inversion can be really confusing to .NET programmers trying to understand the concept. It's applicable, but some of the terminology isn't used among .NET developers.\n\nFrom Robert Martin's definition, as quoted on Wikipedia,\n\nWhat is a \"high level module\" and a \"low level module?\" If you find that confusing you're not alone. We don't really use those terms. The part that we can really understand and apply is that we should depend on abstractions.\n\nIn the case of , if it's just a container for a few properties then it's probably abstract enough. DTOs have been a common practice for some time, so if time had revealed that we needed to wrap them in interfaces then that pattern would have emerged by now. It doesn't hurt, but it's usually not necessary.\n\nGoing back to dependency inversion - the real confusion comes from the name itself. What is getting inverted? When you see diagrams like what's on the Wikipedia page, my recommendation is to look away from the blinding diagrams.\n\nMartin explains his use of the word \"inversion\" this way (going back to his original paper on the subject)\n\nOne might question why I use the word ‚Äúinversion‚Äù. Frankly, it is because more traditional software development methods, such as Structured Analysis and Design, tend to create software structures in which high level modules depend upon low level modules, and in which abstractions depend upon details. Indeed one of the goals of these methods is to define the subprogram hierarchy that describes how the high level modules make calls to the low level modules. Figure 1 is a good example of such a hierarchy. Thus, the dependency structure of a well designed object oriented program is ‚Äúinverted‚Äù with respect to the dependency structure that normally results from traditional procedural methods.\n\nIn other words, the inversion is a contrast between applying dependency inversion, and the \"traditional\" style of not applying dependency inversion. That might be clearer if you're coming from a background in which 'high level modules depend upon low level modules,' (and you use the term \"module.\") But if that was not previously your 'tradition' then what are you 'inverting?' Nothing.\n\nAll of those details still have meaning, but they are extremely confusing when you're trying to learn these concepts for the first time. My suggestion is to apply this part, as you already are: Depend on abstractions.\n\nIf you do that then you're applying the principle because whatever \"high-level modules\" and \"low-level modules\" are, your classes won't be too dependent on other classes - high-level, low-level, or otherwise."
    },
    {
        "link": "https://medium.com/@inzuael/solid-dependency-inversion-principle-part-5-f5bec43ab22e",
        "document": "Today is time for the fifth and last part of my series about the SOLID principles. This time I want to talk about the Dependency Inversion Principle, the letter D of the acronym.\n\nIt is a principle whose name is often misused interchangeable with Dependency Injection even it is not the same. Dependency Injection is an Inversion of Control technique for supplying objects (‚Äúdependencies‚Äù) to a class by a way of the Dependency Injection Design Pattern. Typically passing dependencies via constructor or field. In contrast the Dependency Inversion Principle is a general design guideline which recommends that classes should only have direct relationships with high-level abstractions. So to make things more clear let‚Äôs start having a look at the principle.\n\nWhat is the Dependency Inversion Principle?\n\nThe Dependency Inversion Principle (DIP) emphasizes decoupling and abstraction. The principle consists of two core concepts: high-level modules should not depend on low-level modules, and both should depend on abstractions. This inverted dependency relationship promotes flexibility, testability, and maintainability.\n\nImplementing the Dependency Inversion Principle in projects can yield several benefits:\n‚Ä¢ Loose Coupling: By introducing abstractions, high-level modules are no longer directly dependent on low-level modules. This loose coupling allows for independent development, modification, and replacement of individual components.\n‚Ä¢ Testability: Abstractions make it easier to write unit tests by enabling the use of mock objects or test doubles. With dependencies abstracted away, I can isolate and test individual modules more effectively.\n‚Ä¢ Maintainability: The DIP reduces the impact of changes in low-level modules on high-level modules. This modular structure makes it simpler to update or replace components without affecting the entire system, leading to improved maintainability.\n‚Ä¢ Scalability: The use of abstractions allows for the addition of new implementations without modifying existing code. This scalability makes it easier to extend the system‚Äôs functionality while preserving the existing codebase."
    }
]