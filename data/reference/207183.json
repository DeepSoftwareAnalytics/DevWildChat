[
    {
        "link": "https://stackoverflow.com/questions/71123613/refactoring-nested-loop-with-shared-variables",
        "document": "I have a function that process some quite nested data, using nested loops. Its simplified structure is something like this:\n\nThis does not look very pythonic to me, so I want to refactor it. My idea was to break it in multiple functions, like:\n\nAs you can see, for the more nested level, I need to do something using all its \"parent\" elements. The functions would have unique scopes, so I couldn't access those elements. Passing all the previous elements to each function (like ) does look ugly and not very pythonic to me either..."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/soglp9/thinking_about_best_practices_for_refactoring",
        "document": "I get it if it's pretty straightforward, for example, if there are nested IF statements and it can easily be rearranged for better code, but I often run into more ambiguous situations.\n\nFor example, how do you handle code if the IF and ELSE IF have some similar code, but not all similar code? And when is it justifiable to have nested IF statements? Should I be avoiding loops, if I can, or can I use them liberally? How about lists and arrays?\n\nAnd should you sacrifice a bit of readability to make the code less lines? Or is it okay to have some repeated lines, to help increase readability and to help make more sense to other coders?"
    },
    {
        "link": "https://codechef.com/learn/course/r/LPRLP25/problems/LPRPR162",
        "document": ""
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/300247/refactoring-method-with-nested-loops-and-6-variables",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/programminghorror/comments/rdhkmb/what_is_your_solution_to_break_from_nested_loops",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://stackoverflow.com/questions/72880823/symmetry-matrix-behavior-on-r-4-1",
        "document": "I want to test the symmetry of matrices in R 4.1.1. I have a dataframe and then I convert it to a matrix. The data type with function returns now both a and an . The matrix is symmetric, but the function returns .\n\nThis is what I do:\n\nMy question is: Is there a more straightforward way, other than melting the matrix and building it again, to check for symmetry of a matrix? I need to read many large matrices and this is a quite convoluted way to deal with this."
    },
    {
        "link": "https://geeksforgeeks.org/check-if-a-matrix-is-symmetric-or-not-in-r-programming-issymmetric-function",
        "document": ""
    },
    {
        "link": "http://adv-r.had.co.nz/Data-structures.html",
        "document": "Want a physical copy of the second edition of this material? Buy a book from Amazon!\n\nThis chapter summarises the most important data structures in base R. You’ve probably used many (if not all) of them before, but you may not have thought deeply about how they are interrelated. In this brief overview, I won’t discuss individual types in depth. Instead, I’ll show you how they fit together as a whole. If you need more details, you can find them in R’s documentation.\n\nR’s base data structures can be organised by their dimensionality (1d, 2d, or nd) and whether they’re homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types). This gives rise to the five data types most often used in data analysis:\n\nAlmost all other objects are built upon these foundations. In the OO field guide you’ll see how more complicated objects are built of these simple pieces. Note that R has no 0-dimensional, or scalar types. Individual numbers or strings, which you might think would be scalars, are actually vectors of length one.\n\nGiven an object, the best way to understand what data structures it’s composed of is to use . is short for structure and it gives a compact, human readable description of any R data structure.\n\nTake this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. You can check your answers in answers.\n• None What are the three properties of a vector, other than its contents?\n• None What are the four common types of atomic vectors? What are the two rare types?\n• None What are attributes? How do you get them and set them?\n• None How is a list different from an atomic vector? How is a matrix different from a data frame?\n• None Can you have a list that is a matrix? Can a data frame have a column that is a matrix?\n• None Vectors introduces you to atomic vectors and lists, R’s 1d data structures.\n• None Attributes takes a small detour to discuss attributes, R’s flexible metadata specification. Here you’ll learn about factors, an important data structure created by setting attributes of an atomic vector.\n• None Matrices and arrays introduces matrices and arrays, data structures for storing 2d and higher dimensional data.\n• None Data frames teaches you about the data frame, the most important data structure for storing data in R. Data frames combine the behaviour of lists and matrices to make a structure ideally suited for the needs of statistical data.\n\nThe basic data structure in R is the vector. Vectors come in two flavours: atomic vectors and lists. They have three common properties:\n• Type, , what it is.\n• Length, , how many elements it contains.\n\nThey differ in the types of their elements: all elements of an atomic vector must be the same type, whereas the elements of a list can have different types.\n\nNB: does not test if an object is a vector. Instead it returns only if the object is a vector with no attributes apart from names. Use to test if an object is actually a vector.\n\nThere are four common types of atomic vectors that I’ll discuss in detail: logical, integer, double (often called numeric), and character. There are two rare types that I will not discuss further: complex and raw.\n\nAtomic vectors are usually created with , short for combine:\n\nAtomic vectors are always flat, even if you nest ’s:\n\nMissing values are specified with , which is a logical vector of length 1. will always be coerced to the correct type if used inside , or you can create s of a specific type with (a double vector), and .\n\nGiven a vector, you can determine its type with , or check if it’s a specific type with an “is” function: , , , , or, more generally, .\n\nNB: is a general test for the “numberliness” of a vector and returns for both integer and double vectors. It is not a specific test for double vectors, which are often called numeric.\n\nAll elements of an atomic vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type. Types from least to most flexible are: logical, integer, double, and character.\n\nFor example, combining a character and an integer yields a character:\n\nWhen a logical vector is coerced to an integer or double, becomes 1 and becomes 0. This is very useful in conjunction with and\n\nCoercion often happens automatically. Most mathematical functions ( , , , etc.) will coerce to a double or integer, and most logical operations ( , , , etc) will coerce to a logical. You will usually get a warning message if the coercion might lose information. If confusion is likely, explicitly coerce with , , , or .\n\nLists are different from atomic vectors because their elements can be of any type, including lists. You construct lists by using instead of :\n\nLists are sometimes called recursive vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors.\n\nwill combine several lists into one. If given a combination of atomic vectors and lists, will coerce the vectors to lists before combining them. Compare the results of and :\n\nThe a list is . You can test for a list with and coerce to a list with . You can turn a list into an atomic vector with . If the elements of a list have different types, uses the same coercion rules as .\n\nLists are used to build up many of the more complicated data structures in R. For example, both data frames (described in data frames) and linear models objects (as produced by ) are lists:\n• None What are the six types of atomic vector? How does a list differ from an atomic vector?\n• None What makes and fundamentally different to and ?\n• None Test your knowledge of vector coercion rules by predicting the output of the following uses of :\n• None Why do you need to use to convert a list to an atomic vector? Why doesn’t work?\n• None Why is true? Why is true? Why is false?\n• None Why is the default missing value, , a logical vector? What’s special about logical vectors? (Hint: think about .)\n\nAll objects can have arbitrary additional attributes, used to store metadata about the object. Attributes can be thought of as a named list (with unique names). Attributes can be accessed individually with or all at once (as a list) with .\n\nThe function returns a new object with modified attributes:\n\nBy default, most attributes are lost when modifying a vector:\n\nThe only attributes not lost are the three most important:\n• None Names, a character vector giving each element a name, described in names.\n• None Dimensions, used to turn vectors into matrices and arrays, described in matrices and arrays.\n• None Class, used to implement the S3 object system, described in S3.\n\nEach of these attributes has a specific accessor function to get and set values. When working with these attributes, use , , and , not , , and .\n\nYou can name a vector in three ways:\n• None By modifying an existing vector in place: .\n\nNames don’t have to be unique. However, character subsetting, described in subsetting, is the most important reason to use names and it is most useful when the names are unique.\n\nNot all elements of a vector need to have a name. If some names are missing when you create the vector, the names will be set to an empty string for those elements. If you modify the vector in place by setting some, but not all variable names, will return NA (more specifically, NA_character_) for them. If all names are missing, will return .\n\nYou can create a new vector without names using , or remove names in place with .\n\nOne important use of attributes is to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data. Factors are built on top of integer vectors using two attributes: the , “factor”, which makes them behave differently from regular integer vectors, and the , which defines the set of allowed values.\n\nFactors are useful when you know the possible values a variable may take, even if you don’t see all values in a given dataset. Using a factor instead of a character vector makes it obvious when some groups contain no observations:\n\nSometimes when a data frame is read directly from a file, a column you’d thought would produce a numeric vector instead produces a factor. This is caused by a non-numeric value in the column, often a missing value encoded in a special way like or . To remedy the situation, coerce the vector from a factor to a character vector, and then from a character to a double vector. (Be sure to check for missing values after this process.) Of course, a much better plan is to discover what caused the problem in the first place and fix that; using the argument to is often a good place to start.\n\nUnfortunately, most data loading functions in R automatically convert character vectors to factors. This is suboptimal, because there’s no way for those functions to know the set of all possible levels or their optimal order. Instead, use the argument to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the data. A global option, , is available to control this behaviour, but I don’t recommend using it. Changing a global option may have unexpected consequences when combined with other code (either from packages, or code that you’re ing), and global options make code harder to understand because they increase the number of lines you need to read to understand how a single line of code will behave.\n\nWhile factors look (and often behave) like character vectors, they are actually integers. Be careful when treating them like strings. Some string methods (like and ) will coerce factors to strings, while others (like ) will throw an error, and still others (like ) will use the underlying integer values. For this reason, it’s usually best to explicitly convert factors to character vectors if you need string-like behaviour. In early versions of R, there was a memory advantage to using factors instead of character vectors, but this is no longer the case.\n• None An early draft used this code to illustrate : But when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)\n• None What happens to a factor when you modify its levels?\n• None What does this code do? How do and differ from ?\n\nAdding a attribute to an atomic vector allows it to behave like a multi-dimensional array. A special case of the array is the matrix, which has two dimensions. Matrices are used commonly as part of the mathematical machinery of statistics. Arrays are much rarer, but worth being aware of.\n\nMatrices and arrays are created with and , or by using the assignment form of :\n• None generalises to and for matrices, and for arrays.\n• None generalises to and for matrices, and , a list of character vectors, for arrays.\n\ngeneralises to and for matrices, and to (provided by the package) for arrays. You can transpose a matrix with ; the generalised equivalent for arrays is .\n\nYou can test if an object is a matrix or array using and , or by looking at the length of the . and make it easy to turn an existing vector into a matrix or array.\n\nVectors are not the only 1-dimensional data structure. You can have matrices with a single row or single column, or arrays with a single dimension. They may print similarly, but will behave differently. The differences aren’t too important, but it’s useful to know they exist in case you get strange output from a function ( is a frequent offender). As always, use to reveal the differences.\n\nWhile atomic vectors are most commonly turned into matrices, the dimension attribute can also be set on lists to make list-matrices or list-arrays:\n\nThese are relatively esoteric data structures, but can be useful if you want to arrange objects into a grid-like structure. For example, if you’re running models on a spatio-temporal grid, it might be natural to preserve the grid structure by storing the models in a 3d array.\n• None What does return when applied to a vector?\n• None If is , what will return?\n• None How would you describe the following three objects? What makes them different to ?\n\nA data frame is the most common way of storing data in R, and if used systematically makes data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list. This means that a data frame has , , and , although and are the same thing. The of a data frame is the length of the underlying list and so is the same as ; gives the number of rows.\n\nAs described in subsetting, you can subset a data frame like a 1d structure (where it behaves like a list), or a 2d structure (where it behaves like a matrix).\n\nYou create a data frame using , which takes named vectors as input:\n\nBeware ’s default behaviour which turns strings into factors. Use to suppress this behaviour:\n\nBecause a is an S3 class, its type reflects the underlying vector used to build it: the list. To check if an object is a data frame, use or test explicitly with :\n\nYou can coerce an object to a data frame with :\n• None A list will create one column for each element; it’s an error if they’re not all the same length.\n• None A matrix will create a data frame with the same number of columns and rows as the matrix.\n\nYou can combine data frames using and :\n\nWhen combining column-wise, the number of rows must match, but row names are ignored. When combining row-wise, both the number and names of columns must match. Use to combine data frames that don’t have the same columns.\n\nIt’s a common mistake to try and create a data frame by ing vectors together. This doesn’t work because will create a matrix unless one of the arguments is already a data frame. Instead use directly:\n\nThe conversion rules for are complicated and best avoided by ensuring all inputs are of the same type.\n\nSince a data frame is a list of vectors, it is possible for a data frame to have a column that is a list:\n\nHowever, when a list is given to , it tries to put each item of the list into its own column, so this fails:\n\nA workaround is to use , which causes to treat the list as one unit:\n\nadds the class to its input, but this can usually be safely ignored.\n\nSimilarly, it’s also possible to have a column of a data frame that’s a matrix or array, as long as the number of rows matches the data frame:\n\nUse list and array columns with caution: many functions that work with data frames assume that all columns are atomic vectors.\n• None What does do when applied to a data frame with columns of different types?\n• None Can you have a data frame with 0 rows? What about 0 columns?\n• None The three properties of a vector are type, length, and attributes.\n• None The four common types of atomic vector are logical, integer, double (sometimes called numeric), and character. The two rarer types are complex and raw.\n• None Attributes allow you to associate arbitrary additional metadata to any object. You can get and set individual attributes with and ; or get and set all attributes at once with .\n• None The elements of a list can be any type (even a list); the elements of an atomic vector are all of the same type. Similarly, every element of a matrix must be the same type; in a data frame, the different columns can have different types.\n• None You can make “list-array” by assigning dimensions to a list. You can make a matrix a column of a data frame with , or using when creating a new data frame ."
    },
    {
        "link": "https://rdrr.io/r/base/isSymmetric.html",
        "document": "Test if a Matrix or other Object is Symmetric (Hermitian)\n\nGeneric function to test if is symmetric or not. Currently only a matrix method is implemented, where a matrix must be “Hermitian” for to be true.\n\nany R object; a for the matrix method. numeric scalar >= 0. Smaller differences are not considered, see . numeric scalar >= 0. ‘pre-tests’ the first and last few rows for fast detection of ‘obviously’ asymmetric cases with this tolerance. Setting it to length zero will skip the pre-tests. further arguments passed to methods; the matrix method passes these to . If the row and column names of are allowed to differ for the symmetry check do use !\n\nThe method is used inside by default to test symmetry of matrices up to rounding error, using . It might not be appropriate in all situations.\n\nNote that a matrix is only symmetric if its and are identical. Consider using .\n\nlogical indicating if is symmetric or not.\n\nwhich calls when its argument is missing."
    },
    {
        "link": "https://cran.r-project.org/doc/manuals/r-release/R-intro.html",
        "document": "This is an introduction to R (“GNU S”), a language and environment for statistical computing and graphics. R is similar to the award-winning S system, which was developed at Bell Laboratories by John Chambers et al. It provides a wide variety of statistical and graphical techniques (linear and nonlinear modelling, statistical tests, time series analysis, classification, clustering, ...).\n\nThis manual provides information on data types, programming elements, statistical modelling and graphics.\n\nThis manual is for R, version 4.4.3 (2025-02-28).\n\nNext: The command-line editor, Previous: A sample session, Up: An Introduction to R [Contents][Index] Users of R on Windows or macOS should read the OS-specific section first, but command-line use is also supported. Next: Invoking R under Windows, Previous: Invoking R, Up: Invoking R [Contents][Index] When working at a command line on UNIX or Windows, the command ‘ ’ can be used both for starting the main R program in the form or, via the interface, as a wrapper to various R tools (e.g., for processing files in R documentation format or manipulating add-on packages) which are not intended to be called “directly”. At the Windows command-line, is preferred to . You need to ensure that either the environment variable is unset or it points to a valid place to create temporary files and directories. Most options control what happens at the beginning and at the end of an R session. The startup mechanism is as follows (see also the on-line help for topic ‘ ’ for more information, and the section below for some Windows-specific details).\n• Unless was given, R searches for user and site files to process for setting environment variables. The name of the site file is the one pointed to by the environment variable ; if this is unset, is used (if it exists). The user file is the one pointed to by the environment variable if this is set; otherwise, files in the current or in the user’s home directory (in that order) are searched for. These files should contain lines of the form ‘ ’. (See for a precise description.) Variables you might want to set include (the default paper size), (the default print command) and (specifies the list of R library trees searched for add-on packages).\n• Then R searches for the site-wide startup profile unless the command line option was given. The name of this file is taken from the value of the environment variable. If that variable is unset, the default is used if this exists.\n• Then, unless was given, R searches for a user profile and sources it. The name of this file is taken from the environment variable ; if unset, a file called in the current directory or in the user’s home directory (in that order) is searched for.\n• It also loads a saved workspace from file in the current directory if there is one (unless or was specified).\n• Finally, if a function exists, it is executed. This function (as well as which is executed at the end of the R session) can be defined in the appropriate startup profiles, or reside in . In addition, there are options for controlling the memory available to the R process (see the on-line help for topic ‘ ’ for more information). Users will not normally need to use these unless they are trying to limit the amount of memory used by R. Print short help message to standard output and exit successfully. Specify the encoding to be assumed for input from the console or . This needs to be an encoding known to : see its help page. ( is also accepted.) The input is re-encoded to the locale R is running in and needs to be representable in the latter’s encoding (so e.g. you cannot re-encode Greek text in a French locale unless that locale uses the UTF-8 encoding). Print the path to the R “home directory” to standard output and exit successfully. Apart from the front-end shell script and the man page, R installation puts everything (executables, packages, etc.) into this directory. Control whether data sets should be saved or not at the end of the R session. If neither is given in an interactive session, the user is asked for the desired behavior when ending the session with ; in non-interactive use one of these must be specified or implied by some other option (see below). Do not read any user file to set environment variables. Do not read the site-wide profile at startup. Do not read the user’s profile at startup. Control whether saved images (file in the directory where R was started) should be restored at startup or not. The default is to restore. ( implies all the specific options.) Control whether the history file (normally file in the directory where R was started, but can be set by the environment variable ) should be restored at startup or not. The default is to restore. (Windows only) Prevent loading the file at startup. Combine , , , and . Under Windows, this also includes . (not ) Take input from : ‘ ’ means . Implies unless has been set. On a Unix-alike, shell metacharacters should be avoided in (but spaces are allowed). (UNIX only) Turn off command-line editing via readline. This is useful when running R from within Emacs using the (“Emacs Speaks Statistics”) package. See The command-line editor, for more information. Command-line editing is enabled for default interactive use (see ). This option also affects tilde-expansion: see the help for . For expert use only: set the initial trigger sizes for garbage collection of vector heap (in bytes) and cons cells (number) respectively. Suffix ‘ ’ specifies megabytes or millions of cells respectively. The defaults are 6Mb and 350k respectively and can also be set by environment variables and . Specify the maximum size of the pointer protection stack as locations. This defaults to 10000, but can be increased to allow large and complicated calculations to be done. Currently the maximum value accepted is 100000. Do not print out the initial copyright and welcome messages. Make R run as quietly as possible. This option is intended to support programs which use R to compute results for them. It implies and . (UNIX only) Assert that R really is being run interactively even if input has been redirected: use if input is from a FIFO or pipe and fed from an interactive program. (The default is to deduce that R is being run interactively if and only if is connected to a terminal or .) Using , or asserts non-interactive use even if is given. Note that this does not turn on command-line editing. (Windows only) Set up for use by in , including asserting interactive use (without the command-line editor) and no buffering of . Print more information about progress, and in particular set R’s option to . R code uses this option to control the printing of diagnostic messages. (UNIX only) Run R through debugger . For most debuggers (the exceptions are and recent versions of ), further command line options are disregarded, and should instead be given when starting the R executable from inside the debugger. (UNIX only) Run the specified sub-architecture. This flag does nothing except cause the rest of the command line to be skipped: this can be useful to retrieve values from it with . Note that input and output can be redirected in the usual way (using ‘ ’ and ‘ ’), but the line length limit of 4095 bytes still applies. Warning and error messages are sent to the error channel ( ). The command allows the invocation of various tools which are useful in conjunction with R, but not intended to be called “directly”. The general form is where is the name of the tool and the arguments passed on to it. Currently, the following tools are available. Run R in batch mode. Runs with possibly further options (see ). (UNIX only) Compile C, C++, Fortran … files for use with R. Convert Rd format to various other formats, including , LaTeX, plain text, and extracting the examples. can be used as shorthand for . Extract S/R code from Sweave or other vignette documentation (Unix only) Create Emacs-style tag files from C, R, and Rd files to obtain usage information for each of the tools accessible via the interface. In addition, you can use options , , , and between and : these affect any R processes run by the tools. (Here is equivalent to .) However, note that does not of itself use any R startup files (in particular, neither user nor site files), and all of the R processes run by these tools (except ) use . Most use and so invoke no R startup files: the current exceptions are , , and (which uses ). for any other executable on the path or given by an absolute filepath: this is useful to have the same environment as R or the specific commands run under, for example to run or . Under Windows can be an executable or a batch file, or if it has extension or the appropriate interpreter (if available) is called to run it. Next: Invoking R under macOS, Previous: Invoking R from the command line, Up: Invoking R [Contents][Index] There are two ways to run R under Windows. Within a terminal window (e.g. or a more capable shell), the methods described in the previous section may be used, invoking by or more directly by . For interactive use, there is a console-based GUI ( ). The startup procedure under Windows is very similar to that under UNIX, but references to the ‘home directory’ need to be clarified, as this is not always defined on Windows. If the environment variable is defined, that gives the home directory. Next, if the environment variable is defined, that gives the home directory. After those two user-controllable settings, R tries to find system defined home directories. It first tries to use the Windows \"personal\" directory (typically in recent versions of Windows). If that fails, and environment variables and are defined (and they normally are) these define the home directory. Failing all those, the home directory is taken to be the starting directory. You need to ensure that either the environment variables , and are either unset or one of them points to a valid place to create temporary files and directories. Environment variables can be supplied as ‘ ’ pairs on the command line. If there is an argument ending (in any case) it is interpreted as the path to the workspace to be restored: it implies and sets the working directory to the parent of the named file. (This mechanism is used for drag-and-drop and file association with , but also works for . If the named file does not exist it sets the working directory if the parent directory exists.) The following additional command-line options are available when invoking . Control whether will operate as an MDI program (with multiple child windows within one main window) or an SDI application (with multiple top-level windows for the console, graphics and pager). The command-line setting overrides the setting in the user’s file. Enable the “Break to debugger” menu item in , and trigger a break to the debugger during command line processing. Under Windows with you may also specify your own , , or file. It will be run under the appropriate interpreter (Perl for ) with several environment variables set appropriately, including , , , and . For example, if you already have on your path, then will run LaTeX on , with the path to R’s macros appended to . (Unfortunately, this does not help with the MiKTeX build of LaTeX, but will work in that case.) Next: Scripting with R, Previous: Invoking R under Windows, Up: Invoking R [Contents][Index] There are two ways to run R under macOS. Within a window by invoking , the methods described in the first subsection apply. There is also console-based GUI ( ) that by default is installed in the folder on your system. It is a standard double-clickable macOS application. The startup procedure under macOS is very similar to that under UNIX, but does not make use of command-line arguments. The ‘home directory’ is the one inside the R.framework, but the startup and current working directory are set as the user’s home directory unless a different startup directory is given in the Preferences window accessible from within the GUI. If you just want to run a file of R commands, the recommended way is to use . If you want to run this in the background or as a batch job use OS-specific facilities to do so: for example in most shells on Unix-alike OSes runs a background job. You can pass parameters to scripts via additional arguments on the command line: for example (where the exact quoting needed will depend on the shell in use) will pass arguments to a script which can be retrieved as a character vector by This is made simpler by the alternative front-end , which can be invoked by and this can also be used to write executable script files like (at least on Unix-alikes, and in some Windows shells) If this is entered into a text file and this is made executable (by ), it can be invoked for different arguments by For further options see . This writes R output to and , and this can be redirected in the usual way for the shell running the command. If you do not wish to hardcode the path to but have it in your path (which is normally the case for an installed R except on Windows, but e.g. macOS users may need to add to their path), use At least in Bourne and bash shells, the mechanism does not allow extra arguments like . One thing to consider is what refers to. It is commonplace to write R scripts with segments like and refers to the script file to allow such traditional usage. If you want to refer to the process’s , use as a connection, e.g. . Another way to write executable script files (suggested by François Pinard) is to use a here document like #!/bin/sh [environment variables can be set here] R --no-echo [other options] <<EOF R program goes here... EOF but here refers to the program source and will not be usable. Short scripts can be passed to on the command-line via the flag. (Empty scripts are not accepted.) Note that on a Unix-alike the input filename (such as ) should not contain spaces nor shell metacharacters."
    }
]