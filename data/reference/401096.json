[
    {
        "link": "https://vuejs.org/guide/components/props.html",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    },
    {
        "link": "https://blog.logrocket.com/use-props-pass-data-child-components-vue-3",
        "document": "This article was last reviewed and updated on 4 October 2024.\n\nYou can send state from a parent component to a child component in Vue using props:\n• Static props: You can pass data from a parent component to its child using static values within the parent’s template. This is useful when the value doesn’t need to change dynamically\n• Dynamic props: You can pass reactive state (like arrays or objects) from the parent to the child using , allowing for automatic updates when the data changes\n• Typed props: In the child component, you can define prop types such as , , to validate the incoming data, ensuring proper validation and preventing potential errors\n\nHandling props can be tricky. In this article, we’ll dive deeper into how to pass data between a parent component to its child using props in Vue 3. You can find the complete code for this tutorial on GitHub. Let’s get started!\n\nThis article is suited for developers of all stages, including beginners. To follow along, you’ll need Node.js version ≥16.x installed. You can verify if you already have it installed by running the command in your terminal or the command prompt.\n\nYou’ll also need a code editor; I highly recommend VS Code.\n\nAt the time of writing, Vue 3 is the latest version. To follow along, you’ll need Vue 3 installed globally on your machine.\n\nBefore getting started, download a Vue starter project. Unzip the downloaded project, navigate into the unzipped file, and then run the command below to keep all the dependencies up to date:\n\nWhat are props in Vue?\n\nIn Vue, props are custom attributes that you can register on any component. You define your data on the parent component and give it a value. Then, you go to the child component that needs that data and pass the value to a prop attribute. Therefore, the data becomes a property in the child component.\n\nIn a component, the syntax looks like the following code:\n\nIn a non- component, the syntax looks like this:\n\nTo access this data dynamically from any component that needs it, you can use the root component as the parent component, store the data, and then register props.\n\nVue uses a more flexible approach to props where you can specify the type of a prop using JavaScript constructors:\n\nThe types can be , , , , or .\n\nThe type accepts only string values, the prop with type accepts only numeric values, the prop with type accepts only Boolean values, and the prop with or type accepts only array or object values respectively.\n\nWhy should you use props in Vue?\n\nLet’s say you have an array of objects that you want to display in two different components. For example, component A renders the artist names from the array of objects while component B renders the artist names and countries from the array of objects. Your first instinct might be to:\n• Display them in the template\n\nThis solution is great initially but becomes more complicated as you add more components. Let’s demonstrate this with the starter project you’ve opened in VS Code.\n\nOpen the file and copy the code block below:\n\nCreate a new file in the components folder called and paste the following code block inside it:\n\nTo register the new component you just created, open the file and copy the code below inside it:\n\nIn the VS Code terminal, serve up the application in the development environment with the following command:\n\nIt should look like the following:\n\nYou’ll notice that if you had only about five more components, you would have to keep copying the data in every component. Imagine there was a way that you could define the data in a parent component and then bring it into every child component that needs it by using the property name. This is where using props to pass data from parent to child components comes in handy.\n\nBecause you’ve chosen the root component to be your parent component, you first have to define the data object that you want to share dynamically inside of the root component.\n\nIf you’ve followed this article from the start, open up your file and copy the data object code block inside of the script section:\n\nTo receive props in a component, you have to specify the props that you want to receive inside of that component. After defining the data, go into the two test components, and delete the data objects inside them, and add the specifications in the script section, as shown below:\n\nTo let the Vue engine know that you have props you want to dynamically pass to child components, you have to indicate this in the Vue instance. This is done in the template section as shown here:\n\nThe directive in Vue is used to bind HTML attributes or component props dynamically. In the code above, we used to bind , which is the name of the data object array in the script section, and , the prop name in the test components, which you set up in the section above.\n\nIf you set it up without the following directive, you won’t see any output; neither the Vue compiler nor ESLint will flag it as an error or warning:\n\nTherefore, it’s important to pay attention and remember to use for every dynamic binding.\n\nAfter you’ve set up the props in your Vue app, you can then use them inside of your component as if the data were defined inside of the same component. Therefore, in our demo case, you can set up method calls and easily access .\n\nBy strongly typing the props, you can also ensure that your component only receives exactly the data type you want it to. In our demo, for instance, you can ensure that only arrays get passed down to your component by setting up authentication as follows:\n\nTherefore, whenever you add a wrong type, say, a , you’ll get a warning in the console telling you that the type it received is not the type it expected:\n\nHow to set default values for props\n\nYou can set default values for props using the property in the option:\n\nThe default value of a prop should correspond with the specified type.\n\nHow to work with multiple props in Vue\n\nWorking with multiple props is similar to working with a single prop, but you need to declare and define each prop in the component’s props option.\n\nUsing the component in a parent component, you can pass values for each prop as follows:\n\nIn the child component definition, declare the option as an object where each property represents a prop. You can specify the type, default value, and other options for each prop:\n\nIn the above code, is a required prop of type , is an optional prop of type with a default value of 42, while is an optional prop of type with a default value of .\n\nYou can use the props in the child component’s methods or computed properties just like any other data property:\n\nIn the child component’s template, you can access the props using the syntax:\n\nWorking with multiple props in the Vue 3 Composition API\n\nIn the Vue 3 Composition API, working with multiple props is slightly different than in the Options API discussed above:\n• Declaring props: In the Composition API, you use the function to declare props, while the Options API uses a option object\n• Accessing props: Props in the Composition API are accessed via the argument passed to the function, while in the Options API, they are directly available within the component’s options\n• Destructuring props: Destructuring props in the Composition API can lose reactivity unless you use utilities like\n\nIn the Composition API, you can use the function to declare and define props:\n\nThe first argument in the function is the argument. You can use the prop values directly in the template as follows:\n\nYou may want to destructure the object in the setup function; by doing this, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of .\n\nBut if you need to destructure the props, or need to pass a prop into an external function while retaining reactivity; you can do so with the and utility APIs:\n\nHere, we use to turn the props into an object of refs to destructure. is a ref that tracks .\n\nYou can use the destructured prop values directly in the template as follows:\n\nHow to pass functions to props in Vue\n\nIn Vue 3, you can pass functions as props to child components in a similar way to passing any other data.\n\nIn the parent component, define a function that you want to pass as a prop:\n\nIn the child component, declare the prop to accept a function. You can do this by adding a option and specifying the type as :\n\nYou can then use it in the child component template as follows:\n\nIn this article, we explored how to send state from parent to child components in Vue using Vue 3 props. We demonstrated how to define props for both static and dynamic data and how to enforce prop types for better validation. We also discussed how to send state as an object in Vue, making it easier to pass complex data structures.\n\nFor additional information, check out Vue’s official documentation on props."
    },
    {
        "link": "https://stackoverflow.com/questions/72573590/how-to-pass-props-from-parent-to-child-component-in-vue3js-with-typescript",
        "document": "You defined your props as follows:\n\nWhich means you create two props, one called with a type of and one called with a type of .\n\nIn your type-definition you already defined and\n\nSo what you want to do is presumably something like this:\n\nAnd in your component you only need to loop over .\n\nNOTE: When using defineProps the props will be available in the template without using props.tabsData; although in the script setup you need to access it with props.tabsData\n\nthis prop will then be exposed on the component when used in the parent. There you will have to bind the data to the prop on component call.\n\nCan you provide an english translation of the error?\n\nIt should result in something like this:"
    },
    {
        "link": "https://vuejs.org/guide/components/props",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    },
    {
        "link": "https://salkobalic.com/guide-to-passing-data-from-parent-to-child-component-in-vuejs",
        "document": "Vue.js is an awesome JavaScript framework that's loved by many for its easy-to-use and adaptable nature when it comes to crafting user interfaces.\n\nOne of its coolest features is how it lets you pass data between components, especially from parent to child components.\n\nIn this friendly guide, we'll dive into different ways to make this happen smoothly.\n• None Vue.js excels in enabling seamless data exchange between components, particularly from parent to child components.\n• None Props, or \"properties,\" play a crucial role in front-end frameworks like Vue.js and React.\n• None Props contribute to component modularity, making development, maintenance, and debugging more straightforward.\n• None Vue.js provides the flexibility to choose between static and dynamic props, depending on the desired functionality.\n• None Vue follows a one-way data flow pattern, ensuring data moves from parent components to child components.\n• None Common pitfalls when using props include not defining prop types, relying on two-way data binding, directly modifying props in child components, overusing dynamic props, and not defining default values.\n\nEver been curious about how various components in a Vue.js app chat with each other?\n\nAs your app grows and becomes more complex, it's super important for components to share data effectively.\n\nIn a Vue.js app, components are like independent puzzle pieces, each focusing on specific functionality.\n\nThis modularity lets developers craft reusable bits of code that can be easily plugged into different parts of the app.\n\nData communication is the glue that connects these components, allowing for smooth info-sharing, boosting reusability, and cutting down on redundancy.\n\nAs an app gets more complex, it can be tricky to understand and maintain the codebase.\n\nEffective data communication in Vue.js, using cool techniques like props and custom events, helps make the code more readable and maintainable.\n\nA well-organized app with clear data flows between components is a piece of cake to debug, modify, and enhance.\n\nHandling state management is super important in web app development, as it keeps everything consistent across the user interface.\n\nWith data communication in Vue.js, components can easily access and update a shared state. This way, when one component changes, others stay in sync, giving users a smooth experience.\n\nClear data communication between components is key for growing applications and encouraging teamwork among developers.\n\nA well-organized app with effective data communication lets multiple team members work on different components at the same time.\n\nThis parallel development ensures that components fit together seamlessly and the whole app runs like a well-oiled machine.\n\nUsing Props for Data Transfer in Vue\n\nProps, or \"properties,\" are a super important concept in front-end frameworks like Vue.js and React.\n\nThink of them as a helpful buddy that carries data from a parent component to a child component. It's like sharing info or variables from a higher-level component (the parent) to a lower-level component (the child).\n\nThe Benefits of Using Props\n\nProps are like the glue that holds your web application together, making it neat. They help create self-contained components that can be used all over your app. This friendliness makes development, maintenance, and debugging a breeze since each component focuses on doing its own thing.\n\nIn a big, bustling application, various components need to talk to each other. Props are like the perfect telephone line for this chit-chat. By passing data through props, you create a direct connection between parent and child components, helping them work together like a dream team.\n\nMany modern applications need to update their user interface in the blink of an eye. Props, when paired with reactivity systems like Vue.js, let components react to data changes super fast. This snappy behavior is key for creating fun, user-friendly, and interactive applications.\n\nIn the Vue.js universe, props are super important for helping data move smoothly between parent and child components. But hey, not all props are the same!\n\nDepending on what we're trying to achieve, we can choose between static and dynamic props to make component communication even better and build stronger applications.\n\nStatic props are like those trusty, unchanging values that a parent component shares with its child component. They stay the same throughout the component's life, no matter what users do or how the app evolves.\n\nThey're super easy to use and perfect for times when the data we're passing won't change.\n\nIn contrast, dynamic props are values that can shift depending on user interactions, the app's state, or other elements.\n\nThey're reactive, which means that when a dynamic prop's value changes, the child component will automatically update to show the new value. It's like magic!\n\nWhen you're trying to figure out whether to use static or dynamic props in your Vue app, just keep these things in mind:\n\nPassing Different Value Types as Props in Vue\n\nWhen working with Vue, you might be wondering how to pass different value types like , , or , besides the usual and .\n\nNo worries! Let's dive into the world of Vue props together and discover how to easily pass all sorts of value types.\n\nVue makes it straightforward to pass simple value types like , , or . Here's a quick example.\n\nNow, let's explore how to pass more complex value types.\n\nWhen you've got a bunch of properties to pass from a parent component to a child component, doing it one by one can take ages and make your template look messy.\n\nYou can use an object to bind multiple properties, which will make your code neater and your templates easier to read. This is super handy when you're passing related data or complex objects with lots of properties.\n\nOne-way data flow is a cool design pattern where data moves in just one direction - from parent components to their kiddos (child components).\n\nIn Vue.js, we use props to make this happen, letting parent components share data with their children.\n\nBy sticking to a one-way data flow, Vue.js keeps your app's data consistent and easy to predict, which means fewer bugs and simpler code to understand and take care of.\n\nPass Data from Parent to Child in Vue 3 Options API\n\nHere's an example of how you can easily leverage the power of props in Vue 3 Options API.\n\nPass Data from Parent to Child in Vue 3 Composition API\n\nHere's an example of how you can easily leverage the power of props in Vue 3 Composition API.\n\nProps are an awesome and widely used way to pass data from parent components to child components in Vue.js.\n\nThere are also a bunch of other cool methods you can use to transfer data within your Vue app. Depending on what you're trying to do, these alternatives can offer different levels of complexity and flexibility.\n\nHere are some alternative methods for passing data in Vue besides props:\n\nVuex, Pinia, or any other state management library for Vue can help you create a centralized store to manage your app's state.\n\nThese nifty tools make it easy to store and share data across multiple components, so you don't have to rely on passing data through props.\n\nVue has this cool feature called and that lets you pass data from a parent component to deeply nested child components without using props.\n\nThe parent component shares the data, and the child component happily receives it.\n\nAlthough props are commonly used for parent-to-child communication, custom events are a great way to facilitate child-to-parent communication.\n\nChild components can send out events, while parent components can tune in and respond to these events.\n\nVue Props Mastery: How to Dodge the Common Traps\n\nProps are super handy for parent-to-child communication, but sometimes they can cause a few hiccups.\n\nLet's look at some common challenges developers come across and share some helpful tips to dodge them.\n\nVue.js lets you define prop types, which are super useful for making sure the data passed from a parent component to a child component is valid.\n\nIf you miss this important step, you might run into some strange behavior and tricky-to-solve problems. To keep things smooth, always remember to define prop types for your components.\n\nAlso, keep in mind that Vue props have a one-way data flow, going from parent components to child components. Trying to set up a two-way binding might cause inconsistent data and some unwanted side effects.\n\nTo make sure everything runs smoothly, use custom events (emits) or global state management for more complex stuff.\n\nAvoid directly modifying props in child components, as this can cause data inconsistencies and unexpected outcomes.\n\nInstead, treat props as read-only in child components.\n\nAs for Dynamic Props, they're super cool and offer a lot of flexibility, but be mindful that they can affect performance.\n\nSo, use them wisely and only when you really need to. If a prop's value stays the same throughout the component's lifecycle, you might want to consider using a static prop.\n\nIf a parent component doesn't supply a prop, Vue will give you a warning. To avoid that, it's always a nice idea to set default values for your props.\n\nIn this guide, we explored the awesomeness of Vue.js props for sharing data between components, with a special focus on parent-to-child communication.\n\nWe talked about static and dynamic props, sharing various value types, and the beauty of one-way data flow.\n\nMoreover, we touched on other cool ways to pass data in Vue, like global state management and custom events.\n\nAnd lastly, we shared some handy tips to help you dodge common pitfalls when working with props in Vue."
    },
    {
        "link": "https://stackoverflow.com/questions/70758105/pass-data-from-parent-component-to-child-of-child-in-vue-js",
        "document": "I am deperately searching for a way to pass data from a parent component to a child of the child component. I know I can use props to do this like in this thread Vue JS Pass Data From Parent To Child Of Child Of Child\n\nBut I only get it to work for the \"next\" child component and I get stuck for the second one.\n\nNow, I can log the data in the console from by using the child component\n\nBut what do I have to do in the next child componet to pass the data correctly?"
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/techniques-for-sharing-data-between-vue-js-components",
        "document": "In this example, we are passing the prop with a value of to our child component. We will then be able to access this value from inside of the by initializing our props object in the script tag of our child component file\n\nAs our application grows in size and complexity, passing data through components can become messy. We will have to pass data from a parent component to a child component which may be deeply nested in the component tree. Stores introduce an advanced method of passing data across components by eliminating the problem of prop drilling. Prop drilling refers to transporting data or states as props to the intended destination through intermediate components.\n\nWith stores, our states or data are stored in a centralized point to be accessed by any components irrespective of their hierarchy in the component tree. This is a common way of handling states for big Vue.js applications. Popular state management tools for Vue.js include Pinia and Vuex. For our basic example, we will use Pinia which is the official state management tool for Vue js 3.\n\nProvide and Inject technique is also another useful technique of preventing prop drilling when building complex Vue.js applications. With this technique the parent component can provide dependencies for all its child components. This means that any component in the component tree, regardless of how deep it is, can inject dependencies that are provided by components higher up in the component chain."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-use-props-in-vuejs",
        "document": "We use props to pass information/data from a parent component to child components. In this article, I will explain everything you need to know about props and why you should use props in Vue.js.\n\nHere's a brief outline of what we'll cover in this guide:\n• None What are props in Vue.js?\n• None How to work with multiple props\n• None How to pass data to props\n• None How to pass functions to props\n• None How to set default values for props\n\nWhat are Props in Vue.js?\n\n“Props” is a special keyword which stands for properties. It can be registered on a component to pass data from a parent component to one of its children components.\n\nThis is a lot easier compared to using state management libraries like vuex for Vue.js applications.\n\nData in props can only flow one way – from the top, or parent component, to the bottom, or child components. This simply means you cannot pass data from a child to a parent.\n\nAnother thing to keep in mind is that Props are read-only and cannot be modified by the child component because the parent component \"owns\" that value.\n\nLet’s balance things up now – the parent components pass props to the child component(s) while the child component emit events to the parent component(s).\n\nLet's now take a look at how we can register props inside a component.\n\nIn the above code, we registered a prop called which we can call in the template section of our app.\n\nNote: This is the child component and this prop is going to receive data from the parent component. I will explain this more later.\n\nHow to Work with Multiple Props\n\nYou can have more than one prop by appending them to the props array, just like this:\n\nTo specify the type of prop you want to use in Vue, you will use an object instead of an array. You'll use the name of the property as the key of each property, and the type as the value.\n\nIf the type of the data passed does not match the prop type, Vue sends an alert (in development mode) in the console with a warning. The valid types you can use are:\n\nHow to Pass Data to Props in Vue\n\nThe major goal of using props is to pass down data/information. You can either pass your value as a data property using v-bind, such as in this code:\n\nor as a static value like this:\n\nSuppose we are building an app which has so many buttons with different text/background colors. Instead of repeating the button syntax in all our files, it's better to create a button component and then pass the text/background colors as props.\n\nThe above code shows you how to use both data property and static values when you're getting data from a parent component and using that data in a child component.\n\nNote: you can also use a ternary operator inside the prop value to check a truthy condition and pass a value that depends on it.\n\nIn the above code, we are checking the data property. If it’s true, the data sent should be Logout, else it should be Login.\n\nHow to Pass Functions to Props\n\nPassing a function or a method down to a child component as a prop is relatively straightforward. It's basically the same process as passing any other variable.\n\nBut there are reasons why you shouldn't use props as functions – instead you should use emit. This article properly explains why.\n\nVue makes validating props very easy. All you have to do is add the required key and its value to the prop. We can validate with both the prop type and by using :\n\nBefore concluding this article, let’s now see how to set default values to our props. Default values are rendered if the child component is unable to get data from the parent component.\n\nVue allows you to specify a default value, just as we specified earlier.\n\nYou can also define the default value as an object. And it can be a function that returns an appropriate value, rather than being the actual value.\n\nIn this article, we have learned what props do and how props works in Vue.js.\n\nIn summary, we use props to pass down data from the parent components to the child component(s). The child component also emit events to the parent component(s) in case you need to send data/events from the child to the parent component.\n\nThank you for reading!"
    },
    {
        "link": "https://blog.logrocket.com/use-props-pass-data-child-components-vue-3",
        "document": "This article was last reviewed and updated on 4 October 2024.\n\nYou can send state from a parent component to a child component in Vue using props:\n• Static props: You can pass data from a parent component to its child using static values within the parent’s template. This is useful when the value doesn’t need to change dynamically\n• Dynamic props: You can pass reactive state (like arrays or objects) from the parent to the child using , allowing for automatic updates when the data changes\n• Typed props: In the child component, you can define prop types such as , , to validate the incoming data, ensuring proper validation and preventing potential errors\n\nHandling props can be tricky. In this article, we’ll dive deeper into how to pass data between a parent component to its child using props in Vue 3. You can find the complete code for this tutorial on GitHub. Let’s get started!\n\nThis article is suited for developers of all stages, including beginners. To follow along, you’ll need Node.js version ≥16.x installed. You can verify if you already have it installed by running the command in your terminal or the command prompt.\n\nYou’ll also need a code editor; I highly recommend VS Code.\n\nAt the time of writing, Vue 3 is the latest version. To follow along, you’ll need Vue 3 installed globally on your machine.\n\nBefore getting started, download a Vue starter project. Unzip the downloaded project, navigate into the unzipped file, and then run the command below to keep all the dependencies up to date:\n\nWhat are props in Vue?\n\nIn Vue, props are custom attributes that you can register on any component. You define your data on the parent component and give it a value. Then, you go to the child component that needs that data and pass the value to a prop attribute. Therefore, the data becomes a property in the child component.\n\nIn a component, the syntax looks like the following code:\n\nIn a non- component, the syntax looks like this:\n\nTo access this data dynamically from any component that needs it, you can use the root component as the parent component, store the data, and then register props.\n\nVue uses a more flexible approach to props where you can specify the type of a prop using JavaScript constructors:\n\nThe types can be , , , , or .\n\nThe type accepts only string values, the prop with type accepts only numeric values, the prop with type accepts only Boolean values, and the prop with or type accepts only array or object values respectively.\n\nWhy should you use props in Vue?\n\nLet’s say you have an array of objects that you want to display in two different components. For example, component A renders the artist names from the array of objects while component B renders the artist names and countries from the array of objects. Your first instinct might be to:\n• Display them in the template\n\nThis solution is great initially but becomes more complicated as you add more components. Let’s demonstrate this with the starter project you’ve opened in VS Code.\n\nOpen the file and copy the code block below:\n\nCreate a new file in the components folder called and paste the following code block inside it:\n\nTo register the new component you just created, open the file and copy the code below inside it:\n\nIn the VS Code terminal, serve up the application in the development environment with the following command:\n\nIt should look like the following:\n\nYou’ll notice that if you had only about five more components, you would have to keep copying the data in every component. Imagine there was a way that you could define the data in a parent component and then bring it into every child component that needs it by using the property name. This is where using props to pass data from parent to child components comes in handy.\n\nBecause you’ve chosen the root component to be your parent component, you first have to define the data object that you want to share dynamically inside of the root component.\n\nIf you’ve followed this article from the start, open up your file and copy the data object code block inside of the script section:\n\nTo receive props in a component, you have to specify the props that you want to receive inside of that component. After defining the data, go into the two test components, and delete the data objects inside them, and add the specifications in the script section, as shown below:\n\nTo let the Vue engine know that you have props you want to dynamically pass to child components, you have to indicate this in the Vue instance. This is done in the template section as shown here:\n\nThe directive in Vue is used to bind HTML attributes or component props dynamically. In the code above, we used to bind , which is the name of the data object array in the script section, and , the prop name in the test components, which you set up in the section above.\n\nIf you set it up without the following directive, you won’t see any output; neither the Vue compiler nor ESLint will flag it as an error or warning:\n\nTherefore, it’s important to pay attention and remember to use for every dynamic binding.\n\nAfter you’ve set up the props in your Vue app, you can then use them inside of your component as if the data were defined inside of the same component. Therefore, in our demo case, you can set up method calls and easily access .\n\nBy strongly typing the props, you can also ensure that your component only receives exactly the data type you want it to. In our demo, for instance, you can ensure that only arrays get passed down to your component by setting up authentication as follows:\n\nTherefore, whenever you add a wrong type, say, a , you’ll get a warning in the console telling you that the type it received is not the type it expected:\n\nHow to set default values for props\n\nYou can set default values for props using the property in the option:\n\nThe default value of a prop should correspond with the specified type.\n\nHow to work with multiple props in Vue\n\nWorking with multiple props is similar to working with a single prop, but you need to declare and define each prop in the component’s props option.\n\nUsing the component in a parent component, you can pass values for each prop as follows:\n\nIn the child component definition, declare the option as an object where each property represents a prop. You can specify the type, default value, and other options for each prop:\n\nIn the above code, is a required prop of type , is an optional prop of type with a default value of 42, while is an optional prop of type with a default value of .\n\nYou can use the props in the child component’s methods or computed properties just like any other data property:\n\nIn the child component’s template, you can access the props using the syntax:\n\nWorking with multiple props in the Vue 3 Composition API\n\nIn the Vue 3 Composition API, working with multiple props is slightly different than in the Options API discussed above:\n• Declaring props: In the Composition API, you use the function to declare props, while the Options API uses a option object\n• Accessing props: Props in the Composition API are accessed via the argument passed to the function, while in the Options API, they are directly available within the component’s options\n• Destructuring props: Destructuring props in the Composition API can lose reactivity unless you use utilities like\n\nIn the Composition API, you can use the function to declare and define props:\n\nThe first argument in the function is the argument. You can use the prop values directly in the template as follows:\n\nYou may want to destructure the object in the setup function; by doing this, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of .\n\nBut if you need to destructure the props, or need to pass a prop into an external function while retaining reactivity; you can do so with the and utility APIs:\n\nHere, we use to turn the props into an object of refs to destructure. is a ref that tracks .\n\nYou can use the destructured prop values directly in the template as follows:\n\nHow to pass functions to props in Vue\n\nIn Vue 3, you can pass functions as props to child components in a similar way to passing any other data.\n\nIn the parent component, define a function that you want to pass as a prop:\n\nIn the child component, declare the prop to accept a function. You can do this by adding a option and specifying the type as :\n\nYou can then use it in the child component template as follows:\n\nIn this article, we explored how to send state from parent to child components in Vue using Vue 3 props. We demonstrated how to define props for both static and dynamic data and how to enforce prop types for better validation. We also discussed how to send state as an object in Vue, making it easier to pass complex data structures.\n\nFor additional information, check out Vue’s official documentation on props."
    },
    {
        "link": "https://vuejs.org/guide/components/props.html",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    }
]