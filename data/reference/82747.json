[
    {
        "link": "https://source.android.com/docs/core/architecture/vndk/abi-stability",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nApplication Binary Interface (ABI) stability is a prerequisite of framework-only updates because vendor modules may depend on the Vendor Native Development Kit (VNDK) shared libraries that reside in the system partition. Within an Android release, newly-built VNDK shared libraries must be ABI-compatible to previously released VNDK shared libraries so vendor modules can work with those libraries without recompilation and without runtime errors. Between Android releases, VNDK libraries can be changed and there are no ABI guarantees.\n\nTo help ensure ABI compatibility, Android 9 includes a header ABI checker, as described in the following sections.\n\nThe VNDK is a restrictive set of libraries that vendor modules may link to and which enable framework-only updates. ABI compliance refers to the ability of a newer version of a shared library to work as expected with a module that is dynamically linked to it (i.e. works as an older version of the library would).\n\nAn exported symbol (also known as a global symbol) refers to a symbol that satisfies all of the following:\n• Exported by the public headers of a shared library.\n• Appears in the table of the file corresponding to the shared library.\n• Type is either FUNC or OBJECT.\n\nThe public headers of a shared library are defined as the headers available to other libraries/binaries through the , , , , and attributes in definitions of the module corresponding to the shared library.\n\nA reachable type is any C/C++ built-in or user-defined type that is reachable directly or indirectly through an exported symbol AND exported through public headers. For example, has function , which is an exported symbol found in the table. The library includes the following:\n\nA similar explanation can be given for types reachable through base class specifiers and template parameters as well.\n\nABI compliance must be ensured for the libraries marked and in the corresponding files. For example:\n\nFor data types reachable directly or indirectly by an exported function, the following changes to a library are classified as ABI-breaking:\n\n* Both public and private member functions must not be changed or removed because public inline functions can refer to private member functions. Symbol references to private member functions can be kept in caller binaries. Changing or removing private member functions from shared libraries can result in backward-incompatible binaries.\n\n** The offsets to public or private data members must not be changed because inline functions can refer to these data members in their function body. Changing data member offsets can result in backward-incompatible binaries.\n\n*** While these don't change the memory layout of the type, there are semantic differences that could lead to libraries not functioning as expected.\n\nWhen a VNDK library is built, the library's ABI is compared with the corresponding ABI reference for the version of the VNDK being built. Reference ABI dumps are located in:\n\nFor example, on building for x86 at API level 27, 's inferred ABI is compared with its reference at:\n\nOn ABI breakages, the build log displays warnings with the warning type and a path to the abi-diff report. For example, if 's ABI has an incompatible change, the build system throws an error with a message similar to the following:\n• processes the source files compiled to build the VNDK library (the library's own source files as well as source files inherited through static transitive dependencies), to produce files that correspond to each source.\n• then processes the files (using either a version script provided to it or the file corresponding to the shared library) to produce a file that logs all of the ABI information corresponding to the shared library.\n• compares the file with a reference file to produce a diff report that outlines the differences in the ABIs of the two libraries. \n\n\n\nThe tool parses a C/C++ source file and dumps the ABI inferred from that source file into an intermediate file. The build system runs on all compiled source files while also building a library that includes the source files from transitive dependencies.\n\nCurrently files are in JSON format, which isn't guaranteed to be stable across future releases. As such, file formatting should be considered a build system implementation detail.\n\nFor example, has the following source file :\n\nYou can use to generate an intermediate file that represents the ABI presented by the source file using:\n\nThis command tells to parse with the compiler flags following , and emit the ABI information that is exported by the public headers in the directory. The following is generated by :\n\ncontains ABI information exported by the source file and the public headers, for example,\n• . Refer to structs, unions, or classes defined in the public headers. Each record type has information about its fields, its size, access specifier, the header file it's defined in, and other attributes.\n• . Refer to pointer types directly/indirectly referenced by the exported records/functions in the public headers, along with the type the pointer points to (through the field in ). Similar information is logged in the file for qualified types, built-in C/C++ types, array types, and lvalue and rvalue reference types. Such information allows recursive diffing.\n• . Represent functions exported by public headers. They also have information about the function's mangled name, the return type, the types of the parameters, the access specifier, and other attributes.\n\nThe tool takes the intermediate files produced by as input then links those files:\n\nThe tool merges the type graphs in all the intermediate files given to it, taking into account one-definition (user-defined types in different translation units with the same fully qualified name, might be semantically different) differences across translation units. The tool then parses either a version script or the table of the shared library ( file) to make a list of the exported symbols.\n\nFor example, consists of and . could be invoked to create the complete linked ABI dump of as follows:\n• Links the files provided to it ( and ), filtering out the ABI information not present in the headers residing in the directory: .\n• Parses , and collects information about the symbols exported by the library through its table.\n\nis the final generated ABI dump of .\n\nThe tool compares two files representing the ABI of two libraries and produces a diff report stating the differences between the two ABIs.\n\nThe ABI diff file is in protobuf text format. The format is subject to change in future releases.\n\nFor example, you have two versions of : and . In , in , you change the type of from to . Since is a reachable type, this should be flagged as an ABI breaking change by .\n\nThe contains a report of all ABI breaking changes in . The message indicates a record has changed and lists the incompatible changes, which include:\n• The size of the record changing from bytes to bytes.\n• The field type of changing from to (all typedefs are stripped off).\n\nThe field indicates how reached the type that changed ( ). This field may be interpreted as is an exported function that takes in as parameter, that points to , which was exported and changed.\n\nTo enforce the ABI and API of VNDK shared libraries, ABI references must be checked into . To create these references, run the following command:\n\nAfter creating the references, any change made to the source code that results in an incompatible ABI/API change in a VNDK library now results in a build error.\n\nTo update ABI references for specific libraries, run the following command:\n\nFor example, to update ABI references, run:"
    },
    {
        "link": "https://source.android.com/docs/core/architecture/partitions/abi-stability",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nApplication Binary Interface (ABI) stability is a prerequisite of framework-only updates because vendor modules may depend on the Vendor Native Development Kit (VNDK) shared libraries that reside in the system partition. Within an Android release, newly-built VNDK shared libraries must be ABI-compatible to previously released VNDK shared libraries so vendor modules can work with those libraries without recompilation and without runtime errors. Between Android releases, VNDK libraries can be changed and there are no ABI guarantees.\n\nTo help ensure ABI compatibility, Android 9 includes a header ABI checker, as described in the following sections.\n\nThe VNDK is a restrictive set of libraries that vendor modules may link to and which enable framework-only updates. ABI compliance refers to the ability of a newer version of a shared library to work as expected with a module that is dynamically linked to it (i.e. works as an older version of the library would).\n\nAn exported symbol (also known as a global symbol) refers to a symbol that satisfies all of the following:\n• Exported by the public headers of a shared library.\n• Appears in the table of the file corresponding to the shared library.\n• Type is either FUNC or OBJECT.\n\nThe public headers of a shared library are defined as the headers available to other libraries/binaries through the , , , , and attributes in definitions of the module corresponding to the shared library.\n\nA reachable type is any C/C++ built-in or user-defined type that is reachable directly or indirectly through an exported symbol AND exported through public headers. For example, has function , which is an exported symbol found in the table. The library includes the following:\n\nA similar explanation can be given for types reachable through base class specifiers and template parameters as well.\n\nABI compliance must be ensured for the libraries marked and in the corresponding files. For example:\n\nFor data types reachable directly or indirectly by an exported function, the following changes to a library are classified as ABI-breaking:\n\n* Both public and private member functions must not be changed or removed because public inline functions can refer to private member functions. Symbol references to private member functions can be kept in caller binaries. Changing or removing private member functions from shared libraries can result in backward-incompatible binaries.\n\n** The offsets to public or private data members must not be changed because inline functions can refer to these data members in their function body. Changing data member offsets can result in backward-incompatible binaries.\n\n*** While these don't change the memory layout of the type, there are semantic differences that could lead to libraries not functioning as expected.\n\nWhen a VNDK library is built, the library's ABI is compared with the corresponding ABI reference for the version of the VNDK being built. Reference ABI dumps are located in:\n\nFor example, on building for x86 at API level 27, 's inferred ABI is compared with its reference at:\n\nOn ABI breakages, the build log displays warnings with the warning type and a path to the abi-diff report. For example, if 's ABI has an incompatible change, the build system throws an error with a message similar to the following:\n• processes the source files compiled to build the VNDK library (the library's own source files as well as source files inherited through static transitive dependencies), to produce files that correspond to each source.\n• then processes the files (using either a version script provided to it or the file corresponding to the shared library) to produce a file that logs all of the ABI information corresponding to the shared library.\n• compares the file with a reference file to produce a diff report that outlines the differences in the ABIs of the two libraries. \n\n\n\nThe tool parses a C/C++ source file and dumps the ABI inferred from that source file into an intermediate file. The build system runs on all compiled source files while also building a library that includes the source files from transitive dependencies.\n\nCurrently files are in JSON format, which isn't guaranteed to be stable across future releases. As such, file formatting should be considered a build system implementation detail.\n\nFor example, has the following source file :\n\nYou can use to generate an intermediate file that represents the ABI presented by the source file using:\n\nThis command tells to parse with the compiler flags following , and emit the ABI information that is exported by the public headers in the directory. The following is generated by :\n\ncontains ABI information exported by the source file and the public headers, for example,\n• . Refer to structs, unions, or classes defined in the public headers. Each record type has information about its fields, its size, access specifier, the header file it's defined in, and other attributes.\n• . Refer to pointer types directly/indirectly referenced by the exported records/functions in the public headers, along with the type the pointer points to (through the field in ). Similar information is logged in the file for qualified types, built-in C/C++ types, array types, and lvalue and rvalue reference types. Such information allows recursive diffing.\n• . Represent functions exported by public headers. They also have information about the function's mangled name, the return type, the types of the parameters, the access specifier, and other attributes.\n\nThe tool takes the intermediate files produced by as input then links those files:\n\nThe tool merges the type graphs in all the intermediate files given to it, taking into account one-definition (user-defined types in different translation units with the same fully qualified name, might be semantically different) differences across translation units. The tool then parses either a version script or the table of the shared library ( file) to make a list of the exported symbols.\n\nFor example, consists of and . could be invoked to create the complete linked ABI dump of as follows:\n• Links the files provided to it ( and ), filtering out the ABI information not present in the headers residing in the directory: .\n• Parses , and collects information about the symbols exported by the library through its table.\n\nis the final generated ABI dump of .\n\nThe tool compares two files representing the ABI of two libraries and produces a diff report stating the differences between the two ABIs.\n\nThe ABI diff file is in protobuf text format. The format is subject to change in future releases.\n\nFor example, you have two versions of : and . In , in , you change the type of from to . Since is a reachable type, this should be flagged as an ABI breaking change by .\n\nThe contains a report of all ABI breaking changes in . The message indicates a record has changed and lists the incompatible changes, which include:\n• The size of the record changing from bytes to bytes.\n• The field type of changing from to (all typedefs are stripped off).\n\nThe field indicates how reached the type that changed ( ). This field may be interpreted as is an exported function that takes in as parameter, that points to , which was exported and changed.\n\nTo enforce the ABI/API of VNDK shared libraries, ABI references must be checked into . To create these references, run the following command:\n\nAfter creating the references, any change made to the source code that results in an incompatible ABI/API change in a VNDK library now results in a build error.\n\nTo update ABI references for specific libraries, run the following command:\n\nFor example, to update ABI references, run:"
    },
    {
        "link": "https://android.googlesource.com/platform/bionic/+/372f19e/android-changes-for-ndk-developers.md",
        "document": "This document details important changes related to native code loading in various Android releases.\n\nRequired tools: the NDK has an arch-linux-android-readelf binary (e.g. arm-linux-androideabi-readelf or i686-linux-android-readelf) for each architecture (under toolchains/), but you can use readelf for any architecture, as we will be doing basic inspection only. On Linux you need to have the “binutils” package installed for readelf, and “pax-utils” for scanelf.\n\nNative libraries must use only public API, and must not link against non-NDK platform libraries. Starting with API 24 this rule is enforced and applications are no longer able to load non-NDK platform libraries. The rule is enforced by the dynamic linker, so non-public libraries are not accessible regardless of the way code tries to load them: System.loadLibrary, DT_NEEDED entries, and direct calls to dlopen(3) will all work exactly the same.\n\nUsers should have a consistent app experience across updates, and developers shouldn‘t have to make emergency app updates to handle platform changes. For that reason, we recommend against using private C/C++ symbols. Private symbols aren’t tested as part of the Compatibility Test Suite (CTS) that all Android devices must pass. They may not exist, or they may behave differently. This makes apps that use them more likely to fail on specific devices, or on future releases --- as many developers found when Android 6.0 Marshmallow switched from OpenSSL to BoringSSL.\n\nIn order to reduce the user impact of this transition, we‘ve identified a set of libraries that see significant use from Google Play’s most-installed apps, and that are feasible for us to support in the short term (including libandroid_runtime.so, libcutils.so, libcrypto.so, and libssl.so). In order to give you more time to transition, we will temporarily support these libraries; so if you see a warning that means your code will not work in a future release -- please fix it now!\n\nPotential problems: starting from API 24 the dynamic linker will not load private libraries, preventing the application from loading.\n\nResolution: rewrite your native code to rely only on public API. As a short term workaround, platform libraries without complex dependencies (libcutils.so) can be copied to the project. As a long term solution the relevant code must be copied to the project tree. SSL/Media/JNI internal/binder APIs should not be accessed from the native code. When necessary, native code should call appropriate public Java API methods.\n\nA complete list of public libraries is available within the NDK, under platforms/android-API/usr/lib.\n\nNote: SSL/crypto is a special case, applications must NOT use platform libcrypto and libssl libraries directly, even on older platforms. All applications should use GMS Security Provider to ensure they are protected from known vulnerabilities.\n\nEach ELF file has additional information contained in the section headers. These headers must be present now, because the dynamic linker uses them for sanity checking. Some developers strip them in an attempt to obfuscate the binary and prevent reverse engineering. (This doesn't really help because it is possible to reconstruct the stripped information using widely-available tools.)\n\nResolution: remove the extra steps from your build that strip section headers.\n\nStarting with API 23, shared objects must not contain text relocations. That is, the code must be loaded as is and must not be modified. Such an approach reduces load time and improves security.\n\nThe usual reason for text relocations is non-position independent hand-written assembler. This is not common. Use the scanelf tool as described in our documentation for further diagnostics:\n\nIf you have no scanelf tool available, it is possible to do a basic check with readelf instead, look for either a TEXTREL entry or the TEXTREL flag. Either alone is sufficient. (The value corresponding to the TEXTREL entry is irrelevant and typically 0 --- simply the presence of the TEXTREL entry declares that the .so contains text relocations). This example has both indicators present:\n\nNote: it is technically possible to have a shared object with the TEXTREL entry/flag but without any actual text relocations. This doesn‘t happen with the NDK, but if you’re generating ELF files yourself make sure you're not generating ELF files that claim to have text relocations, because the Android dynamic linker trusts the entry/flag.\n\nPotential problems: Relocations enforce code pages being writable, and wastefully increase the number of dirty pages in memory. The dynamic linker has issued warnings about text relocations since Android K (API 19), but on API 23 and above it refuses to load code with text relocations.\n\nResolution: rewrite assembler to be position independent to ensure no text relocations are necessary. The Gentoo Textrels guide has instructions for fixing text relocations, and more detailed scanelf documentation.\n\nWhile library dependencies (DT_NEEDED entries in the ELF headers) can be absolute paths, that doesn‘t make sense on Android because you have no control over where your library will be installed by the system. A DT_NEEDED entry should be the same as the needed library’s SONAME, leaving the business of finding the library at runtime to the dynamic linker.\n\nBefore API 23, Android‘s dynamic linker ignored the full path, and used only the basename (the part after the last ‘/’) when looking up the required libraries. Since API 23 the runtime linker will honor the DT_NEEDED exactly and so it won't be able to load the library if it is not present in that exact location on the device.\n\nEven worse, some build systems have bugs that cause them to insert DT_NEEDED entries that point to a file on the build host, something that cannot be found on the device.\n\nPotential problems: before API 23 the DT_NEEDED entry‘s basename was used, but starting from API 23 the Android runtime will try to load the library using the path specified, and that path won’t exist on the device. There are broken third-party toolchains/build systems that use a path on a build host instead of the SONAME.\n\nResolution: make sure all required libraries are referenced by SONAME only. It is better to let the runtime linker to find and load those libraries as the location may change from device to device.\n\nEach ELF shared object (“native library”) must have a SONAME (Shared Object Name) attribute. The NDK toolchain adds this attribute by default, so its absence indicates either a misconfigured alternative toolchain or a misconfiguration in your build system. A missing SONAME may lead to runtime issues such as the wrong library being loaded: the filename is used instead when this attribute is missing.\n\nPotential problems: namespace conflicts may lead to the wrong library being loaded at runtime, which leads to crashes when required symbols are not found, or you try to use an ABI-incompatible library that isn't the library you were expecting.\n\nResolution: the current NDK generates the correct SONAME by default. Ensure you‘re using the current NDK and that you haven’t configured your build system to generate incorrect SONAME entries (using the -soname linker option).\n\nEach segment in an ELF file has associated flags that tell the dynamic linker what permissions to give the corresponding page in memory. For security, data shouldn‘t be executable and code shouldn’t be writable. This means that the W (for Writable) and E (for Executable) flags should be mutually exclusive. This wasn't historically enforced, but is now.\n\nResolution: we're aware of one middleware product that introduces these into your app. The middleware vendor is aware of the problem and has a fix available.\n\nAndroid loader now checks for invalid values in ELF header and section headers and fails if they are invalid.\n\nResolution Do not use tools that produce invalid/malformed elf-files. Note that using them puts application under high risk of being incompatible with future versions of Android."
    },
    {
        "link": "https://github.com/immunant/android_bionic/blob/master/android-changes-for-ndk-developers.md",
        "document": "This document details important changes related to native code loading in various Android releases.\n\nRequired tools: the NDK has an arch-linux-android-readelf binary (e.g. arm-linux-androideabi-readelf or i686-linux-android-readelf) for each architecture (under toolchains/), but you can use readelf for any architecture, as we will be doing basic inspection only. On Linux you need to have the “binutils” package installed for readelf, and “pax-utils” for scanelf.\n\nOur general practice with dynamic linker behavior changes is that they will be tied to an app's target API level:\n• Below the affected API level we'll preserve the old behavior or issue a warning, as appropriate.\n• At the affected API level and above, we’ll refuse to load the library.\n• Warnings about any behavior change that will affect a library if you increase your target API level will appear in logcat when that library is loaded, even if you're not yet targeting that API level.\n• On a developer preview build, dynamic linker warnings will also show up as toasts. Experience has shown that many developers don’t habitually check logcat for warnings until their app stops functioning, so the toasts help bring some visibility to the issues before it's too late.\n\nWe have made various fixes to library search order when resolving symbols.\n\nWith API 22, load order switched from depth-first to breadth-first to fix dlsym(3).\n\nBefore API 23, the default search order was to try the main executable, LD_PRELOAD libraries, the library itself, and its DT_NEEDED libraries in that order. For API 23 and later, for any given library, the dynamic linker divides other libraries into the global group and the local group. The global group is shared by all libraries and contains the main executable, LD_PRELOAD libraries, and any library with the DF_1_GLOBAL flag set (by passing “-z global” to ld(1)). The local group is the breadth-first transitive closure of the library and its DT_NEEDED libraries. The M dynamic linker searches the global group followed by the local group. This allows ASAN, for example, to ensure that it can intercept any symbol.\n\nThe dlopen(3) RTLD_LOCAL flag used to be ignored but is implemented correctly in API 23 and later. Note that RTLD_LOCAL is the default, so even calls to dlopen(3) that didn’t explicitly use RTLD_LOCAL will be affected (unless they explicitly used RTLD_GLOBAL). With RTLD_LOCAL, symbols will not be made available to libraries loaded by later calls to dlopen(3) (as opposed to being referenced by DT_NEEDED entries).\n\nThe GNU hash style available with --hash-style=gnu allows faster symbol lookup and is now supported by the dynamic linker in API 23 and above. (Use --hash-style=both if you want to build code that uses this feature >= Android M but still works on older releases.)\n\nThe dynamic linker now understands the difference between a library’s soname and its path (public bug https://code.google.com/p/android/issues/detail?id=6670). API level 23 is the first release where search by soname is implemented. Earlier releases would assume that the basename of the library was the soname, and used that to search for already-loaded libraries. For example, would find because it’s already loaded. This also meant that it was impossible to have two libraries and --- the dynamic linker couldn’t tell the difference and would always use whichever was loaded first, even if you explicitly tried to load both. This also applied to DT_NEEDED entries.\n\nSome apps have bad DT_NEEDED entries (usually absolute paths on the build machine’s file system) that used to work because we ignored everything but the basename. These apps will fail to load on API level 23 and above.\n\nSymbol versioning allows libraries to provide better backwards compatibility. For example, if a library author knowingly changes the behavior of a function, they can provide two versions in the same library so that old code gets the old version and new code gets the new version. This is supported in API level 23 and above.\n\nIn API level 23 and above, it’s possible to open a .so file directly from your APK. Just use exactly as normal but set in your . In older releases, the .so files were extracted from the APK file at install time. This meant that they took up space in your APK and again in your installation directory (and this was counted against you and reported to the user as space taken up by your app). Any .so file that you want to load directly from your APK must be page aligned (on a 4096-byte boundary) in the zip file and stored uncompressed. Current versions of the zipalign tool take care of alignment.\n\nNote that in API level 23 and above dlopen(3) will open a library from any zip file, not just your APK. Just give dlopen(3) a path of the form \"my_zip_file.zip!/libs/libstuff.so\". As with APKs, the library must be page-aligned and stored uncompressed for this to work.\n\nNative libraries must use only public API, and must not link against non-NDK platform libraries. Starting with API 24 this rule is enforced and applications are no longer able to load non-NDK platform libraries. The rule is enforced by the dynamic linker, so non-public libraries are not accessible regardless of the way code tries to load them: System.loadLibrary, DT_NEEDED entries, and direct calls to dlopen(3) will all work exactly the same.\n\nUsers should have a consistent app experience across updates, and developers shouldn't have to make emergency app updates to handle platform changes. For that reason, we recommend against using private C/C++ symbols. Private symbols aren't tested as part of the Compatibility Test Suite (CTS) that all Android devices must pass. They may not exist, or they may behave differently. This makes apps that use them more likely to fail on specific devices, or on future releases --- as many developers found when Android 6.0 Marshmallow switched from OpenSSL to BoringSSL.\n\nIn order to reduce the user impact of this transition, we've identified a set of libraries that see significant use from Google Play's most-installed apps, and that are feasible for us to support in the short term (including libandroid_runtime.so, libcutils.so, libcrypto.so, and libssl.so). In order to give you more time to transition, we will temporarily support these libraries; so if you see a warning that means your code will not work in a future release -- please fix it now!\n\nIn O and later, the system property can be used to deny access to the greylist even to an app that would normally be allowed it. This allows you to test compatibility without bumping the app's . Use to turn this on (any other value leaves the greylist enabled).\n\nPotential problems: starting from API 24 the dynamic linker will not load private libraries, preventing the application from loading.\n\nResolution: rewrite your native code to rely only on public API. As a short term workaround, platform libraries without complex dependencies (libcutils.so) can be copied to the project. As a long term solution the relevant code must be copied to the project tree. SSL/Media/JNI internal/binder APIs should not be accessed from the native code. When necessary, native code should call appropriate public Java API methods.\n\nA complete list of public libraries is available within the NDK, under platforms/android-API/usr/lib.\n\nNote: SSL/crypto is a special case, applications must NOT use platform libcrypto and libssl libraries directly, even on older platforms. All applications should use GMS Security Provider to ensure they are protected from known vulnerabilities.\n\nEach ELF file has additional information contained in the section headers. These headers must be present now, because the dynamic linker uses them for sanity checking. Some developers strip them in an attempt to obfuscate the binary and prevent reverse engineering. (This doesn't really help because it is possible to reconstruct the stripped information using widely-available tools.)\n\nResolution: remove the extra steps from your build that strip section headers.\n\nStarting with API 23, shared objects must not contain text relocations. That is, the code must be loaded as is and must not be modified. Such an approach reduces load time and improves security.\n\nThe usual reason for text relocations is non-position independent hand-written assembler. This is not common. Use the scanelf tool as described in our documentation for further diagnostics:\n\nIf you have no scanelf tool available, it is possible to do a basic check with readelf instead, look for either a TEXTREL entry or the TEXTREL flag. Either alone is sufficient. (The value corresponding to the TEXTREL entry is irrelevant and typically 0 --- simply the presence of the TEXTREL entry declares that the .so contains text relocations). This example has both indicators present:\n\nNote: it is technically possible to have a shared object with the TEXTREL entry/flag but without any actual text relocations. This doesn't happen with the NDK, but if you're generating ELF files yourself make sure you're not generating ELF files that claim to have text relocations, because the Android dynamic linker trusts the entry/flag.\n\nPotential problems: Relocations enforce code pages being writable, and wastefully increase the number of dirty pages in memory. The dynamic linker has issued warnings about text relocations since Android K (API 19), but on API 23 and above it refuses to load code with text relocations.\n\nResolution: rewrite assembler to be position independent to ensure no text relocations are necessary. The Gentoo Textrels guide has instructions for fixing text relocations, and more detailed scanelf documentation.\n\nWhile library dependencies (DT_NEEDED entries in the ELF headers) can be absolute paths, that doesn't make sense on Android because you have no control over where your library will be installed by the system. A DT_NEEDED entry should be the same as the needed library's SONAME, leaving the business of finding the library at runtime to the dynamic linker.\n\nBefore API 23, Android's dynamic linker ignored the full path, and used only the basename (the part after the last ‘/') when looking up the required libraries. Since API 23 the runtime linker will honor the DT_NEEDED exactly and so it won't be able to load the library if it is not present in that exact location on the device.\n\nEven worse, some build systems have bugs that cause them to insert DT_NEEDED entries that point to a file on the build host, something that cannot be found on the device.\n\nPotential problems: before API 23 the DT_NEEDED entry's basename was used, but starting from API 23 the Android runtime will try to load the library using the path specified, and that path won't exist on the device. There are broken third-party toolchains/build systems that use a path on a build host instead of the SONAME.\n\nResolution: make sure all required libraries are referenced by SONAME only. It is better to let the runtime linker to find and load those libraries as the location may change from device to device.\n\nEach ELF shared object (“native library”) must have a SONAME (Shared Object Name) attribute. The NDK toolchain adds this attribute by default, so its absence indicates either a misconfigured alternative toolchain or a misconfiguration in your build system. A missing SONAME may lead to runtime issues such as the wrong library being loaded: the filename is used instead when this attribute is missing.\n\nPotential problems: namespace conflicts may lead to the wrong library being loaded at runtime, which leads to crashes when required symbols are not found, or you try to use an ABI-incompatible library that isn't the library you were expecting.\n\nResolution: the current NDK generates the correct SONAME by default. Ensure you're using the current NDK and that you haven't configured your build system to generate incorrect SONAME entries (using the -soname linker option).\n\nIf an ELF file contains a DT_RUNPATH entry, the directories listed there will be searched to resolve DT_NEEDED entries. The string will be rewritten at runtime to the directory containing the ELF file. This allows the use of relative paths. The and substitutions supported on some systems are not currently implemented on Android.\n\nEach segment in an ELF file has associated flags that tell the dynamic linker what permissions to give the corresponding page in memory. For security, data shouldn't be executable and code shouldn't be writable. This means that the W (for Writable) and E (for Executable) flags should be mutually exclusive. This wasn't historically enforced, but is now.\n\nResolution: we're aware of one middleware product that introduces these into your app. The middleware vendor is aware of the problem and has a fix available.\n\nIn API level 26 and above the dynamic linker checks more values in the ELF header and section headers and fails if they are invalid.\n\nResolution: don't use tools that produce invalid/malformed ELF files. Note that using them puts application under high risk of being incompatible with future versions of Android.\n\nStarting with Android O it is possible to enable logging of all dlsym/dlopen calls for debuggable apps. Here is short instruction on how to do that:\n\nAny subset of (dlsym,dlopen,dlerror) can be used.\n\nOn userdebug and eng builds it is possible to enable tracing for the whole system by using debug.ld.all system property instead of app-specific one:\n\nenables logging of all errors and dlopen calls"
    },
    {
        "link": "https://reddit.com/r/androiddev/comments/10qdep8/abi_and_app_compatibility_in_android",
        "document": ""
    },
    {
        "link": "https://source.android.com/docs/core/architecture/vndk/abi-stability",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nApplication Binary Interface (ABI) stability is a prerequisite of framework-only updates because vendor modules may depend on the Vendor Native Development Kit (VNDK) shared libraries that reside in the system partition. Within an Android release, newly-built VNDK shared libraries must be ABI-compatible to previously released VNDK shared libraries so vendor modules can work with those libraries without recompilation and without runtime errors. Between Android releases, VNDK libraries can be changed and there are no ABI guarantees.\n\nTo help ensure ABI compatibility, Android 9 includes a header ABI checker, as described in the following sections.\n\nThe VNDK is a restrictive set of libraries that vendor modules may link to and which enable framework-only updates. ABI compliance refers to the ability of a newer version of a shared library to work as expected with a module that is dynamically linked to it (i.e. works as an older version of the library would).\n\nAn exported symbol (also known as a global symbol) refers to a symbol that satisfies all of the following:\n• Exported by the public headers of a shared library.\n• Appears in the table of the file corresponding to the shared library.\n• Type is either FUNC or OBJECT.\n\nThe public headers of a shared library are defined as the headers available to other libraries/binaries through the , , , , and attributes in definitions of the module corresponding to the shared library.\n\nA reachable type is any C/C++ built-in or user-defined type that is reachable directly or indirectly through an exported symbol AND exported through public headers. For example, has function , which is an exported symbol found in the table. The library includes the following:\n\nA similar explanation can be given for types reachable through base class specifiers and template parameters as well.\n\nABI compliance must be ensured for the libraries marked and in the corresponding files. For example:\n\nFor data types reachable directly or indirectly by an exported function, the following changes to a library are classified as ABI-breaking:\n\n* Both public and private member functions must not be changed or removed because public inline functions can refer to private member functions. Symbol references to private member functions can be kept in caller binaries. Changing or removing private member functions from shared libraries can result in backward-incompatible binaries.\n\n** The offsets to public or private data members must not be changed because inline functions can refer to these data members in their function body. Changing data member offsets can result in backward-incompatible binaries.\n\n*** While these don't change the memory layout of the type, there are semantic differences that could lead to libraries not functioning as expected.\n\nWhen a VNDK library is built, the library's ABI is compared with the corresponding ABI reference for the version of the VNDK being built. Reference ABI dumps are located in:\n\nFor example, on building for x86 at API level 27, 's inferred ABI is compared with its reference at:\n\nOn ABI breakages, the build log displays warnings with the warning type and a path to the abi-diff report. For example, if 's ABI has an incompatible change, the build system throws an error with a message similar to the following:\n• processes the source files compiled to build the VNDK library (the library's own source files as well as source files inherited through static transitive dependencies), to produce files that correspond to each source.\n• then processes the files (using either a version script provided to it or the file corresponding to the shared library) to produce a file that logs all of the ABI information corresponding to the shared library.\n• compares the file with a reference file to produce a diff report that outlines the differences in the ABIs of the two libraries. \n\n\n\nThe tool parses a C/C++ source file and dumps the ABI inferred from that source file into an intermediate file. The build system runs on all compiled source files while also building a library that includes the source files from transitive dependencies.\n\nCurrently files are in JSON format, which isn't guaranteed to be stable across future releases. As such, file formatting should be considered a build system implementation detail.\n\nFor example, has the following source file :\n\nYou can use to generate an intermediate file that represents the ABI presented by the source file using:\n\nThis command tells to parse with the compiler flags following , and emit the ABI information that is exported by the public headers in the directory. The following is generated by :\n\ncontains ABI information exported by the source file and the public headers, for example,\n• . Refer to structs, unions, or classes defined in the public headers. Each record type has information about its fields, its size, access specifier, the header file it's defined in, and other attributes.\n• . Refer to pointer types directly/indirectly referenced by the exported records/functions in the public headers, along with the type the pointer points to (through the field in ). Similar information is logged in the file for qualified types, built-in C/C++ types, array types, and lvalue and rvalue reference types. Such information allows recursive diffing.\n• . Represent functions exported by public headers. They also have information about the function's mangled name, the return type, the types of the parameters, the access specifier, and other attributes.\n\nThe tool takes the intermediate files produced by as input then links those files:\n\nThe tool merges the type graphs in all the intermediate files given to it, taking into account one-definition (user-defined types in different translation units with the same fully qualified name, might be semantically different) differences across translation units. The tool then parses either a version script or the table of the shared library ( file) to make a list of the exported symbols.\n\nFor example, consists of and . could be invoked to create the complete linked ABI dump of as follows:\n• Links the files provided to it ( and ), filtering out the ABI information not present in the headers residing in the directory: .\n• Parses , and collects information about the symbols exported by the library through its table.\n\nis the final generated ABI dump of .\n\nThe tool compares two files representing the ABI of two libraries and produces a diff report stating the differences between the two ABIs.\n\nThe ABI diff file is in protobuf text format. The format is subject to change in future releases.\n\nFor example, you have two versions of : and . In , in , you change the type of from to . Since is a reachable type, this should be flagged as an ABI breaking change by .\n\nThe contains a report of all ABI breaking changes in . The message indicates a record has changed and lists the incompatible changes, which include:\n• The size of the record changing from bytes to bytes.\n• The field type of changing from to (all typedefs are stripped off).\n\nThe field indicates how reached the type that changed ( ). This field may be interpreted as is an exported function that takes in as parameter, that points to , which was exported and changed.\n\nTo enforce the ABI and API of VNDK shared libraries, ABI references must be checked into . To create these references, run the following command:\n\nAfter creating the references, any change made to the source code that results in an incompatible ABI/API change in a VNDK library now results in a build error.\n\nTo update ABI references for specific libraries, run the following command:\n\nFor example, to update ABI references, run:"
    },
    {
        "link": "https://source.android.com/docs/core/architecture/partitions/abi-stability",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nApplication Binary Interface (ABI) stability is a prerequisite of framework-only updates because vendor modules may depend on the Vendor Native Development Kit (VNDK) shared libraries that reside in the system partition. Within an Android release, newly-built VNDK shared libraries must be ABI-compatible to previously released VNDK shared libraries so vendor modules can work with those libraries without recompilation and without runtime errors. Between Android releases, VNDK libraries can be changed and there are no ABI guarantees.\n\nTo help ensure ABI compatibility, Android 9 includes a header ABI checker, as described in the following sections.\n\nThe VNDK is a restrictive set of libraries that vendor modules may link to and which enable framework-only updates. ABI compliance refers to the ability of a newer version of a shared library to work as expected with a module that is dynamically linked to it (i.e. works as an older version of the library would).\n\nAn exported symbol (also known as a global symbol) refers to a symbol that satisfies all of the following:\n• Exported by the public headers of a shared library.\n• Appears in the table of the file corresponding to the shared library.\n• Type is either FUNC or OBJECT.\n\nThe public headers of a shared library are defined as the headers available to other libraries/binaries through the , , , , and attributes in definitions of the module corresponding to the shared library.\n\nA reachable type is any C/C++ built-in or user-defined type that is reachable directly or indirectly through an exported symbol AND exported through public headers. For example, has function , which is an exported symbol found in the table. The library includes the following:\n\nA similar explanation can be given for types reachable through base class specifiers and template parameters as well.\n\nABI compliance must be ensured for the libraries marked and in the corresponding files. For example:\n\nFor data types reachable directly or indirectly by an exported function, the following changes to a library are classified as ABI-breaking:\n\n* Both public and private member functions must not be changed or removed because public inline functions can refer to private member functions. Symbol references to private member functions can be kept in caller binaries. Changing or removing private member functions from shared libraries can result in backward-incompatible binaries.\n\n** The offsets to public or private data members must not be changed because inline functions can refer to these data members in their function body. Changing data member offsets can result in backward-incompatible binaries.\n\n*** While these don't change the memory layout of the type, there are semantic differences that could lead to libraries not functioning as expected.\n\nWhen a VNDK library is built, the library's ABI is compared with the corresponding ABI reference for the version of the VNDK being built. Reference ABI dumps are located in:\n\nFor example, on building for x86 at API level 27, 's inferred ABI is compared with its reference at:\n\nOn ABI breakages, the build log displays warnings with the warning type and a path to the abi-diff report. For example, if 's ABI has an incompatible change, the build system throws an error with a message similar to the following:\n• processes the source files compiled to build the VNDK library (the library's own source files as well as source files inherited through static transitive dependencies), to produce files that correspond to each source.\n• then processes the files (using either a version script provided to it or the file corresponding to the shared library) to produce a file that logs all of the ABI information corresponding to the shared library.\n• compares the file with a reference file to produce a diff report that outlines the differences in the ABIs of the two libraries. \n\n\n\nThe tool parses a C/C++ source file and dumps the ABI inferred from that source file into an intermediate file. The build system runs on all compiled source files while also building a library that includes the source files from transitive dependencies.\n\nCurrently files are in JSON format, which isn't guaranteed to be stable across future releases. As such, file formatting should be considered a build system implementation detail.\n\nFor example, has the following source file :\n\nYou can use to generate an intermediate file that represents the ABI presented by the source file using:\n\nThis command tells to parse with the compiler flags following , and emit the ABI information that is exported by the public headers in the directory. The following is generated by :\n\ncontains ABI information exported by the source file and the public headers, for example,\n• . Refer to structs, unions, or classes defined in the public headers. Each record type has information about its fields, its size, access specifier, the header file it's defined in, and other attributes.\n• . Refer to pointer types directly/indirectly referenced by the exported records/functions in the public headers, along with the type the pointer points to (through the field in ). Similar information is logged in the file for qualified types, built-in C/C++ types, array types, and lvalue and rvalue reference types. Such information allows recursive diffing.\n• . Represent functions exported by public headers. They also have information about the function's mangled name, the return type, the types of the parameters, the access specifier, and other attributes.\n\nThe tool takes the intermediate files produced by as input then links those files:\n\nThe tool merges the type graphs in all the intermediate files given to it, taking into account one-definition (user-defined types in different translation units with the same fully qualified name, might be semantically different) differences across translation units. The tool then parses either a version script or the table of the shared library ( file) to make a list of the exported symbols.\n\nFor example, consists of and . could be invoked to create the complete linked ABI dump of as follows:\n• Links the files provided to it ( and ), filtering out the ABI information not present in the headers residing in the directory: .\n• Parses , and collects information about the symbols exported by the library through its table.\n\nis the final generated ABI dump of .\n\nThe tool compares two files representing the ABI of two libraries and produces a diff report stating the differences between the two ABIs.\n\nThe ABI diff file is in protobuf text format. The format is subject to change in future releases.\n\nFor example, you have two versions of : and . In , in , you change the type of from to . Since is a reachable type, this should be flagged as an ABI breaking change by .\n\nThe contains a report of all ABI breaking changes in . The message indicates a record has changed and lists the incompatible changes, which include:\n• The size of the record changing from bytes to bytes.\n• The field type of changing from to (all typedefs are stripped off).\n\nThe field indicates how reached the type that changed ( ). This field may be interpreted as is an exported function that takes in as parameter, that points to , which was exported and changed.\n\nTo enforce the ABI/API of VNDK shared libraries, ABI references must be checked into . To create these references, run the following command:\n\nAfter creating the references, any change made to the source code that results in an incompatible ABI/API change in a VNDK library now results in a build error.\n\nTo update ABI references for specific libraries, run the following command:\n\nFor example, to update ABI references, run:"
    },
    {
        "link": "https://stackoverflow.com/questions/14705185/android-different-abi-compatibility",
        "document": "For example let build static library called \"some\".\n\nAnd get armeabi version of our lib in LibSome/obj/local/armeabi/libsome.a\n\nSo now we need to drop our lib to mainProject jni folder and use it\n\nBut there are different ABI like mips, x86, armeabi-v7a and we can get all supported versions of somelib by current ndk just adding\n\nto SomeLib Application.mk, so we get LibSome/obj/local/armeabi-v7a/libsome.a, LibSome/obj/local/x86/libsome.a etc\n\nMain question - do i really need to think about different ABI and create project for every supported ABI like mainProjectx86, mainProjectMIPS with different ABI builded libs?\n\nIf i build project for armeabi ABI (default) how many devices will be cut out? Can armeabi-v7a ABI device run armeabi ABI app?\n\nIf there is a way to have one project with different set of pre-builded libs? So if you build mainProject for ameabi-v7a it will use armeabi-v7a libs and so on?"
    },
    {
        "link": "https://reddit.com/r/androiddev/comments/10qdep8/abi_and_app_compatibility_in_android",
        "document": "While working on my first android library (AAR file), I am finding myself stuck on a basic android topic that I'm not understanding well, and not finding much documentation for online.\n\nMy background is in creating kernel drivers for Windows, and \"device helper\" dlls that have a flat C API and have broad binary compatibility on Windows. As far as I know the rule on windows is that if a dll is built with a valid version of the windows SDK, it is supported on that versions of windows and \"~all\" future versions, too... and I believe it I have games from the late 90s, and basic GDI apps from windows 95 that still run on Windows 10 today.\n\nSo my question is, does android make similar guarantees either for apps or libraries. Do apps written for very old android versions like donut(1.6) still run on Modern OS versions, and do Libraries developed on older SDKs still work with apps developed with newer SDKs.\n\nMy goal is to put out an AAR that is consumed by completely separate team and build system that may take android SDK updates much faster than I do. If I expose a Java interface from my AAR, and limit myself to only calling java and native C apis that are supported by my android SDK version, will I risk breaking my app project down the road if it decided to use a different SDK version from the likely ancient SDK version I am using. How does google announce breaking changes if they occur?\n\nI'm worried about either my AAR no longer linking(is that the java term?) if packages I used in my SDK version are removed or have breaking changes made to them in newer SDK versions, or my app just not functioning at all due to runtime or ABI changes... I wonder if something like this happened when they moved from Dalvik to ART? I have searched online for any mentions of compatibility levels and breaking changes, and not found anything..."
    },
    {
        "link": "https://livefront.com/writing/native-android-libraries-gone-bad",
        "document": "I work on the Android app for a large company that is broken into multiple teams — Android, iOS, cloud services, etc. About a year ago one of those teams, the AV platform team, came out with an updated AV player library that we wanted to integrate into the app. Version 1.0 of the library was already present in the app so I expected the whole process to take about an hour. I just needed to copy over the updated AAR to the libs folder, fix any broken API calls, and call it good.\n\nSo that’s what I did. I copied over the new library, updated a few calls, compiled, and ran the app. Everything looked almost right. The videos would play, but there were many spots in the app that just weren’t loading. Looking through the logs I saw:\n\nThe application suddenly couldn’t find some native dependencies that it had no problem finding before.\n\nHow can something like this happen? A little background on Android hardware is necessary to explain it. From Android’s guide on ABIs :\n\nA device’s OS can support one or more ABIs, and expects to find native libraries within the APK at the path where can be any of the ABIs listed here . The Android system will pick the ABI best suited to the device; it will first try its primary ABI (e.g. arm64-v8a ), and if it doesn’t find anything it will continue to any of the secondary ABIs it supports (e.g. armeabi-v7a ). The key thing to note is that the OS will only pick a single folder and will not combine the contents of two or more of the folders. Also keep in mind that certain ABIs are backwards compatible with others (armeabi-v7a and armeabi, for example). So native armeabi code can be run on armeabi-v7a devices, which will prove to be useful later.\n\nI wanted to see how the binary was packaged before and after the library update. I gave the generated APK a .zip extension, unzipped it, and looked in the folder to see how the native dependencies were setup.\n\nThe old version only contains native dependencies for the armeabi ABI. The new version now contains an additional target for armeabi-v7a. The best suited ABI for my device among the selections available is armeabi-v7a, so the OS is only looking inside that folder.\n\nThe AV platform libraries were compiled with the Android Native Development Kit, or NDK, which “ …is a set of tools that allows you to use C and C++ code with Android. ” Support for the armeabi ABI was removed in version r17 of the NDK. The AV platform team started using a version of NDK that no longer supported the architecture we needed. We could have asked the team to rollback their NDK version and supply us with an AAR that only supported armeabi, but other groups relied on this library and I didn’t want to be the one to block anyone else’s progress.\n\nThe best solution is for each native library in the app to target all of the possible ABIs we want to support. Unfortunately our application uses a large number of libraries from a wide variety of teams. Each library only targeted the armeabi ABI at this point. It would take quite a commitment from the entire global organization to go back and recompile everything we need. Some of those original teams probably don’t even exist! In the short-term this isn’t feasible, but as I discuss later, in the long-term this is unavoidable.\n\nAs mentioned above, we could also ask the AV platform team to rollback the version of NDK they were using. But, again, that was something I really wanted to avoid.\n\nA last resort is to copy over all of those files into the application’s folder. This folder sits alongside your Java or Kotlin code, and is a place where you can manually add native libraries, grouped by ABI.\n\nIf we copy over the contents of the folder contained in the final APK directly into the here, everything would start working. The application would find everything it needed in a combination of the folder and the folder the build process produces. However, any addition or future update to a native library is prone to break this. Other developers will need to know to unzip their new library, extract all the files from the folder, and copy them over to the folder. It’s a lot of extra work for something that we can work around.\n\nLuck is on our side in this particular situation. The new native dependencies we’re dealing with are targeting an ABI that is backwards-compatible with the other, armeabi-v7a and armeabi, respectively. As mentioned above, any device supporting armeabi-v7a is going to be able to handle native code targeting armeabi as well. As long as we can group all of these files together in one place for the app to find, everything should start working. So now the tricky part, how do we package these together?\n\nOur overall goal is to take the files in one of the library folders and copy or move them over to the other folder. Which folder is the source and which is the destination doesn’t matter since we’ll be deleting the source directory, but let’s plan on moving everything over to the armeabi-v7a folder for demonstration purposes. The Gradle build process for Android is a powerful, if finicky tool, that we can leverage to accomplish this goal. The build process is broken down into multiple steps; for each step we can hook into immediately before or after it runs to run some code of our own. Each of these steps, or tasks, will have a name we can examine. One of these tasks, with a name prefixed by , is where these native dependencies first show up. This is where we start.\n\nFirst we iterate through all of the build tasks. Anything with a name not starting with we don’t care about, and can quickly bail on.\n\nNow that we have the correct build task, we can get the system path where all of the build files are being placed. We iterate through all possible build variants of our application to compare against the version of the app currently being built. We do this by grabbing the portion of the task name after , which will potentially contain the flavor and build type. If the flavor and build type of the variant being built are contained in this string, we most likely have a match. The variant’s directory name is a starting place to find the native dependencies.\n\nIn my case the task path is .\n\nFinally, if the task path is found, we call the function to copy the files.\n\nThe function isn’t too complicated. First a “base” directory to where to find the native libraries is constructed based on the application’s project directory (a global variable called ) and the task path that was just found.\n\nFrom there we can search for the desired source and destination folders. Note that once we find the source directory (armeabi), we immediately construct the destination directory (armeabi-v7a) whether it already exists or not. No matter what, we copy files into that directory.\n\nOnce we have both directories, we copy over all native dependencies (files with the extension ), and then delete the source directory. We can just leave the source directory alone, but those files will never be used and will just contribute to an increased APK size. I use the Apache Commons IO library to copy and delete the directories, but you can probably use the Gradle / type tasks or come up with something of your own if you didn’t want to import a third-party library.\n\nHere’s the function to search for a sub-directory referenced in the previous code snippet above. It just iterates over a directory’s list of files, looping recursively over any sub-directories it might find, until it finds the desired directory name.\n\nThe new folder will get rolled into the APK just as if the build process itself had constructed it. Once the build finishes and we have the final APK, we can unzip it to verify the directory structure is to our liking:\n\nNotice that there’s only the single armeabi-v7a folder now, just as we want. A quick test confirms that the app is now running as expected.\n\nWhat has happened since\n\nAs mentioned above, the solution I went with is not the long-term solution required. We need to update all our native libraries to support more than just the armeabi architecture (and even beyond armeabi-v7a). Besides eliminating the need for the work-around I implemented here, it has two main benefits:\n• By supporting the x86 architecture, we will be able to deploy the app to an emulator. You can setup an emulator to target a different ABI than x86, but I wouldn’t recommend it. Everything from system startup to running an app is preposterously slower. Also, without emulator support it’s next to impossible to run UI tests in a continuous integration environment. From my point-of-view as a developer, this would be the biggest benefit.\n• It is now required! In an article from the Android Developers Blog , starting August 1, 2019:\n\nSo at the very least our libraries need to support the arm64-v8a architecture in addition to armeabi; otherwise we won’t be able to update our app in the Play Store. Fortunately, in the year since I had to implement this solution, the various teams have been able to add 64-bit support to their respective libraries. We don’t have x86 support yet, but we’re at least able to update our Play Store listing. That’s at least a start, and will hopefully lead to support for a wider range of ABIs in the not-too-distant future."
    }
]