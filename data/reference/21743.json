[
    {
        "link": "https://gpfault.net/posts/perlin-noise.txt.html",
        "document": "Using Perlin Noise to Generate 2D Terrain and Water\n\nThis post is going to be the Perlin noise tutorial that I've always wanted to see. By the end of it, we'll procedurally generate 2D terrain and water with GLSL.\n\nPerlin noise was invented in the eighties and has since been used countless times to generate natural-looking visual effects in films and games.\n\nIf you google \"perlin noise\", you will get a trove of articles and code. However, in my opinion, a beginner will have a hard time figuring out how it really works. I think that a lot of articles on the subject don't provide enough context, jump into too much detail too quickly and use scary terminology like \"surflets\". I've even stumbled upon some articles presenting blurred white noise as perlin noise, which is not the case!\n\nAnd that's why I decided to try and write a more beginner-friendly article on the subject, that starts from a simple and easy to understand case, and builds up towards a more advanced one. Hopefully, people who read this tutorial won't have to struggle any more!\n\nBefore we go any further, I want to make sure a simple, but very important point is understood: noise is a mathematical function, just like the sine or the exponent. The gray, amorphous, lumpy fog that you see in most pictures is just one of the possible graphical representations of said function. The reason I want to make this explicit is that some people may think about calculating noise in terms of pixels being affected by neighbor pixels, which really isn't the correct way to think about Perlin noise.\n\nMost of us are familiar with mathematical functions of a single variable (again, sine for example), but functions can depend on multiple variables. It's fairly easy to visually represent a function of two variables. For a function of three variables, you can imagine the time, t, as the third variable, and the graphical representation would be animated: the values of the function along the z at each point (x, y) would change with the passage of time.\n\nNow, if you image-search for perlin noise, what you'll usually see is the graphical representation of a two-dimensional function, where lighter pixels correspond to higher values at particular x and y coordinates. But the thing is, perlin noise doesn't have to be two-dimensional. The concept can be extended to any number of dimensions. But more importantly for us, it can be reduced to just a single dimension! And, for us mere mortals, it's much easier to understand how the one-dimensional case works. Armed with that knowledge, we'll be ready to tackle the more complex cases. That is the approach that this post is going to take.\n\nRegardless of dimensionality, the noise function must be continuous, smooth and random-looking. Of course, there are strict mathematical definitions for what things like \"continuous\" and \"smooth\" mean, but you needn't worry about that right now - just go with your intuitive understanding.\n\nIn the one-dimensional case, the graph of a function possessing the above-mentioned properties will look like a neat squiggly line. Our first goal will be to construct such a function.\n\nIt should be noted that there are multiple methods to construct a function fitting these criteria, Perlin's technique is just one of them.\n\nConstructing the Noise Function of One Variable\n\nAs promised, we're going to consider the single-variable case first. Thus, our noise function n is defined in the domain of real numbers, R.\n\nNow, let's imagine that for each integer, a value of either 1 or -1 is chosen randomly. For a given integer i, we're going to denote the corresponding randomly chosen value as g(i). We'll call these values gradients.\n\nThe noise function is defined as follows:\n• p = floor(p) (largest integer smaller than or equal to p)\n• g(p ) and g(p ) are the gradients at p and p respectively\n• F(t) = t3(t(t-15)+10), a fade function, the purpose of which will be explained a bit later\n\nAs you can see, it's just interpolating between two values, g(p )(p-p ) and g(p )(p-p ), with the interpolation parameter given by applying the fade function to p-p . The noise function turns out to have a number of interesting properties (the rigorous proof of which isn't within the scope of the article):\n• The values of this function at integer points are zero (this property is actually easy to see)\n• The value of the function will decrease as its argument approaches an integer for which -1 was randomly chosen as the gradient value.\n• Conversely, the value of the function will increase as its argument approaches an integer for which 1 was chosen as the gradient value.\n• The function is continuous and smooth\n\nExplained in a handwavy kind of way, the technique boils down to randomly specifying the desired kind of growth (positive or negative) in the neighborhood of each integer point of the function's domain and then fitting a nice smooth curve that satisfies the growth requirements, with the caveat that the function's values must be 0 at integer points.\n\nOf course, showing is better than telling, so I suggest you play with the following interactive demo to get an intuitive sense of how the function works (javascript must be enabled):\n\nI still owe you an explanation for that \"fade function\" polynomial. I won't go too deep into it for the sake of brevity, but I'll try to give you an idea.\n\nFirst, try unchecking the \"apply fade function\" checkbox in the demo and observe the results. Doesn't look very smooth, does it? Look at these sharp corners!\n\nWithout the fade function, our noise becomes constant 0 between integer points with the same gradient values. On the surface, it's easy to see why: if you just plug in the same gradient values for p and p into the expression for noise without the fade function, it'll be zero. But there's a bit more to it than that, and we'll need just a bit of calculus to explain it.\n\nBefore we proceed with the explanation, we need to strictly define what it means for a function to be \"smooth\". A function is called Ci-smooth if it has continuous derivatives of up to i-th order (in case your calculus is rusty, or these words don't sound familiar at all, I suggest consulting your favorite calculus textbook or Wikipedia).\n\nNow, if you don't apply the fade function to the interpolation parameter and instead use p-p directly, the resulting function will not be smooth enough. You can try doing it yourself: replace F(p-p ) with just p-p in the noise function definition, simplify the expression and try working out the derivative. The equation for the derivative between p and p is going to look like (some constant value)*p + (some other constant value), in other words it'll be a straight line. The constants depend on p and p , so the derivative for the overall noise function will look like a bunch of various straight lines. We don't even have a continuous first-order derivative, so our function isn't smooth at all!\n\nBasically, applying the fade gives our noise function continuous higher-order derivatives which makes it look nice and smooth. Instead of varying the interpolation parameter from 0 to 1 linearly, the fade function varies it along an s-shaped curve.\n\nAssigning a Random Value to Each Integer\n\nBefore we move on to the implementation, something needs to be mentioned about how we're going to randomly pick gradient values for each integer point of the noise function's domain. The way it's done in the \"classic\" implementation (and the way you'll most likely encounter in other Perlin noise write-ups) goes something like this:\n• An array P of integers from 0 to 256 is permutated at random. Of course, this isn't done at runtime; usually the random permutation is simply hardcoded. Also, it is repeated 2 times in a row, so that Perlin ends up containing 512 elements (this is needed to simplify the next step).\n• A value is looked up from P based on the point the gradient of which we're trying to determinine (i.e. for single-dimensional case it will be P[x & 0xff], for 2-dimensional it will be P[P[P[x & 0xff] + (y & 0xff)] ], etc.)\n• The value from the previous lookup is used to look up into an array of uniformly distributed gradient values\n\nI don't want you to dwell on this too much though, because it is an implementation detail that is not critical to understanding how the overall technique works. Different methods can be used for this. For example, if you're trying to implement Perlin noise in a shader using WebGL, you cannot use the described method because WebGL shaders can't use variable indices with arrays. Instead, you can read the values from a texture filled with random RGB values, and it'll pretty much work the same.\n\nNow we've got everything ready to implement one-dimensional perlin noise. I'm going to use GLSL for this, because then I can paste the code into Shadertoy which is very handy for online demos like this. The code should be portable to other languages with minimal changes though.\n\nThe function is straightforward, so I'm not going to explain it.\n\nNow comes the function. It returns a gradient value for a given integer p. We're using WebGL and can't do variable indexes into arrays, so we're going to sample from a random RGB texture and return 1 if the red channel is > 0.5, and -1 otherwise.\n• The texture needs to be repeated (i.e. both and options need to be set to ) so that values that are greater than the pixel size of the texture (or even negative values) can be used with .\n• The texture needs to use nearest-neighbor filtering.\n\nFinally, let's take a closer look at the main function of the shader where we actually use the noise function.\n\nMaking the Noise Look More Interesting\n\nAt this point, we've covered the core of what makes Perlin noise work. Now is the time to apply it to make something interesting-looking. The trick is to sample the noise function multiple times, with different frequencies and amplitudes, and add the results up. That is called \"fractal noise\".\n\nThe bulk of the shader stays the same, the only part that changes is the main function:\n\nBy manipulating frequencies and amplitudes, you can control how the result looks: lower frequencies give you gently sloped hills, while higher frequencies with higher amplitudes give you more jagged, spiky look. Play with the demo yourself:\n\nUsing the stuff covered that we covered so far, it's easy to put together a simple demo that endlessly flies you past a 2d mountain range! The demo below uses the time counter (shadertoy-specific) for scrolling, and it uses different factors for it on the foreground and background mountains to achieve a nice parallax effect.\n\nJump to the Second Dimension\n\nHopefully by now you have a solid understanding of the the one-dimensional case. You should be well-equipped then to deal with the two-dimensional case.\n\nAt this point I should explain why we call those random values corresponding to integer points \"gradients\". In mathematics, the term gradient is used to refer to the direction in which a function experiences the fastest growth at a given point. In other words, \"gradient at a given point p\" answers the question: \"from a given point p, which direction should the argument go in order for the function to grow the most?\". In case of single-variable functions, the argument can either go forwards (corresponding to gradient value of 1) or backwards (corresponding to gradient value -1). In the case of two-dimensional functions, the gradient has to be a unit 2d vector, because the argument can change in any direction on the XY plane.\n\nSo the first thing we should do is modify our function to give us a random two-dimensional unit vector:\n\nThe function requires a little more changes. But first, let's recap what we did to calculate noise at point p in the 1D case:\n• We determined the integers p and p surrounding the point p\n• For both p and p , we calculated the product between the gradient at that point, and the difference between p and that point.\n• Finally, we did an interpolation between the values calculated in the previous step\n• Determine the four integer points on the plane p , p , p and p surrounding the point p (\"lattice points\")\n• For each of those four lattice points, calculate the dot product between the gradient at the lattice point and the direction from the lattice point to the point p\n• Do something similar to bilinear interpolation: interpolate between the dot products corresponding to the top two lattice points, then interpolate between the dot products corresponding to the two bottom lattice points. Finally, interpolate between the results of the previous two interpolations.\n\nSo, overall, the idea is pretty much the same as in the 1D case, it's just that scalar values have become 2D vectors!\n\nHere is the code:\n\nIf you render 2D noise in the exact same way we did with the 1D noise in the mountains example, but vary the y coordinate with time, you can get a neat effect, resembling rising and falling waves in a body of water. If you also vary the x coordinate with time, you'll get the appearance of rolling waves. You can enhance the effect even further, if you advance the x coordinate for larger, low frequency waves at a slower rate than for smaller, high frequency waves. Check out the demo below:\n\nAt this point, you should be able to figure out how to extend the noise function to 3 variables yourself. The only difference now is that the interpolation becomes more involved: the lattice is now three-dimensional, so there are now 8 integer points surrounding the point p. You do the same interpolation as in the 2D case twice: once for the top 4 vertices, once for the bottom 4 vertices, and finally you interpolate between those two results.\n\nHere is the modified version of the function.\n\nSimilarly to what we did in the 2D case, we can move a 2D slice through the 3D noise by varying the third argument with the time counter and get an animated image. With some coloring we can get an effect reselmbling lava or maybe the surface of a glowing star. Demo:\n\nNow you too can use perlin noise for your game, demo or whatever it is you're making! The code should be fairly easy to adapt to your language of choice. If you have questions or found something incorrect, let me know in the comments.\n\nLike this post? Follow me on bluesky for more!"
    },
    {
        "link": "https://reddit.com/r/opengl/comments/f8h3a0/perlin_noise_calculations",
        "document": "Hi, I’m writing a program to generate a terrain. Right now I can generate it from the height map, it’s colored (mix of colors based on vertex’s height) and distance dependent LOD. I would like to implement procedural generation using Perlin noise, but I am a bit stuck with calculations and design.\n\nI’ll be honest, I am not the greatest mathematician. I am okay and I will understand the maths behind it, but I’d have to see an example. Can anyone point me a tutorial I could use to perform necessary calculations? (I am using C++)\n\nAlso: A) how would you design the class structure? I currently have a Terrain class, which generates a 50x50 terrain chunk. I assume, I’d have to create a PerlinNoise class and alter the terrain there? B) How to design procedural generation - I was thinking about moving the terrain with the camera, so that it doesn’t create hundreds of them when flying for a long time?\n\nAny help is appreciated, thank you."
    },
    {
        "link": "https://jessekaukonen.net/blog_perlin.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/4753055/perlin-noise-generation-for-terrain",
        "document": "A friend just linked me to this question, and I thought I'd try and clear up a couple things that aren't addressed in the accepted answer.\n\nElias' interesting and helpful article uses \"value noise\" not \"Perlin noise\". Value noise involves curve-fitting of randomized points. Gradient noise (of which Perlin noise is a primary example) creates a lattice of 0-value points and gives each one a random gradient. They are frequently confused with one another!\n\nSecondly, using a 3rd value as a seed is expensive. If you want random terrain, consider translating your origin a random amount instead. 3D calls are significantly more expensive than 2D calls (e.g., prefer over ). Assuming the z value remains constant, all you are doing is using the z value to select a particular slice of 2D noise.\n\nThirdly, the straight function call is going to return values that are fairly smooth and rolling overall, not as craggy as real terrain, since it's randomness is limited to a single frequency. To get craggier terrain, a good technique is to sum together multiple calls that progress through the noise space at differing frequencies, usually set a \"fractal\" values.\n\nThus, for example, sum together ...\n\nThe resulting sum will probably often be outside the range -1 to 1, so you will have to normalize the result before the values are useful. I'd like to suggest setting up a series that is guaranteed to remain within [-1, 1], for example, by progressive weighting depending upon how many 'octaves' you use. (But I don't know if this is truly the most efficient way to do this.)\n\nExample with four octaves:\n\nFourthly, when mapping the results, which range from -1 to 1, to the normalization more often used with color values or color maps (0 to 1), Ken Perlin described two algorithms. One was given the name \"smooth\", where the mapped values are operated on by a simple translation algorithm:\n\nThe other was given the name \"turbulent\", where the mapped values are computed as follows:\n\nWith the former, the resulting values will range over the color range, with sparser population at the extremes. With the latter, the resulting values will \"fold\" at one end of the color range or color map. This folding will give the terrain angular ridges at the fold point, as opposed to being smoothly rolling. (This assumes that one is keeping the sum of the octaves within the range -1 to 1, and that if a custom color mapping is being used, the color ranges progress smoothly over the course of the map. Neither of these conditions is \"required\" though, and can be played with for interesting effects.)\n\nI'm working on a SimplexNoise visualizer... [Edit: now up at GitHub: SiVi: A Java-based 2D Gradient Noise Visualizer] ... as a Java project. A first draft of the visualizer can be found ... [Edit: I am deleting a dead link to the old java-gaming.org site. The site has been migrated to jvm.gaming.org. If you go to jvm-gaming, be warned that older references to SiVi tend to have dead links, as well.]\n\nGreat article on how SimplexNoise works (and Perlin vs Gradient background): http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n\nStefan Gustavson did a really nice job of this!"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/23w1ox/looping_perlin_noise_for_terrain_generation",
        "document": "My current project works by generating a section of perlin noise which is used as a reference for terrain generation. I want to create a globe-like effect where going off one end of the map moves you to the opposite side. But to do this effectively the map, and therefor the noise, has to mesh on each side. Sorry if this makes no sense, the cloesest example I could think of is a civilization map. Does anyone know if this is possible? Or would I be better off just cheating and ensuring that the edges of the map are all water or somthing"
    },
    {
        "link": "https://thebookofshaders.com/glossary?search=smoothstep",
        "document": "specifies the value of the lower edge of the Hermite function.\n\nspecifies the value of the upper edge of the Hermite function.\n\nspecifies the source value for interpolation.\n\nperforms smooth Hermite interpolation between and when . This is useful in cases where a threshold function with a smooth transition is desired. is equivalent to:"
    },
    {
        "link": "https://medium.com/@vnflqkq/glsl-smoothstep-6554e62be517",
        "document": "With the above code, we can make the gradient from black to white.\n\nIf the type ‘vec3’ has only one parameter, it assigns the same values with the one. So in line 14, it is same as ‘vec3(y,y,y)’. Oh, the book mentions it too.\n\nThe vec3type constructor “understands” that you want to assign the three color channels with the same value, while vec4understands that you want to construct a four dimensional vector with a three dimensional one plus a fourth value (in this case the value that controls the alpha or opacity).\n\nNow let’s look at a deeper code.\n\nAs you can see, it can be used in many declarations. But, usually the first definition is used. It means:\n\n- case 1. If the x value is less than edge0, it returns 0.\n\n- case 2. If the x value is greater than edge1, it returns 1.\n\n- case 3. If the x value is between edge0 and 1, it returns the value between 0 and 1 (which gentle increase.)\n\nSo, let’s go back to the codes. In line 23, the function ‘plot’ is called, and it gets the arguments st and y(st.x). So the function ‘plot’ returns ‘smoothstep( st.x-0.02, st.x, st.y) — smoothstep( st, st.x+0.02, st.y)’.\n\nLet’s divide a region of pixels with the same x-coordinate. If the y-coordinate of the pixel (normalized between 0 and 1) is less then ‘x-coordinate(also normalized) — 0.02’, it belongs to region 1. If the y-coord is between ‘x-coord — 0.02’ and ‘x-coord’, it belongs to region 2. If the y-coord is between ‘x-coord’ and ‘x-coord + 0.02’, it belongs to region 3. And last, if the y-coord is greater than ‘x-coord + 0.02’, it belongs to region 4.\n\nIf the pixel belongs region 1, the function ‘plot’ returns 0–0, 0. If belongs region 2, returns 0~1–0, 0~1. If belongs region 3, returns 0~1–1, 1~0. And if belongs region 4, returns 1–1, 0.\n\nSo, the return values are 0, 0~1, 1~0, 0. Then in line 24, the color don’t be replaced when pct is 0, or not, it is mixed with green color in level of pct. (It is same as the built-in fuction mix().)\n\nIf I replace the value ‘0.02’ with a variable ‘span’ and change its value, it will looks like:\n\nCheck the result video on my blog : https://blog.naver.com/wngnl3219/221489116827\n\nNext time, let’s look at various shaping functions including smoothstep."
    },
    {
        "link": "https://substack.com/home/post/p-137238089",
        "document": "Despite the 5th chapter of The book of shaders being a great resource to start on the shader programming, it could take too much from a completely beginner.\n\nPatricio starts the technical part with a code snippet that directly uses the smoothstep function. It’s not straightforward what this function does. It gets worse with the following examples due the combination of multiple function calls (in the plot function).\n\nAlso, in the middle of the chapter, he asks the reader to replace the function with , and function without much guidance. It finalizes the post with much simple code.\n\nIn short, and after reviewing the chapter to write this post, it seems to me that its structure has been turned upside down.\n\nAnyway, let’s get down to a most deeper explanation on the smoothstep function, how it’s used and hopefully you will get empowered again to retake the book.\n\nAlways start with the simplest case\n\nUse this simple code to start. You can use the template of the previous post to build your own offline environment and run this shader directly in your browser.\n\nNow it’s easy to visualize what the smoothstep function does and to play with it. Change the values in the line to see how it affects the shader. For example, change to or to .\n\nRegarding colors. If you comment the line you will get a confusing gradient in which more than half of the screen is taken by the white color, or at least it’s what it looks. Don’t get confused. This effect is caused due the interaction between white and black. We will see why this happens in following posts. For the moment, stick to white and yellow to avoid undesired effects in our perception.\n\nNow that we have a more simplistic example in which we can visualize more directly what the smoothstep does, we are ready to deep dive on the math. Do not afraid, it’s more simple than it looks. One of the most though aspects in maths is nomenclature.\n\nInstead of looking to the definition provided by Patricio (the same as OpenGL docs), look to this explanation in stackoverflow that uses python. Don’t look to the math definition (taken from wikipedia) and just study the code.\n\nIt uses the function from scipy and basically it implements literally the math definition. If you are not familiar with combinatorics, check this khan academy unit. You are interested in the 3th section called “Combinations” but it’s okay to check the first two called “Counting principle and factorial” and “Permutations”.\n\nAfter understanding the formula, the second most important thing to notice is that the function takes a parameter called . This parameter defines the “smoothness” of the function. You can visualize in the provided plot.\n\nAs you can see, with higher values of more “smooth” is the curve. This smoothness is achieved by differentiating the function times. That is, computing the derivative times for the provided points ( parameter).\n\nIf you check the OpenGL documentation, it saids that the smoothstep function is implemented using the cubic hermite interpolation. Despite the bombastic name, it simply means that . That corresponds to the green line in the plot. That’s all.\n\nNow the other parameters. The and simply defines the lower and upper limit of the interpolation. In other words, from which value the smoothness starts and to which value it stops. Any value below will equals to 0 and any value greater than will be 1. This can visualized too in the plot. There, because all points to the left in the x axis at value 0 are 0 and because all values to the right in the x axis at value 1 are 1.\n\nThis values are exactly the ones you have changed in the shader code earlier. Repeat the code change now to truly understand how it’s related to the provided math explanation.\n\nFinally, if you invert the values, being you simply inverse the interpolation. Any value below 0 or greater than 1 from and will force the interpolation to start or end outside the boundaries. Play with these three values till you are totally sure how they work.\n\nAs an exercise try to draw this circle exactly as it is by just changing the values of the three parameters provided in the smoothstep function. Force yourself to think about it.\n\nDo it now before continuing because otherwise you will see the solution and you need to start training your problem solving intuition. If you feel lost, search for \"circle function\" and note that the function is available in GLSL.\n\nNow, you must perfectly control the behaviour of the circle. You must be able to draw it with any radius length and on any position, not just in the center of the screen.\n\nLet’s try to focus on what Patricio did to draw that green line in the chapter but instead of using a line we will use our circle.\n\nWe have drawn a circle filled with yellow but, How can we draw just the boundary? in other words, How can we draw a white circle with a yellow border?\n\nIf you notice it, just returns a single float value, and it's with the combination of the different parallel calls to the main function that we succeed at drawing the circle (a deep explanation of this parallel calls can be found on the first post).\n\nWith this in mind, would not be straightforward to just draw another white circle inside our yellow one but just a little bit smaller to achieve the desired border?\n\nThat's exactly what are we going to do, but because we need to return pixel values and the yellow is already we cannot add the circle but instead subtract it. Another smoothstep will do the work.\n\nWhat is happening here? We were expecting a white circle with yellow border on a white background, not a yellow circle with black border on a yellow background.\n\nThe answer is straightforward. You can visualize it if you remove the first smoothstep call.\n\nBecause smoothstep applies to all the image (not just the inner circle) when subtracting both smoothsteps, it gets values equal to 0 to all RGB components in the black border and for the yellow areas. Just adding solves the issue. (Be sure to understand this paragraph)\n\nCongrats!! If you have understand this part you are probably ready to review the 5th chapter of The book of shaders again and play with the green line and subdue the code. It takes a little bit of effort, but you are also ready to change the function with , and in the code snippets too.\n\nAs a final exercise try to replicate the following effect by using the variable. If you feel lost, you must use the and functions.\n\nThis is one of a set of blogs explaining my journey learning shaders. In the next post I'll be explaining color theory and how it affects our shaders. You will understand why using black and white in these examples has not have the same results as using yellow and white.\n\nIf you want to learn shaders too, please, start reading The book of shaders resource first. It's possibly the best resource from an entrypoint perspective. If you feel overwhelmed come back and I'll be filling the gaps with deep explanations and some exercises that are more narrowed and require less of you."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-smoothstep",
        "document": "Returns a smooth Hermite interpolation between 0 and 1, if x is in the range [min, max].\n\nReturns 0 if x is less than min; 1 if x is greater than max; otherwise, a value between 0 and 1 if x is in the range [min, max].\n\nUse the smoothstep HLSL intrinsic function to create a smooth transition between two values. For example, you can use this function to blend two colors smoothly.\n\nThis function is supported in the following shader models."
    },
    {
        "link": "https://reddit.com/r/computergraphics/comments/9q2r7c/how_to_produce_a_smooth_interpolation_algorithm",
        "document": "I guess we all know and use the smoothstep glsl function but what is the theory behind it and how can you understand it enough to be able to make your own smooth interpolation algorithms?"
    }
]