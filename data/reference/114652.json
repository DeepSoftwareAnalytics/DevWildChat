[
    {
        "link": "https://docs.python.org/3/library/tk.html",
        "document": "Tk/Tcl has long been an integral part of Python. It provides a robust and platform independent windowing toolkit, that is available to Python programmers using the package, and its extension, the module.\n\nThe package is a thin object-oriented layer on top of Tcl/Tk. To use , you don’t need to write Tcl code, but you will need to consult the Tk documentation, and occasionally the Tcl documentation. is a set of wrappers that implement the Tk widgets as Python classes.\n\n’s chief virtues are that it is fast, and that it usually comes bundled with Python. Although its standard documentation is weak, good material is available, which includes: references, tutorials, a book and others. is also famous for having an outdated look and feel, which has been vastly improved in Tk 8.5. Nevertheless, there are many other GUI libraries that you could be interested in. The Python wiki lists several alternative GUI frameworks and tools."
    },
    {
        "link": "https://docs.python.org/3/library/tkinter.html",
        "document": "The package (“Tk interface”) is the standard Python interface to the Tcl/Tk GUI toolkit. Both Tk and are available on most Unix platforms, including macOS, as well as on Windows systems.\n\nRunning from the command line should open a window demonstrating a simple Tk interface, letting you know that is properly installed on your system, and also showing what version of Tcl/Tk is installed, so you can read the Tcl/Tk documentation specific to that version.\n\nTkinter supports a range of Tcl/Tk versions, built either with or without thread support. The official Python binary release bundles Tcl/Tk 8.6 threaded. See the source code for the module for more information about supported versions.\n\nTkinter is not a thin wrapper, but adds a fair amount of its own logic to make the experience more pythonic. This documentation will concentrate on these additions and changes, and refer to the official Tcl/Tk documentation for details that are unchanged.\n\nTcl/Tk is not a single library but rather consists of a few distinct modules, each with separate functionality and its own official documentation. Python’s binary releases also ship an add-on module together with it. Tcl is a dynamic interpreted programming language, just like Python. Though it can be used on its own as a general-purpose programming language, it is most commonly embedded into C applications as a scripting engine or an interface to the Tk toolkit. The Tcl library has a C interface to create and manage one or more instances of a Tcl interpreter, run Tcl commands and scripts in those instances, and add custom commands implemented in either Tcl or C. Each interpreter has an event queue, and there are facilities to send events to it and process them. Unlike Python, Tcl’s execution model is designed around cooperative multitasking, and Tkinter bridges this difference (see Threading model for details). Tk is a Tcl package implemented in C that adds custom commands to create and manipulate GUI widgets. Each object embeds its own Tcl interpreter instance with Tk loaded into it. Tk’s widgets are very customizable, though at the cost of a dated appearance. Tk uses Tcl’s event queue to generate and process GUI events. Themed Tk (Ttk) is a newer family of Tk widgets that provide a much better appearance on different platforms than many of the classic Tk widgets. Ttk is distributed as part of Tk, starting with Tk version 8.5. Python bindings are provided in a separate module, . Internally, Tk and Ttk use facilities of the underlying operating system, i.e., Xlib on Unix/X11, Cocoa on macOS, GDI on Windows. When your Python application uses a class in Tkinter, e.g., to create a widget, the module first assembles a Tcl/Tk command string. It passes that Tcl command string to an internal binary module, which then calls the Tcl interpreter to evaluate it. The Tcl interpreter will then call into the Tk and/or Ttk packages, which will in turn make calls to Xlib, Cocoa, or GDI.\n\nSupport for Tkinter is spread across several modules. Most applications will need the main module, as well as the module, which provides the modern themed widget set and API: Construct a toplevel Tk widget, which is usually the main window of an application, and initialize a Tcl interpreter for this widget. Each instance has its own associated Tcl interpreter. The class is typically instantiated using all default values. However, the following keyword arguments are currently recognized: When given (as a string), sets the environment variable. (X11 only) Name of the profile file. By default, baseName is derived from the program name ( ). Name of the widget class. Used as a profile file and also as the name with which Tcl is invoked (argv0 in interp). If , initialize the Tk subsystem. The function sets this to . If , execute all X server commands synchronously, so that errors are reported immediately. Can be used for debugging. (X11 only) Specifies the id of the window in which to embed the application, instead of it being created as an independent toplevel window. id must be specified in the same way as the value for the -use option for toplevel widgets (that is, it has a form like that returned by ). Note that on some platforms this will only work correctly if id refers to a Tk frame or toplevel that has its -container option enabled. reads and interprets profile files, named and , into the Tcl interpreter and calls on the contents of and . The path for the profile files is the environment variable or, if that isn’t defined, then . The Tk application object created by instantiating . This provides access to the Tcl interpreter. Each widget that is attached the same instance of has the same value for its attribute. The widget object that contains this widget. For , the master is because it is the main window. The terms master and parent are similar and sometimes used interchangeably as argument names; however, calling returns a string of the widget name whereas returns the object. parent/child reflects the tree-like relationship while master/slave reflects the container structure. The immediate descendants of this widget as a with the child widget names as the keys and the child instance objects as the values. The function is a factory function which creates an object much like that created by the class, except that it does not initialize the Tk subsystem. This is most often useful when driving the Tcl interpreter in an environment where one doesn’t want to create extraneous toplevel windows, or where one cannot (such as Unix/Linux systems without an X server). An object created by the object can have a Toplevel window created (and the Tk subsystem initialized) by calling its method. Dialog to let the user choose a color. Base class for the dialogs defined in the other modules listed here. Common dialogs to allow the user to specify a file to open or save. Utilities to help work with fonts. Themed widget set introduced in Tk 8.5, providing modern alternatives for many of the classic widgets in the main module. A binary module that contains the low-level interface to Tcl/Tk. It is automatically imported by the main module, and should never be used directly by application programmers. It is usually a shared library (or DLL), but might in some cases be statically linked with the Python interpreter. Symbolic constants that can be used in place of strings when passing various parameters to Tkinter calls. Automatically imported by the main module. (experimental) Drag-and-drop support for . This will become deprecated when it is replaced with the Tk DND.\n\nThis section is not designed to be an exhaustive tutorial on either Tk or Tkinter. For that, refer to one of the external resources noted earlier. Instead, this section provides a very quick orientation to what a Tkinter application looks like, identifies foundational Tk concepts, and explains how the Tkinter wrapper is structured. The remainder of this section will help you to identify the classes, methods, and options you’ll need in your Tkinter application, and where to find more detailed documentation on them, including in the official Tcl/Tk reference manual. We’ll start by walking through a “Hello World” application in Tkinter. This isn’t the smallest one we could write, but has enough to illustrate some key concepts you’ll need to know. After the imports, the next line creates an instance of the class, which initializes Tk and creates its associated Tcl interpreter. It also creates a toplevel window, known as the root window, which serves as the main window of the application. The following line creates a frame widget, which in this case will contain a label and a button we’ll create next. The frame is fit inside the root window. The next line creates a label widget holding a static text string. The method is used to specify the relative layout (position) of the label within its containing frame widget, similar to how tables in HTML work. A button widget is then created, and placed to the right of the label. When pressed, it will call the method of the root window. Finally, the method puts everything on the display, and responds to user input until the program terminates. Even this simple program illustrates the following key Tk concepts: A Tkinter user interface is made up of individual widgets. Each widget is represented as a Python object, instantiated from classes like , , and . Widgets are arranged in a hierarchy. The label and button were contained within a frame, which in turn was contained within the root window. When creating each child widget, its parent widget is passed as the first argument to the widget constructor. Widgets have configuration options, which modify their appearance and behavior, such as the text to display in a label or button. Different classes of widgets will have different sets of options. Widgets aren’t automatically added to the user interface when they are created. A geometry manager like controls where in the user interface they are placed. Tkinter reacts to user input, changes from your program, and even refreshes the display only when actively running an event loop. If your program isn’t running the event loop, your user interface won’t update. When your application uses Tkinter’s classes and methods, internally Tkinter is assembling strings representing Tcl/Tk commands, and executing those commands in the Tcl interpreter attached to your application’s instance. Whether it’s trying to navigate reference documentation, trying to find the right method or option, adapting some existing code, or debugging your Tkinter application, there are times that it will be useful to understand what those underlying Tcl/Tk commands look like. To illustrate, here is the Tcl/Tk equivalent of the main part of the Tkinter script above. Tcl’s syntax is similar to many shell languages, where the first word is the command to be executed, with arguments to that command following it, separated by spaces. Without getting into too many details, notice the following:\n• None The commands used to create widgets (like ) correspond to widget classes in Tkinter.\n• None Tcl widget options (like ) correspond to keyword arguments in Tkinter.\n• None Widgets are referred to by a pathname in Tcl (like ), whereas Tkinter doesn’t use names but object references.\n• None A widget’s place in the widget hierarchy is encoded in its (hierarchical) pathname, which uses a (dot) as a path separator. The pathname for the root window is just (dot). In Tkinter, the hierarchy is defined not by pathname but by specifying the parent widget when creating each child widget.\n• None Operations which are implemented as separate commands in Tcl (like or ) are represented as methods on Tkinter widget objects. As you’ll see shortly, at other times Tcl uses what appear to be method calls on widget objects, which more closely mirror what would is used in Tkinter. How do I…? What option does…?¶ If you’re not sure how to do something in Tkinter, and you can’t immediately find it in the tutorial or reference documentation you’re using, there are a few strategies that can be helpful. First, remember that the details of how individual widgets work may vary across different versions of both Tkinter and Tcl/Tk. If you’re searching documentation, make sure it corresponds to the Python and Tcl/Tk versions installed on your system. When searching for how to use an API, it helps to know the exact name of the class, option, or method that you’re using. Introspection, either in an interactive Python shell or with , can help you identify what you need. To find out what configuration options are available on any widget, call its method, which returns a dictionary containing a variety of information about each object, including its default and current values. Use to get just the names of each option. As most widgets have many configuration options in common, it can be useful to find out which are specific to a particular widget class. Comparing the list of options to that of a simpler widget, like a frame, is one way to do that. Similarly, you can find the available methods for a widget object using the standard function. If you try it, you’ll see there are over 200 common widget methods, so again identifying those specific to a widget class is helpful. As noted, the official Tk commands reference manual (man pages) is often the most accurate description of what specific operations on widgets do. Even when you know the name of the option or method that you need, you may still have a few places to look. While all operations in Tkinter are implemented as method calls on widget objects, you’ve seen that many Tcl/Tk operations appear as commands that take a widget pathname as its first parameter, followed by optional parameters, e.g. Others, however, look more like methods called on a widget object (in fact, when you create a widget in Tcl/Tk, it creates a Tcl command with the name of the widget pathname, with the first parameter to that command being the name of a method to call). In the official Tcl/Tk reference documentation, you’ll find most operations that look like method calls on the man page for a specific widget (e.g., you’ll find the method on the ttk::button man page), while functions that take a widget as a parameter often have their own man page (e.g., grid). You’ll find many common options and methods in the options or ttk::widget man pages, while others are found in the man page for a specific widget class. You’ll also find that many Tkinter methods have compound names, e.g., , , . You’d find documentation for all of these in the winfo man page. Somewhat confusingly, there are also methods on all Tkinter widgets that don’t actually operate on the widget, but operate at a global scope, independent of any widget. Examples are methods for accessing the clipboard or the system bell. (They happen to be implemented as methods in the base class that all Tkinter widgets inherit from).\n\nPython and Tcl/Tk have very different threading models, which tries to bridge. If you use threads, you may need to be aware of this. A Python interpreter may have many threads associated with it. In Tcl, multiple threads can be created, but each thread has a separate Tcl interpreter instance associated with it. Threads can also create more than one interpreter instance, though each interpreter instance can be used only by the one thread that created it. Each object created by contains a Tcl interpreter. It also keeps track of which thread created that interpreter. Calls to can be made from any Python thread. Internally, if a call comes from a thread other than the one that created the object, an event is posted to the interpreter’s event queue, and when executed, the result is returned to the calling Python thread. Tcl/Tk applications are normally event-driven, meaning that after initialization, the interpreter runs an event loop (i.e. ) and responds to events. Because it is single-threaded, event handlers must respond quickly, otherwise they will block other events from being processed. To avoid this, any long-running computations should not run in an event handler, but are either broken into smaller pieces using timers, or run in another thread. This is different from many GUI toolkits where the GUI runs in a completely separate thread from all application code including event handlers. If the Tcl interpreter is not running the event loop and processing events, any calls made from threads other than the one running the Tcl interpreter will fail.\n• None Tcl/Tk libraries can be built so they are not thread-aware. In this case, calls the library from the originating Python thread, even if this is different than the thread that created the Tcl interpreter. A global lock ensures only one call occurs at a time.\n• None While allows you to create more than one instance of a object (with its own interpreter), all interpreters that are part of the same thread share a common event queue, which gets ugly fast. In practice, don’t create more than one instance of at a time. Otherwise, it’s best to create them in separate threads and ensure you’re running a thread-aware Tcl/Tk build.\n• None Blocking event handlers are not the only way to prevent the Tcl interpreter from reentering the event loop. It is even possible to run multiple nested event loops or abandon the event loop entirely. If you’re doing anything tricky when it comes to events or threads, be aware of these possibilities.\n• None There are a few select functions that presently work only when called from the thread that created the Tcl interpreter.\n\nOptions control things like the color and border width of a widget. Options can be set in three ways: After object creation, treating the option name like a dictionary index Use the config() method to update multiple attrs subsequent to object creation For a complete explanation of a given option and its behavior, see the Tk man pages for the widget in question. Note that the man pages list “STANDARD OPTIONS” and “WIDGET SPECIFIC OPTIONS” for each widget. The former is a list of options that are common to many widgets, the latter are the options that are idiosyncratic to that particular widget. The Standard Options are documented on the options(3) man page. No distinction between standard and widget-specific options is made in this document. Some options don’t apply to some kinds of widgets. Whether a given widget responds to a particular option depends on the class of the widget; buttons have a option, labels do not. The options supported by a given widget are listed in that widget’s man page, or can be queried at runtime by calling the method without arguments, or by calling the method on that widget. The return value of these calls is a dictionary whose key is the name of the option as a string (for example, ) and whose values are 5-tuples. Some options, like are synonyms for common options with long names ( is shorthand for “background”). Passing the method the name of a shorthand option will return a 2-tuple, not 5-tuple. The 2-tuple passed back will contain the name of the synonym and the “real” option (such as ). Of course, the dictionary printed will include all the options available and their values. This is meant only as an example. The packer is one of Tk’s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual master. In contrast to the more cumbersome placer (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - above, to the left of, filling, etc - and works everything out to determine the exact placement coordinates for you. The size of any master widget is determined by the size of the “slave widgets” inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed. Note that widgets do not appear until they have had their geometry specified with a geometry manager. It’s a common early mistake to leave out the geometry specification, and then be surprised when the widget is created but nothing appears. A widget will appear only after it has had, for example, the packer’s method applied to it. The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples: For more extensive information on the packer and the options that it can take, see the man pages and page 183 of John Ousterhout’s book. Anchor type. Denotes where the packer is to place each slave in its parcel. A distance - designating internal padding on each side of the slave widget. A distance - designating external padding on each side of the slave widget. The current-value setting of some widgets (like text entry widgets) can be connected directly to application variables by using special options. These options are , , , , and . This connection works both ways: if the variable changes for any reason, the widget it’s connected to will be updated to reflect the new value. Unfortunately, in the current implementation of it is not possible to hand over an arbitrary Python variable to a widget through a or option. The only kinds of variables for which this works are variables that are subclassed from a class called Variable, defined in . There are many useful subclasses of Variable already defined: , , , and . To read the current value of such a variable, call the method on it, and to change its value you call the method. If you follow this protocol, the widget will always track the value of the variable, with no further intervention on your part. # Tell the entry widget to watch this variable. # Define a callback for when the user hits return. # It prints the current value of the variable. \"Hi. The current entry content is:\" In Tk, there is a utility command, , for interacting with the window manager. Options to the command allow you to control things like titles, placement, icon bitmaps, and the like. In , these commands have been implemented as methods on the class. Toplevel widgets are subclassed from the class, and so can call the methods directly. To get at the toplevel window that contains a given widget, you can often just refer to the widget’s master. Of course if the widget has been packed inside of a frame, the master won’t represent a toplevel window. To get at the toplevel window that contains an arbitrary widget, you can call the method. This method begins with an underscore to denote the fact that this function is part of the implementation, and not an interface to Tk functionality. Here are some examples of typical usage: # here are method calls to the window manager class Legal values are points of the compass: , , , , , , , , and also . There are eight built-in, named bitmaps: , , , , , , , . To specify an X bitmap filename, give the full path to the file, preceded with an , as in . You can pass integers 0 or 1 or the strings or . This is any Python function that takes no arguments. For example: Colors can be given as the names of X colors in the rgb.txt file, or as strings representing RGB values in 4 bit: , 8 bit: , 12 bit: , or 16 bit: ranges, where R,G,B here represent any legal hex digit. See page 160 of Ousterhout’s book for details. The standard X cursor names from can be used, without the prefix. For example to get a hand cursor ( ), use the string . You can also specify a bitmap and mask file of your own. See page 179 of Ousterhout’s book. Screen distances can be specified in either pixels or absolute distances. Pixels are given as numbers and absolute distances as strings, with the trailing character denoting units: for centimetres, for inches, for millimetres, for printer’s points. For example, 3.5 inches is expressed as . Tk uses a list font name format, such as . Font sizes with positive numbers are measured in points; sizes with negative numbers are measured in pixels. This is a string of the form , where width and height are measured in pixels for most widgets (in characters for widgets displaying text). For example: . Legal values are the strings: , , , and . This is a string with four space-delimited elements, each of which is a legal distance (see above). For example: and and are all legal regions. Determines what the border style of a widget will be. Legal values are: , , , , and . This is almost always the method of some scrollbar widget, but can be any widget method that takes a single argument. Must be one of: , , or . The bind method from the widget command allows you to watch for certain events and to have a callback function trigger when that event type occurs. The form of the bind method is: is a string that denotes the target kind of event. (See the bind(3tk) man page, and page 201 of John Ousterhout’s book, , for details). is a Python function, taking one argument, to be invoked when the event occurs. An Event instance will be passed as the argument. (Functions deployed this way are commonly known as callbacks.) is optional, either or . Passing an empty string denotes that this binding is to replace any other bindings that this event is associated with. Passing a means that this function is to be added to the list of functions bound to this event type. Notice how the widget field of the event is being accessed in the callback. This field contains the widget that caught the X event. The following table lists the other event fields you can access, and how they are denoted in Tk, which can be useful when referring to the Tk man pages. A number of widgets require “index” parameters to be passed. These are used to point at a specific place in a Text widget, or to particular characters in an Entry widget, or to particular menu items in a Menu widget. Entry widgets have options that refer to character positions in the text being displayed. You can use these functions to access these special points in text widgets: The index notation for Text widgets is very rich and is best described in the Tk man pages. Some options and methods for menus manipulate specific menu entries. Anytime a menu index is needed for an option or a parameter, you may pass in:\n• None an integer which refers to the numeric position of the entry in the widget, counted from the top, starting with 0;\n• None the string , which refers to the menu position that is currently under the cursor;\n• None the string which refers to the last menu item;\n• None An integer preceded by , as in , where the integer is interpreted as a y pixel coordinate in the menu’s coordinate system;\n• None the string , which indicates no menu entry at all, most often used with menu.activate() to deactivate all entries, and finally,\n• None a text string that is pattern matched against the label of the menu entry, as scanned from the top of the menu to the bottom. Note that this index type is considered after all the others, which means that matches for menu items labelled , , or may be interpreted as the above literals, instead. Images of different formats can be created through the corresponding subclass of :\n• None for images in PGM, PPM, GIF and PNG formats. The latter is supported starting with Tk 8.6. Either type of image is created through either the or the option (other options are available as well). Changed in version 3.13: Added the method to copy a region from one image to other image, possibly with pixel zooming and/or subsampling. Add from_coords parameter to methods , and . Add zoom and subsample parameters to method . The image object can then be used wherever an option is supported by some widget (e.g. labels, buttons, menus). In these cases, Tk will not keep a reference to the image. When the last Python reference to the image object is deleted, the image data is deleted as well, and Tk will display an empty box wherever the image was used. The Pillow package adds support for formats such as BMP, JPEG, TIFF, and WebP, among others."
    },
    {
        "link": "https://geeksforgeeks.org/python-gui-tkinter",
        "document": "Python Tkinter is a standard GUI (Graphical User Interface) library for Python which provides a fast and easy way to create desktop applications. Tkinter provides a variety of widgets like buttons, labels, text boxes, menus and more that can be used to create interactive user interfaces. Tkinter supports event-driven programming, where actions are taken in response to user events like clicks or keypresses.\n• Import the tkinter module : Import the tkinter module, which is necessary for creating the GUI components.\n• Create the main window (container) : Initialize the main application window using the Tk() class.\n• Set Window Properties : We can set properties like the title and size of the window.\n• Add widgets to the main window : We can add any number of widgets like buttons, labels, entry fields, etc., to the main window to design the interface.\n• Pack Widgets: Use geometry managers like pack(), grid() or place() to arrange the widgets within the window.\n• Apply event triggers to the widgets : We can attach event triggers to the widgets to define how they respond to user interactions.\n\nThere are two main methods used which the user needs to remember while creating the Python application with GUI.\n\nTo create a main window in Tkinter, we use the Tk() class. The syntax for creating a main window is as follows:\n• screenName: This parameter is used to specify the display name.\n• baseName: This parameter can be used to set the base name of the application.\n• className: We can change the name of the window by setting this parameter to the desired name.\n• useTk: This parameter indicates whether to use Tk or not.\n\nThe mainloop() method is used to run application once it is ready. It is an infinite loop that keeps the application running, waits for events to occur (such as button clicks) and processes these events as long as the window is not closed.\n\nThere are a number of tkinter widgets which we can put in our tkinter application. Some of the major widgets are explained below:\n\nIt refers to the display box where we display text or image. It can have various options like font, background, foreground, etc. The general syntax is:\n• master is the parameter used to represent the parent window.\n\nNote: We have a number of options and parameters that we can pass to widgets, only some them are used in the examples given in this article.\n\nA clickable button that can trigger an action. The general syntax is:\n\nIt is used to input the single line text entry from the user. For multi-line text input, Text widget is used. The general syntax is:\n\nA checkbox can be toggled on or off. It can be linked to a variable to store its state. The general syntax is:\n\nIt allows the user to select one option from a set of choices. They are grouped by sharing the same variable. The general syntax is:\n\nIt displays a list of items from which a user can select one or more. The general syntax is:\n\nIt refers to the slide controller which will be used to implement listed widgets. The general syntax is:\n\nIt is used to create all kinds of menus used by the application. The general syntax is:\n\nCombobox widget is created using the ttk.Combobox class from the tkinter.ttk module. The values for the Combobox are specified using the values parameter. The default value is set using the set method. An event handler function on_select is bound to the Combobox using the bind method, which updates a label with the selected item whenever an item is selected.\n\nIt is used to provide a graphical slider that allows to select any value from that scale. The general syntax is:\n\nThis widget is directly controlled by the window manager. It don’t need any parent window to work on.The general syntax is:\n\nIt is a widget to display text messages with word wrapping. The general syntax is:\n\nIt is a part of top-down menu which stays on the window all the time. Every menubutton has its own functionality. The general syntax is:\n\nprogressbar indicates the progress of a long-running task. When the button is clicked, the progressbar fills up to 100% over a short period, simulating a task that takes time to complete.\n\nIt is an entry of ‘Entry’ widget. Here, value can be input by selecting a fixed value of numbers. The general syntax is:\n\nTo edit a multi-line text and format the way it has to be displayed. The general syntax is:\n\nIt is used to draw pictures and other complex layout like graphics, text and widgets. The general syntax is:\n\nIt is a container widget which is used to handle number of panes arranged in it. The general syntax is:\n\nThis example demonstrates the usage of various color options in Tkinter widgets, including active background and foreground colors, background and foreground colors, disabled state colors, and selection colors. Each widget in the example showcases a different color option, providing a visual representation of how these options affect the appearance of the widgets.\n\nTkinter also offers access to the geometric configuration of the widgets which can organize the widgets in the parent windows. There are mainly three geometry manager classes class.\n\nIt organizes the widgets in blocks before placing in the parent widget. Widgets can be packed from the top, bottom, left or right. It can expand widgets to fill the available space or place them in a fixed size.\n\nIt organizes the widgets in grid (table-like structure) before placing in the parent widget. Each widget is assigned a row and column. Widgets can span multiple rows or columns using rowspan and columnspan.\n\nIt organizes the widgets by placing them on specific positions directed by the programmer. Widgets are placed at specific x and y coordinates. Sizes and positions can be specified in absolute or relative terms.\n\nIn Tkinter, events are actions that occur when a user interacts with the GUI, such as pressing a key, clicking a mouse button or resizing a window. Event handling allows us to define how our application should respond to these interactions.\n\nEvents in Tkinter are captured and managed using a mechanism called bindings. A binding links an event to a callback function (also known as an event handler) that is called when the event occurs.\n• widget: The Tkinter widget you want to bind the event to.\n• event: A string that specifies the type of event (e.g., <Button-1> for a left mouse click).\n• handler: The callback function that will be executed when the event occurs.\n\nKey events are triggered when a user presses a key on the keyboard. Mouse events are triggered by mouse actions, such as clicking or moving the mouse.\n\nIn this advanced example, multiple event types are handled simultaneously. The on_mouse_motion function is called whenever the mouse is moved within the window, demonstrating how we can track and respond to continuous events.\n\nThe event object is passed to the callback function when an event occurs. It contains useful information about the event, such as:\n• event.x and event.y: The x and y coordinates of the mouse event.\n• event.widget: The widget that triggered the event.\n\nWhat is Tkinter in Python used for?\n\nWhat does TK() mean in Python?\n\nIs Tkinter the only GUI for Python?\n\nWhat is a Tkinter window in Python?\n\nWhich GUI is best for Python?"
    },
    {
        "link": "https://reddit.com/r/Tkinter/comments/hzl6b0/best_documentation",
        "document": "I am new to tkinter, and struggling to find good documentation for methods and constructor parameters. And recommendations?"
    },
    {
        "link": "https://realpython.com/python-gui-tkinter",
        "document": "Tkinter is Python’s standard GUI framework, making it convenient for developing graphical user interfaces. As a cross-platform library, Tkinter ensures your applications appear native across Windows, macOS, and Linux. Despite criticisms of its outdated appearance, Tkinter remains a practical choice for quickly creating functional and cross-platform GUI applications.\n\nBy the end of this tutorial, you’ll understand that:\n• GUI refers to graphical user interfaces, and Tkinter is Python’s built-in library for creating them.\n• Tkinter is included with most Python installations, so separate installation is often unnecessary.\n• Tkinter is still a relevant choice for building simple, cross-platform GUI applications.\n• Widgets in a Tkinter application can be arranged using geometry managers like , , and .\n• Interactive GUI applications with Tkinter are created by binding events, such as button clicks, to Python functions.\n\nYou’ll cover getting started with Tkinter, managing widgets, and creating interactive applications. Once you’ve mastered these skills by working through the exercises at the end of each section, you’ll tie everything together by building two applications. The first is a temperature converter, and the second is a text editor. It’s time to dive right in and learn how to build an application with Tkinter!\n\nBuilding Your First Python GUI Application With Tkinter The foundational element of a Tkinter GUI is the window. Windows are the containers in which all other GUI elements live. These other GUI elements, such as text boxes, labels, and buttons, are known as widgets. Widgets are contained inside of windows. First, create a window that contains a single widget. Start up a new Python shell session and follow along! Note: The code examples in this tutorial have all been tested on Windows, macOS, and Ubuntu Linux 20.04 with Python version 3.10. If you’ve installed Python with the official installers available for Windows and macOS from python.org, then you should have no problem running the sample code. You can safely skip the rest of this note and continue with the tutorial! If you haven’t installed Python with the official installers, or there’s no official distribution for your system, then here are some tips for getting up and going. The Python distribution for macOS available on Homebrew doesn’t come bundled with the Tcl/Tk dependency required by Tkinter. The default system version is used instead. This version may be outdated and prevent you from importing the Tkinter module. To avoid this problem, use the official macOS installer. To conserve memory space, the default version of the Python interpreter that comes pre-installed on Ubuntu Linux 20.04 has no support for Tkinter. However, if you want to continue using the Python interpreter bundled with your operating system, then install the following package: If you’re unable to get a working Python installation on your flavor of Linux, then you can build Python with the correct version of Tcl/Tk from the source code. For a step-by-step walk-through of this process, check out the Python 3 Installation & Setup Guide. You may also try using pyenv to manage multiple Python versions. With your Python shell open, the first thing you need to do is import the Python GUI Tkinter module: A window is an instance of Tkinter’s class. Go ahead and create a new window and assign it to the variable : When you execute the above code, a new window pops up on your screen. How it looks depends on your operating system: Throughout the rest of this tutorial, you’ll see Windows screenshots. Now that you have a window, you can add a widget. Use the class to add some text to a window. Create a widget with the text and assign it to a variable called : The window you created earlier doesn’t change. You just created a widget, but you haven’t added it to the window yet. There are several ways to add widgets to a window. Right now, you can use the widget’s method: The window now looks like this: When you pack a widget into a window, Tkinter sizes the window as small as it can be while still fully encompassing the widget. Now execute the following: Nothing seems to happen, but notice that no new prompt appears in the shell. tells Python to run the Tkinter event loop. This method listens for events, such as button clicks or keypresses, and blocks any code that comes after it from running until you close the window where you called the method. Go ahead and close the window you’ve created, and you’ll see a new prompt displayed in the shell. Warning: When you work with Tkinter from a Python REPL, updates to windows are applied as each line is executed. This is not the case when a Tkinter program is executed from a Python file! If you don’t include at the end of a program in a Python file, then the Tkinter application will never run, and nothing will be displayed. Alternatively, you can build your user interface incrementally in Python REPL by calling after each step to reflect the change. Creating a window with Tkinter only takes a couple of lines of code. But blank windows aren’t very useful! In the next section, you’ll learn about some of the widgets available in Tkinter, and how you can customize them to meet your application’s needs. Expand the code blocks below to check your understanding: Write a full Python script that creates a Tkinter window with the text . The window should look like this: You can expand the code block below to see a solution: Keep in mind your code may look different. When you’re ready, you can move on to the next section.\n\nWidgets are the bread and butter of the Python GUI framework Tkinter. They’re the elements through which users interact with your program. Each widget in Tkinter is defined by a class. Here are some of the widgets available: A widget used to display text on the screen A button that can contain text and can perform an action when clicked A text entry widget that allows only a single line of text A rectangular region used to group related widgets or provide padding between widgets You’ll see how to work with each of these in the following sections, but keep in mind that Tkinter has many more widgets than those listed here. The widget’s choice gets even more complicated when you account for a whole new set of themed widgets. In the remaining part of this tutorial, you’re only going to use Tkinter’s classic widgets, though. If you’d like to learn more about the two widget types, then you can expand the collapsible section below: It’s worth noting that there are currently two broad categories of widgets in Tkinter:\n• Classic widgets: Available in the package, for example\n• Themed widgets: Available in the submodule, for example Tkinter’s classic widgets are highly customizable and straightforward, but they tend to appear dated or somewhat foreign on most platforms today. If you’d like to take advantage of widgets with a native look and feel familiar to users of a given operating system, then you might want to check out the themed widgets. Most of the themed widgets are near drop-in replacements for their legacy counterparts, but with a more modern look. You can also use a few brand-new widgets, such as the progress bar, which weren’t available in Tkinter before. At the same time, you’ll need to continue using some of the classic widgets that don’t have a themed alternative. Note: Themed widgets in the module use the operating system’s native look and feel by default. However, you can change their theme for a customized visual appearance, such as light and dark modes. A theme is a collection of reusable style definitions, which you can think of as a Cascading Style Sheet (CSS) for Tkinter. Making the new widgets themable meant extracting most of their style information into separate objects. On the one hand, such a separation of concerns is a desired property in the library’s design, but on the other hand, it introduces an additional abstraction layer, which makes themed widgets more difficult to style than the classic ones. When working with regular and themed widgets in Tkinter, it’s customary to declare the following aliases for the Tkinter packages and modules: Aliases like this let you explicitly refer to either or , for example, in one program depending on your needs: However, you may sometimes find it more convenient to use a wildcard import ( ) to automatically override all legacy widgets with the themed ones where possible, like so: Now, you don’t have to prefix the widget’s class name with its corresponding Python module. You’ll always create a themed widget as long as it’s available, or you’ll fall back to the classic widget otherwise. The two import statements above must be placed in the specified order to have an effect. Because of that, wildcard imports are considered a bad practice, which should generally be avoided unless used consciously. For a full list of Tkinter widgets, check out Basic Widgets and More Widgets in the TkDocs tutorial. Even though it describes themed widgets introduced in Tcl/Tk 8.5, most of the information there should also apply to the classic widgets. Fun Fact: Tkinter literally stands for “Tk interface” because it’s a Python binding or a programming interface to the Tk library in the Tcl scripting language. For now, take a closer look at the widget. widgets are used to display text or images. The text displayed by a widget can’t be edited by the user. It’s for display purposes only. As you saw in the example at the beginning of this tutorial, you can create a widget by instantiating the class and passing a string to the parameter: widgets display text with the default system text color and the default system text background color. These are typically black and white, respectively, but you may see different colors if you’ve changed these settings in your operating system. You can control text and background colors using the and parameters: Many of the HTML color names work with Tkinter. For a full reference, including macOS- and Windows-specific system colors that the current system theme controls, check out the colors manual page. You can also specify a color using hexadecimal RGB values: This sets the label background to a nice, light blue color. Hexadecimal RGB values are more cryptic than named colors, but they’re also more flexible. Fortunately, there are tools available that make getting hexadecimal color codes relatively painless. If you don’t feel like typing out and all the time, then you can use the shorthand and parameters to set the foreground and background colors: You can also control the width and height of a label with the and parameters: Here’s what this label looks like in a window: It may seem strange that the label in the window isn’t square even though the width and height are both set to . This is because the width and height are measured in text units. One horizontal text unit is determined by the width of the character , or the number zero, in the default system font. Similarly, one vertical text unit is determined by the height of the character . Note: For width and height measurements, Tkinter uses text units, instead of something like inches, centimeters, or pixels, to ensure consistent behavior of the application across platforms. Measuring units by the width of a character means that the size of a widget is relative to the default font on a user’s machine. This ensures the text fits properly in labels and buttons, no matter where the application is running. Labels are great for displaying some text, but they don’t help you get input from a user. The next three widgets that you’ll learn about are all used to get user input. widgets are used to display clickable buttons. You can configure them to call a function whenever they’re clicked. You’ll cover how to call functions from button clicks in the next section. For now, take a look at how to create and style a button. There are many similarities between and widgets. In many ways, a button is just a label that you can click! The same keyword arguments that you use to create and style a will work with widgets. For example, the following code creates a button with a blue background and yellow text. It also sets the width and height to and text units, respectively: Here’s what the button looks like in a window: Pretty nifty! You can use the next two widgets to collect text input from a user. When you need to get a little bit of text from a user, like a name or an email address, use an widget. It’ll display a small text box that the user can type some text into. Creating and styling an widget works pretty much exactly like with and widgets. For example, the following code creates a widget with a blue background, some yellow text, and a width of text units: The interesting bit about widgets isn’t how to style them, though. It’s how to use them to get input from a user. There are three main operations that you can perform with widgets: The best way to get an understanding of widgets is to create one and interact with it. Open up a Python shell and follow along with the examples in this section. First, import and create a new window: Now create a and an widget: The describes what sort of text should go in the widget. It doesn’t enforce any sort of requirements on the , but it tells the user what your program expects them to put there. You need to the widgets into the window so that they’re visible: Here’s what that looks like: Notice that Tkinter automatically centers the label above the widget in the window. This is a feature of , which you’ll learn more about in later sections. Click inside the widget with your mouse and type : Now you’ve got some text entered into the widget, but that text hasn’t been sent to your program yet. You can use to retrieve the text and assign it to a variable called : You can delete text as well. This method takes an integer argument that tells Python which character to remove. For example, the code block below shows how deletes the first character from : The text remaining in the widget is now : Note that, just like Python string objects, text in an widget is indexed starting with . If you need to remove several characters from an , then pass a second integer argument to indicating the index of the character where deletion should stop. For example, the following code deletes the first four letters in : works just like string slicing. The first argument determines the starting index, and the deletion continues up to but not including the index passed as the second argument. Use the special constant for the second argument of to remove all text in : On the opposite end of the spectrum, you can also insert text into an widget: The window now looks like this: The first argument tells where to insert the text. If there’s no text in , then the new text will always be inserted at the beginning of the widget, no matter what value you pass as the first argument. For example, calling with as the first argument instead of , as you did above, would’ve generated the same output. If already contains some text, then will insert the new text at the specified position and shift all existing text to the right: widgets are great for capturing small amounts of text from a user, but because they’re only displayed on a single line, they’re not ideal for gathering large amounts of text. That’s where widgets come in! widgets are used for entering text, just like widgets. The difference is that widgets may contain multiple lines of text. With a widget, a user can input a whole paragraph or even several pages of text! Just like with widgets, you can perform three main operations with widgets: Although the method names are the same as the methods, they work a bit differently. It’s time to get your hands dirty by creating a widget and seeing what it can do. Note: Do you still have the window from the previous section open? If so, then you can close it by executing the following: You can also close it manually by clicking the Close button. In your Python shell, create a new blank window and pack a widget into it: Text boxes are much larger than widgets by default. Here’s what the window created above looks like: Click anywhere inside the window to activate the text box. Type in the word . Then press and type on the second line. The window should now look like this: Just like with widgets, you can retrieve the text from a widget using . However, calling with no arguments doesn’t return the full text in the text box like it does for widgets. It raises an exception: requires at least one argument. Calling with a single index returns a single character. To retrieve several characters, you need to pass a start index and an end index. Indices in widgets work differently than in widgets. Since widgets can have several lines of text, an index must contain two pieces of information:\n• The position of a character on that line Line numbers start with , and character positions start with . To make an index, you create a string of the form , replacing with the line number and with the character number. For example, represents the first character on the first line, and represents the fourth character on the second line. Use the index to get the first letter from the text box that you created earlier: There are five letters in the word , and the character number of is , since character numbers start from , and the word starts at the first position in the text box. Just like with Python string slices, in order to get the entire word from the text box, the end index must be one more than the index of the last character to be read. So, to get the word from the text box, use for the first index and for the second index: To get the word on the second line of the text box, change the line numbers in each index to : To get all of the text in a text box, set the starting index in and use the special constant for the second index: Notice that text returned by includes any newline characters. You can also see from this example that every line in a widget has a newline character at the end, including the last line of text in the text box. is used to delete characters from a text box. It works just like for widgets. There are two ways to use : Using the single-argument version, you pass to the index of a single character to be deleted. For example, the following deletes the first character, , from the text box: The first line of text in the window now reads : With the two-argument version, you pass two indices to delete a range of characters starting at the first index and up to, but not including, the second index. For example, to delete the remaining on the first line of the text box, use the indices and : Notice that the text is gone from the first line. This leaves a blank line followed the word on the second line: Even though you can’t see it, there’s still a character on the first line. It’s a newline character! You can verify this using : If you delete that character, then the rest of the contents of the text box will shift up a line: Now, is on the first line of the text box: Try to clear out the rest of the text in the text box. Set as the start index and use for the second index: The text box is now empty: You can insert text into a text box using : This inserts the word at the beginning of the text box, using the same format used by to specify the insertion position: Check out what happens if you try to insert the word on the second line: Instead of inserting the text on the second line, the text is inserted at the end of the first line: If you want to insert text onto a new line, then you need to insert a newline character manually into the string being inserted: Now is on the second line of the text box: will do one of two things:\n• Insert text at the specified position if there’s already text at or after that position.\n• Append text to the specified line if the character number is greater than the index of the last character in the text box. It’s usually impractical to try and keep track of what the index of the last character is. The best way to insert text at the end of a widget is to pass to the first parameter of : Don’t forget to include the newline character ( ) at the beginning of the text if you want to put it on a new line: , , , and widgets are just a few of the widgets available in Tkinter. There are several others, including widgets for checkboxes, radio buttons, scroll bars, and progress bars. For more information on all of the available widgets, see the Additional Widgets list in the Additional Resources section. In this tutorial, you’re going to work with only five widgets: These are the four you’ve seen so far plus the widget. widgets are important for organizing the layout of your widgets in an application. Before you get into the details about laying out the visual presentation of your widgets, take a closer look at how widgets work, and how you can assign other widgets to them. The following script creates a blank widget and assigns it to the main application window: packs the frame into the window so that the window sizes itself as small as possible to encompass the frame. When you run the above script, you get some seriously uninteresting output: An empty widget is practically invisible. Frames are best thought of as containers for other widgets. You can assign a widget to a frame by setting the widget’s attribute: To get a feel for how this works, write a script that creates two widgets called and . In this script, contains a label with the text , and contains the label . Here’s one way to do this: Note that is packed into the window before . The window that opens shows the label in above the label in : Now see what happens when you swap the order of and : # Swap the order of `frame_a` and `frame_b` The output looks like this: Now is on top. Since is assigned to , it moves to wherever is positioned. All four of the widget types that you’ve learned about— , , , and —have a attribute that’s set when you instantiate them. That way, you can control which a widget is assigned to. widgets are great for organizing other widgets in a logical manner. Related widgets can be assigned to the same frame so that, if the frame is ever moved in the window, then the related widgets stay together. Note: If you omit the argument when creating a new widget instance, then it’ll be placed inside of the top-level window by default. In addition to grouping your widgets logically, widgets can add a little flare to the visual presentation of your application. Read on to see how to create various borders for widgets. widgets can be configured with a attribute that creates a border around the frame. You can set to be any of the following values:\n• : Has no border effect (the default value) To apply the border effect, you must set the attribute to a value greater than . This attribute adjusts the width of the border in pixels. The best way to get a feel for what each effect looks like is to see them for yourself. Here’s a script that packs five widgets into a window, each with a different value for the argument:\n• Lines 3 to 9 create a dictionary whose keys are the names of the different relief effects available in Tkinter. The values are the corresponding Tkinter objects. This dictionary is assigned to the variable.\n• Line 13 starts a loop to loop over each item in the dictionary.\n• Line 14 creates a new widget and assigns it to the object. The attribute is set to the corresponding relief in the dictionary, and the attribute is set to so that the effect is visible.\n• Line 15 packs the into the window using . The keyword argument tells Tkinter in which direction to pack the objects. You’ll see more about how this works in the next section.\n• Lines 16 and 17 create a widget to display the name of the relief and pack it into the object you just created. The window produced by the above script looks like this: In this image, you can see the following effects:\n• creates a frame that appears to be flat.\n• adds a border that gives the frame the appearance of being sunken into the window.\n• gives the frame a border that makes it appear to stick out from the screen.\n• adds a border that appears as a sunken groove around an otherwise flat frame.\n• gives the appearance of a raised lip around the edge of the frame. These effects give your Python GUI Tkinter application a bit of visual appeal. When you create a widget, you can give it any name you like, as long as it’s a valid Python identifier. It’s usually a good idea to include the name of the widget class in the variable name that you assign to the widget instance. For example, if a widget is used to display a user’s name, then you might name the widget . An widget used to collect a user’s age might be called . Note: Sometimes, you may define a new widget without assigning it to a variable. You’ll call its method directly on the same line of code: This might be helpful when you don’t intend to refer to the widget’s instance later on. Due to automatic memory management, Python would normally garbage collect such unassigned objects, but Tkinter prevents that by registering every new widget internally. When you include the widget class name in the variable name, you help yourself and anyone else who needs to read your code to understand what type of widget the variable name refers to. However, using the full name of the widget class can lead to long variable names, so you may want to adopt a shorthand for referring to each widget type. For the rest of this tutorial, you’ll use the following shorthand prefixes to name widgets: In this section, you learned how to create a window, use widgets, and work with frames. At this point, you can make some plain windows that display messages, but you’ve yet to create a full-blown application. In the next section, you’ll learn how to control the layout of your applications using Tkinter’s powerful geometry managers. Expand the code block below for an exercise to check your understanding: Exercise: Create an Entry widget and insert some textShow/Hide Write a complete script that displays an widget that’s 40 text units wide and has a white background and black text. Use to display text in the widget that reads What is your name? . The output window should look like this: You can expand the code block below to see a solution: Solution: Create an Entry widget and insert some textShow/Hide There are a couple of ways to solve this exercise. Here’s one solution that uses the and parameters to set the widget’s background and foreground colors: This solution is great because it explicitly sets the background and foreground colors for the widget. On most systems, the default background color for an widget is white, and the default foreground color is black. So, you might be able to generate the same window with the and parameters left out: Keep in mind your code may look different. When you’re ready, you can move on to the next section.\n\nUp until now, you’ve been adding widgets to windows and widgets using , but you haven’t learned what exactly this method does. Let’s clear things up! Application layout in Tkinter is controlled with geometry managers. While is an example of a geometry manager, it isn’t the only one. Tkinter has two others: Each window or in your application can use only one geometry manager. However, different frames can use different geometry managers, even if they’re assigned to a frame or window using another geometry manager. Start by taking a closer look at . The geometry manager uses a packing algorithm to place widgets in a or window in a specified order. For a given widget, the packing algorithm has two primary steps:\n• Compute a rectangular area called a parcel that’s just tall (or wide) enough to hold the widget and fills the remaining width (or height) in the window with blank space.\n• Center the widget in the parcel unless a different location is specified. is powerful, but it can be difficult to visualize. The best way to get a feel for is to look at some examples. See what happens when you three widgets into a : places each below the previous one by default, in the order that they’re assigned to the window: Each is placed at the topmost available position. Therefore, the red is placed at the top of the window. Then the yellow is placed just below the red one and the blue just below the yellow one. There are three invisible parcels, each containing one of the three widgets. Each parcel is as wide as the window and as tall as the that it contains. Because no anchor point was specified when was called for each they’re all centered inside of their parcels. That’s why each is centered in the window. accepts some keyword arguments for more precisely configuring widget placement. For example, you can set the keyword argument to specify in which direction the frames should fill. The options are to fill in the horizontal direction, to fill vertically, and to fill in both directions. Here’s how you would stack the three frames so that each one fills the whole window horizontally: Notice that the is not set on any of the widgets. is no longer necessary because each frame sets to fill horizontally, overriding any width you may set. The window produced by this script looks like this: One of the nice things about filling the window with is that the fill is responsive to window resizing. Try widening the window generated by the previous script to see how this works. As you widen the window, the width of the three widgets grow to fill the window: Notice, though, that the widgets don’t expand in the vertical direction. The keyword argument of specifies on which side of the window the widget should be placed. These are the available options: If you don’t set , then will automatically use and place new widgets at the top of the window, or at the topmost portion of the window that isn’t already occupied by a widget. For example, the following script places three frames side by side from left to right and expands each frame to fill the window vertically: This time, you have to specify the keyword argument on at least one of the frames to force the window to have some height. The resulting window looks like this: Just like when you set to make the frames responsive when you resized the window horizontally, you can set to make the frames responsive when you resize the window vertically: To make the layout truly responsive, you can set an initial size for your frames using the and attributes. Then, set the keyword argument of to and set the keyword argument to : When you run the above script, you’ll see a window that initially looks the same as the one you generated in the previous example. The difference is that now you can resize the window however you want, and the frames will expand and fill the window responsively: You can use to control the precise location that a widget should occupy in a window or . You must provide two keyword arguments, and , which specify the x- and y-coordinates for the top-left corner of the widget. Both and are measured in pixels, not text units. Keep in mind that the origin, where and are both , is the top-left corner of the or window. So, you can think of the argument of as the number of pixels from the top of the window, and the argument as the number of pixels from the left edge of the window. Here’s an example of how the geometry manager works:\n• Lines 5 and 6 create a new widget called , measuring pixels wide and pixels tall, and pack it into the window with .\n• Lines 8 and 9 create a new called with a red background and place it in at position (0, 0).\n• Lines 11 and 12 create a second called with a yellow background and place it in at position (75, 75). Here’s the window that the code produces: Note that if you run this code on a different operating system that uses different font sizes and styles, then the second label might become partially obscured by the window’s edge. That’s why isn’t used often. In addition to this, it has two main drawbacks:\n• Layout can be difficult to manage with . This is especially true if your application has lots of widgets.\n• Layouts created with aren’t responsive. They don’t change as the window is resized. One of the main challenges of cross-platform GUI development is making layouts that look good no matter which platform they’re viewed on, and is a poor choice for making responsive and cross-platform layouts. That’s not to say you should never use ! In some cases, it might be just what you need. For example, if you’re creating a GUI interface for a map, then might be the perfect choice to ensure widgets are placed at the correct distance from each other on the map. is usually a better choice than , but even has some downsides. The placement of widgets depends on the order in which is called, so it can be difficult to modify existing applications without fully understanding the code controlling the layout. The geometry manager solves a lot of these issues, as you’ll see in the next section. The geometry manager you’ll likely use most often is , which provides all the power of in a format that’s easier to understand and maintain. works by splitting a window or into rows and columns. You specify the location of a widget by calling and passing the row and column indices to the and keyword arguments, respectively. Both row and column indices start at , so a row index of and a column index of tells to place a widget in the third column of the second row. The following script creates a 3 × 3 grid of frames with widgets packed into them: Here’s what the resulting window looks like: You’re using two geometry managers in this example. Each frame is attached to with the geometry manager: Each is attached to its master with : The important thing to realize here is that even though is called on each object, the geometry manager applies to the object. Similarly, the layout of each is controlled with the geometry manager. The frames in the previous example are placed tightly next to one another. To add some space around each frame, you can set the padding of each cell in the grid. Padding is just some blank space that surrounds a widget and visually sets its content apart. The two types of padding are external and internal padding. External padding adds some space around the outside of a grid cell. It’s controlled with two keyword arguments to : Both and are measured in pixels, not text units, so setting both of them to the same value will create the same amount of padding in both directions. Try to add some padding around the outside of the frames from the previous example: also has and parameters. The following code is nearly identical to the previous code, except that you add five pixels of additional padding around each label in both the and directions: The extra padding around the widgets gives each cell in the grid a little bit of breathing room between the border and the text in the label: That looks pretty nice! But if you try and expand the window in any direction, then you’ll notice that the layout isn’t very responsive: The whole grid stays at the top-left corner as the window expands. By using and on the object, you can adjust how the rows and columns of the grid grow as the window is resized. Remember, the grid is attached to , even though you’re calling on each widget. Both and take three essential arguments:\n• Index: The index of the grid column or row that you want to configure or a list of indices to configure multiple rows or columns at the same time\n• Weight: A keyword argument called that determines how the column or row should respond to window resizing, relative to the other columns and rows\n• Minimum Size: A keyword argument called that sets the minimum size of the row height or column width in pixels is set to by default, which means that the column or row doesn’t expand as the window resizes. If every column or row is given a weight of , then they all grow at the same rate. If one column has a weight of and another a weight of , then the second column expands at twice the rate of the first. Adjust the previous script to better handle window resizing: and are placed in the body of the outer loop. You could explicitly configure each column and row outside of the loop, but that would require writing an additional six lines of code. On each iteration of the loop, the -th column and row are configured to have a weight of . This ensures that the row and column expand at the same rate whenever the window is resized. The argument is set to for each column and for each row. This ensures that the widget always displays its text without chopping off any characters, even if the window size is extremely small. The result is a grid layout that expands and contracts smoothly as the window is resized: Try it yourself to get a feel for how it works! Play around with the and parameters to see how they affect the grid. By default, widgets are centered in their grid cells. For example, the following code creates two widgets and places them in a grid with one column and two rows: Each grid cell is pixels wide and pixels tall. The labels are placed in the center of each cell, as you can see in the following figure: You can change the location of each label inside of the grid cell using the parameter, which accepts a string containing one or more of the following letters:\n• or to align to the top-center part of the cell\n• or to align to the right-center side of the cell\n• or to align to the bottom-center part of the cell\n• or to align to the left-center side of the cell The letters , , , and come from the cardinal directions north, south, east, and west. Setting to on both labels in the previous code positions each label at the top-center of its grid cell: You can combine multiple letters in a single string to position each label in the corner of its grid cell: In this example, the parameter of is set to , which places the label at the top-right corner of its grid cell. is positioned in the bottom-left corner by passing to . Here’s what that looks like in the window: When a widget is positioned with , the size of the widget itself is just big enough to contain any text and other contents inside of it. It won’t fill the entire grid cell. In order to fill the grid, you can specify to force the widget to fill the cell in the vertical direction, or to fill the cell in the horizontal direction. To fill the entire cell, set to . The following example illustrates each of these options: Here’s what the output looks like: What the above example illustrates is that the geometry manager’s parameter can be used to achieve the same effects as the geometry manager’s parameter. The correspondence between the and parameters is summarized in the following table: is a powerful geometry manager. It’s often easier to understand than and is much more flexible than . When you’re creating new Tkinter applications, you should consider using as your primary geometry manager. Note: offers much more flexibility than you’ve seen here. For example, you can configure cells to span multiple rows and columns. For more information, check out the Grid Geometry Manager section of the TkDocs tutorial. Now that you’ve got the fundamentals of geometry managers down for the Python GUI framework Tkinter, the next step is to assign actions to buttons to bring your applications to life. Expand the code block below for an exercise to check your understanding: Below is an image of an address entry form made with Tkinter: Write a complete script that re-creates the window. You may use any geometry manager you like. You can expand the code block below to see a solution: There are many different ways to solve this exercise. If your solution generates a window identical to the one in the exercise statement, then congratulations! You’ve successfully solved the exercise! Below, you can look at two solutions that use the geometry manager. One solution creates a and widget with the desired settings for each field: # Create a new window with the title \"Address Entry Form\" # Create a new frame `frm_form` to contain the Label # Pack the frame into the window # Create the Label and Entry widgets for \"First Name\" # Use the grid geometry manager to place the Label and # Entry widgets in the first and second columns of the # Create the Label and Entry widgets for \"Last Name\" # Place the widgets in the second row of the grid # Create the Label and Entry widgets for \"Address Line 1\" # Place the widgets in the third row of the grid # Create the Label and Entry widgets for \"Address Line 2\" # Place the widgets in the fourth row of the grid # Create the Label and Entry widgets for \"City\" # Place the widgets in the fifth row of the grid # Create the Label and Entry widgets for \"State/Province\" # Place the widgets in the sixth row of the grid # Create the Label and Entry widgets for \"Postal Code\" # Place the widgets in the seventh row of the grid # Create the Label and Entry widgets for \"Country\" # Place the widgets in the eight row of the grid # Create a new frame `frm_buttons` to contain the # Submit and Clear buttons. This frame fills the # whole window in the horizontal direction and has # Create the \"Submit\" button and pack it to the # Create the \"Clear\" button and pack it to the There’s nothing wrong with this solution. It’s a bit long, but everything is very explicit. If you want to change something, then it’s clear to see exactly where to do so. That said, the solution can be considerably shortened by recognizing that each has the same width, and that all you need for each is the text: # Create a new window with the title \"Address Entry Form\" # Create a new frame `frm_form` to contain the Label # Pack the frame into the window # Loop over the list of field labels # Create a Label widget with the text from the labels list # Use the grid geometry manager to place the Label and # Entry widgets in the row whose index is idx # Create a new frame `frm_buttons` to contain the # Submit and Clear buttons. This frame fills the # whole window in the horizontal direction and has # Create the \"Submit\" button and pack it to the # Create the \"Clear\" button and pack it to the In this solution, a list is used to store the strings for each label in the form. They’re stored in the order that each form field should appear. Then, gets both the index and string from each value in the list. When you’re ready, you can move on to the next section.\n\nBy now, you have a pretty good idea of how to create a window with Tkinter, add some widgets, and control the application layout. That’s great, but applications shouldn’t just look good—they actually need to do something! In this section, you’ll learn how to bring your applications to life by performing actions whenever certain events occur. When you create a Tkinter application, you must call to start the event loop. During the event loop, your application checks if an event has occurred. If so, then it’ll execute some code in response. The event loop is provided for you with Tkinter, so you don’t have to write any code that checks for events yourself. However, you do have to write the code that will be executed in response to an event. In Tkinter, you write functions called event handlers for the events that you use in your application. Note: An event is any action that occurs during the event loop that might trigger some behavior in the application, such as when a key or mouse button is pressed. When an event occurs, an event object is emitted, which means that an instance of a class representing the event is created. You don’t need to worry about instantiating these classes yourself. Tkinter will create instances of event classes for you automatically. You’ll write your own event loop in order to better understand how Tkinter’s event loop works. That way, you can see how Tkinter’s event loop fits into your application, and which parts you need to write yourself. Assume there’s a list called that contains event objects. A new event object is automatically appended to every time an event occurs in your program. You don’t need to implement this updating mechanism. It just automatically happens for you in this conceptual example. Using an infinite loop, you can continually check if there are any event objects in : # Assume that this list gets updated automatically # If the event list is empty, then no events have occurred # and you can skip to the next iteration of the loop # If execution reaches this point, then there is at least one Right now, the event loop that you’ve created doesn’t do anything with . Let’s change that. Suppose your application needs to respond to keypresses. You need to check that was generated by a user pressing a key on their keyboard, and if so, pass to an event handler function for keypresses. Assume that has a attribute set to the string if the event is a keypress event object, and a attribute containing the character of the key that was pressed. Create a new function and update your event loop code: \"\"\"Print the character associated to the key pressed\"\"\" When you call , something like the above loop is run for you. This method takes care of two parts of the loop for you:\n• It maintains a list of events that have occurred.\n• It runs an event handler any time a new event is added to that list. Update your event loop to use instead of your own event loop: \"\"\"Print the character associated to the key pressed\"\"\" takes care of a lot for you, but there’s something missing from the above code. How does Tkinter know when to use ? Tkinter widgets have a method called for just this purpose. To call an event handler whenever an event occurs on a widget, use . The event handler is said to be bound to the event because it’s called every time the event occurs. You’ll continue with the keypress example from the previous section and use to bind to the keypress event: \"\"\"Print the character associated to the key pressed\"\"\" Here, the event handler is bound to a event using . Whenever a key is pressed while the application is running, your program will print the character of the key pressed. Note: The output of the above program is not printed in the Tkinter application window. It’s printed to the standard output stream (stdout). If you run the program in IDLE, then you’ll see the output in the interactive window. If you run the program from a terminal, then you should see the output in your terminal. always takes at least two arguments:\n• An event that’s represented by a string of the form , where can be any of Tkinter’s events\n• An event handler that’s the name of the function to be called whenever the event occurs The event handler is bound to the widget on which is called. When the event handler is called, the event object is passed to the event handler function. In the example above, the event handler is bound to the window itself, but you can bind an event handler to any widget in your application. For example, you can bind an event handler to a widget that will perform some action whenever the button is pressed: In this example, the event on the widget is bound to the event handler. The event occurs whenever the left mouse button is pressed while the mouse is over the widget. There are other events for mouse button clicks, including for the middle mouse button and for the right mouse button. Note: For a list of commonly used events, see the Event types section of the Tkinter 8.5 reference. You can bind any event handler to any kind of widget with , but there’s a more straightforward way to bind event handlers to button clicks using the widget’s attribute. Every widget has a attribute that you can assign to a function. Whenever the button is pressed, the function is executed. Take a look at an example. First, you’ll create a window with a widget that holds a numeric value. You’ll put buttons on the left and right side of the label. The left button will be used to decrease the value in the , and the right one will increase the value. Here’s the code for the window: The window looks like this: With the app layout defined, you can bring it to life by giving the buttons some commands. Start with the left button. When this button is pressed, it should decrease the value in the label by one. In order to do this, you first need to get answers to two questions:\n• How do you get the text in ?\n• How do you update the text in ? widgets don’t have like and widgets do. However, you can retrieve the text from the label by accessing the attribute with a dictionary-style subscript notation: # Set new text for the label Now that you know how to get and set a label’s text, write an function that increases the value in by one: gets the text from and converts it to an integer with . Then, it increases this value by one and sets the label’s attribute to this new value. You’ll also need to decrease the value in by one: Put and in your code just after the statement. To connect the buttons to the functions, assign the function to the button’s attribute. You can do this when you instantiate the buttons. For example, update the two lines that instantiate the buttons to the following: That’s all you need to do to bind the buttons to and and make the program functional. Try saving your changes and running the application! Click the buttons to increase and decrease the value in the center of the window: Here’s the full application code for your reference: This app isn’t particularly useful, but the skills you learned here apply to every app you’ll make:\n• Use widgets to create the components of the user interface.\n• Use geometry managers to control the layout of the application.\n• Write event handlers that interact with various components to capture and transform user input. In the next two sections, you’ll build more useful apps. First, you’ll build a temperature converter that converts a temperature value from Fahrenheit to Celsius. After that, you’ll build a text editor that can open, edit, and save text files! Expand the code block below for an exercise to check your understanding: Write a program that simulates rolling a six-sided die. There should be one button with the text . When the user clicks the button, a random integer from to should be displayed. Hint: You can generate a random number using in the module. If you’re not familiar with the module, then check out Generating Random Data in Python (Guide) for more information. The application window should look something like this: You can expand the code block below to see a solution: Keep in mind that your code may look different. When you’re ready, you can move on to the next section.\n\nIn this section, you’ll build a temperature converter application that allows the user to input temperature in degrees Fahrenheit and push a button to convert that temperature to degrees Celsius. You’ll walk through the code step by step. You can also find the full source code at the end of this section for your reference. Note: To get the most out of this section, follow along in a Python shell. Before you start coding, you’ll first design the app. You need three elements:\n• : A widget called for entering the Fahrenheit value\n• : A widget called that reads the value from the widget, converts it from Fahrenheit to Celsius, and sets the text of the widget to the result when clicked You can arrange these in a grid with a single row and one column for each widget. That gets you a minimally working application, but it isn’t very user-friendly. Everything needs to have labels. You’ll put a label directly to the right of the widget containing the Fahrenheit symbol (℉) so that the user knows that the value should be in degrees Fahrenheit. To do this, set the label text to , which uses Python’s named Unicode character support to display the Fahrenheit symbol. You can give a little flair by setting its text to the value , which displays a black arrow pointing to the right. You’ll also make sure that always has the Celsius symbol (℃) following the label text to indicate that the result is in degrees Celsius. Here’s what the final window will look like: Now that you know what widgets you need and what the window is going to look like, you can start coding it up! First, import and create a new window: sets the title of an existing window, while with both arguments set to makes the window have a fixed size. When you finally run this application, the window will have the text Temperature Converter in its title bar. Next, create the widget with a label called and assign both to a widget called : The user will enter the Fahrenheit value in , and is used to label with the Fahrenheit symbol. The container groups and together. You want to be placed directly to the right of . You can lay them out in using the geometry manager with one row and two columns: You’ve set the parameter to for so that it always sticks to the rightmost edge of its grid cell. You also set to for to keep it stuck to the leftmost edge of its grid cell. This ensures that is always located immediately to the right of . Now, make the and the for converting the temperature entered into and displaying the results: Like , both and are assigned to . Together, these three widgets make up the three cells in the main application grid. Use to go ahead and lay them out now: That looks great! But the button doesn’t do anything just yet. At the top of your script file, just below the line, add a function called : \"\"\"Convert the value for Fahrenheit to Celsius and insert the This function reads the value from , converts it from Fahrenheit to Celsius, and then displays the result in . Now go down to the line where you define and set its parameter to : That’s it! You’ve created a fully functional temperature converter app in just twenty-six lines of code! Pretty cool, right? You can expand the code block below to see the full script: Here’s the full script for your reference: \"\"\"Convert the value for Fahrenheit to Celsius and insert the # Create the Fahrenheit entry frame with an Entry # Layout the temperature Entry and Label in frm_entry # Set up the layout using the .grid() geometry manager It’s time to kick things up a notch! Read on to learn how to build a text editor.\n\nIn this section, you’ll build a text editor application that can create, open, edit, and save text files. There are three essential elements in the application:\n• A widget called for creating and editing the text file The three widgets will be arranged so that the two buttons are on the left-hand side of the window, and the text box is on the right-hand side. The whole window should have a minimum height of 800 pixels, and should have a minimum width of 800 pixels. The whole layout should be responsive so that if the window is resized, then is resized as well. The width of the frame holding the buttons should not change, however. Here’s a sketch of how the window will look: You can achieve the desired layout using the geometry manager. The layout contains a single row and two columns:\n• A narrow column on the left for the buttons\n• A wider column on the right for the text box To set the minimum sizes for the window and , you can set the parameters of the window methods and to . To handle resizing, you can set the parameters of these methods to . In order to get both buttons into the same column, you’ll need to create a widget called . According to the sketch, the two buttons should be stacked vertically inside of this frame, with on top. You can do that with either the or geometry manager. For now, you’ll stick with since it’s a little easier to work with. Now that you have a plan, you can start coding the application. The first step is to create all of the widgets you need:\n• Lines 3 and 4 create a new window with the title .\n• Lines 6 and 7 set the row and column configurations.\n• Lines 9 to 12 create the four widgets you’ll need for the text box, the frame, and the open and save buttons. Take a look at line 6 more closely. The parameter of is set to , and is set to : The first argument is , which sets the height of the first row to pixels and makes sure that the height of the row grows proportionally to the height of the window. There’s only one row in the application layout, so these settings apply to the entire window. Let’s also take a closer look at line 7. Here, you use to set the and attributes of the column with index to and , respectively: Remember, row and column indices are zero-based, so these settings apply only to the second column. By configuring just the second column, the text box will expand and contract naturally when the window is resized, while the column containing the buttons will remain at a fixed width. Now you can work on the application layout. First, assign the two buttons to the frame using the geometry manager: These two lines of code create a grid with two rows and one column in the frame since both and have their attribute set to . is put in the first row and in the second row so that appears above in the layout, just you planned in your sketch. Both and have their attributes set to , which forces the buttons to expand horizontally in both directions and fill the entire frame. This ensures that both buttons are the same size. You place five pixels of padding around each button by setting the and parameters to . Only has vertical padding. Since it’s on top, the vertical padding offsets the button down from the top of the window a bit and makes sure that there’s a small gap between it and . Now that is laid out and ready to go, you can set up the grid layout for the rest of the window: These two lines of code create a grid with one row and two columns for . You place in the first column and in the second column so that appears to the left of in the window layout. The parameter for is set to , which forces the whole frame to expand vertically and fill the entire height of its column. fills its entire grid cell because you set its parameter to , which forces it to expand in every direction. Now that the application layout is complete, add to the bottom of the program and save and run the file: The following window is displayed: That looks great! But it doesn’t do anything just yet, so you need to start writing the commands for the buttons. needs to show a file open dialog and allow the user to select a file. It then needs to open that file and set the text of to the contents of the file. Here’s an function that does just this:\n• Lines 5 to 7 use the dialog from the module to display a file open dialog and store the selected file path to .\n• Lines 8 and 9 check to see if the user closes the dialog box or clicks the Cancel button. If so, then will be , and the function will without executing any of the code to read the file and set the text of .\n• Line 10 clears the current contents of using .\n• Lines 11 and 12 open the selected file and its contents before storing the as a string.\n• Line 13 assigns the string to using .\n• Line 14 sets the title of the window so that it contains the path of the open file. Now you can update the program so that calls whenever it’s clicked. There are a few things that you need to do to update the program. First, import from by adding the following import to the top of your program: Next, set the attribute of to : Save the file and run it to check that everything is working. Then try opening a text file! With working, it’s time to work on the function for . This needs to open a save file dialog box so that the user can choose where they would like to save the file. You’ll use the dialog in the module for this. This function also needs to extract the text currently in and write this to a file at the selected location. Here’s a function that does just this: \"\"\"Save the current file as a new file.\"\"\"\n• Lines 19 to 22 use the dialog box to get the desired save location from the user. The selected file path is stored in the variable.\n• Lines 23 and 24 check to see if the user closes the dialog box or clicks the Cancel button. If so, then will be , and the function will return without executing any of the code to save the text to a file.\n• Line 25 creates a new file at the selected file path.\n• Line 26 extracts the text from with method and assigns it to the variable .\n• Line 28 updates the title of the window so that the new file path is displayed in the window title. Now you can update the program so that calls when it’s clicked. Again, there are a few things you need to do in order to update the program. First, import from by updating the import at the top of your script, like so: Finally, set the attribute of to : Save the file and run it. You’ve now got a minimal yet fully functional text editor! You can expand the code block below to see the full script: Here’s the full script for your reference: \"\"\"Save the current file as a new file.\"\"\" You’ve now built two GUI applications in Python and applied many of the skills that you’ve learned throughout this tutorial. That’s no small achievement, so take some time to feel good about what you’ve done. You’re now ready to tackle some applications on your own!"
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    },
    {
        "link": "https://realpython.com/image-processing-with-the-python-pillow-library",
        "document": "Python Pillow allows you to manipulate images and perform basic image processing tasks. As a fork of the Python Imaging Library (PIL), Pillow supports image formats like JPEG, PNG, and more, enabling you to read, edit, and save images. With Python Pillow, you can crop, resize, rotate, and apply filters to images, making it a versatile tool for image manipulation.\n\nPillow is often used for high-level image processing tasks and exploratory work. While not the fastest library, it offers a gentle learning curve and a comprehensive set of features for basic to intermediate image processing needs. You can enhance its capabilities by integrating it with NumPy for pixel-level manipulations and creating animations.\n\nBy the end of this tutorial, you’ll understand that:\n• Python Pillow is used for image manipulation and basic image processing.\n• Pillow offers reasonable speed for its intended use cases.\n• PIL is the original library, while Pillow is its actively maintained fork.\n• You read an image in Python Pillow using from the PIL module.\n• Pillow is used for its ease of use, versatility, and integration with NumPy.\n\nWith these insights, you’re ready to dive into the world of image processing with Python Pillow. You’ll use several images in this tutorial, which you can download from the tutorial’s image repository:\n\nWith these images in hand, you’re now ready to get started with Pillow.\n\nThe Python Pillow library is a fork of an older library called PIL. PIL stands for Python Imaging Library, and it’s the original library that enabled Python to deal with images. PIL was discontinued in 2011 and only supports Python 2. To use its developers’ own description, Pillow is the friendly PIL fork that kept the library alive and includes support for Python 3. There’s more than one module in Python to deal with images and perform image processing. If you want to deal with images directly by manipulating their pixels, then you can use NumPy and SciPy. Other popular libraries for image processing are OpenCV, scikit-image, and Mahotas. Some of these libraries are faster and more powerful than Pillow. However, Pillow remains an important tool for dealing with images. It provides image processing features that are similar to ones found in image processing software such as Photoshop. Pillow is often the preferred option for high-level image processing tasks that don’t require more advanced image processing expertise. It’s also often used for exploratory work when dealing with images. Pillow also has the advantage of being widely used by the Python community, and it doesn’t have the same steep learning curve as some of the other image processing libraries. You’ll need to install the library before you can use it. You can install Pillow using within a virtual environment: Now that you’ve installed the package, you’re ready to start familiarizing yourself with the Python Pillow library and perform basic manipulations of images. The Module and Class in Pillow The main class defined in Pillow is the class. When you read an image using Pillow, the image is stored in an object of type . For the code in this section, you’ll need the image file named (image credit), which you can find in the image repository for this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You can place this image file in the project folder that you’re working in. When exploring images with Pillow, it’s best to use an interactive REPL environment. You’ll start by opening the image that you just downloaded: You might expect to import from Pillow instead of from PIL. You did install , after all, not . However, Pillow is a fork of the PIL library. Therefore, you’ll still need to use when importing into your code. You call the function to read the image from the file and to read the image into memory so that the file can now be closed. You use a statement to create a context manager to ensure the file is closed as soon as it’s no longer needed. In this example, the object is a JPEG image-specific type that’s a subclass of the class, as you confirm with the call to . Note that both the class and the module where the class is defined share the same name, . You can display the image using : The method saves the image as a temporary file and displays it using your operating system’s native software for dealing with images. When you run the code above, you’ll see the following image displayed: On some systems, calling will block the REPL until you close the image. This depends on the operating system and the default image viewing software that you’re using. You’ll need to be familiar with three key properties when dealing with images in the Python Pillow library. You can explore these using the class attributes , , and : The format of an image shows what type of image you’re dealing with. In this case, the format of the image is . The size shows the width and height of the image in pixels. The mode of this image is . You’ll learn more about modes shortly. Often, you may need to crop and resize images. The class has two methods that you can use to perform these operations, and : The argument to must be a 4-tuple that defines the left, upper, right, and bottom edges of the region that you wish to crop. The coordinate system used in Pillow assigns the coordinates (0, 0) to the pixel in the upper-left corner. This is the same coordinate system that’s usually used for two-dimensional arrays. The 4-tuple represents the following section of the image: The new image that returns in the code above has a size of pixels. The cropped image shows only one of the buildings from the original picture: In the code above, you also change the resolution of the cropped image using , which needs a tuple as a required argument. The tuple that you use as an argument defines the new width and height of the image in pixels. In the example above, you’re setting the new width and height to a quarter of their original values using the floor division operator ( ) and the attributes and . The final call to displays the cropped and resized image: There are additional optional parameters that you can use with to control how the image is resampled. Alternatively, you can achieve similar scaling using : The argument determines the factor by which you scale the image down. If you prefer to set a maximum size rather than a scaling factor, then you can use . The size of the thumbnail will be smaller than or equal to the size that you set. Note: The method changes the object in place and doesn’t return a new object. However, , , and all return a new object. Not all methods in the Pillow library behave in the same way. Once you’re happy with your returned image, you can save any of the objects to file using : Once you call the method, it creates the image files in your project folder. In this example, one of the images is a JPEG image and the other is a PNG image. The extension that you use as a filname automatically determines the file format, or you can specify the format as an additional optional argument. You can manipulate the image beyond cropping and resizing. Another common requirement is to rotate or flip the image. You can use the method for some transformations. Go ahead and carry on with the same REPL session that you started in the previous section: This code displays the following image: There are seven options that you can pass as arguments to :\n• : Flips the image left to right, resulting in a mirror image\n• : Rotates the image by 270 degrees counterclockwise, which is the same as 90 degrees clockwise\n• : Transposes the rows and columns using the top-left pixel as the origin, with the top-left pixel being the same in the transposed image as in the original image\n• : Transposes the rows and columns using the bottom-left pixel as the origin, with the bottom-left pixel being the one that remains fixed between the original and modified versions All the rotation options above define rotations in steps of 90 degrees. If you need to rotate an image by another angle, then you can use : This method call rotates the image by 45 degrees counterclockwise, giving the following image: The object returned is the same size as the original . Therefore, the corners of the image are missing in this display. You can change this behavior using the named parameter: This method returns a larger image that fully contains the rotated image: You can customize the rotation further with additional optional parameters. You can now change the size and orientation of an image. In the next section, you’ll learn about different types of images in the Python Pillow library. Bands and Modes of an Image in the Python Pillow Library An image is a two-dimensional array of pixels, where each pixel corresponds to a color. Each pixel can be represented by one or more values. For example, in an RGB image, each pixel is represented by three values corresponding to the red, green, and blue values for that pixel. Therefore, the object for an RBG image contains three bands, one for each color. An RGB image of size pixels is represented by a array of values. RGBA images also include the alpha value, which contains information about the transparency for each pixel. An RGBA image has four bands, one for each of the colors and a fourth one containing the alpha values. Each band has the same dimensions as the image dimensions. Therefore, an RGBA image of size pixels is represented by a array of values. The mode of an image describes what type of image you’re working with. Pillow supports most standard modes, including black-and-white (binary), grayscale, RGB, RGBA, and CMYK. You can see the full list of supported modes in the Pillow documentation on modes. You can find out how many bands are in an object using the method, and you can convert between modes using . Now you’ll use the image named (image credit) from the image repository for this tutorial: This image’s mode is also RGB. You can convert this image into other modes. This code uses the same REPL session that you started in the previous sections: You call twice to convert the RGB image into a CMYK and a grayscale version. The CMYK image looks similar to the original image but is encoded using the mode that’s common for printed material rather than digital displays. The conversion to grayscale gives the following output: The outputs from the calls to confirm that there are three bands in the RGB image, four bands in the CMYK image, and one band in the grayscale image. You can separate an image into its bands using and combine separate bands back into an object using . When you use , the method returns all the bands as separate objects. You can confirm this by displaying the string representation of one of the objects returned: The mode of the object that returns is , indicating this is a grayscale image, or an image that only displays the luminance values of each pixel. Now, you can create three new RGB images showing the red, green, and blue channels separately using , which is a function in the module: The first argument in determines the mode of the image that you want to create. The second argument contains the individual bands that you want to merge into a single image. The red band alone, stored in the variable , is a grayscale image with mode L. To create the image showing only the red channel, you merge the red band from the original image with green and blue bands that only contain zeros. To create a band containing zeros everywhere, you use the method. This method needs a function as an argument. The function that you use determines how each point transforms. In this case, you use a function to map each point to . When you merge the red band with green and blue bands containing zeros, you get an RGB image called . Therefore, the RGB image that you create only has non-zero values in the red channel, but because it’s still an RGB image, it’ll display in color. You also repeat a similar process to obtain and , which contain RGB images with the green and blue channels from the original image. The code displays the following three images: The red image contains a strong signal in the pixels that represent the strawberry, because these pixels are mostly red. The green and blue channels show these pixels as dark because they have small values. The exceptions are those pixels that represent the reflection of the light on the surface of the strawberry as these pixels are nearly white. Creating the side-by-side displays shown in this tutorialShow/Hide In this tutorial, when there are several images output in the code that need to be displayed next to one another to make comparisons easier, the images are displayed side by side rather than as separate images. These side-by-side displays were created using Pillow itself. You can use the function , shown below, to merge several images into a single display: The first parameter in uses the unpacking operator ( ) so that any number of objects of type can be used as input arguments. The keyword parameter can be set to if you want to tile the images vertically rather than horizontally. This function assumes that all images have the same size. The overall size of the display is calculated from the size of the images and the number of images used. You then create a new object with the same mode as the original images and with the size of the overal display. The loop pastes the images that you input when you call the function into the final display. The function returns the final object containing all the images side by side. The image in the main article showing the three color channels for the strawberry image was obtained by calling the function as follows: This function was used to generate all the displays that show more than one image in this tutorial.\n\nYou’ve learned how to crop and rotate images, resize them, and extract color bands from color images. However, none of the actions that you’ve taken so far have made any changes to the content of the image. In this section, you’ll learn about image processing features in the Python Pillow library. You’ll use the module in Pillow. One of the methods that’s used in image processing is image convolution using kernels. The aim of this tutorial is not to give a detailed explanation of image processing theory. If you’re interested in the science of image processing, one of the best resources that you can use is Digital Image Processing by Gonzalez and Woods. In this section, you’ll learn the basics of how you can use convolution kernels to perform image processing. But what’s a convolution kernel? A kernel is a matrix: You can consider a simple image to understand the process of convolution using kernels. The image has a size of pixels and contains a vertical line and a dot. The line is four pixels wide, and the dot consists of a pixel square. The image below is enlarged for display purposes: You can place the kernel anywhere on the image and use the location of the kernel’s central cell as a reference. The diagram below is a representation of the top-left portion of the image: The elements in this diagram represent different aspects of the image and the kernel:\n• The white squares represent pixels in the image that have a value of .\n• The red squares represent pixels in the image that have a value of . These make up the dot in the image shown above.\n• Each purple region represents the kernel. This kernel consists of a region, and each cell in the kernel has a value of . The diagram shows the kernel in three different positions labeled 1, 2, and 3. A new image can be created as a result of the convolution of the image with the kernel. You can understand the convolution process through the following steps:\n• Locate kernel: Consider one of the kernel locations and look at the image pixels covered by the kernel’s nine cells.\n• Multiply kernel and pixel values: Multiply the values in each of the kernel’s cells with the corresponding pixel values in the image. You’ll have nine values from the nine multiplications.\n• Sum results of multiplications: Add those nine values together. The result will be the value of the pixel in the new image that has the same coordinates as the kernel’s center pixel.\n• Repeat for all pixels: Repeat the process for every pixel in the image, moving the kernel each time so that the kernel’s central cell corresponds to a different image pixel each time. You can see this process with the three kernel positions labeled 1, 2, and 3 in diagram above. Consider the kernel position labeled 1. The position of this kernel is , which is the position of its central cell because it’s in the fourth row (index = ) and the third column (index = ). Each image pixel in the region covered by the kernel has a value of zero. Therefore, all the multiplications from step 2 will be zero, and their addition will also be zero. The new image will have a value of zero at pixel . The scenario is different for the other kernel positions shown. Next, consider the kernel labeled 2, located at . One of the image pixels overlapping this is not zero. The multiplication of this pixel value with the kernel value will give . The eight remaining multiplications are still zero because the image pixels are zero. Therefore, the value of the pixel at position in the new image will be . The third kernel position illustrated above is at . There are four non-zero image pixels overlapping with this kernel. Each one has a value of , so the multiplication result will again be for each of those pixel positions. The overall result for this kernel position is . The new image will have this value at . The diagram and the discussion above only consider three kernel positions. The convolution process repeats this process for every possible kernel position in the image. This gives a value for each pixel position in the new image. The result of the convolution is shown on the right in the following image, with the original image on the left: The kernel that you used is a box blur kernel. The factor of is there so that the overall weighting of the kernel is . The result of the convolution is a blurred version of the original image. There are other kernels that perform different functions, including different blurring methods, edge detection, sharpening, and more. The Python Pillow library has several built-in kernels and functions that’ll perform the convolution described above. You don’t need to understand the math of filtering through convolution to use these filters, but it always helps to know what’s happening behind the scenes when using these tools. The next sections will look at the kernels and image filtering capabilities available in the module in Pillow. You’ll return to using the image of the buildings that you used at the beginning of this tutorial. You can start a new REPL session for this section: In addition to , you also import the module from Pillow. You can use the method to apply filtering to the image. This method needs a convolution kernel as its argument, and you can use one of the several kernels available in the module in Pillow. The first set of filters that you’ll learn about deal with blurring, sharpening, and smoothing an image. You can blur the image using the predefined filter: The displayed image is a blurred version of the original one. You can zoom in to observe the difference in more detail using and then display the images again using : The two cropped images show the difference between the two versions: You can customize the type and amount of blurring that you need using or : You can see the three blurred images below, shown in the same order as in the code above: The filter is similar to the one described in the previous section introducing convolution kernels. The argument is the radius of the box blur filter. In the earlier section discussing kernels, the box blur filter that you used was a filter. This means that it had a radius of , because the filter extends by one pixel from the center. The blurred images show that the box blur filter with a radius of produces an image that’s more blurred than the image generated by the box blur filter with radius . You can also use the filter, which uses a Gaussian blur kernel. The Gaussian kernel puts more weight on the pixels at the center of the kernel than those at the edges, and this leads to smoother blurring than what’s obtained with the box blur. For this reason, Gaussian blurring can give better results in many cases. What if you want to sharpen an image? In that case, you can use the filter and compare the result with the original image: You’re comparing a cropped version of both images showing a small portion of the building. The sharpened image is on the right: Perhaps instead of sharpening an image, you need to smooth it. You can achieve this by passing as an argument for : Below, you can see the original image on the left and the smoothed image on the right: You’ll see an application of the smooth filter in the next section, in which you’ll learn about more filters in the module. These filters act on the edges of objects in the image. When you look at an image, it’s relatively easy to determine the edges of objects within that image. It’s also possible for an algorithm to detect edges automatically using edge detection kernels. The module in Pillow has a predefined kernel to achieve this. In this section, you’ll use the image of the buildings again and convert it to grayscale before you apply the edge detection filter. You can carry on with the REPL session from the previous section: The result is an image showing the edges from the original image: This filter identifies the edges in the image. You can obtain a better outcome by applying the filter before finding the edges: You can see a comparison of the original grayscale image and the two edge detection results below. The version with smoothing before edge detection is shown at the bottom: You can also enhance the edges of the original image with the filter: You used the smoothed version of the grayscale image to enhance the edges. A portion of the original grayscale image and the image with the edges enhanced are shown side by side below. The image with edge enhancement is on the right: Another predefined filter in that deals with object edges is . You can pass it as an argument to as you did with the other filters in this section: You’re using the smoothed, grayscale version as a starting point for this filter. You can see the embossed image below, which shows a different effect using the edges in the image: In this section, you’ve learned about several filters available in the module that you can apply to images. There are other filters that you can use to process images. You can see a list of all the filters available in the documentation.\n\nImage Segmentation and Superimposition: An Example In this section, you’ll use the image files named (image credit) and (image credit), which you can find in the image repository for this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You can use the Python Pillow library to extract the cat from the first image and place it on the floor of the monastery courtyard. You’ll use a number of image processing techniques to achieve this. You’ll start by working on . You’ll need to remove the picture of the cat from the background using image segmentation techniques. In this example, you’ll segment the image using thresholding techniques. First, you can crop the image to a smaller one to remove some of the background. You can start a new REPL session for this project: The cropped image contains the cat and some of the background that’s too close to the cat for you to crop it: Each pixel in a color image is represented digitally by three numbers corresponding to the red, green, and blue values of that pixel. Thresholding is the process of converting all the pixels to either the maximum or minimum value depending on whether they’re higher or lower than a certain number. It’s easier to do this on a grayscale image: You achieve thresholding by calling to convert each pixel in the grayscale image into either or . The conversion depends on whether the value in the grayscale image is greater or smaller than the threshold value. The threshold value in this example is . The figure below shows the grayscale image and the result from the thresholding process: In this example, all the points in the grayscale image that had a pixel value greater than are converted to white, and all other pixels are changed to black. You can change the sensitivity of the thresholding process by varying the threshold value. Thresholding can be used to segment images when the object to segment is distinct from the background. You can achieve better results with versions of the original image that have higher contrast. In this example, you can achieve higher contrast by thresholding the blue channel of the original image rather than the grayscale image, because the dominant colors in the background are brown and green colors, which have a weak blue component. You can extract the red, green, and blue channels from the color image as you did earlier: The red, green, and blue channels are shown below, from left to right. All three are displayed as grayscale images: The blue channel has a higher contrast between the pixels representing the cat and those representing the background. You can use the blue channel image to threshold: You use a threshold value of in this example. You also convert the image into a binary mode using as an argument to . The pixels in a binary image can only have the values of or . Note: When dealing with certain image formats, such as JPEG, that rely on lossy compression, the images may vary slightly depending on which JPEG decoders you’re using. Different operating systems often come with different default JPEG decoders. Therefore, the results that you get when processing images may vary depending on the operating system and JPEG decoder that you’re using. You may need to slightly adjust the threshold value if your results do not match the ones shown in this tutorial. The result of thresholding is the following: You can identify the cat in this black-and-white image. However, you’d like to have an image in which all the pixels that correspond to the cat are white and all other pixels are black. In this image, you still have black regions in the area which corresponds to the cat, such as where the eyes, nose and mouth are, and you also still have white pixels elsewhere in the image. You can use the image processing techniques called erosion and dilation to create a better mask that represents the cat. You’ll learn about these two techniques in the next section. You can look at the image file called , which you can download from the repository linked to this tutorial: The left-hand side of this binary image shows a white dot on a black background, while the right-hand side shows a black hole in a solid white section. Erosion is the process of removing white pixels from the boundaries in an image. You can achieve this in a binary image by using as an argument for the method. This filter replaces the value of a pixel with the minimum value of the nine pixels in the array centered around the pixel. In a binary image, this means that a pixel will have the value of zero if any of its neighboring pixels are zero. You can see the effect of erosion by applying several times to the image. You should continue with the same REPL session as in the previous section: You’ve applied the filter three times using a loop. This code gives the following output: The dot has shrunk but the hole has grown as a result of erosion. Dilation is the opposite process to erosion. White pixels are added to the boundaries in a binary image. You can achieve dilation by using , which converts a pixel to white if any of its neighbors are white. You can apply dilation to the same image containing a dot and a hole, which you can open and load again: The dot has now grown bigger, and the hole has shrunk: You can use erosion and dilation together to fill in holes and remove small objects from a binary image. Using the image with a dot and hole, you can perform ten erosion cycles to remove the dot, followed by ten dilation cycles to restore the hole to its original size: You perform ten erosion cycles with the first loop. The image at this stage is the following: The dot has disappeared, and the hole is larger than it was in the original image. The second loop performs ten dilation cycles, which return the hole to its original size: However, the dot is no longer present in the image. The erosions and dilations have modified the image to keep the hole but remove the dot. The number of erosions and dilations needed depends on the image and what you want to achieve. Often, you’ll need to find the right combination through trial and error. You can define functions to perform several cycles of erosion and dilation: These functions make it easier to experiment with erosion and dilation for an image. You’ll use these functions in the next section as you continue working on placing the cat into the monastery. You can use a sequence of erosions and dilations on the threshold image that you obtained earlier to remove parts of the mask that don’t represent the cat and to fill in any gaps in the region containing the cat. Once you’ve experimented with erosion and dilation, you’ll be able to use educated guesses in a trial-and-error process to find the best combination of erosions and dilations to achieve the ideal mask. Starting with the image , which you obtained earlier, you can start with a series of erosions to remove the white pixels that represent the background in the original image. You should continue working in the same REPL session as in the previous sections: The eroded threshold image no longer contains white pixels representing the background of the image: However, the remaining mask is smaller than the overall outline of the cat and has holes and gaps within it. You can perform dilations to fill the gaps: The fifty-eight cycles of dilation filled all the holes in the mask to give the following image: However, this mask is too big. You can therefore finish the process with a series of erosions: The result is a mask that you can use to segment the image of the cat: You can avoid the sharp edges of a binary mask by blurring this mask. You’ll have to convert it from a binary image into a grayscale image first: The filter returns the following mask: The mask now looks like a cat! Now you’re ready to extract the image of the cat from its background: First, you create a blank image with the same size as . You create a new object from by using and setting all values to zero. Next, you use the function in to create an image made up from both and using to determine which parts of each image are used. The composite image is shown below: You’ve segmented the image of the cat and extracted the cat from its background. You can go a step further and paste the segmented image of the cat into the image of the monastery courtyard from the image repository for this tutorial: You’ve used to paste an image onto another one. This method can be used with three arguments:\n• The first argument is the image that you want to paste in. You’re resizing the image to one-fifth of its size using the integer division operator ( ).\n• The second argument is the location in the main image where you want to paste the second picture. The tuple includes the coordinates within the main image where you want to place the top-left corner of the image that you’re pasting in.\n• The third argument provides the mask that you wish to use if you don’t want to paste the entire image. You’ve used the mask that you obtained from the process of thresholding, erosion, and dilation to paste the cat without its background. The output is the following image: You’ve segmented the cat from one image and placed it into another image to show the cat sitting quietly in the monastery courtyard rather than in the field where it was sitting in the original image. Your final task in this example is to add the Real Python logo as a watermark to the image. You can get the image file with the Real Python logo from the repository accompanying this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You should continue working in the same REPL session: This is the full-size logo in color: You can change the image to grayscale and threshold it using to transform it into a black-and-white image. You also reduce its size and transform it into a contour image: The output shows the contour from the Real Python logo. The contour is ideal for using as a watermark on your image: To use this as a watermark, you’ll need to reverse the colors so that the background is black and only the outline that you want to keep is white. You can achieve this using again: You’ve converted the pixels that had a value of and assigned them the value , converting them from white to black pixels. You set the remaining pixels to white. The reversed outline logo is shown below: Your final step is to paste this outline onto the image of the cat sitting in the monastery courtyard. You can use again: The first argument in indicates the image that you wish to paste in, and the third argument represents the mask. In this case, you’re using the same image as a mask because the image is a binary image. The second argument provides the top-left coordinates of the region where you want to paste the image. The watermark has a rectangular outline, which is a result of the contour filter that you used earlier. If you prefer to remove this outline, you can crop the image using . This is an exercise that you can try on your own.\n\nPillow has an extensive selection of built-in functions and filters. However, there are times when you need to go further and manipulate images beyond the features that are already available in Pillow. You can manipulate the image further with the help of NumPy. NumPy is a very popular Python library for dealing with numeric arrays, and it’s an ideal tool to use with Pillow. You can learn more about NumPy in NumPy Tutorial: Your First Steps Into Data Science in Python. When you convert an image into a NumPy array, you can perform any transformations that you require directly on the pixels in the array. Once you’ve completed your processing in NumPy, you can convert the array back into an object using Pillow. You need to install NumPy for this section: Now that you’ve installed NumPy, you’re ready to use Pillow and NumPy to spot the difference between two images. Using NumPy to Subtract Images From Each Other See if you can spot the differences between the following two images: This isn’t a hard one! However, you decide to cheat and write a Python program to solve the puzzle for you. You can download the image files and (image credit) from the repository accompanying this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. Your first step is to read the images using Pillow and convert them to NumPy arrays: Since and are objects of type , you can manipulate them using all the tools that you have available in NumPy. You can subtract one array from the other to show the pixels that differ between the two images: When you subtract an array from another one of the same size, the result is another array with the same shape as the original arrays. You can convert this array into an image using in Pillow: The result of subtracting one NumPy array from another and converting into a Pillow is the difference image shown below: The difference image only shows three regions from the original image. These regions highlight the differences between the two images. You can also see some noise surrounding the cloud and the fence, which is due to small changes in the original JPEG compression in the region surrounding these items. You can go further and create images from scratch using NumPy and Pillow. You can start by creating a grayscale image. In this example, you’ll create a simple image containing a square, but you can create more elaborate images in the same way: You create an array of size containing zeros everywhere. Next, you set the value of a set of pixels at the center of the array to . You can index NumPy arrays using both rows and columns. In this example, the first slice, , represents the rows to . The second slice, , which follows the comma, represents the columns to . You can use to convert the NumPy array into an object of type . The output from the code above is shown below: You’ve created a grayscale image containing a square. The mode of the image is inferred automatically when you use . In this case, mode is used, which corresponds to an image with 32-bit floating-point pixels. You can convert this to a simpler grayscale image with 8-bit pixels if you wish: You can also go further and create a color image. You can repeat the process above to create three images, one corresponding to the red channel, another to the green, and a final one corresponding to the blue channel: You create an object from each NumPy array and convert the images to mode , which represents grayscale. Now, you can combine these three separate images into one RGB image using : The first argument in is the mode of the image output. The second argument is a sequence with the individual single-band images. This code creates the following image: You’ve combined the separate bands into an RGB color image. In the next section, you’ll go a step further and create a GIF animation using NumPy and Pillow. In the previous section, you created a color image containing three overlapping squares of different colors. In this section, you’ll create an animation showing those three squares merging into a single white square. You’ll create several versions of the images containing three squares, and the location of the squares will vary slightly between successive images: You create an empty list called , which you’ll use to store the various images that you generate. Within the loop, you create NumPy arrays for the red, green, and blue channels, as you did in the previous section. The array containing the green layer is always the same and represents a square in the center of the image. The red square starts in a position displaced to the top-left of the center. In each successive frame, the red square moves closer to the center until it reaches the center in the final iteration of the loop. The blue square is initially shifted toward the bottom-right then moves towards the center with each iteration. Note that in this example, you’re iterating over , which means that the variable increases in steps of two. You learned earlier that you can save an object to file using . You can use the same function to save to a GIF file that includes a sequence of images. You call on the first image in the sequence, which is the first image that you stored in the list : The first argument in is the filename for the file that you want to save. The extension in the filename tells what file format it needs to output. You also include two keyword arguments in :\n• ensures that all the images in the sequence are saved, and not just the first one.\n• allows you to append the remaining images in the sequence to the GIF file. This code saves to file, and you can then open the GIF file with any image software. The GIF should loop by default, but on some systems you’ll need to add the keyword argument to to make sure the GIF loops. The animation that you get is the following one: The three squares with different colors merge into a single white square. Can you create your own animation using different shapes and different colors?"
    },
    {
        "link": "https://auth0.com/blog/image-processing-in-python-with-pillow",
        "document": "If you’re building your application with Python and it needs to process images, you have a choice of libraries, including OpenCV, scikit-image, Python Imaging Library and Pillow.\n\nWe won't debate which library is the best here; they all have their merits. This article will focus on Pillow, a powerful library that provides a wide array of image processing features and is simple to use. To make the tutorial more interactive and easy to follow, we'll run all the code using Jupyter Notebooks.\n\nPillow is a fork of the Python Imaging Library (PIL). PIL is a library that offers several standard functions for manipulating images. It's a powerful library but hasn't been updated since 2009 and doesn't support Python 3.\n\nPillow builds on PIL, adding more features and support for Python 3. It supports a range of image file formats such as PNG, JPEG, PPM, GIF, TIFF, and BMP. We'll see how to perform various operations on images using this library, such as cropping, resizing, adding text to images, rotating, greyscaling, and more.\n\nYou can follow along by downloading our sample Jupyter notebook from GitHub, or you can create your own project and install the following packages:\n\nTo follow along, you can download the images (courtesy of Unsplash) that we'll use in the article.\n\nAll the code examples will assume the required images are in the same directory as your Jupyter Notebook file.\n\nYou’ll find the code for all the Pillow exercise in this article in a Jupyter Notebook in this GitHub repository.\n\nOf all the classes in Pillow, you’ll probably use\n\nthe most. It's defined in themodule and is the class that represents images and provides methods for loading or creating them, processing them, and displaying them.\n\nTo load an image from a file, use the\n\nfunction in themodule, which takes thefor the image as its argument:\n\nRun the cell. Here’s what it should look like in Jupyter Notebook:\n\nIf you’re using a command-line Python REPL (or something similar) instead of a Jupyter Notebook, you’ll need to call on an external viewer application to see the image. You can do this with\n\nGetting information about an image\n\nlaunches your system’s external viewer, using it to display the image. On Windows, it will usually launch Paint; on macOS, it will launch Preview; and on Linux and other Unix-based systems, it will launch xv.\n\nYou can get some information about an\n\nobject using its attributes. Enter the following into a new cell and run it:\n\nFor more on what you can do with the\n\n’smethod takes a two-integer tuple argument representing the width and height of the new resized image.\n\nHere’s an example that takes the image you loaded and resizes both its width and height to 300 pixels — enter it into a new cell and run it:\n\ndoesn't modify the image but returns anotherinstance with the new dimensions.\n\nchanges the image’s dimensions to the ones you provide, it doesn’t preserve the image’s aspect ratio unless you purposely do so. The resulting image may end up looking stretched or compressed, which may not be the effect you want. You can see this in the newly-created image from the code above; it looks a bit squished horizontally:\n\nIf you want to resize images and keep their aspect ratios, use\n\n’smethod instead. Liketakes a two-integer tuple argument. However, the values in the tuple represent the maximum x- and y-sizes allowed while also preserving the image’s aspect ratio.\n\nEnter the code below into a new cell and run it:\n\n, themethod does not create a newinstance. Instead, it modifies the original. That’s why the code above first makes a copy of the image.\n\nThe code above resize the image to 300 × 200 and preserves the original’s aspect ratio:\n\nAnother significant difference between the\n\nandmethods is thatenalrges an image if given parameters that are larger than the original image, whiledoesn't.\n\nFor example, given an image of size 400 × 200, a call to\n\nwill create a larger-sized image 1200 pixels wide and 600 pixels tall, along with the expected loss of sharpness. A similar call tousing the original image will not enlarge the image since themethod cannot expand an image beyond either of its original dimensions.\n\nThe rise of retrocomputing and retrogaming has created a lot of interest in old-school “pixelated” graphics. You can use a combination of\n\n’sandmethods to turn a modern, high-resolution image into a “retro” one like the one below:\n\nHere’s the code that produces this effect:\n\nThe code above takes advantage of the\n\nmethod’s optionalparameter, which specifies how to draw pixels when resizing the image. When making an image larger, the “nearest neighbor” resampling method creates a “retro” pixel effect.\n\nclass provides themethod for quick image flipping.takes the following arguments:\n\nHere’s how you would create a horizontal mirror image of the original:\n\nThe resulting image can be seen below. Notice that the puffin with the open beak is now on the left side of the photo:\n\narguments rotate the image counterclockwise 90, 180, and 270 degrees, respectively. The following rotates the image 180 degrees:\n\nTransposing an image means mirroring it along the diagonal line that runs from the top left to the bottom right, while tranversing it means mirroring it along the diagonal line running from the bottom left to the top right. This is yet another case where showing is better than telling, so let’s make the code do that.\n\nYou can rotate images with Pillow using\n\n’smethod. This takes an integer or float argument representing the degrees to rotate an image (positive for counterclockwise, negative for clockwise) and returns a newobject for the rotated image.\n\nBy default, the rotated image keeps the dimensions of the original image. This means that for angles other than multiples of 180, the image will be cut and/or padded to fit the original dimensions. Consider this code, which rotates an image 90 degrees counterclockwise:\n\nNotice that the image has been “clipped” to fit the original height, and its sides have been padded with black background (on some operating systems, the padding will be made of transparent pixels) to fit the original width.\n\nThe example below, where the original image is rotated 18 degrees counterclockwise, shows this “clipping” effect more clearly.\n\nThe resulting image is shown below:\n\nTo expand the dimensions of the rotated image to fit the entire view, you pass a second argument to\n\nNow the contents of the image will be fully visible, and the dimensions of the image will have increased to account for this:\n\n’smethod to create a new image by cropping a section from an existing one. This method takes a 4-tuple that defines the position and size of the cropped region, as shown in the method call example below:\n\nPillow’s coordinate system starts with (0, 0) in the upper left corner, with x increasing from left to right and y increasing from top to bottom:\n\nThe cropped section includes the left column and the upper row of pixels and goes up to — but doesn't include — the right column and bottom row of pixels. This is better explained with a diagram:\n\nHere’s an example that creates a new image by cropping the rectangle described below:\n\nPasting an Image onto Another Image\n\nPillow enables you to paste an image onto another one. Some example use cases where this could be useful is in the protection of publicly available images by adding watermarks on them, the branding of images by adding a company logo, and in any other case where there is a need to merge two images.\n\nclass’method pastes another image onto the current one. This is useful for protecting publicly available images by adding watermarks, branding images with a company logo, or simply creating compositions of two or more images.\n\nis unlike manymethods (but like) in that it modifies theobject in place rather than returning a new `one. Because of this, we'll first make a copy of our puffin image before performing the paste to continue with the other examples using the original.\n\nThe code above loads a new image,\n• A 2-tuple specifying the upper left corner of the pasted image,\n• a 4-tuple defining the left, upper, right, and lower pixel coordinates of the pasted image, or\n• , which simply pastes the image at the coordinates (0, 0).\n\n, and makes a copy of the puffin image. We want to paste the logo image onto the puffin image copy at the bottom right corner. The code calculates the coordinates for pasting the logo, which can be:\n\nIn this case, we’re pasting the logo using a 2-tuple coordinate:\n\nYou can see the result below:\n\n, transparent pixels are pasted as solid pixels by default. Hence the black (white on some OSs) box surrounding the logo. Most of the time, this isn't what you want. You can't have your watermark covering the underlying image's content. We would rather have transparent pixels appear as such.\n\nTo achieve this, you need to pass in an optional third argument to the\n\nmethod. This argument is anobject that acts as an opacity mask.\n\nAn opacity mask is an\n\nobject where only the alpha value is significant, while its green, red, and blue values are ignored. If a mask is provided as an optional third argument to, the method updates only the regions the mask indicated. You can use either, orimages for masks. Pasting an RGBA image and using it as the mask pastes only the opaque portion of the image — not its transparent background.\n\nThe code below provides an example of this approach:\n\nWith Pillow, you can also draw on an image using the ImageDraw module. You can draw lines, points, ellipses, rectangles, arcs, bitmaps, chords, pie slices, polygons, shapes, and text.\n\nThe code below draws a black rectangle with a fine white outline near the lower left corner of the puffin image from the previous code example. It then draws the text message “Hello, puffins!” in large white text inside the rectangle:\n\nConverting an image from color to grayscale\n\n’smethod can convert images between different pixel representations, such as the RGB (red-green-blue) format used by screens and the CMYK (cyan-magenta-yellow-black) format used in printing. Like mostmethods,returns a newobject.\n\nalso supports converting images to the(luminance) format, which is a grayscale image format. The code below converts our puffin image from color to grayscale monochrome:\n\nReducing the number of colors in an image\n\nIn addition to pixelation, another way to make an image look “retro” is to reduce the number of colors it uses to 256 or fewer. You can do this with a single call to\n\nThe code below reduces the number of colors in our puffin photo to 16, producing an effect that should remind you of 1990s computer graphics:\n\nmethod of Pillow’sclass makes it possible to split a multi-band image into individual bands, such as the R, G, and B bands from an RGB image.creates new images, each containing one band from the original image.\n\nhas an inverse function,, which merges a set of single band images into a new multi-band image.takes a mode and a tuple of images and combines them into a new image.\n\nThe code below takes the original “puffin” image, splits it into three images — one for each of the R, G, and B bands — and then merges them so that:\n\nPillow allows you to enhance an image by adjusting its contrast, color, brightness, and sharpness using classes in the\n\nHere’s code that boosts the contrast of the “puffin” image:\n\nHere’s the image after enhancing its contrast:\n\nThe code above adjusts the image contrast by a factor of 3; smaller values will produce more subtle effects. A factor of 1.0 returns a copy of the original image; lower factors produce images with lower contrast.\n\nBelow, we increase the color of the image. If we used a factor of\n\n, we would get a black and white image.\n\nBelow we make the image brighter. A factor of\n\nBelow, we make the image sharper. An enhancement factor of\n\nTo save an image, use\n\n’smethod. For example, here’s how you’d save the image from the Enhancing sharpness exercise above as a PNG file:\n\nPillow sees the file extension has been specified as\n\nand converts it to PNG before saving it to a file.\n\nTo save it as a JPEG image, use this:\n\nYou can provide a second argument to\n\nto explicitly specify a file format.will do the same thing as the previous save(). Usually, it's unnecessary to supply this second argument as Pillow will determine the file storage format to use from the filename extension, but if you're using non-standard extensions, you should always specify the format this way.\n\nIn this article, we've covered some of the more common image-processing operations in applications. Pillow is a powerful library, and we have yet to discuss everything it can do. If you want to find out more, be sure to read the documentation."
    },
    {
        "link": "https://geeksforgeeks.org/python-pil-image-resize-method",
        "document": "PIL is the Python Imaging Library which provides the python interpreter with image editing capabilities. The Image module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nImage.resize() Returns a resized copy of this image.\n\n\n\nSyntax: Image.resize(size, resample=0) \n\nParameters: \n\nsize – The requested size in pixels, as a 2-tuple: (width, height). \n\nresample – An optional resampling filter. This can be one of PIL.Image.NEAREST (use nearest neighbour), PIL.Image.BILINEAR (linear interpolation), PIL.Image.BICUBIC (cubic spline interpolation), or PIL.Image.LANCZOS (a high-quality downsampling filter). If omitted, or if the image has mode “1” or “P”, it is set PIL.Image.NEAREST. Otherwise, the default filter is Resampling.BICUBIC. \n\nReturns type: An Image object.\n\n\n\nAnother example:Here we use the different newsize value.\n\n\n\n\n\n What is the PIL Function in Python?\n\nWhat Does PIL Stand For in Python?\n\nHow to Import PIL Image in Python?\n\nTo import an image using PIL (now Pillow), you first need to install Pillow, then use the module to open and manipulate images. Here’s how to import and open an image: \n\n\n\n\n\n \n\n img.show() # Displays the image using an external viewer\n\nWhat is the Difference Between Numpy and PIL?\n\nNumpy and PIL (Pillow) are both powerful libraries in Python but serve different purposes:\n• Numpy : Primarily used for numerical operations and serves as the foundational package for scientific computing with Python. It provides a high-performance multidimensional array object and tools for working with these arrays. It’s typically used for large-scale numerical computations.\n• PIL/Pillow : Focused on image processing capabilities. It can read, write, and manipulate image data in various formats. Pillow provides functionality that is specifically geared towards image editing, such as cropping, rotating, converting between formats, and applying filters. Both can be used together, for example, converting a PIL image into a NumPy array to perform complex numerical operations on image data, then converting it back to a PIL image for saving or further manipulation.\n\nHow to Install PIL in Python Command?\n\nSince the original PIL is no longer maintained, you should install Pillow, the friendly PIL fork, which is fully backward compatible with PIL. You can install it using pip: This command installs Pillow, and you can start using it under the namespace, as shown in the import example earlier. Pillow continues to use the namespace to make it a drop-in replacement for legacy PIL installations"
    },
    {
        "link": "https://pillow.readthedocs.io/en/latest/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    }
]