[
    {
        "link": "https://legacy.reactjs.org/docs/state-and-lifecycle.html",
        "document": "This page introduces the concept of state and lifecycle in a React component. You can find a detailed component API reference here.\n\nConsider the ticking clock example from one of the previous sections. In Rendering Elements, we have only learned one way to update the UI. We call to change the rendered output:\n\nTry it on CodePen\n\nIn this section, we will learn how to make the component truly reusable and encapsulated. It will set up its own timer and update itself every second.\n\nWe can start by encapsulating how the clock looks:\n\nTry it on CodePen\n\nHowever, it misses a crucial requirement: the fact that the sets up a timer and updates the UI every second should be an implementation detail of the .\n\nIdeally we want to write this once and have the update itself:\n\nTo implement this, we need to add “state” to the component.\n\nState is similar to props, but it is private and fully controlled by the component.\n\nYou can convert a function component like to a class in five steps:\n• Create an ES6 class, with the same name, that extends .\n• Move the body of the function into the method.\n• Replace with in the body.\n\nTry it on CodePen\n\nis now defined as a class rather than a function.\n\nThe method will be called each time an update happens, but as long as we render into the same DOM node, only a single instance of the class will be used. This lets us use additional features such as local state and lifecycle methods.\n\nWe will move the from props to state in three steps:\n• Replace with in the method:\n\nNote how we pass to the base constructor:\n\nClass components should always call the base constructor with .\n• Remove the prop from the element:\n\nWe will later add the timer code back to the component itself.\n\nThe result looks like this:\n\nTry it on CodePen\n\nNext, we’ll make the set up its own timer and update itself every second.\n\nIn applications with many components, it’s very important to free up resources taken by the components when they are destroyed.\n\nWe want to set up a timer whenever the is rendered to the DOM for the first time. This is called “mounting” in React.\n\nWe also want to clear that timer whenever the DOM produced by the is removed. This is called “unmounting” in React.\n\nWe can declare special methods on the component class to run some code when a component mounts and unmounts:\n\nThe method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:\n\nNote how we save the timer ID right on ( ).\n\nWhile is set up by React itself and has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID).\n\nWe will tear down the timer in the lifecycle method:\n\nFinally, we will implement a method called that the component will run every second.\n\nIt will use to schedule updates to the component local state:\n\nTry it on CodePen\n\nNow the clock ticks every second.\n\nLet’s quickly recap what’s going on and the order in which the methods are called:\n• When is passed to , React calls the constructor of the component. Since needs to display the current time, it initializes with an object including the current time. We will later update this state.\n• React then calls the component’s method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the ’s render output.\n• When the output is inserted in the DOM, React calls the lifecycle method. Inside it, the component asks the browser to set up a timer to call the component’s method once a second.\n• Every second the browser calls the method. Inside it, the component schedules a UI update by calling with an object containing the current time. Thanks to the call, React knows the state has changed, and calls the method again to learn what should be on the screen. This time, in the method will be different, and so the render output will include the updated time. React updates the DOM accordingly.\n• If the component is ever removed from the DOM, React calls the lifecycle method so the timer is stopped.\n\nThere are three things you should know about .\n\nFor example, this will not re-render a component:\n\nThe only place where you can assign is the constructor.\n\nReact may batch multiple calls into a single update for performance.\n\nBecause and may be updated asynchronously, you should not rely on their values for calculating the next state.\n\nFor example, this code may fail to update the counter:\n\nTo fix it, use a second form of that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:\n\nWe used an arrow function above, but it also works with regular functions:\n\nWhen you call , React merges the object you provide into the current state.\n\nFor example, your state may contain several independent variables:\n\nThen you can update them independently with separate calls:\n\nThe merging is shallow, so leaves intact, but completely replaces .\n\nNeither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.\n\nThis is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.\n\nA component may choose to pass its state down as props to its child components:\n\nThe component would receive the in its props and wouldn’t know whether it came from the ’s state, from the ’s props, or was typed by hand:\n\nTry it on CodePen\n\nThis is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.\n\nIf you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.\n\nTo show that all components are truly isolated, we can create an component that renders three s:\n\nTry it on CodePen\n\nEach sets up its own timer and updates independently.\n\nIn React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa."
    },
    {
        "link": "https://react.dev/learn/managing-state",
        "document": "Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset. Read More Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs! For example, this form has a redundant state variable:\n\nThis might seem like a small change, but many bugs in React apps are fixed this way. Read Choosing the State Structure to learn how to design the state shape to avoid bugs. Read More Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.\n\nRead Sharing State Between Components to learn how to lift state up and keep components in sync. Read More When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:\n\nReact lets you override the default behavior, and force a component to reset its state by passing it a different , like . This tells React that if the recipient is different, it should be considered a different component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.\n\nRead Preserving and Resetting State to learn the lifetime of state and how to control it. Read More Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!\n\nRead Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function. Read More Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props. Here, the component determines its heading level by “asking” the closest for its level. Each tracks its own level by asking the parent and adding one to it. Every provides information to all components below it without passing props—it does that through context.\n\nRead Passing Data Deeply with Context to learn about using context as an alternative to passing props. Read More Scaling up with reducer and context Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state."
    },
    {
        "link": "https://medium.com/@rashmipatil24/react-lifecycle-methods-and-hooks-28522be7d7e4",
        "document": "React is a popular JavaScript library for building dynamic user interfaces. To fully harness its power, understanding how components evolve throughout their lifecycle is crucial. In React, class components have lifecycle methods that allow developers to manage the various stages of a component’s existence, from creation to unmounting. With the introduction of React Hooks, developers now have a simpler, more functional approach to handling component lifecycle events.\n\nIn this blog, we’ll cover the traditional lifecycle methods in class components and introduce the key React Hooks, including and , that have revolutionized functional components.\n\nBefore Hooks, React components used classes to manage state and lifecycle events. Every class component in React goes through a lifecycle that consists of three main phases:\n• Mounting: When the component is being created and inserted into the DOM.\n• Updating: When the component is being re-rendered due to changes in props or state.\n• Unmounting: When the component is being removed from the DOM.\n\nDuring the mounting phase, the component is created and added to the DOM. React provides the following lifecycle methods for this phase:\n• : This is the first method that runs in a component’s lifecycle. It is mainly used for initializing state or binding event handlers.\n• : Called immediately after the component is mounted. It’s often used for fetching data from an API or interacting with the DOM.\n\nIn the updating phase, a component re-renders in response to changes in state or props. The following lifecycle methods are available:\n• : This method is called after a component has updated. It allows you to perform actions after the component has been re-rendered, such as updating the DOM or making new API requests.\n\nThe unmounting phase occurs when the component is removed from the DOM. The only lifecycle method available in this phase is:\n• : This method is called right before a component is removed from the DOM. It’s useful for cleaning up resources like timers or event listeners.\n\nReact Hooks, introduced in React 16.8, allow functional components to manage state and lifecycle events, eliminating the need for class components in most cases. The two most essential hooks that replace lifecycle methods are and .\n\nThe Hook allows you to add state to functional components. It returns an array containing the current state value and a function to update it.\n\nHere, initializes the state variable with a value of 0. The function is used to update the state whenever the button is clicked.\n\nThe Hook serves the same purpose as lifecycle methods like , , and . It allows you to perform side effects, such as data fetching or interacting with the DOM, in functional components.\n\nIn this example:\n• The Hook is used to fetch data when the component mounts.\n• The empty dependency array ( ) ensures the effect only runs on mount and unmount.\n• Class Components vs. Functional Components:\n\nLifecycle methods are exclusive to class components, while Hooks bring similar functionality to functional components.\n• Multiple Effects:\n\nWith Hooks, you can have multiple calls to handle different side effects, whereas lifecycle methods combine everything into a single method (e.g., for all initialization logic).\n• Simplified Code:\n\nHooks allow for more concise and readable code compared to lifecycle methods, especially when handling state and side effects in smaller, focused chunks.\n• No Need for :\n\nClass components require binding to access state and props, which can lead to confusion. Hooks eliminate this issue, making functional components easier to work with.\n\nWhen to Use Lifecycle Methods vs. Hooks\n\nReact encourages developers to use Hooks over class components for new projects due to their simplicity and flexibility. However, you may still encounter class components in legacy codebases, and understanding lifecycle methods is essential for maintaining such projects.\n• Use Hooks for managing state and side effects in functional components.\n• Use Lifecycle Methods in class components only if you’re working with older codebases that haven’t migrated to Hooks.\n\nReact lifecycle methods and Hooks are fundamental concepts for managing a component’s state and side effects throughout its existence. While class components rely on lifecycle methods to handle various phases, Hooks provide a more modern, functional approach that simplifies state management and side effects.\n\nWhether you’re working with class components or functional components, mastering these concepts will help you build more dynamic, responsive, and maintainable React applications.\n\nNow that you’ve learned the basics of React lifecycle methods and Hooks, why not dive deeper into your own projects? Try refactoring a class component to use Hooks or experiment with managing side effects using . Don't forget to subscribe for more React tips and tutorials, and feel free to leave a comment if you have any questions!"
    },
    {
        "link": "https://react.dev/learn/lifecycle-of-reactive-effects",
        "document": "Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state.\n• How an Effect’s lifecycle is different from a component’s lifecycle\n• How to think about each individual Effect in isolation\n• When your Effect needs to re-synchronize, and why\n• How your Effect’s dependencies are determined\n• What it means for a value to be reactive\n• How React verifies your dependencies are correct with a linter\n• What to do when you disagree with the linter The lifecycle of an Effect Every React component goes through the same lifecycle:\n• A component mounts when it’s added to the screen.\n• A component updates when it receives new props or state, usually in response to an interaction.\n• A component unmounts when it’s removed from the screen. It’s a good way to think about components, but not about Effects. Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how to synchronize an external system to the current props and state. As your code changes, synchronization will need to happen more or less often. To illustrate this point, consider this Effect connecting your component to a chat server: Your Effect’s body specifies how to start synchronizing: The cleanup function returned by your Effect specifies how to stop synchronizing: Intuitively, you might think that React would start synchronizing when your component mounts and stop synchronizing when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted. Let’s look at why this is necessary, when it happens, and how you can control this behavior. Some Effects don’t return a cleanup function at all. More often than not, you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function. Why synchronization may need to happen more than once Imagine this component receives a prop that the user picks in a dropdown. Let’s say that initially the user picks the room as the . Your app displays the chat room: Welcome to the room!\n\n After the UI is displayed, React will run your Effect to start synchronizing. It connects to the room: Later, the user picks a different room in the dropdown (for example, ). First, React will update the UI: Welcome to the room!\n\n Think about what should happen next. The user sees that is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the room. The prop has changed, so what your Effect did back then (connecting to the room) no longer matches the UI. At this point, you want React to do two things:\n• Stop synchronizing with the old (disconnect from the room)\n• Start synchronizing with the new (connect to the room) Luckily, you’ve already taught React how to do both of these things! Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens. Recall that your component has received a new value for its prop. It used to be , and now it is . React needs to re-synchronize your Effect to re-connect you to a different room. To stop synchronizing, React will call the cleanup function that your Effect returned after connecting to the room. Since was , the cleanup function disconnects from the room: Then React will run the Effect that you’ve provided during this render. This time, is so it will start synchronizing to the chat room (until its cleanup function is eventually called too): Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted! Every time after your component re-renders with a different , your Effect will re-synchronize. For example, let’s say the user changes from to . React will again stop synchronizing your Effect by calling its cleanup function (disconnecting you from the room). Then it will start synchronizing again by running its body with the new prop (connecting you to the room). Finally, when the user goes to a different screen, unmounts. Now there is no need to stay connected at all. React will stop synchronizing your Effect one last time and disconnect you from the chat room. Let’s recap everything that’s happened from the component’s perspective: During each of these points in the component’s lifecycle, your Effect did different things:\n• Your Effect connected to the room\n• Your Effect disconnected from the room and connected to the room\n• Your Effect disconnected from the room and connected to the room\n• Your Effect disconnected from the room Now let’s think about what happened from the perspective of the Effect itself: This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:\n• Your Effect connected to the room (until it disconnected)\n• Your Effect connected to the room (until it disconnected)\n• Your Effect connected to the room (until it disconnected) Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid. Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed. This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React figures out the rest. How React verifies that your Effect can re-synchronize Here is a live example that you can play with. Press “Open chat” to mount the component:\n\nNotice that when the component mounts for the first time, you see three logs: The first two logs are development-only. In development, React always remounts each component once. React verifies that your Effect can re-synchronize by forcing it to do that immediately in development. This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check you’ve implemented its cleanup well. The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the changes, your Effect re-synchronizes. However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization. How React knows that it needs to re-synchronize the Effect You might be wondering how React knew that your Effect needed to re-synchronize after changes. It’s because you told React that its code depends on by including it in the list of dependencies:\n• You knew is a prop, which means it can change over time.\n• You knew that your Effect reads (so its logic depends on a value that may change later).\n• This is why you specified it as your Effect’s dependency (so that it re-synchronizes when changes). Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect. For example, if you passed during the initial render, and later you passed during the next render, React will compare and . These are different values (compared with ), so React will re-synchronize your Effect. On the other hand, if your component re-renders but has not changed, your Effect will remain connected to the same room. Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends on , so you might feel tempted to add the analytics call there: But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects: Each Effect in your code should represent a separate and independent synchronization process. In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner. Your Effect reads two variables ( and ), but you only specified as a dependency: Why doesn’t need to be a dependency? This is because the never changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. Since never changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time! On the other hand, may be different on a re-render. Props, state, and other values declared inside the component are reactive because they’re calculated during rendering and participate in the React data flow. If was a state variable, it would be reactive. Reactive values must be included in dependencies: By including as a dependency, you ensure that the Effect re-synchronizes after it changes. Try changing the selected chat room or edit the server URL in this sandbox:\n\nHowever, if you think from the Effect’s perspective, you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change or over time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies. All variables declared in the component body are reactive Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list. Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in a context so you read the from that context. Now you calculate the based on the selected server from props and the default server: In this example, is not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive. All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies. In other words, Effects “react” to all values from the component body. Can global or mutable values be dependencies? A mutable value like can’t be a dependency. It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React wouldn’t know to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks purity of rendering. Instead, you should read and subscribe to an external mutable value with . A mutable value like or things you read from it also can’t be a dependency. The ref object returned by itself can be a dependency, but its property is intentionally mutable. It lets you keep track of something without triggering a re-render. But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes. As you’ll learn below on this page, a linter will check for these issues automatically. React verifies that you specified every reactive value as a dependency If your linter is configured for React, it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because both and are reactive:\n\nThis may look like a React error, but really React is pointing out a bug in your code. Both and may change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initial and even after the user picks different values in the UI. To fix the bug, follow the linter’s suggestion to specify and as dependencies of your Effect: Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed. In some cases, React knows that a value never changes even though it’s declared inside the component. For example, the function returned from and the ref object returned by are stable—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter. What to do when you don’t want to re-synchronize In the previous example, you’ve fixed the lint error by listing and as dependencies. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if and don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies: You can also move them inside the Effect. They aren’t calculated during rendering, so they’re not reactive: Effects are reactive blocks of code. They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary. You can’t “choose” your dependencies. Your dependencies must include every reactive value you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:\n• Check that your Effect represents an independent synchronization process. If your Effect doesn’t synchronize anything, it might be unnecessary. If it synchronizes several independent things, split it up.\n• If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect, you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called an Effect Event). Read about separating Events from Effects.\n• Avoid relying on objects and functions as dependencies. If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. Read more about removing unnecessary dependencies from Effects. The linter is your friend, but its powers are limited. The linter only knows when the dependencies are wrong. It doesn’t know the best way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’t need to be a dependency. If you have an existing codebase, you might have some Effects that suppress the linter like this: On the next pages, you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!\n• Each Effect has a separate lifecycle from the surrounding component.\n• Each Effect describes a separate synchronization process that can start and stop.\n• When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).\n• Reactive values should re-synchronize the Effect because they can change over time.\n• The linter verifies that all reactive values used inside the Effect are specified as dependencies.\n• All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules."
    },
    {
        "link": "https://medium.com/@vyakymenko/react-18-a-comprehensive-guide-to-the-latest-features-and-improvements-82825f209ae7",
        "document": "Lets explore the most recent version of React, diving into key features, improvements, and best practices to leverage in your projects.\n\nHey fellow developer! Welcome to this comprehensive guide on React 18. We’ll provide an overview of the latest version of React, discuss the key features and improvements, and compare it to previous versions. So, let’s dive in!\n\nReact 18 is the latest major release of the popular JavaScript library for building user interfaces. The React team has been hard at work to bring us new features and optimizations that improve both the developer experience and application performance.\n\nSome of the most notable features and improvements in React 18 include:\n• Concurrent Mode: This long-awaited feature allows React to work on multiple tasks simultaneously, leading to a smoother, more responsive user interface. This is particularly useful for complex and data-heavy applications, as it prevents the UI from becoming unresponsive due to long-running tasks.\n• React Server Components: This new feature enables developers to build modern applications with server-rendered components, improving performance and reducing the amount of JavaScript code that needs to be sent to the client.\n• Automatic Batching: React 18 now batches multiple state updates together, reducing the number of renders and improving performance. This is particularly useful in situations where multiple updates occur in quick succession, such as in response to user input.\n• Improved Suspense: React 18 brings enhancements to the Suspense feature, making it easier to handle data fetching, loading states, and error boundaries in your applications.\n\nCompared to previous versions, React 18 offers a more efficient and flexible approach to building user interfaces, with a strong focus on performance and developer experience. While some of these features were available as experimental features in previous versions, they are now stable and ready for use in production applications.\n\nIn the following chapters, we’ll dive deeper into each of these features and learn how to implement them in our projects. We’ll also explore best practices, migration strategies, and integration with other tools and libraries in the React ecosystem.\n\nConcurrent Mode is a new way for React to handle the rendering of components and updates to the DOM. It allows React to work on multiple tasks simultaneously without blocking the main thread, resulting in a smoother and more responsive user interface. This is especially beneficial for large, complex applications where long-running tasks can cause the UI to become unresponsive.\n\nHere are some of the key benefits of Concurrent Mode:\n• Improved responsiveness: By allowing React to work on multiple tasks at once, your application can remain responsive even during heavy workloads or when rendering large component trees.\n• Smoother transitions: Concurrent Mode helps to avoid janky animations and transitions by prioritizing user interactions over other tasks.\n• Easier to reason about: By introducing a more predictable rendering model, Concurrent Mode makes it easier to understand and reason about the behavior of your application.\n\nNow, let’s see how we can enable Concurrent Mode in our React application. It’s important to note that Concurrent Mode is an opt-in feature, which means you’ll need to explicitly enable it for your application.\n\nFirst, you’ll need to update your React and ReactDOM packages to version 18 or higher. You can do this using your package manager of choice:\n\nNext, you’ll need to wrap your application’s root component with the function from the package. Replace the traditional function with the new function like this:\n\nThat’s it! With just a few simple changes, you’ve enabled Concurrent Mode in your React application.\n\nIt’s important to note that while Concurrent Mode provides many benefits, it may also expose issues in your existing codebase. It’s recommended to test your application thoroughly after enabling Concurrent Mode to ensure everything works as expected.\n\nReact Server Components aim to improve application performance by reducing the amount of JavaScript code sent to the client. They enable you to offload some of the rendering work to the server, which can result in faster initial load times and improved user experience, especially on slower devices and networks.\n• Server rendering: Components are rendered on the server and sent to the client as HTML. This can lead to faster initial load times and improved SEO but may result in slower interactivity as the client waits for data to be fetched from the server.\n• Client rendering: Components are rendered on the client-side, usually in the browser. This approach provides faster interactivity but may result in slower initial load times as the client has to download and parse JavaScript code before rendering components.\n\nReact Server Components strike a balance between these two approaches. They are rendered on the server but can be seamlessly integrated with client-rendered components, allowing you to build applications that are both fast and interactive.\n\nHere’s how you can start using React Server Components in your application:\n• Update your React and ReactDOM packages to version 18 or higher, if you haven’t already:\n• Create a new file for your Server Component with the extension, like . This naming convention is important, as it tells React that this file contains a Server Component:\n• Import and use your Server Component in a client component:\n\nKeep in mind that React Server Components have some limitations, such as not being able to use DOM-related APIs or certain React features like . Make sure to check the documentation for a complete list of limitations and best practices when working with Server Components.\n\nIn React 18, automatic batching is introduced as a new feature to optimize performance. This chapter will provide an overview of automatic batching, explain how it works in React 18, and discuss the performance benefits and use cases of this feature.\n\nAutomatic batching is a mechanism that combines multiple state updates into a single render cycle. In previous versions of React, multiple state updates within event handlers were already batched. However, with React 18, this batching behavior is extended to asynchronous operations and other scenarios as well. This allows the application to render more efficiently by reducing the number of render cycles needed.\n\nHere’s an example that demonstrates the difference in behavior between React 17 and React 18:\n\nIn React 17, the two state updates within the would trigger two separate renders. However, in React 18, these updates are automatically batched together, resulting in just one render cycle.\n• Improved performance: By reducing the number of renders, automatic batching can lead to a significant performance improvement, especially when dealing with multiple state updates in quick succession.\n• Simplified code: With automatic batching, you don’t need to manually group state updates together using or other workarounds.\n• More predictable behavior: Automatic batching makes it easier to reason about your application’s behavior, as you no longer need to worry about the specific timing of state updates and renders.\n\nIn conclusion, automatic batching is a powerful feature in React 18 that enables you to optimize the performance of your application by reducing the number of render cycles needed. By taking advantage of this feature, you can create more efficient and responsive applications, providing a better user experience.\n\nIn upcoming chapters, we’ll explore other new features and improvements in React 18, such as enhanced Suspense and React DevTools updates. Stay tuned as we continue to delve into the exciting world of React 18!\n\nReact 18 brings several improvements to Suspense, including better support for handling loading states and error boundaries, integration with Concurrent Mode, and support for Server Components. These enhancements make it even more powerful and easier to work with.\n\nLet’s start by discussing how to use Suspense for data fetching. In React 18, you can use the function in combination with the and hooks to fetch data and manage loading states:\n• Next, create a custom hook to fetch data using Suspense:\n• Finally, use the custom hook and Suspense in your component:\n\nIn this example, the component uses the hook to fetch data from an API endpoint. The component wraps the component, providing a fallback UI to display while the data is being fetched.\n\nError boundaries can also be integrated with Suspense to handle errors during data fetching and rendering. To do this, create an error boundary component and wrap it around your Suspense-wrapped components:\n\nIn this setup, the component wraps the component. If an error occurs during data fetching or rendering, the component will catch the error and display a fallback UI, preventing the entire application from crashing.\n\nBy combining Suspense and error boundaries, you can create more robust and resilient applications that gracefully handle data fetching, loading states, and errors.\n\nIn addition to the improvements mentioned above, React 18 also includes better integration between Suspense and Concurrent Mode. This allows Suspense to take full advantage of the performance benefits provided by Concurrent Mode, such as smoother transitions and improved responsiveness.\n\nIn summary, React 18 brings a variety of improvements to the Suspense feature, making it even more powerful and easier to work with. By using Suspense in combination with error boundaries and Concurrent Mode, you can create applications that handle data fetching, loading states, and errors gracefully, providing a better user experience.\n\nReact DevTools is a powerful browser extension that provides a suite of debugging tools to help you inspect and understand your React application’s component hierarchy, state, and props. With React 18, DevTools receives several updates that make it even more useful for debugging and profiling your applications.\n\nHere are some of the key updates to React DevTools in React 18:\n• Improved component filtering: React DevTools now allows you to filter components by name, state, and props more easily. This makes it simpler to find and focus on specific components within large and complex applications.\n• Concurrent Mode support: With the introduction of Concurrent Mode in React 18, DevTools now includes the ability to visualize and debug components rendered using Concurrent Mode. This helps you understand how your components are being prioritized and updated in real-time.\n• Server Components support: React DevTools has been updated to support React Server Components, allowing you to inspect server-rendered components and their props, state, and context. This makes it easier to debug and understand the behavior of your Server Components.\n• Enhanced performance profiling: The performance profiler in React DevTools has been improved to provide more accurate and detailed information about component render times, state updates, and other performance metrics. This can help you identify performance bottlenecks and optimize your application.\n• Improved error handling: React DevTools now provides more helpful error messages and stack traces when an error occurs in your application. This makes it easier to identify and fix issues as they arise.\n\nTo get started with the updated React DevTools, you’ll need to install or update the browser extension for your preferred browser:\n\nAfter installing or updating the extension, open your React application in the browser and open the browser’s developer tools. You should see a new “React” tab, which gives you access to the React DevTools features.\n\nIn conclusion, the updates to React DevTools in React 18 provide even more powerful and useful tools for debugging and profiling your applications. By taking advantage of these enhancements, you can gain deeper insights into your application’s behavior, performance, and component hierarchy, making it easier to identify and fix issues and optimize your application.\n\nUpgrading to a new major version of a library or framework can be challenging, but the React team has put significant effort into ensuring a smooth and gradual migration path. We’ll cover the recommended steps and best practices for upgrading your application to React 18 while minimizing disruptions to your development process and users.\n\nHere’s a high-level overview of the recommended migration process for upgrading to React 18:\n• Update your dependencies: Before upgrading to React 18, ensure that your application’s dependencies are compatible with React 18 or have been updated to support the new version. Check the documentation and release notes of your dependencies for compatibility information and follow any necessary upgrade steps.\n• Install React 18: Update your and packages to version 18:\n• Opt-in to Concurrent Mode (optional): React 18 introduces Concurrent Mode, a new rendering strategy that can significantly improve the performance and responsiveness of your application. While opting into Concurrent Mode is not required, it’s recommended to take advantage of its benefits. To enable Concurrent Mode, update the call in your application's entry point:\n• Test your application: After updating to React 18 and enabling Concurrent Mode, thoroughly test your application to ensure that it continues to work correctly. Pay special attention to areas where new features and changes in React 18 may have an impact, such as error boundaries, Suspense, and component lifecycle methods.\n• Address any warnings and deprecations: React 18 may introduce new warnings and deprecations for features or patterns that are no longer recommended. Carefully review any warnings or deprecations in your application and follow the recommended migration steps to address them.\n• Adopt new features incrementally: Once your application is running smoothly on React 18, you can start adopting new features and improvements incrementally. For example, you might begin using React Server Components, the improved Suspense features, or the automatic batching of state updates. Introduce these changes one at a time and thoroughly test your application to ensure a smooth transition.\n• Monitor and optimize performance: As you adopt new features in React 18, monitor your application’s performance to ensure that it remains optimal. Use tools like React DevTools, browser developer tools, and third-party monitoring solutions to identify any performance bottlenecks or regressions and make any necessary optimizations.\n\nIn summary, upgrading to React 18 is a manageable process that can be carried out in a gradual and controlled manner. By following the recommended migration steps and best practices, you can ensure a smooth transition to React 18 while minimizing disruptions to your development process and users.\n\nWith your application now running on React 18, you can take full advantage of the new features and improvements it offers. As we’ve explored throughout this series, React 18 brings many exciting enhancements, such as React Server Components, improved Suspense features, automatic batching, and more. I hope that you find these new features valuable in building more performant, responsive, and enjoyable applications for your users.\n\nBy following these recommendations, you can create more maintainable, performant, and scalable applications that are easier to debug and provide a better user experience.\n• Leverage React Server Components: React Server Components allow you to build parts of your application that run on the server, reducing the amount of JavaScript that needs to be sent to the client. This can result in faster load times and improved performance. Consider using Server Components for parts of your application that do not require interactivity or immediate updates.\n• Embrace Concurrent Mode: Concurrent Mode is a powerful new rendering strategy introduced in React 18 that can significantly improve the performance and responsiveness of your application. By opting into Concurrent Mode, you can take advantage of features like automatic batching, improved Suspense, and smoother transitions.\n• Use React.lazy and Suspense for code splitting: Code splitting is an important technique for reducing the initial load time of your application by loading only the necessary parts of the application when needed. Use in combination with Suspense to split your application into smaller chunks that can be loaded on-demand.\n• Handle errors gracefully with error boundaries: Error boundaries allow you to catch and handle errors in your application more effectively, preventing the entire application from crashing. Use error boundaries in combination with Suspense to handle errors during data fetching, rendering, and other operations.\n• Optimize performance with React DevTools: React DevTools is an essential tool for debugging and profiling your React applications. Use the updated DevTools in React 18 to gain deeper insights into your application’s behavior, performance, and component hierarchy. This can help you identify and fix issues, optimize performance, and improve the overall quality of your application.\n• Use functional components and hooks: Functional components and hooks have become the recommended way to build components in React. They provide a simpler and more concise syntax, better performance, and improved support for features like Concurrent Mode. When building new components or refactoring existing ones, consider using functional components and hooks.\n• Keep your component hierarchy shallow and modular: A shallow and modular component hierarchy makes it easier to understand, maintain, and optimize your application. Break down complex components into smaller, reusable parts, and avoid deep nesting of components whenever possible.\n• Write tests for your components: Writing tests for your components helps ensure that they work correctly and continue to do so as your application evolves. Use testing libraries like React Testing Library or Enzyme to write unit and integration tests for your components.\n• Stay up-to-date with React releases and best practices: The React ecosystem is constantly evolving, with new features, improvements, and best practices being introduced regularly. Stay informed about new releases and best practices by following the React team’s blog, attending conferences, and participating in the React community.\n\nBy following these best practices, you can create more maintainable, performant, and scalable applications using React 18. As you continue to explore the new features and improvements in React 18, you’ll find even more ways to build better applications that provide a great user experience.\n\nReact 18 and the Future of Web Development\n\nAs a major release, React 18 brings numerous new features and improvements that have the potential to shape the way we build web applications moving forward.\n• The rise of server-side rendering and hybrid applications: With the introduction of React Server Components, React 18 has brought server-side rendering back into the spotlight. As developers embrace the benefits of reduced JavaScript payloads and faster load times, we can expect to see more hybrid applications that leverage both server-rendered and client-rendered components for an optimal balance of performance and interactivity.\n• Enhanced performance with Concurrent Mode: Concurrent Mode is a game-changing feature that enables React to work on multiple tasks simultaneously, leading to smoother transitions and improved responsiveness. As more developers adopt Concurrent Mode, we can expect web applications to become more performant and provide better user experiences.\n• Focus on user experience and accessibility: React 18’s improved Suspense and error handling capabilities make it easier to build applications that gracefully handle data fetching, loading states, and errors. This focus on user experience and accessibility will continue to be a priority for the React team and the broader web development community.\n• Greater emphasis on web performance optimization: React 18’s enhancements, such as automatic batching and the updated DevTools, provide developers with more tools to optimize their applications’ performance. As web applications become increasingly complex, performance optimization will continue to be a critical aspect of web development.\n• Growing adoption of React in new platforms and environments: React has already expanded beyond the web with projects like React Native and React VR. With React 18’s improvements and innovations, we can expect React to be adopted in even more platforms and environments, enabling developers to build consistent and performant user interfaces across a wide range of devices and technologies.\n• Continued growth of the React ecosystem: As React continues to evolve, we can expect the React ecosystem to grow alongside it. This includes the development of new tools, libraries, and best practices that help developers build better applications more efficiently. By staying up-to-date with the latest trends and innovations in the React ecosystem, you’ll be well-equipped to navigate the ever-changing landscape of web development.\n\nIn conclusion, React 18 marks an exciting new chapter in the world of web development. Its many new features and improvements have the potential to shape the way we build web applications for years to come. As you continue to explore React 18 and build your applications using the latest best practices, you’ll be well-prepared for the future of web development."
    },
    {
        "link": "https://legacy.reactjs.org/docs/handling-events.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nHandling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:\n• React events are named using camelCase, rather than lowercase.\n• With JSX you pass a function as the event handler, rather than a string.\n\nFor example, the HTML:\n\nis slightly different in React:\n\nAnother difference is that you cannot return to prevent default behavior in React. You must call explicitly. For example, with plain HTML, to prevent the default form behavior of submitting, you can write:\n\nIn React, this could instead be:\n\nHere, is a synthetic event. React defines these synthetic events according to the W3C spec, so you don’t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the reference guide to learn more.\n\nWhen using React, you generally don’t need to call to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.\n\nWhen you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this component renders a button that lets the user toggle between “ON” and “OFF” states:\n\nTry it on CodePen\n\nYou have to be careful about the meaning of in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind and pass it to , will be when the function is actually called.\n\nThis is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without after it, such as , you should bind that method.\n\nIf calling annoys you, there are two ways you can get around this. You can use public class fields syntax to correctly bind callbacks:\n\nThis syntax is enabled by default in Create React App.\n\nIf you aren’t using class fields syntax, you can use an arrow function in the callback:\n\nThe problem with this syntax is that a different callback is created each time the renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.\n\nInside a loop, it is common to want to pass an extra parameter to an event handler. For example, if is the row ID, either of the following would work:\n\nThe above two lines are equivalent, and use arrow functions and respectively.\n\nIn both cases, the argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with any further arguments are automatically forwarded."
    },
    {
        "link": "https://react.dev/reference/react/Component",
        "document": "\n• Alternatives\n• Migrating a component with state from a class to a function\n• Migrating a component with lifecycle methods from a class to a function\n• Migrating a component with context from a class to a function\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nOnly the method is required, other methods are optional.\n\nSee more examples below.\n\nThe context of a class component is available as . It is only available if you specify which context you want to receive using .\n\nA class component can only read one context at a time.\n\nThe props passed to a class component are available as .\n\nThe state of a class component is available as . The field must be an object. Do not mutate the state directly. If you wish to change the state, call with the new state.\n\nThe constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:\n\nA constructor should not contain any side effects or subscriptions.\n\nshould not return anything.\n• Do not run any side effects or subscriptions in the constructor. Instead, use for that.\n• Inside a constructor, you need to call before any other statement. If you don’t do that, will be while the constructor runs, which can be confusing and cause bugs.\n• Constructor is the only place where you can assign directly. In all other methods, you need to use instead. Do not call in the constructor.\n• When you use server rendering, the constructor will run on the server too, followed by the method. However, lifecycle methods like or will not run on the server.\n• When Strict Mode is on, React will call twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the .\n\nIf you define , React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\n\nTypically, it is used together with which lets you update state in response to an error and display an error message to the user. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n• : An object containing additional information about the error. Its field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n\nshould not return anything.\n• In the past, it was common to call inside in order to update the UI and display the fallback error message. This is deprecated in favor of defining .\n• Production and development builds of React slightly differ in the way handles errors. In development, the errors will bubble up to , which means that any or will intercept the errors that have been caught by . In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nIf you define the method, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement , you usually need to implement other lifecycle methods to avoid bugs. For example, if reads some state or props, you also have to implement to handle their changes, and to clean up whatever was doing.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with and :\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n• : If you implemented , will contain the value you returned from that method. Otherwise, it will be .\n\nshould not return anything.\n• will not get called if is defined and returns .\n• The logic inside should usually be wrapped in conditions comparing with , and with . Otherwise, there’s a risk of creating infinite loops.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside should “mirror” the logic inside . For example, if sets up a subscription, should clean up that subscription. If the cleanup logic in your reads some props or state, you will usually also need to implement to clean up resources (such as subscriptions) corresponding to the old props and state.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n\nUsually, this is not necessary. If your component’s method only reads from , , or , it will re-render automatically when you call inside your component or one of its parents. However, if your component’s method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what lets you do.\n\nTry to avoid all uses of and only read from and in .\n• optional If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• If you call , React will re-render without calling .\n\nIf you implement , React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\nIn the above example, it is important to read the property directly in . It is not safe to read it in , , or because there is a potential time gap between these methods getting called and React updating the DOM.\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n\nYou should return a snapshot value of any type that you’d like, or . The value you returned will be passed as the third argument to .\n• will not get called if is defined and returns .\n\nThe method is the only required method in a class component.\n\nThe method should specify what you want to appear on the screen, for example:\n\nReact may call at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the method should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the method can read , , and .\n\nYou should write the method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like .\n\ndoes not take any parameters.\n\ncan return any valid React node. This includes React elements such as , strings, numbers, portals, empty nodes ( , , , and ), and arrays of React nodes.\n• should be written as a pure function of props, state, and context. It should not have side effects.\n• will not get called if is defined and returns .\n• When Strict Mode is on, React will call twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the method.\n• There is no one-to-one correspondence between the call and the subsequent or call. Some of the call results may be discarded by React when it’s beneficial.\n\nCall to update the state of your React component.\n\nenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.\n\nYou can also pass a function to . It lets you update state based on the previous state:\n\nYou don’t have to do this, but it’s handy if you want to update state multiple times during the same event.\n• : Either an object or a function.\n• If you pass an object as , it will be shallowly merged into .\n• If you pass a function as , it will be treated as an updater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into . React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n• optional : If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• Think of as a request rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in , but this may hurt performance.\n• does not update immediately. This makes reading right after calling a potential pitfall. Instead, use or the setState argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to as described above.\n\nIf you define , React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped.\n\nReact calls before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n• : The next context that the component is about to render with. Compare to to determine what changed. Only available if you specify .\n\nReturn if you want the component to re-render. That’s the default behavior.\n\nReturn to tell React that re-rendering can be skipped.\n• This method only exists as a performance optimization. If your component breaks without it, fix that first.\n• Consider using instead of writing by hand. shallowly compares props and state, and reduces the chance that you’ll skip a necessary update.\n• We do not recommend doing deep equality checks or using in . It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n• Returning does not prevent child components from re-rendering when their state changes.\n• Returning does not guarantee that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n\nIf you define , React will call it immediately after the . It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• To initialize state, declare as a class field or set inside the .\n• If you need to run a side effect or set up a subscription, move that logic to instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\ndoes not take any parameters.\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will get mounted if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go into .\n• is the only lifecycle method that runs during server rendering. For all practical purposes, it is identical to , so you should use the for this type of logic instead.\n\nIf you define , React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to instead.\n• If you need to avoid re-computing some data only when a prop changes, use a memoization helper instead.\n• If you need to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\n• If you need to “adjust” some state when a prop changes, check whether you can compute all the necessary information from props alone during rendering. If you can’t, use instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to receive from its parent component. Compare to to determine what changed.\n• : The next context that the component is about to receive from the closest provider. Compare to to determine what changed. Only available if you specify .\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will receive those props if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props than the last time. You need to compare and yourself to check if something changed.\n• React doesn’t call with initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, calling doesn’t generally trigger inside the same component.\n\nIf you define , React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to instead.\n• If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in later, read it inside instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n\nshould not return anything.\n• will not get called if is defined and returns .\n• will not get called if the component implements or .\n• It’s not supported to call (or any method that leads to being called, like dispatching a Redux action) during .\n• Despite its naming, does not guarantee that the component will update if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props or state than the last time. You need to compare with and with yourself to check if something changed.\n• React doesn’t call with initial props and state during mounting.\n\nIf you want to read from your class component, you must specify which context it needs to read. The context you specify as the must be a value previously created by .\n\nYou can define to set the default props for the class. They will be used for and missing props, but not for props.\n\nFor example, here is how you define that the prop should default to :\n\nIf the prop is not provided or is , it will be set by default to :\n\nIf you define , React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with which lets you send the error report to some analytics service. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n\nshould return the state telling the component to display the error message.\n• should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement .\n\nIf you define , React will call it right before calling , both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, this component resets the state when the prop changes:\n\nNote that this pattern requires you to keep a previous value of the prop (like ) in state (like ).\n• : The next props that the component is about to render with.\n• : The next state that the component is about to render with.\n\nreturn an object to update the state, or to update nothing.\n• This method is fired on every render, regardless of the cause. This is different from , which only fires when the parent causes a re-render and not as a result of a local .\n• This method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nReact will call your method whenever it needs to figure out what to display on the screen. Usually, you will return some JSX from it. Your method should be a pure function: it should only calculate the JSX.\n\nSimilarly to function components, a class component can receive information by props from its parent component. However, the syntax for reading props is different. For example, if the parent component renders , then you can read the prop from , like :"
    },
    {
        "link": "https://react.dev/learn/responding-to-events",
        "document": "You defined the function and then passed it as a prop to . is an event handler. Event handler functions:\n• Are usually defined inside your components.\n• Have names that start with , followed by the name of the event. By convention, it is common to name event handlers as followed by the event name. You’ll often see , , and so on. Alternatively, you can define an event handler inline in the JSX: Or, more concisely, using an arrow function: All of these styles are equivalent. Inline event handlers are convenient for short functions. Functions passed to event handlers must be passed, not called. For example: The difference is subtle. In the first example, the function is passed as an event handler. This tells React to remember it and only call your function when the user clicks the button. In the second example, the at the end of fires the function immediately during rendering, without any clicks. This is because JavaScript inside the JSX and executes right away. When you write code inline, the same pitfall presents itself in a different way: Passing inline code like this won’t fire on click—it fires every time the component renders: If you want to define your event handler inline, wrap it in an anonymous function like so: Rather than executing the code inside with every render, this creates a function to be called later. In both cases, what you want to pass is a function: Because event handlers are declared inside of a component, they have access to the component’s props. Here is a button that, when clicked, shows an alert with its prop:\n\nThis lets these two buttons show different messages. Try changing the messages passed to them. Often you’ll want the parent component to specify a child’s event handler. Consider buttons: depending on where you’re using a component, you might want to execute a different function—perhaps one plays a movie and another uploads an image. To do this, pass a prop the component receives from its parent as the event handler like so:\n\nHere, the component renders a and an :\n• passes as the prop to the inside.\n• passes as the prop to the inside. Finally, your component accepts a prop called . It passes that prop directly to the built-in browser with . This tells React to call the passed function on click. If you use a design system, it’s common for components like buttons to contain styling but not specify behavior. Instead, components like and will pass event handlers down. Built-in components like and only support browser event names like . However, when you’re building your own components, you can name their event handler props any way that you like. By convention, event handler props should start with , followed by a capital letter. For example, the component’s prop could have been called :\n\nNotice how the component does not need to know what will do with or . That’s an implementation detail of the . Here, passes them down as handlers to its s, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions like gives you the flexibility to change how they’re used later. Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use instead of . Using a real browser enables built-in browser behaviors like keyboard navigation. If you don’t like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS. Learn more about writing accessible markup. Event handlers will also catch events from any children your component might have. We say that an event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree. This contains two buttons. Both the and each button have their own handlers. Which handlers do you think will fire when you click a button?\n\nIf you click on either button, its will run first, followed by the parent ’s . So two messages will appear. If you click the toolbar itself, only the parent ’s will run. All events propagate in React except , which only works on the JSX tag you attach it to. Event handlers receive an event object as their only argument. By convention, it’s usually called , which stands for “event”. You can use this object to read information about the event. That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to call like this component does:\n\nWhen you click on a button:\n• That handler, defined in , does the following:\n• Calls , preventing the event from bubbling further.\n• Calls the function, which is a prop passed from the component.\n• That function, defined in the component, displays the button’s own alert.\n• Since the propagation was stopped, the parent ’s handler does not run. As a result of , clicking on the buttons now only shows a single alert (from the ) rather than the two of them (from the and the parent toolbar ). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI. In rare cases, you might need to catch all events on child elements, even if they stopped propagation. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by adding at the end of the event name: Each event propagates in three phases:\n• It travels down, calling all handlers. Capture events are useful for code like routers or analytics, but you probably won’t use them in app code. Notice how this click handler runs a line of code and then calls the prop passed by the parent: You could add more code to this handler before calling the parent event handler, too. This pattern provides an alternative to propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it’s not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event. If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead. Some browser events have default behavior associated with them. For example, a submit event, which happens when a button inside of it is clicked, will reload the whole page by default:"
    },
    {
        "link": "https://legacy.reactjs.org/docs/react-component.html",
        "document": "This page contains a detailed API reference for the React component class definition. It assumes you’re familiar with fundamental React concepts, such as Components and Props, as well as State and Lifecycle. If you’re not, read them first.\n\nReact lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend :\n\nThe only method you must define in a subclass is called . All the other methods described on this page are optional.\n\nWe strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance.\n\nEach component has several “lifecycle methods” that you can override to run code at particular times in the process. You can use this lifecycle diagram as a cheat sheet. In the list below, commonly used lifecycle methods are marked as bold. The rest of them exist for relatively rare use cases.\n\nThese methods are called in the following order when an instance of a component is being created and inserted into the DOM:\n\nAn update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:\n\nThis method is called when a component is being removed from the DOM:\n\nThese methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.\n\nEach component also provides some other APIs:\n\nThe methods in this section cover the vast majority of use cases you’ll encounter creating React components. For a visual reference, check out this lifecycle diagram.\n\nThe method is the only required method in a class component.\n\nWhen called, it should examine and and return one of the following types:\n• React elements. Typically created via JSX. For example, and are React elements that instruct React to render a DOM node, or another user-defined component, respectively.\n• Arrays and fragments. Let you return multiple elements from render. See the documentation on fragments for more details.\n• Portals. Let you render children into a different DOM subtree. See the documentation on portals for more details.\n• String and numbers. These are rendered as text nodes in the DOM.\n• Booleans or or . Render nothing. (Mostly exists to support pattern, where is boolean).\n\nThe function should be pure, meaning that it does not modify component state, it returns the same result each time it’s invoked, and it does not directly interact with the browser.\n\nIf you need to interact with the browser, perform your work in or the other lifecycle methods instead. Keeping pure makes components easier to think about.\n\nIf you don’t initialize state and you don’t bind methods, you don’t need to implement a constructor for your React component.\n\nThe constructor for a React component is called before it is mounted. When implementing the constructor for a subclass, you should call before any other statement. Otherwise, will be undefined in the constructor, which can lead to bugs.\n\nTypically, in React constructors are only used for two purposes:\n• Initializing local state by assigning an object to .\n\nYou should not call in the . Instead, if your component needs to use local state, assign the initial state to directly in the constructor:\n\nConstructor is the only place where you should assign directly. In all other methods, you need to use instead.\n\nAvoid introducing any side-effects or subscriptions in the constructor. For those use cases, use instead.\n\nis invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.\n\nThis method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in .\n\nYou may call immediately in . It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nis invoked immediately after updating occurs. This method is not called for the initial render.\n\nUse this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).\n\nYou may call immediately in but note that it must be wrapped in a condition like in the example above, or you’ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you’re trying to “mirror” some state to a prop coming from above, consider using the prop directly instead. Read more about why copying props into state causes bugs.\n\nIf your component implements the lifecycle (which is rare), the value it returns will be passed as a third “snapshot” parameter to . Otherwise this parameter will be undefined.\n\nis invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in .\n\nYou should not call in because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.\n\nThe methods in this section correspond to uncommon use cases. They’re handy once in a while, but most of your components probably don’t need any of them. You can see most of the methods below on this lifecycle diagram if you click the “Show less common lifecycles” checkbox at the top of it.\n\nUse to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.\n\nis invoked before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n\nThis method only exists as a performance optimization. Do not rely on it to “prevent” a rendering, as this can lead to bugs. Consider using the built-in instead of writing by hand. performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped. Note that returning does not prevent child components from re-rendering when their state changes.\n\nWe do not recommend doing deep equality checks or using in . It is very inefficient and will harm performance.\n\nCurrently, if returns , then , , and will not be invoked. In the future React may treat as a hint rather than a strict directive, and returning may still result in a re-rendering of the component.\n\nis invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, it might be handy for implementing a component that compares its previous and next children to decide which of them to animate in and out.\n\nDeriving state leads to verbose code and makes your components difficult to think about. Make sure you’re familiar with simpler alternatives:\n• If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use lifecycle instead.\n• If you want to re-compute some data only when a prop changes, use a memoization helper instead.\n• If you want to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a instead.\n\nThis method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nNote that this method is fired on every render, regardless of the cause. This is in contrast to , which only fires when the parent causes a re-render and not as a result of a local .\n\nis invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nThis use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.\n\nA snapshot value (or ) should be returned.\n\nIn the above examples, it is important to read the property in because there may be delays between “render” phase lifecycles (like ) and “commit” phase lifecycles (like and ).\n\nError boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.\n\nA class component becomes an error boundary if it defines either (or both) of the lifecycle methods or . Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.\n\nOnly use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow.\n\nFor more details, see Error Handling in React 16.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:\n• - The error that was thrown.\n• - An object with a key containing information about which component threw the error.\n\nis called during the “commit” phase, so side-effects are permitted. It should be used for things like logging errors:\n\nProduction and development builds of React slightly differ in the way handles errors.\n\nOn development, the errors will bubble up to , this means that any or will intercept the errors that have been caught by .\n\nOn production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nThe lifecycle methods below are marked as “legacy”. They still work, but we don’t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in this blog post.\n\nis invoked just before mounting occurs. It is called before , therefore calling synchronously in this method will not trigger an extra rendering. Generally, we recommend using the instead for initializing state.\n\nAvoid introducing any side-effects or subscriptions in this method. For those use cases, use instead.\n\nThis is the only lifecycle method called on server rendering.\n\nis invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare and and perform state transitions using in this method.\n\nNote that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.\n\nReact doesn’t call with initial props during mounting. It only calls this method if some of component’s props may update. Calling generally doesn’t trigger .\n\nis invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.\n\nNote that you cannot call here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before returns.\n\nTypically, this method can be replaced by . If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to .\n\nUnlike the lifecycle methods above (which React calls for you), the methods below are the methods you can call from your components.\n\nThere are just two of them: and .\n\nenqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.\n\nThink of as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in , but this may hurt performance.\n\ndoes not always immediately update the component. It may batch or defer the update until later. This makes reading right after calling a potential pitfall. Instead, use or a callback ( ), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the argument below.\n\nwill always lead to a re-render unless returns . If mutable objects are being used and conditional rendering logic cannot be implemented in , calling only when the new state differs from the previous state will avoid unnecessary re-renders.\n\nThe first argument is an function with the signature:\n\nis a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from and . For instance, suppose we wanted to increment a value in state by :\n\nBoth and received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with .\n\nThe second parameter to is an optional callback function that will be executed once is completed and the component is re-rendered. Generally we recommend using for such logic instead.\n\nYou may optionally pass an object as the first argument to instead of a function:\n\nThis performs a shallow merge of into the new state, e.g., to adjust a shopping cart item quantity:\n\nThis form of is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:\n\nSubsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:\n\nFor more detail, see:\n• In depth: When and why are calls batched?\n\nBy default, when your component’s state or props change, your component will re-render. If your method depends on some other data, you can tell React that the component needs re-rendering by calling .\n\nCalling will cause to be called on the component, skipping . This will trigger the normal lifecycle methods for child components, including the method of each child. React will still only update the DOM if the markup changes.\n\nNormally you should try to avoid all uses of and only read from and in .\n\ncan be defined as a property on the component class itself, to set the default props for the class. This is used for props, but not for props. For example:\n\nIf is not provided, it will be set by default to :\n\nIf is set to , it will remain :\n\nThe string is used in debugging messages. Usually, you don’t need to set it explicitly because it’s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.\n\ncontains the props that were defined by the caller of this component. See Components and Props for an introduction to props.\n\nIn particular, is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.\n\nThe state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.\n\nIf some value isn’t used for rendering or data flow (for example, a timer ID), you don’t have to put it in the state. Such values can be defined as fields on the component instance.\n\nSee State and Lifecycle for more information about the state.\n\nNever mutate directly, as calling afterwards may replace the mutation you made. Treat as if it were immutable."
    },
    {
        "link": "https://freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb",
        "document": "While working on React, you must have come across controlled components and event handlers. We need to bind these methods to the component instance using in our custom component’s constructor.\n\nIn this article, we are going to find out why we need to do this.\n\nI would recommend reading about here if you do not already know what it does.\n\nWell, laying blame sounds a bit harsh. This is not something we need to do because of the way React works or because of JSX. This is because of the way the binding works in JavaScript.\n\nLet’s see what happens if we do not bind the event handler method with its component instance:\n\nIf you run this code, click on the “Click Me” button and check your console. You will see printed to the console as the value of from inside the event handler method. The method seems to have lost its context (component instance) or value.\n\nAs I mentioned, this happens because of the way binding works in JavaScript. I won’t go into a lot of detail in this post, but here is a great resource to understand how the binding works in JavaScript.\n\nBut relevant to our discussion here, the value of inside a function depends upon how that function is invoked.\n\nThis is a plain function call. The value of inside the method in this case is the window — or the global — object in non-strict mode. In strict mode, the value is .\n\nWhen we call a function in this manner — preceded by a context object — the value inside is set to .\n\nBut when we assign this function reference to some other variable and invoke the function using this new function reference, we get a different value of inside .\n\nIn the above example, when we call , we don’t specify a context object. It is a plain function call without an owner object. In this case, the value of inside falls back to default binding. It points to the global object or if the function being invoked uses strict mode.\n\nThis is especially applicable while passing such functions as callbacks to another custom function, a third-party library function, or a built-in JavaScript function like .\n\nConsider the dummy definition as shown below, and then invoke it.\n\nWe can figure out that when we call , JavaScript internally assigns to its argument .\n\nThis assignment operation, as we have seen before, causes the function to lose its context. When this callback is eventually invoked inside , the value inside falls back to default binding.\n\nTo avoid this, we can explicitly hard bind the value to a function by using the method.\n\nNow, when we call , the value of points to inside .\n\nEven if we pass as a callback, the value inside will correctly point to .\n\nRecreating the scenario using only JavaScript\n\nIn the beginning of this article, we saw this in our React component called . If we did not bind the event handler with , its value inside the event handler was set as .\n\nAs I mentioned and explained, this is because of the way binding works in JavaScript and not related to how React works. So let’s remove the React-specific code and construct a similar pure JavaScript example to simulate this behavior.\n\nWe are not simulating actual events and handlers, but instead we are using synonymous code. As we observed in the React Component example, the value was as the context was lost after passing the handler as a callback — synonymous with an assignment operation. This is what we observe here in this non-React JavaScript snippet as well.\n\n“Wait a minute! Shouldn’t the value point to the global object, since we are running this in non-strict mode according to the rules of default binding?” you might ask.\n\nNo. This is why:\n\nYou can read the full article here.\n\nSo, to prevent the error, we need to bind the value like this:\n\nWe don’t need to do this in the constructor, and we can do this somewhere else as well. Consider this:\n\nBut the constructor is the most optimal and efficient place to code our event handler bind statements, considering that this is where all the initialization takes place.\n\nWhy don’t we need to bind ‘ for Arrow functions?\n\nWe have two more ways we can define event handlers inside a React component.\n\nBoth of these use the arrow functions introduced in ES6. When using these alternatives, our event handler is already automatically bound to the component instance, and we do not need to bind it in the constructor.\n\nThe reason is that in the case of arrow functions, is bound lexically. This means that it uses the context of the enclosing function — or global — scope as its value.\n\nIn the case of the public class fields syntax example, the arrow function is enclosed inside the class — or constructor function — so the context is the component instance, which is what we want.\n\nIn the case of the arrow function as callback example, the arrow function is enclosed inside the method, which is invoked by React in the context of the component instance. This is why the arrow function will also capture this same context, and the value inside it will properly point to the component instance.\n\nFor more details regarding lexical binding, check out this excellent resource.\n\nIn Class Components in React, when we pass the event handler function reference as a callback like this\n\nthe event handler method loses its implicitly bound context. When the event occurs and the handler is invoked, the value falls back to default binding and is set to , as class declarations and prototype methods run in strict mode.\n\nWhen we bind the of the event handler to the component instance in the constructor, we can pass it as a callback without worrying about it losing its context.\n\nArrow functions are exempt from this behavior because they use lexical binding which automatically binds them to the scope they are defined in."
    }
]