[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient",
        "document": "In this article, you learn how to make HTTP requests and handle responses with the class.\n\nHTTP endpoints commonly return JavaScript Object Notation (JSON) data, but not always. For convenience, the optional System.Net.Http.Json NuGet package provides several extension methods for and objects that perform automatic serialization and deserialization by using the ðŸ“¦ System.Text.Json NuGet package. The examples in this article call attention to places where these extensions are available.\n\nMost of the examples in this article reuse the same instance, so you can configure the instance once and use it for the remaining examples. To create an object, use the class constructor. For more information, see Guidelines for using HttpClient.\n\nThe code completes the following tasks:\nâ€¢ Instantiate a new instance as a variable. According to the guidelines, the recommended approach is to reuse instances during the application lifecycle.\n\nThis instance uses the base address to make subsequent requests. To apply other configurations, consider the following APIs:\n\nTo make an HTTP request, you call any of the following API methods:\n\nThe HttpContent type is used to represent an HTTP entity body and corresponding content headers. For HTTP methods (or request methods) that require a body ( , , ), you use the HttpContent class to specify the body of the request. Most examples show how to prepare the StringContent subclass with a JSON payload, but other subclasses exist for different content (MIME) types.\nâ€¢ FormUrlEncodedContent: Provides HTTP content for name/value tuples encoded by using the MIME type.\nâ€¢ MultipartContent: Provides a collection of HttpContent objects that get serialized by using the MIME type specification.\nâ€¢ MultipartFormDataContent: Provides a container for content encoded by using the MIME type.\nâ€¢ ReadOnlyMemoryContent: Provides HTTP content based on an ReadOnlyMemory<T> value.\n\nThe class is also used to represent the response body of the HttpResponseMessage class, which is accessible on the HttpResponseMessage.Content property.\n\nUse an HTTP GET request\n\nA request shouldn't send a body. This request is used (as the method name indicates) to retrieve (or get) data from a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.GetAsync method:\n\nThe code completes the following tasks:\nâ€¢ Write the request details to the console.\nâ€¢ Write the JSON response body to the console.\n\nThe method is a custom extension that isn't part of the framework. If you're curious about the implementation, consider the following C# code:\n\nThis functionality is used to write the request details to the console in the following form:\n\nAs an example, the request to the endpoint outputs the following message:\n\nCreate the HTTP GET request from JSON\n\nThe https://jsonplaceholder.typicode.com/todos endpoint returns a JSON array of objects. Their JSON structure resembles the following form:\n\nThe C# object is defined as follows:\n\nIt's a type, with optional , , , and properties. For more information on the type, see Introduction to record types in C#. To automatically deserialize requests into a strongly typed C# object, use the GetFromJsonAsync extension method that's part of the ðŸ“¦ System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ The query string represents the filtering criteria for the request. When the command succeeds, the response is automatically deserialized into a object.\nâ€¢ None Write the request details to the console, along with each object.\n\nA request sends data to the server for processing. The header of the request signifies what MIME type the body is sending. To make an HTTP request given an instance and a Uri object, use the HttpClient.PostAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Write the response body as a string to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PostAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the object to the console.\n\nThe request method either replaces an existing resource or creates a new one by using the request body payload. To make an HTTP request given an instance and a Uri object, use the HttpClient.PutAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PutAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the objects to the console.\n\nThe request is a partial update to an existing resource. This request doesn't create a new resource and it isn't intended to replace an existing resource. Instead, this method only partially updates a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.PatchAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nNo extension methods exist for requests in the NuGet package.\n\nA request removes an existing resource and the request is idempotent, but not safe. Multiple requests to the same resources yield the same result, but the request affects the state of the resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.DeleteAsync method:\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\n\nThe request is similar to a request. Instead of returning the resource, this request returns only the headers associated with the resource. A response to the request doesn't return a body. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response headers and write each header to the console.\n\nThe request is used to identify which HTTP methods a server or endpoint supports. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Send an HTTP request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response content headers and write each header to the console.\n\nThe request can be useful for debugging as it provides application-level loop-back of the request message. To make an HTTP request, create an HttpRequestMessage by using the type:\n\nWhen you handle an HTTP response, you interact with the HttpResponseMessage type. Several members are used to evaluate the validity of a response. The HTTP status code is available in the HttpResponseMessage.StatusCode property.\n\nTo ensure the is (HTTP status code 200), you can evaluate the value as shown in the following example:\n\nThere are other HTTP status codes that represent a successful response, such as (HTTP status code 201), (HTTP status code 202), (HTTP status code 204), and (HTTP status code 205). You can use the HttpResponseMessage.IsSuccessStatusCode property to evaluate these codes as well, which ensures that the response status code is within the range 200-299:\n\nIf you need to have the framework throw the HttpRequestException error, you can call the HttpResponseMessage.EnsureSuccessStatusCode() method:\n\nThis code throws an error if the response status code isn't within the 200-299 range.\n\nWith a valid response, you can access the response body by using the Content property. The body is available as an HttpContent instance, which you can use to access the body as a stream, byte array, or string.\n\nThe following code uses the object to read the response body:\n\nYou can use different objects to read the response body. Use the object to read the response body:\n\nUse the object to read the response body:\n\nWhen you know an HTTP endpoint returns JSON, you can deserialize the response body into any valid C# object by using the System.Net.Http.Json NuGet package:\n\nIn this code, the value is the response body deserialized as the type .\n\nWhen an HTTP request fails, the system throws the HttpRequestException object. Catching the exception alone might not be sufficient. There are other potential exceptions thrown that you might want to consider handling. For example, the calling code might use a cancellation token that was canceled before the request completed. In this scenario, you can catch the TaskCanceledException error:\n\nLikewise, when you make an HTTP request, if the server doesn't respond before the HttpClient.Timeout value is exceeded, the same exception is thrown. In this scenario, you can distinguish that the time-out occurred by evaluating the Exception.InnerException property when catching the TaskCanceledException error:\n\nIn the code, when the inner exception is an TimeoutException type, then the time-out occurred and the cancellation token doesn't cancel the request.\n\nTo evaluate the HTTP status code when you catch the HttpRequestException object, you can evaluate the HttpRequestException.StatusCode property:\n\nIn the code, the EnsureSuccessStatusCode() method is called to throw an exception if the response isn't successful. The HttpRequestException.StatusCode property is then evaluated to determine if the response was a (HTTP status code 404). There are several helper methods on the object that implicitly call the method on your behalf.\n\nFor HTTP error handing, consider the following APIs:\n\nWhen you call these methods, you can handle the object and evaluate the HttpRequestException.StatusCode property to determine the HTTP status code of the response:\n\nThere might be scenarios where you need to throw the HttpRequestException object in your code. The HttpRequestException() constructor is public and you can use it to throw an exception with a custom message:\n\nAn HTTP proxy can be configured in one of two ways. A default is specified on the HttpClient.DefaultProxy property. Alternatively, you can specify a proxy on the HttpClientHandler.Proxy property.\n\nThe property is a static property that determines the default proxy that all instances use, if no proxy is set explicitly in the HttpClientHandler object passed through its constructor.\n\nThe default instance returned by this property initializes according to a different set of rules depending on your platform:\nâ€¢ Windows: Read proxy configuration from environment variables, or if variables aren't defined, read from user proxy settings.\nâ€¢ macOS: Read proxy configuration from environment variables, or if variables aren't defined, read from system proxy settings.\nâ€¢ Linux: Read proxy configuration from environment variables, or if variables aren't defined, initialize a nonconfigured instance to bypass all addresses.\n\nThe property initialization on Windows and Unix-based platforms uses the following environment variables:\nâ€¢ : The proxy server used on HTTP requests.\nâ€¢ : The proxy server used on HTTPS requests.\nâ€¢ : The proxy server used on HTTP and/or HTTPS requests when the and/or variables aren't defined.\nâ€¢ : A comma-separated list of hostnames to exclude from proxying. Asterisks aren't supported for wildcards. Use a leading period (.) when you want to match a subdomain. Examples: (with leading period) matches , but doesn't match . (without leading period) doesn't match . This behavior might be revisited in the future to match other ecosystems better.\n\nOn systems where environment variables are case-sensitive, the variable names can be all lowercase or all uppercase. The lowercase names are checked first.\n\nThe proxy server can be a hostname or IP address, optionally followed by a colon and port number, or it can be an URL, optionally including a username and password for proxy authentication. The URL must start with , not , and can't include any text after the hostname, IP, or port.\n\nThe HttpClientHandler.Proxy property identifies the WebProxy object to use to process requests to internet resources. To specify that no proxy should be used, set the property to the proxy instance returned by the GlobalProxySelection.GetEmptyWebProxy() method.\n\nThe local computer or application configuration file might specify that a default proxy is used. If the property is specified, then the proxy settings from the property override the local computer or application config file and the handler uses the proxy settings specified. If no proxy is specified in a config file and the property is unspecified, the handler uses the proxy settings inherited from the local computer. If there are no proxy settings, the request is sent directly to the server.\n\nThe HttpClientHandler class parses a proxy bypass list with wildcard characters inherited from local computer settings. For example, the class parses a bypass list of from browsers as a regular expression of . Therefore, a URL of bypasses the proxy by using the class.\n\nThe class supports local proxy bypass. The class considers a destination to be local if any of the following conditions are met:\nâ€¢ The destination contains a flat name (no periods (.) in the URL).\nâ€¢ The destination contains a loopback address (Loopback or IPv6Loopback) or the destination contains an IPAddress property assigned to the local computer.\nâ€¢ The domain suffix of the destination matches the local computer's domain suffix, as defined in the DomainName property.\n\nFor more information about configuring a proxy, see the following APIs:"
    },
    {
        "link": "https://code-maze.com/httpclient-example-aspnet-core-post-put-delete",
        "document": "In the previous article, we have learned how to integrate HttpClient in ASP.NET Core, and how to use it to fetch the data from Web API. Also, we learned how to send the GET request using both the GetAsync method and the HttpRequestMessage class. As a continuation, in this article, we are going to learn how to send POST, PUT, and DELETE requests using HttpClient in ASP.NET Core. We are going to show you both examples for each request with shortcut methods (PostAsync, PutAsync, DeleteAsync) and with the HttpRequestMessage class.\n\nYou can also visit our HttpClient Tutorial page, to see all the articles from this tutorial.\n\nIf you have read our previous article, you know that we have the class in the application. This class already contains two methods, and we are going to expand it with all the methods from this article.\n\nSo, since the configuration is already prepared, we can add a new method to send the POST request to the Web API:\n\nWe first prepare a company object that we want to create and serialize it with the method. Then, we create a new object providing our serialized company, encoding type, and the media type arguments. After that, we use the method to send the POST request to the API. After we receive a response, we check if it is a successful one. Then, we apply a well-known logic (from a previous article) by reading the content with the method and deserializing the content using the argument. Remember that we created the parameter in a previous article.\n\nAt this point, we have to ensure that our client app calls this method. So, letâ€™s modify the method inside the class:\n\nNow, if we place a breakpoint in the method and start both applications:\n\nWe can see our created company as a result. You can also check the database if you want.\n\nUsing HttpRequestMessage Class to Send the POST Request\n\nThe method is a shortcut method because it encapsulates the class. And as we could see, it works great. But, if we want to have greater control over our request and also to explicitly set up different request options, like headers, we have to use the class. So, letâ€™s see how we can do that:\n\nAgain, we start with a new object and its serialization. Then, we create a new object and provide the type of the request and the endpointâ€™s address. After that, we add an accept header to determine which format we support as a response. Right after that, we populate the of our request by using the class and providing the serialized company object and encoding type. Also, we specify the media type of our request with the property.\n\nNote: We can configure the in the constructor of the class as well, but with this implementation, it is easier to understand the process, and where the property is coming from.\n\nTo send the request, we use the method. After we are sure a successful status code is returned, we read our content and deserialize it.\n\nNow, we can modify the method:\n\nPlace a breakpoint in our new method, and start our client app:\n\nThere we go. Our company was successfully created.\n\nAlso, if we inspect our response, we will find the 201 â€“ Created â€“ status code:\n\nUsing HttpClient in ASP.NET Core to Send a PUT Request\n\nLetâ€™s see, how we can send a PUT request using HttpClinet in ASP.NET Core.\n\nAs we did with the POST request, we are going to use the shortcut method first, and then show how to do the same thing with the class.\n\nBefore we modify the client project, we just want to mention that our Web APIâ€™s action returns a response. So, there is no content to deserialize on the client-side, just a 204 status code. Of course, you can check the code on your own by visiting our GitHub repo.\n\nThat said, we are ready to add a new method in the class:\n\nIn this method, we create a new object with a modified property. Then, as we did in the method, we serialize the object and create a new providing the serialized object, encoding type, and media type. After that, we create the URI to the controllerâ€™s action, which expects the Id of the company we are updating. As soon as we do that, we send our PUT request using the shortcut method and just ensure that we receive a successful status code. In this case the status code.\n\nWith this in place, we can modify the method:\n\nNow, letâ€™s put a breakpoint in the method and start the app:\n\nAlso, if we inspect our database:\n\nWe can confirm our company is updated successfully.\n\nUsing the HttpRequestMessage Class to Send the PUT Request\n\nAs we already said, using the class allows us more control over our requests. So, letâ€™s see how we can utilize it to send the PUT request:\n\nWhen we look at this method, we can see that it has almost the same implementation as the method. Of course, here we create an additional parameter and we donâ€™t deserialize our response body content since it is empty.\n\nAfter the method implementation, letâ€™s call it from the method:\n\nThere we go. We have a successful result.\n\nFeel free to check the database as well.\n\nSince the DELETE request is the simplest of all the previous ones, we are just going to show the code.\n\nSo, letâ€™s first see how to send a DELETE request with a shortcut method:\n\nAlso, letâ€™s call this method from the method:\n\nAs soon as we run the client app, we are going to get the 204 response. This is a valid response for the Delete action in Web API.\n\nNow, letâ€™s see how we can do the same thing using the HttpRequestMessage class:\n\nAgain, nothing new here. Just one note. We are still adding the accept header to our request because some APIs return the content if something goes wrong. We then have to deserialize that content on the client-side.\n\nWe can call this method from the Execute method and run the app.\n\nWe should get the 204 response.\n\nSo, in this article, we have learned how to send POST, PUT and DELETE requests from our client application using both the shortcut methods and the HttpRequestMessage class. Combining this with the knowledge we have from the previous article, we have covered all the CRUD methods with the HttpClient class.\n\nIn the next article, we are going to learn more about the PATCH request and how to send it with HttpClient.\n\nAll the best."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-9.0",
        "document": "An IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\nâ€¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\nâ€¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\nâ€¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\nâ€¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicModel : PageModel { private readonly IHttpClientFactory _httpClientFactory; public BasicModel(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public IEnumerable<GitHubBranch>? GitHubBranches { get; set; } public async Task OnGet() { var httpRequestMessage = new HttpRequestMessage( HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\") { Headers = { { HeaderNames.Accept, \"application/vnd.github.v3+json\" }, { HeaderNames.UserAgent, \"HttpRequestsSample\" } } }; var httpClient = _httpClientFactory.CreateClient(); var httpResponseMessage = await httpClient.SendAsync(httpRequestMessage); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); GitHubBranches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\nâ€¢ The app requires many distinct uses of .\nâ€¢ Many s have different configuration. Specify configuration for a named during its registration in : builder.Services.AddHttpClient(\"GitHub\", httpClient => { httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); }); In the preceding code the client is configured with:\nâ€¢ Two headers required to work with the GitHub API.\nâ€¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _httpClientFactory; public NamedClientModel(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public IEnumerable<GitHubBranch>? GitHubBranches { get; set; } public async Task OnGet() { var httpClient = _httpClientFactory.CreateClient(\"GitHub\"); var httpResponseMessage = await httpClient.GetAsync( \"repos/dotnet/AspNetCore.Docs/branches\"); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); GitHubBranches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\nâ€¢ Provide the same capabilities as named clients without the need to use strings as keys.\nâ€¢ Provides IntelliSense and compiler help when consuming clients.\nâ€¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\nâ€¢ To encapsulate all logic dealing with the endpoint.\nâ€¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor: public class GitHubService { private readonly HttpClient _httpClient; public GitHubService(HttpClient httpClient) { _httpClient = httpClient; _httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. _httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); _httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); } public async Task<IEnumerable<GitHubBranch>?> GetAspNetCoreDocsBranchesAsync() => await _httpClient.GetFromJsonAsync<IEnumerable<GitHubBranch>>( \"repos/dotnet/AspNetCore.Docs/branches\"); }\nâ€¢ The configuration is moved into the typed client.\nâ€¢ The provided instance is stored as a private field. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve docs GitHub branches. The following code calls AddHttpClient in to register the typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\nâ€¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: The configuration for a typed client can also be specified during its registration in , rather than in the typed client's constructor: can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. Call to generate a dynamic implementation of an interface, which uses to make the external HTTP calls. Call to generate the dynamic implementation and then call to configure the underlying : builder.Services.AddRefitClient<IGitHubClient>() .ConfigureHttpClient(httpClient => { httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); }); Use DI to access the dynamic implementation of : In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: public async Task CreateItemAsync(TodoItem todoItem) { var todoItemJson = new StringContent( JsonSerializer.Serialize(todoItem), Encoding.UTF8, Application.Json); // using static System.Net.Mime.MediaTypeNames; using var httpResponseMessage = await _httpClient.PostAsync(\"/api/TodoItems\", todoItemJson); httpResponseMessage.EnsureSuccessStatusCode(); } In the preceding code, the method:\nâ€¢ Serializes the parameter to JSON using .\nâ€¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\nâ€¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\nâ€¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code doesn't indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\nâ€¢ Simplifies defining the handlers to apply for each named client.\nâ€¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\nâ€¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\nâ€¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\nâ€¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"The API key header X-API-KEY is required.\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: In the preceding code, runs first, before . When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: The following delegating handler consumes and uses to set the header for the outgoing request: In the download, navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\nâ€¢ Pass data into the handler using HttpRequestMessage.Options.\nâ€¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\nâ€¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\nâ€¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a . For example:\nâ€¢ Two policies, and , are added to the Polly registry.\nâ€¢ AddPolicyHandlerFromRegistry configures individual named clients to use these policies from the Polly registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\nâ€¢ Create an instance of when the app starts and use it for the life of the app.\nâ€¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\nâ€¢ The shares connections across instances. This sharing prevents socket exhaustion.\nâ€¢ The cycles connections according to to avoid stale DNS problems. Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: In a console app, add the following package references to the project: In the following example:\nâ€¢ IHttpClientFactory and are registered in the Generic Host's service container.\nâ€¢ is requested from DI, which in-turn requests an instance of .\nâ€¢ uses to create an instance of , which it uses to retrieve docs GitHub branches. using System.Text.Json; using System.Text.Json.Serialization; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; var host = new HostBuilder() .ConfigureServices(services => { services.AddHttpClient(); services.AddTransient<GitHubService>(); }) .Build(); try { var gitHubService = host.Services.GetRequiredService<GitHubService>(); var gitHubBranches = await gitHubService.GetAspNetCoreDocsBranchesAsync(); Console.WriteLine($\"{gitHubBranches?.Count() ?? 0} GitHub Branches\"); if (gitHubBranches is not null) { foreach (var gitHubBranch in gitHubBranches) { Console.WriteLine($\"- {gitHubBranch.Name}\"); } } } catch (Exception ex) { host.Services.GetRequiredService<ILogger<Program>>() .LogError(ex, \"Unable to load branches from GitHub.\"); } public class GitHubService { private readonly IHttpClientFactory _httpClientFactory; public GitHubService(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public async Task<IEnumerable<GitHubBranch>?> GetAspNetCoreDocsBranchesAsync() { var httpRequestMessage = new HttpRequestMessage( HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\") { Headers = { { \"Accept\", \"application/vnd.github.v3+json\" }, { \"User-Agent\", \"HttpRequestsConsoleSample\" } } }; var httpClient = _httpClientFactory.CreateClient(); var httpResponseMessage = await httpClient.SendAsync(httpRequestMessage); httpResponseMessage.EnsureSuccessStatusCode(); using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } public record GitHubBranch( [property: JsonPropertyName(\"name\")] string Name); Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing requests. To use header propagation:\nâ€¢ None Configure the and middleware pipeline in : // Add services to the container. builder.Services.AddControllers(); builder.Services.AddHttpClient(\"PropagateHeaders\") .AddHeaderPropagation(); builder.Services.AddHeaderPropagation(options => { options.Headers.Add(\"X-TraceId\"); }); var app = builder.Build(); // Configure the HTTP request pipeline. app.UseHttpsRedirection(); app.UseHeaderPropagation(); app.MapControllers();\nâ€¢ None Make outbound requests using the configured instance, which includes the added headers.\nâ€¢ View or download sample code (how to download)\nâ€¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\nâ€¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\nâ€¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\nâ€¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\nâ€¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\nâ€¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download). The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. can be registered by calling : An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); Branches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(responseStream); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\nâ€¢ The app requires many distinct uses of .\nâ€¢ Many s have different configuration. Configuration for a named can be specified during registration in : In the preceding code the client is configured with:\nâ€¢ Two headers required to work with the GitHub API.\nâ€¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); PullRequests = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubPullRequest>>(responseStream); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\nâ€¢ Provide the same capabilities as named clients without the need to use strings as keys.\nâ€¢ Provides IntelliSense and compiler help when consuming clients.\nâ€¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\nâ€¢ To encapsulate all logic dealing with the endpoint.\nâ€¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor:\nâ€¢ The configuration is moved into the typed client.\nâ€¢ The object is exposed as a public property. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve open issues. The following code calls AddHttpClient in to register a typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\nâ€¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } The configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: The can be encapsulated within a typed client. Rather than exposing it as a property, define a method which calls the instance internally: In the preceding code, the is stored in a private field. Access to the is by the public method. can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: In the preceding code, the method:\nâ€¢ Serializes the parameter to JSON using . This uses an instance of JsonSerializerOptions to configure the serialization process.\nâ€¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\nâ€¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\nâ€¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code does not indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is very similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\nâ€¢ Simplifies defining the handlers to apply for each named client.\nâ€¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\nâ€¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\nâ€¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\nâ€¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: public void ConfigureServices(IServiceCollection services) { services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5001/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); // Remaining code deleted for brevity. In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: public void ConfigureServices(IServiceCollection services) { services.AddDbContext<TodoContext>(options => options.UseInMemoryDatabase(\"TodoItems\")); services.AddHttpContextAccessor(); services.AddHttpClient<TodoClient>((sp, httpClient) => { var httpRequest = sp.GetRequiredService<IHttpContextAccessor>().HttpContext.Request; // For sample purposes, assume TodoClient is used in the context of an incoming request. httpClient.BaseAddress = new Uri(UriHelper.BuildAbsolute(httpRequest.Scheme, httpRequest.Host, httpRequest.PathBase)); httpClient.Timeout = TimeSpan.FromSeconds(5); }); services.AddScoped<IOperationScoped, OperationScoped>(); services.AddTransient<OperationHandler>(); services.AddTransient<OperationResponseHandler>(); services.AddHttpClient(\"Operation\") .AddHttpMessageHandler<OperationHandler>() .AddHttpMessageHandler<OperationResponseHandler>() .SetHandlerLifetime(TimeSpan.FromSeconds(5)); services.AddControllers(); services.AddRazorPages(); } The following delegating handler consumes and uses to set the header for the outgoing request: In the download], navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\nâ€¢ Pass data into the handler using HttpRequestMessage.Options.\nâ€¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\nâ€¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\nâ€¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a .\nâ€¢ The \"regular\" and \"long\" policies are added.\nâ€¢ AddPolicyHandlerFromRegistry adds the \"regular\" and \"long\" policies from the registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\nâ€¢ Create an instance of when the app starts and use it for the life of the app.\nâ€¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\nâ€¢ The shares connections across instances. This sharing prevents socket exhaustion.\nâ€¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\nâ€¢ IHttpClientFactory is registered in the Generic Host's service container.\nâ€¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\nâ€¢ creates a scope to execute the service's method and write the first 500 characters of the webpage content to the console. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (Â©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\nâ€¢ None Configure the middleware and in :\nâ€¢ None The client includes the configured headers on outbound requests:\nâ€¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\nâ€¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\nâ€¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\nâ€¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\nâ€¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\nâ€¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download). The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. can be registered by calling : An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); Branches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(responseStream); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\nâ€¢ The app requires many distinct uses of .\nâ€¢ Many s have different configuration. Configuration for a named can be specified during registration in : In the preceding code the client is configured with:\nâ€¢ Two headers required to work with the GitHub API.\nâ€¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); PullRequests = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubPullRequest>>(responseStream); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\nâ€¢ Provide the same capabilities as named clients without the need to use strings as keys.\nâ€¢ Provides IntelliSense and compiler help when consuming clients.\nâ€¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\nâ€¢ To encapsulate all logic dealing with the endpoint.\nâ€¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor: public class GitHubService { public HttpClient Client { get; } public GitHubService(HttpClient client) { client.BaseAddress = new Uri(\"https://api.github.com/\"); // GitHub API versioning client.DefaultRequestHeaders.Add(\"Accept\", \"application/vnd.github.v3+json\"); // GitHub requires a user-agent client.DefaultRequestHeaders.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); Client = client; } public async Task<IEnumerable<GitHubIssue>> GetAspNetDocsIssues() { var response = await Client.GetAsync( \"/repos/dotnet/AspNetCore.Docs/issues?state=open&sort=created&direction=desc\"); response.EnsureSuccessStatusCode(); using var responseStream = await response.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync <IEnumerable<GitHubIssue>>(responseStream); } } If you would like to see code comments translated to languages other than English, let us know in this GitHub discussion issue.\nâ€¢ The configuration is moved into the typed client.\nâ€¢ The object is exposed as a public property. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve open issues. The following code calls AddHttpClient in to register a typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\nâ€¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } The configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: The can be encapsulated within a typed client. Rather than exposing it as a property, define a method which calls the instance internally: In the preceding code, the is stored in a private field. Access to the is by the public method. can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: In the preceding code, the method:\nâ€¢ Serializes the parameter to JSON using . This uses an instance of JsonSerializerOptions to configure the serialization process.\nâ€¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\nâ€¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\nâ€¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code does not indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is very similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\nâ€¢ Simplifies defining the handlers to apply for each named client.\nâ€¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\nâ€¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\nâ€¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\nâ€¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: public void ConfigureServices(IServiceCollection services) { services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5001/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); // Remaining code deleted for brevity. In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: public void ConfigureServices(IServiceCollection services) { services.AddDbContext<TodoContext>(options => options.UseInMemoryDatabase(\"TodoItems\")); services.AddHttpContextAccessor(); services.AddHttpClient<TodoClient>((sp, httpClient) => { var httpRequest = sp.GetRequiredService<IHttpContextAccessor>().HttpContext.Request; // For sample purposes, assume TodoClient is used in the context of an incoming request. httpClient.BaseAddress = new Uri(UriHelper.BuildAbsolute(httpRequest.Scheme, httpRequest.Host, httpRequest.PathBase)); httpClient.Timeout = TimeSpan.FromSeconds(5); }); services.AddScoped<IOperationScoped, OperationScoped>(); services.AddTransient<OperationHandler>(); services.AddTransient<OperationResponseHandler>(); services.AddHttpClient(\"Operation\") .AddHttpMessageHandler<OperationHandler>() .AddHttpMessageHandler<OperationResponseHandler>() .SetHandlerLifetime(TimeSpan.FromSeconds(5)); services.AddControllers(); services.AddRazorPages(); } The following delegating handler consumes and uses to set the header for the outgoing request: In the download], navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\nâ€¢ Pass data into the handler using HttpRequestMessage.Properties.\nâ€¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\nâ€¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\nâ€¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a .\nâ€¢ The \"regular\" and \"long\" policies are added.\nâ€¢ AddPolicyHandlerFromRegistry adds the \"regular\" and \"long\" policies from the registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\nâ€¢ Create an instance of when the app starts and use it for the life of the app.\nâ€¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\nâ€¢ The shares connections across instances. This sharing prevents socket exhaustion.\nâ€¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\nâ€¢ IHttpClientFactory is registered in the Generic Host's service container.\nâ€¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\nâ€¢ creates a scope to execute the service's method and write the first 500 characters of the webpage content to the console. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (Â©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\nâ€¢ None Configure the middleware and in :\nâ€¢ None The client includes the configured headers on outbound requests:\nâ€¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\nâ€¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. It offers the following benefits:\nâ€¢ Provides a central location for naming and configuring logical instances. For example, a github client can be registered and configured to access GitHub. A default client can be registered for other purposes.\nâ€¢ Codifies the concept of outgoing middleware via delegating handlers in and provides extensions for Polly-based middleware to take advantage of that.\nâ€¢ Manages the pooling and lifetime of underlying instances to avoid common DNS problems that occur when manually managing lifetimes.\nâ€¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download) Projects targeting .NET Framework require installation of the Microsoft.Extensions.Http NuGet package. Projects that target .NET Core and reference the Microsoft.AspNetCore.App metapackage already include the package. There are several ways can be used in an app: None of them are strictly superior to another. The best approach depends upon the app's constraints. The can be registered by calling the extension method on the , inside the method. Once registered, code can accept an anywhere services can be injected with dependency injection (DI). The can be used to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { Branches = await response.Content .ReadAsAsync<IEnumerable<GitHubBranch>>(); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using in this fashion is a good way to refactor an existing app. It has no impact on the way is used. In places where instances are currently created, replace those occurrences with a call to CreateClient. If an app requires many distinct uses of , each with a different configuration, an option is to use named clients. Configuration for a named can be specified during registration in . In the preceding code, is called, providing the name github. This client has some default configuration appliedâ€”namely the base address and two headers required to work with the GitHub API. Each time is called, a new instance of is created and the configuration action is called. To consume a named client, a string parameter can be passed to . Specify the name of the client to be created: public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { PullRequests = await response.Content .ReadAsAsync<IEnumerable<GitHubPullRequest>>(); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. It can pass just the path, since the base address configured for the client is used.\nâ€¢ Provide the same capabilities as named clients without the need to use strings as keys.\nâ€¢ Provides IntelliSense and compiler help when consuming clients.\nâ€¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used for a single backend endpoint and encapsulate all logic dealing with that endpoint.\nâ€¢ Work with DI and can be injected where required in your app. A typed client accepts an parameter in its constructor: In the preceding code, the configuration is moved into the typed client. The object is exposed as a public property. It's possible to define API-specific methods that expose functionality. The method encapsulates the code needed to query for and parse out the latest open issues from a GitHub repository. To register a typed client, the generic AddHttpClient extension method can be used within , specifying the typed client class: The typed client is registered as transient with DI. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } If preferred, the configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: It's possible to entirely encapsulate the within a typed client. Rather than exposing it as a property, public methods can be provided which call the instance internally. In the preceding code, the is stored as a private field. All access to make external calls goes through the method. can be used in combination with other third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: already has the concept of delegating handlers that can be linked together for outgoing HTTP requests. The makes it easy to define the handlers to apply for each named client. It supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern is similar to the inbound middleware pipeline in ASP.NET Core. The pattern provides a mechanism to manage cross-cutting concerns around HTTP requests, including caching, error handling, serialization, and logging. To create a handler, define a class deriving from DelegatingHandler. Override the method to execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code defines a basic handler. It checks to see if an header has been included on the request. If the header is missing, it can avoid the HTTP call and return a suitable response. During registration, one or more handlers can be added to the configuration for an . This task is accomplished via extension methods on the IHttpClientBuilder. services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5000/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); In the preceding code, the is registered with DI. The handler must be registered in DI as a transient service, never scoped. If the handler is registered as a scoped service and any services that the handler depends upon are disposable:\nâ€¢ The handler's services could be disposed before the handler goes out of scope.\nâ€¢ The disposed handler services causes the handler to fail. Once registered, AddHttpMessageHandler can be called, passing in the handler type. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); Use one of the following approaches to share per-request state with message handlers:\nâ€¢ Pass data into the handler using .\nâ€¢ Use to access the current request. integrates with a popular third-party library called Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions:\nâ€¢ Can be used after installing the Microsoft.Extensions.Http.Polly NuGet package. The package isn't included in the ASP.NET Core shared framework. Most common faults occur when external HTTP calls are transient. A convenient extension method called is included which allows a policy to be defined to handle transient errors. Policies configured with this extension method handle , HTTP 5xx responses, and HTTP 408 responses. The extension can be used within . The extension provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Additional extension methods exist which can be used to add Polly-based handlers. One such extension is , which has multiple overloads. One overload allows the request to be inspected when defining which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. It's common to nest Polly policies to provide enhanced functionality: In the preceding example, two handlers are added. The first uses the extension to add a retry policy. Failed requests are retried up to three times. The second call to adds a circuit breaker policy. Further external requests are blocked for 30 seconds if five failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a . An extension method is provided which allows a handler to be added using a policy from the registry: In the preceding code, two policies are registered when the is added to the . To use a policy from the registry, the method is used, passing the name of the policy to apply. Further information about and Polly integrations can be found on the Polly wiki. A new instance is returned each time is called on the . There's an HttpMessageHandler per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis. To override it, call SetHandlerLifetime on the that is returned when creating the client: Disposal of the client isn't required. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. The instances can generally be treated as .NET objects not requiring disposal. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\nâ€¢ Create an instance of when the app starts and use it for the life of the app.\nâ€¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\nâ€¢ The shares connections across instances. This sharing prevents socket exhaustion.\nâ€¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in your logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of . Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged against the log category . For the request, this occurs after all other handlers have run and immediately before the request is sent out on the network. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers, for example, or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients where necessary. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\nâ€¢ IHttpClientFactory is registered in the Generic Host's service container.\nâ€¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\nâ€¢ The service's method is executed to write the first 500 characters of the webpage content to the console. For more information on calling services from , see Dependency injection in ASP.NET Core. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (Â©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is a community supported middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\nâ€¢ None Reference the community supported port of the package HeaderPropagation. ASP.NET Core 3.1 and later supports Microsoft.AspNetCore.HeaderPropagation.\nâ€¢ None Configure the middleware and in :\nâ€¢ None The client includes the configured headers on outbound requests:\nâ€¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies"
    },
    {
        "link": "https://medium.com/@jaimin_99136/httpclient-usage-in-net-core-with-examples-506f4ad17f3b",
        "document": "A software element or library that permits communication with HTTP servers is known as an HTTP client. It enables you to communicate with servers by sending requests (such as GET, POST, PUT, and DELETE) and receiving answers.\n\nAn application protocol for networked, cooperative, hypermedia information systems is called the Hypertext Transfer Protocol (HTTP). The World Wide Webâ€™s data transfer infrastructure is built on HTTP.\n\nA collection of request methods is defined by HTTP to specify the desired action to be carried out for a certain resource.\n\nÂ· GET â€” requests an image of the given resource.\n\nÂ· HEAD â€” Similar to a GET request, but without the body of the response.\n\nÂ· POST â€” delivers data to a resource, frequently resulting in adverse effects or state changes.\n\nÂ· PUT â€” generates new resources or modifies already-existing ones.\n\nÂ· CONNECT â€” initiates a two-way conversation with the resource that was requested.\n\nÂ· PATCH â€” makes some minor changes to the resource.\n\nThe status codes for HTTP responses provide information about whether a particular HTTP request was fulfilled successfully. Five classes are created from the responses:\n\nÂ· Sending Requests: A server can receive and process HTTP requests created by an HTTP client.\n\nÂ· Response Handling: It takes in and interprets the answers from the server.\n\nÂ· Connection management: oversees the management of connections (connection pooling, reuse, etc.).\n\nÂ· Authentication: Accepts a number of authentication techniques (such as basic and OAuth).\n\nÂ· Error Handling: Addresses errors, such as network problems and timeouts.\n\nÂ· Customization: Enables the setting of timeouts, headers, and other parameters.\n\nAs an illustration, follow the below code and use it on your application side whenever needed.\n\nIn some of the places where we require authorization tokens, we will add them in the header, make the request, and give the response.\n\nThe HTTPClient waits 100000 ms, or 100 seconds, by default, for a request to complete. It throws an exception if it finishes before then. We refer to this as a timeout.\n\nIf you feel compelled to alter that, you are free to do so. The HTTPClient class has an option named Timeout that is configured using a TimeSpan.\n\nAn picture can be downloaded from the internet using the HTTPClient, stored as an array of bytes, and then saved as a file. We make use of the GetByteArrayAsync(uri) function for this.\n\nIn C#, you can use the HTTPClient to reach a target through a proxy. You can set up its unique handler to make use of the proxy.\n\nThe proxy in the following example is made up.\n\nIn this article, we are using the HttpClient to send the request to the external resources and get a response. For that, we are creating the new object manually. In the next article, we will learn how to register the http client in the .NET core application and make use of that http client on the .NET core application side for sending the request to external resources.\n\nWe learned the new technique and evolved together."
    },
    {
        "link": "https://stackoverflow.com/questions/54886594/making-rest-api-requests-get-post-put-delet-in-c-sharp-console",
        "document": "Use the HttpClient class available in .NET Core. This class contains methods for all of the HTTP operations you mentioned (such as PostAsJson). It will also handle any object-to-Json serialisation for you."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient",
        "document": "In this article, you learn how to make HTTP requests and handle responses with the class.\n\nHTTP endpoints commonly return JavaScript Object Notation (JSON) data, but not always. For convenience, the optional System.Net.Http.Json NuGet package provides several extension methods for and objects that perform automatic serialization and deserialization by using the ðŸ“¦ System.Text.Json NuGet package. The examples in this article call attention to places where these extensions are available.\n\nMost of the examples in this article reuse the same instance, so you can configure the instance once and use it for the remaining examples. To create an object, use the class constructor. For more information, see Guidelines for using HttpClient.\n\nThe code completes the following tasks:\nâ€¢ Instantiate a new instance as a variable. According to the guidelines, the recommended approach is to reuse instances during the application lifecycle.\n\nThis instance uses the base address to make subsequent requests. To apply other configurations, consider the following APIs:\n\nTo make an HTTP request, you call any of the following API methods:\n\nThe HttpContent type is used to represent an HTTP entity body and corresponding content headers. For HTTP methods (or request methods) that require a body ( , , ), you use the HttpContent class to specify the body of the request. Most examples show how to prepare the StringContent subclass with a JSON payload, but other subclasses exist for different content (MIME) types.\nâ€¢ FormUrlEncodedContent: Provides HTTP content for name/value tuples encoded by using the MIME type.\nâ€¢ MultipartContent: Provides a collection of HttpContent objects that get serialized by using the MIME type specification.\nâ€¢ MultipartFormDataContent: Provides a container for content encoded by using the MIME type.\nâ€¢ ReadOnlyMemoryContent: Provides HTTP content based on an ReadOnlyMemory<T> value.\n\nThe class is also used to represent the response body of the HttpResponseMessage class, which is accessible on the HttpResponseMessage.Content property.\n\nUse an HTTP GET request\n\nA request shouldn't send a body. This request is used (as the method name indicates) to retrieve (or get) data from a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.GetAsync method:\n\nThe code completes the following tasks:\nâ€¢ Write the request details to the console.\nâ€¢ Write the JSON response body to the console.\n\nThe method is a custom extension that isn't part of the framework. If you're curious about the implementation, consider the following C# code:\n\nThis functionality is used to write the request details to the console in the following form:\n\nAs an example, the request to the endpoint outputs the following message:\n\nCreate the HTTP GET request from JSON\n\nThe https://jsonplaceholder.typicode.com/todos endpoint returns a JSON array of objects. Their JSON structure resembles the following form:\n\nThe C# object is defined as follows:\n\nIt's a type, with optional , , , and properties. For more information on the type, see Introduction to record types in C#. To automatically deserialize requests into a strongly typed C# object, use the GetFromJsonAsync extension method that's part of the ðŸ“¦ System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ The query string represents the filtering criteria for the request. When the command succeeds, the response is automatically deserialized into a object.\nâ€¢ None Write the request details to the console, along with each object.\n\nA request sends data to the server for processing. The header of the request signifies what MIME type the body is sending. To make an HTTP request given an instance and a Uri object, use the HttpClient.PostAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Write the response body as a string to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PostAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the object to the console.\n\nThe request method either replaces an existing resource or creates a new one by using the request body payload. To make an HTTP request given an instance and a Uri object, use the HttpClient.PutAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PutAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the objects to the console.\n\nThe request is a partial update to an existing resource. This request doesn't create a new resource and it isn't intended to replace an existing resource. Instead, this method only partially updates a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.PatchAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nNo extension methods exist for requests in the NuGet package.\n\nA request removes an existing resource and the request is idempotent, but not safe. Multiple requests to the same resources yield the same result, but the request affects the state of the resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.DeleteAsync method:\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\n\nThe request is similar to a request. Instead of returning the resource, this request returns only the headers associated with the resource. A response to the request doesn't return a body. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response headers and write each header to the console.\n\nThe request is used to identify which HTTP methods a server or endpoint supports. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Send an HTTP request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response content headers and write each header to the console.\n\nThe request can be useful for debugging as it provides application-level loop-back of the request message. To make an HTTP request, create an HttpRequestMessage by using the type:\n\nWhen you handle an HTTP response, you interact with the HttpResponseMessage type. Several members are used to evaluate the validity of a response. The HTTP status code is available in the HttpResponseMessage.StatusCode property.\n\nTo ensure the is (HTTP status code 200), you can evaluate the value as shown in the following example:\n\nThere are other HTTP status codes that represent a successful response, such as (HTTP status code 201), (HTTP status code 202), (HTTP status code 204), and (HTTP status code 205). You can use the HttpResponseMessage.IsSuccessStatusCode property to evaluate these codes as well, which ensures that the response status code is within the range 200-299:\n\nIf you need to have the framework throw the HttpRequestException error, you can call the HttpResponseMessage.EnsureSuccessStatusCode() method:\n\nThis code throws an error if the response status code isn't within the 200-299 range.\n\nWith a valid response, you can access the response body by using the Content property. The body is available as an HttpContent instance, which you can use to access the body as a stream, byte array, or string.\n\nThe following code uses the object to read the response body:\n\nYou can use different objects to read the response body. Use the object to read the response body:\n\nUse the object to read the response body:\n\nWhen you know an HTTP endpoint returns JSON, you can deserialize the response body into any valid C# object by using the System.Net.Http.Json NuGet package:\n\nIn this code, the value is the response body deserialized as the type .\n\nWhen an HTTP request fails, the system throws the HttpRequestException object. Catching the exception alone might not be sufficient. There are other potential exceptions thrown that you might want to consider handling. For example, the calling code might use a cancellation token that was canceled before the request completed. In this scenario, you can catch the TaskCanceledException error:\n\nLikewise, when you make an HTTP request, if the server doesn't respond before the HttpClient.Timeout value is exceeded, the same exception is thrown. In this scenario, you can distinguish that the time-out occurred by evaluating the Exception.InnerException property when catching the TaskCanceledException error:\n\nIn the code, when the inner exception is an TimeoutException type, then the time-out occurred and the cancellation token doesn't cancel the request.\n\nTo evaluate the HTTP status code when you catch the HttpRequestException object, you can evaluate the HttpRequestException.StatusCode property:\n\nIn the code, the EnsureSuccessStatusCode() method is called to throw an exception if the response isn't successful. The HttpRequestException.StatusCode property is then evaluated to determine if the response was a (HTTP status code 404). There are several helper methods on the object that implicitly call the method on your behalf.\n\nFor HTTP error handing, consider the following APIs:\n\nWhen you call these methods, you can handle the object and evaluate the HttpRequestException.StatusCode property to determine the HTTP status code of the response:\n\nThere might be scenarios where you need to throw the HttpRequestException object in your code. The HttpRequestException() constructor is public and you can use it to throw an exception with a custom message:\n\nAn HTTP proxy can be configured in one of two ways. A default is specified on the HttpClient.DefaultProxy property. Alternatively, you can specify a proxy on the HttpClientHandler.Proxy property.\n\nThe property is a static property that determines the default proxy that all instances use, if no proxy is set explicitly in the HttpClientHandler object passed through its constructor.\n\nThe default instance returned by this property initializes according to a different set of rules depending on your platform:\nâ€¢ Windows: Read proxy configuration from environment variables, or if variables aren't defined, read from user proxy settings.\nâ€¢ macOS: Read proxy configuration from environment variables, or if variables aren't defined, read from system proxy settings.\nâ€¢ Linux: Read proxy configuration from environment variables, or if variables aren't defined, initialize a nonconfigured instance to bypass all addresses.\n\nThe property initialization on Windows and Unix-based platforms uses the following environment variables:\nâ€¢ : The proxy server used on HTTP requests.\nâ€¢ : The proxy server used on HTTPS requests.\nâ€¢ : The proxy server used on HTTP and/or HTTPS requests when the and/or variables aren't defined.\nâ€¢ : A comma-separated list of hostnames to exclude from proxying. Asterisks aren't supported for wildcards. Use a leading period (.) when you want to match a subdomain. Examples: (with leading period) matches , but doesn't match . (without leading period) doesn't match . This behavior might be revisited in the future to match other ecosystems better.\n\nOn systems where environment variables are case-sensitive, the variable names can be all lowercase or all uppercase. The lowercase names are checked first.\n\nThe proxy server can be a hostname or IP address, optionally followed by a colon and port number, or it can be an URL, optionally including a username and password for proxy authentication. The URL must start with , not , and can't include any text after the hostname, IP, or port.\n\nThe HttpClientHandler.Proxy property identifies the WebProxy object to use to process requests to internet resources. To specify that no proxy should be used, set the property to the proxy instance returned by the GlobalProxySelection.GetEmptyWebProxy() method.\n\nThe local computer or application configuration file might specify that a default proxy is used. If the property is specified, then the proxy settings from the property override the local computer or application config file and the handler uses the proxy settings specified. If no proxy is specified in a config file and the property is unspecified, the handler uses the proxy settings inherited from the local computer. If there are no proxy settings, the request is sent directly to the server.\n\nThe HttpClientHandler class parses a proxy bypass list with wildcard characters inherited from local computer settings. For example, the class parses a bypass list of from browsers as a regular expression of . Therefore, a URL of bypasses the proxy by using the class.\n\nThe class supports local proxy bypass. The class considers a destination to be local if any of the following conditions are met:\nâ€¢ The destination contains a flat name (no periods (.) in the URL).\nâ€¢ The destination contains a loopback address (Loopback or IPv6Loopback) or the destination contains an IPAddress property assigned to the local computer.\nâ€¢ The domain suffix of the destination matches the local computer's domain suffix, as defined in the DomainName property.\n\nFor more information about configuring a proxy, see the following APIs:"
    },
    {
        "link": "https://infoq.com/articles/creating-http-sdks-dotnet-6",
        "document": "Today's cloud-based, microservice-based or internet-of-things applications often depend on communicating with other systems across a network. Each service runs in its process and solves a bounded set of problems. Communication between services is based on a lightweight mechanism, often an HTTP resource API.\n\nFrom a .NET developer perspective, we want to provide a consistent and manageable way of integrating with a particular service in the form of a distributable package. Preferably, we also want to ship the service integration code we develop as a NuGet package and share it with other people, teams, or even organizations. In this article, I will share many aspects of creating and using HTTP Client SDKs using .NET 6.\n\nClient SDKs provide a meaningful abstraction layer over remote service. Essentially, it allows making Remote Procedure Calls (RPC) The responsibility of a Client SDK is to serialize some data, send it to a remote destination, deserialize incoming data, and process a response.\n\nHTTP Client SDKs are used in conjunction with APIs to:\nâ€¢ Give partial control to service owners over the way APIs are consumed\n\nIn this article, we will write a full-fledged Dad Jokes API Client. Its purpose is to serve dad jokes; let's have some fun. The source code can be found at GitHub.\n\nWhen developing a Client SDK to be used with an API, it is a good idea to start from the interface contract (between the API and the SDK):\n\nThe contract is created based on the API with which you are integrating. My general recommendations are to develop common-purpose APIs and follow the Robustness Principle and the Principle of least astonishment. But it is also totally fine if you want to modify and transform data contracts based on your needs and just think about it from a consumer perspective.\n\nThe bread and butter of HTTP-based integrations is the . It contains everything you need to work with HTTP abstractions successfully.\n\nWe usually use JSON over HTTP APIs, which is why since .NET 5 the namespace was added to BCL. It provides many extension methods for and that perform serialization and deserialization using . If you don't have something complex and exotic, I suggest using because it frees you from writing boilerplate code. Not only is it boring, but it also is not trivial to get it right in the most efficient and bug-free way from the get-go. I suggest you check Steves' Gordon blog post - sending and receiving JSON using HttpClient\n\nTip: You may want to create some centralized place to manage the endpoints URLs, like this:\n\nTip: If you need to deal with complex URIs - use Flurl. It provides a fluent URL-building experience.\n\nNext, we must specify the required headers (and other required configurations). We want to provide a flexible mechanism for configuring used as part of the SDK. In this case, we need to supply credentials in the custom header and specify a well-known \"Accept\" header.\n\nTip: Expose high-level building blocks as . It makes it easy to discover API-specific configurations. For example, if you have a custom authorization mechanism, it should be supported by SDK (at least provide documentation for it).\n\nTo construct our we need to create a . As you know, implements because there is an underlying unmanageable resource - TCP connection. Only a limited amount of concurrent TCP connections can be opened simultaneously on a single machine. This consideration also brings an important question - \"Should I create HttpClient every time I need it or only once during an application startup?\"\n\nis a shared object. This means that under the covers, it is reentrant and thread-safe. Instead of creating a new instance for each execution, you should share a single instance of . However, this approach also comes with its own set of issues. For example, the client will keep connections open for the lifespan of the application, it won't respect the DNS TTL settings, and it will never get DNS updates. So this isn't a perfect solution either.\n\nYou need to manage a pool of TCP connections disposed of from time to time to respect DNS updates. This is exactly what does. The official documentation describes as being \"an opinionated factory for creating instances to be used in your applications.\" We will see how to use it in a moment.\n\nEach time you get an object from the a new instance is returned. But each uses an that's pooled and reused by the to reduce resource consumption. Pooling of handlers is desirable as each handler typically manages its underlying HTTP connections. Some handlers also keep connections open indefinitely, preventing the handler from reacting to DNS changes. has a limited lifetime.\n\nBelow, you can see how comes into play when using managed by dependency injection (DI).\n\nIn our example, a basic usage scenario for consuming an API is a console application without a dependency injection container. The goal here is to give consumers the fastest way possible to access an existing API.\n\nThis way, we can use from the console application:\n\nThe next step is to configure as part of a dependency injection container. I will not go into details over this subject: there are a lot of good stuff on the internet. Once again, there is a really good article from Steve Gordon - HttpClientFactory in ASP.NET Core\n\nTo add a pooled instance using DI, you need to use from .\n\nUse the extension method as follows:\n\nAs you see, you can use outside of ASP.NET Core. For example, console applications, workers, lambdas, etc.\n\nThe interesting part here is that clients created by DI automatically log outgoing requests, making development and troubleshooting so much easier.\n\nIf you manipulate the format of the log template and add and you can see that adds additional handlers itself. This is useful when you try to troubleshoot issues related to HTTP request processing.\n\nThe most common scenario is web applications. Here is .NET 6 MinimalAPI example:\n\nalso provides an extension point: a message handler. It is a class that receives an HTTP request and returns an HTTP response. A wide variety of problems could be expressed as cross-cutting concerns. For example, logging, authentication, caching, header forwarding, auditing, etc. Aspect-oriented programming aims to encapsulate cross-cutting concerns into aspects to retain modularity. Typically, a series of message handlers are chained together. The first handler receives an HTTP request, does some processing, and gives the request to the next handler. At some point, the response is created and goes back up the chain.\n\nTask. Assume you need to copy a list of headers from ASP.NET Core and pass them to all outgoing requests made by Dad Jokes API client.\n\nWe want to \"plug\" a into the request pipeline.\n\nFor non- scenarios, we want clients to specify a list to build an underlying chain for .\n\nSo, without using a DI container, extending could be done like this:\n\nIn DI container scenarios, on the other hand, we want to provide an auxiliary extension method to easily plug by using .\n\nHere is how extended MinimalAPI example looks like:\n\nSometimes functionality like this is reused by other services. You might want to take it one step further and factor out all shared code into a common NuGet package and use it in HTTP Client SDKs.\n\nNot only can we write our message handlers. There are many useful NuGet packages provided and supported by the .NET OSS community. Here are my favorites:\n\nResiliency patterns - retry, cache, fallback, etc.: Very often, in a distrusted systems world, you need to ensure high availability by incorporating some resilience policies. Luckily, we have a built-in solution to build and define policies in .NET - Polly. There is out-of-the-box integration with provided by Polly. This uses a convenience method, IHttpClientBuilder.AddTransientHttpErrorPolicy. It configures a policy to handle errors typical of HTTP calls: HTTP 5XX status codes (server errors), HTTP 408 status code (request timeout).\n\nFor example, transient errors might be handled proactively by using Retry and Circuit Breaker patterns. Usually, we use a retry pattern when there is a hope that downstream service will self-correct eventually. Waiting between retries provides an opportunity for a downstream service to stabilize. It is common to use retries based on the Exponential Backoff algorithm. On paper, it sounds great, but in real-world scenarios, the retry pattern may be overused. Additional retries might be the source of additional load or spikes. In the worst case, resources in the caller may then become exhausted or excessively blocked, waiting for replies which will never come causing an upstream-cascading failure.\n\nThis is when the Circuit Breaker pattern comes into play. It detects the level of faults and prevents calls to a downstream service when a fault threshold is exceeded. Use this pattern when there is no chance of succeeding - for example, where a subsystem is completely offline or struggling under load. The idea behind Circuit Breaker is pretty straightforward, although, you might build something more complex on top of it. When faults exceed the threshold, calls are placed through the circuit, so instead of processing a request, we practice the fail-fast approach, throwing an exception immediately.\n\nPolly is really powerful and it provides a way to combine resilience strategies. See PolicyWrap.\n\n Here is a classification of the strategies you might want to use:\n\nDesigning reliable systems could be a challenging task, I suggest you investigate the subject on your own. Here is a good introduction - .NET microservices - Architecture e-book: Implement resilient applications\n\nAuthentication in OAuth2/OIDC: If you need to manage user and client access tokens, I suggest using IdentityModel.AspNetCore. It acquires, caches, and rotates tokens for you. See the docs.\n\nYou should be pretty comfortable designing and writing your HTTP Client SDKs by this time. The only thing left is to write some tests to ensure expected behavior. Note that it might be good to skip extensive unit testing and write more integration or e2e to ensure proper integration. For now, I will show you how to unit test .\n\nAs you have seen previously, is extensible. Furthermore, we can replace the standard with the test version. So, instead of sending actual requests over the wire, we will use the mock. This technique opens tons of opportunities because we can simulate all kinds of behaviors that otherwise could be hard to replicate in a normal situation.\n\nLet's define reusable methods to create a mock of that we will pass as a dependency to .\n\nFrom this point, unit testing is a pretty simple process:\n\nUsing is the most flexible approach. You have full control over integration with APIs. But, there is a downside, you need to write a lot of boilerplate code. In some situations, an API you are integrating with is trivial, so you don't need all capabilities provided by , , .\nâ€¢ Full control over behavior and data contracts. You can even write a \"smart\" API Client and move some logic inside SDK if it makes sense for a particular scenario. For example, you can throw custom exceptions, transform requests and responses, provide default values for headers, etc.\nâ€¢ Easy to debug and troubleshoot. A stack trace is simple, and you can always spin up the debugger to see what is happening under the hood.\nâ€¢ Need to write a lot of repetitive code\nâ€¢ Someone should maintain a codebase in case of API changes and bugs. This is a tedious and error-prone process.\n\nRefit is an automatic type-safe REST library for .NET. It turns your REST API into a live interface. Refit uses as the default JSON serializer.\n\nEvery method must have an HTTP attribute that provides the request method and relative URL.\n\nRefit generates type that implements based on information provided by\n\nThe approach is the same as for vanilla integration, but instead of constructing a client manually, we use the static method provided by Refit.\n\nFor DI container scenarios, we can use the extension method.\n\nNote, since the contract of the generated client should match the underlying data contract, we no longer have control of contract transformation, and this responsibility is delegated to consumers.\n\nLet's see how the code above works in practice. The output of the MinimalAPI example is different because I've added Serilog logging.\n\nAs usual, there are some pros and some cons:\nâ€¢ Easy to use and develop API clients.\nâ€¢ Highly configurable. Flexible enough to get things done.\nâ€¢ No need for additional unit testing\nâ€¢ Hard to troubleshoot. Sometimes it can be hard to understand how the generated code works. For example, there is a mismatch in configuration.\nâ€¢ Requires other team members to understand how to read and write code developed with Refit.\nâ€¢ Still consumes some time for medium/large APIs.\n\nThere is a way to automate HTTP Client SDKs fully. The OpenAPI/Swagger specification uses JSON and JSON Schema to describe a RESTful web API. The NSwag project provides tools to generate client code from these OpenAPI specifications. Everything can be automated via CLI (distributed via NuGet tool, build target, or NPM).\n\nDad Jokes API doesn't provide OpenAPI, so I wrote it manually. Fortunately, it was quite easy to do:\n\nNow, we want to generate HTTP Client SDK automatically. Let's use NSwagStudio.\n\nHere is how the generated looks like (XML comments are deleted for brevity):\n\nAs usual, we want to provide the registration of typed clients as an extension method:\n\nLet's run it and enjoy the last joke of this article:\nâ€¢ Supported by a rich set of tools and vibrant community\nâ€¢ Fully automated, new SDK can be generated as part of CI/CD process every time OpenAPI specification is changed\nâ€¢ Relatively easy to troubleshoot since we can see the code generated by the toolchain.\nâ€¢ Can't be applied without proper OpenAPI specification\nâ€¢ Hard to customize and control the contract of generated API Client\n\nIn this article, we learned three different ways of producing SDK clients. The process of choosing the right approach can be simplified as follows:\n\nIn this article, we have reviewed different ways of developing HTTP Client SDKs. Choosing the right approach depends on specific use-case and requirements, but I hope this article gives you the foundations you need to make the best design decisions when designing your own Client SDK. Thank you."
    },
    {
        "link": "https://stackoverflow.com/questions/75714743/best-practice-to-use-httpclient-in-net-6-0",
        "document": "I am looking for a best practice solution for the next task.\n\nI created an SDK which works with public API. The SDK communicates with API via Http request. I use class to make http requests.\n\nMy goal is to build a Nuget package so consumers will be able to just install this SDK and communicate with the public API.\n\nIn the end we have two projects :\n\nQuestion: where do I have to instantiate an instance of class?\n\nMy thoughts: if I do it in the Sdk project, and just use:\n\nThis is not good. Because it is bad practice to create an instance of HttpClient class via . See https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines\n\nAccording this guide from MS, I have to initiate this instance via DI in the consumer project:\n\nIf I select this options I thinks It is will be hard for client to register my SDK, client must do two steps:\n\nIs it possible to reduce the amount of steps and make using my library easier?"
    },
    {
        "link": "https://github.com/dotnet/runtime/blob/main/src/libraries/System.Net.Http/src/System/Net/Http/HttpClient.cs",
        "document": ""
    }
]