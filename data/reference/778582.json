[
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/mvc/views/layout?view=aspnetcore-9.0",
        "document": "Pages and views frequently share visual and programmatic elements. This article demonstrates how to:\n\nThis document discusses layouts for the two different approaches to ASP.NET Core MVC: Razor Pages and controllers with views. For this topic, the differences are minimal:\n• Razor Pages are in the Pages folder.\n• Controllers with views uses a Views folder for views.\n\nMost web apps have a common layout that provides the user with a consistent experience as they navigate from page to page. The layout typically includes common user interface elements such as the app header, navigation or menu elements, and footer.\n\nCommon HTML structures such as scripts and stylesheets are also frequently used by many pages within an app. All of these shared elements may be defined in a layout file, which can then be referenced by any view used within the app. Layouts reduce duplicate code in views.\n\nBy convention, the default layout for an ASP.NET Core app is named . The layout files for new ASP.NET Core projects created with the templates are:\n\nThe layout defines a top level template for views in the app. Apps don't require a layout. Apps can define more than one layout, with different views specifying different layouts.\n\nThe following code shows the layout file for a template created project with a controller and views:\n\nRazor views have a property. Individual views specify a layout by setting this property:\n\nThe layout specified can use a full path (for example, or ) or a partial name (example: ). When a partial name is provided, the Razor view engine searches for the layout file using its standard discovery process. The folder where the handler method (or controller) exists is searched first, followed by the Shared folder. This discovery process is identical to the process used to discover partial views.\n\nBy default, every layout must call . Wherever the call to is placed, the contents of the view will be rendered.\n\nA layout can optionally reference one or more sections, by calling . Sections provide a way to organize where certain page elements should be placed. Each call to can specify whether that section is required or optional:\n\nIf a required section isn't found, an exception is thrown. Individual views specify the content to be rendered within a section using the Razor syntax. If a page or view defines a section, it must be rendered (or an error will occur).\n\nAn example definition in Razor Pages view:\n\nIn the preceding code, is added to the section on a page or view. Other pages or views in the same app might not require this script and wouldn't define a scripts section.\n\nThe following markup uses the Partial Tag Helper to render :\n\nThe preceding markup was generated by scaffolding Identity.\n\nSections defined in a page or view are available only in its immediate layout page. They cannot be referenced from partials, view components, or other parts of the view system.\n\nBy default, the body and all sections in a content page must all be rendered by the layout page. The Razor view engine enforces this by tracking whether the body and each section have been rendered.\n\nTo instruct the view engine to ignore the body or sections, call the and methods.\n\nThe body and every section in a Razor page must be either rendered or ignored.\n\nViews and pages can use Razor directives to import namespaces and use dependency injection. Directives shared by many views may be specified in a common file. The file supports the following directives:\n\nThe file doesn't support other Razor features, such as functions and section definitions.\n\nThe file for an ASP.NET Core MVC app is typically placed in the Pages (or Views) folder. A file can be placed within any folder, in which case it will only be applied to pages or views within that folder and its subfolders. files are processed starting at the root level and then for each folder leading up to the location of the page or view itself. settings specified at the root level may be overridden at the folder level.\n\nPages and views in the subfolder will have access to both Tag Helpers and the model.\n\nIf multiple files are found in the file hierarchy, the combined behavior of the directives are:\n• : the closest one to the view overrides any others\n• : the closest one to the view overrides any others\n• : the closest one to the view overrides any others\n• : all are included; duplicates are ignored\n• : for each property, the closest one to the view overrides any others with the same property name\n\nCode that needs to run before each view or page should be placed in the file. By convention, the file is located in the Pages (or Views) folder. The statements listed in are run before every full view (not layouts, and not partial views). Like ViewImports.cshtml, is hierarchical. If a file is defined in the view or pages folder, it will be run after the one defined in the root of the Pages (or Views) folder (if any).\n\nThe file above specifies that all views will use the layout.\n\nand are not typically placed in the /Pages/Shared (or /Views/Shared) folder. The app-level versions of these files should be placed directly in the /Pages (or /Views) folder."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-9.0",
        "document": "Razor is a markup syntax for embedding .NET based code into webpages. The Razor syntax consists of Razor markup, C#, and HTML. Files containing Razor generally have a file extension. Razor is also found in Razor component files ( ). Razor syntax is similar to the templating engines of various JavaScript single-page application (SPA) frameworks, such as Angular, React, VueJs, and Svelte. For more information see, The features described in this article are obsolete as of ASP.NET Core 3.0.\n\nIntroduction to ASP.NET Web Programming Using the Razor Syntax provides many samples of programming with Razor syntax. Although the topic was written for ASP.NET rather than ASP.NET Core, most of the samples apply to ASP.NET Core.\n\nThe default Razor language is HTML. Rendering HTML from Razor markup is no different than rendering HTML from an HTML file. HTML markup in Razor files is rendered by the server unchanged.\n\nRazor supports C# and uses the symbol to transition from HTML to C#. Razor evaluates C# expressions and renders them in the HTML output.\n\nWhen an symbol is followed by a Razor reserved keyword, it transitions into Razor-specific markup. Otherwise, it transitions into plain HTML.\n\nTo escape an symbol in Razor markup, use a second symbol:\n\nThe code is rendered in HTML with a single symbol:\n\nHTML attributes and content containing email addresses don't treat the symbol as a transition character. The email addresses in the following example are untouched by Razor parsing:\n\nImplicit Razor expressions start with followed by C# code:\n\nWith the exception of the C# keyword, implicit expressions must not contain spaces. If the C# statement has a clear ending, spaces can be intermingled:\n\nImplicit expressions cannot contain C# generics, as the characters inside the brackets ( ) are interpreted as an HTML tag. The following code is not valid:\n\nThe preceding code generates a compiler error similar to one of the following:\n• The \"int\" element wasn't closed. All elements must be either self-closing or have a matching end tag.\n• Cannot convert method group 'GenericMethod' to non-delegate type 'object'. Did you intend to invoke the method?`\n\nGeneric method calls must be wrapped in an explicit Razor expression or a Razor code block.\n\nExplicit Razor expressions consist of an symbol with balanced parenthesis. To render last week's time, the following Razor markup is used:\n\nAny content within the parenthesis is evaluated and rendered to the output.\n\nImplicit expressions, described in the previous section, generally can't contain spaces. In the following code, one week isn't subtracted from the current time:\n\nThe code renders the following HTML:\n\nExplicit expressions can be used to concatenate text with an expression result:\n\nWithout the explicit expression, is treated as an email address, and is rendered. When written as an explicit expression, is rendered.\n\nExplicit expressions can be used to render output from generic methods in files. The following markup shows how to correct the error shown earlier caused by the brackets of a C# generic. The code is written as an explicit expression:\n\nC# expressions that evaluate to a string are HTML encoded. C# expressions that evaluate to are rendered directly through . C# expressions that don't evaluate to are converted to a string by and encoded before they're rendered.\n\nThe preceding code renders the following HTML:\n\nThe HTML is shown in the browser as plain text:\n\nThe code renders the following HTML:\n\nRazor code blocks start with and are enclosed by . Unlike expressions, C# code inside code blocks isn't rendered. Code blocks and expressions in a view share the same scope and are defined in order:\n\nThe code renders the following HTML:\n\nIn code blocks, declare local functions with markup to serve as templating methods:\n\nThe code renders the following HTML:\n\nThe default language in a code block is C#, but the Razor Page can transition back to HTML:\n\nTo define a subsection of a code block that should render HTML, surround the characters for rendering with the Razor tag:\n\nUse this approach to render HTML that isn't surrounded by an HTML tag. Without an HTML or Razor tag, a Razor runtime error occurs.\n\nThe tag is useful to control whitespace when rendering content:\n• Only the content between the tag is rendered.\n• No whitespace before or after the tag appears in the HTML output.\n\nTo render the rest of an entire line as HTML inside a code block, use syntax:\n\nWithout the in the code, a Razor runtime error is generated.\n\nExtra characters in a Razor file can cause compiler errors at statements later in the block. These extra compiler errors:\n• Can be difficult to understand because the actual error occurs before the reported error.\n• Is common after combining multiple implicit and explicit expressions into a single code block.\n\nRazor automatically omits attributes that aren't needed. If the value passed in is or , the attribute isn't rendered.\n\nFor example, consider the following razor:\n\nThe preceding Razor markup generates the following HTML:\n\nControl structures are an extension of code blocks. All aspects of code blocks (transitioning to markup, inline C#) also apply to the following structures:\n\nConditionals @if, else if, else, and @switch\n\nThe following markup shows how to use a switch statement:\n\nLooping @for, @foreach, @while, and @do while\n\nTemplated HTML can be rendered with looping control statements. To render a list of people:\n\nThe following looping statements are supported:\n\nIn C#, a statement is used to ensure an object is disposed. In Razor, the same mechanism is used to create HTML Helpers that contain additional content. In the following code, HTML Helpers render a tag with the statement:\n\nException handling is similar to C#:\n\nRazor has the capability to protect critical sections with lock statements:\n\nThe code renders the following HTML:\n\nRazor comments are removed by the server before the webpage is rendered. Razor uses to delimit comments. The following code is commented out, so the server doesn't render any markup:\n\nRazor directives are represented by implicit expressions with reserved keywords following the symbol. A directive typically changes the way a view is compiled or functions.\n\nUnderstanding how Razor generates code for a view makes it easier to understand how directives work.\n\nThe code generates a class similar to the following:\n\nLater in this article, the section Inspect the Razor C# class generated for a view explains how to view this generated class.\n\nThe directive adds the given attribute to the class of the generated page or view. The following example adds the attribute:\n\nThe directive can also be used to supply a constant-based route template in a Razor component. In the following example, the directive in a component is replaced with the directive and the constant-based route template in , which is set elsewhere in the app to \" \":\n\nThis scenario only applies to Razor components ( ).\n\nThe block enables a Razor component to add C# members (fields, properties, and methods) to a component:\n\nFor Razor components, is an alias of and recommended over . More than one block is permissible.\n\nThe directive enables adding C# members (fields, properties, and methods) to the generated class:\n\nIn Razor components, use over to add C# members.\n\nThe code generates the following HTML markup:\n\nThe following code is the generated Razor C# class:\n\nmethods serve as templating methods when they have markup:\n\nThe code renders the following HTML:\n\nThe directive implements an interface for the generated class.\n\nThe following example implements System.IDisposable so that the Dispose method can be called:\n\nThe directive provides full control of the class the view inherits:\n\nThe following code is a custom Razor page type:\n\nThe is displayed in a view:\n\nThe code renders the following HTML:\n\nand can be used in the same view. can be in a file that the view imports:\n\nThe following code is an example of a strongly-typed view:\n\nIf \"rick@contoso.com\" is passed in the model, the view generates the following HTML markup:\n\nThe directive enables the Razor Page to inject a service from the service container into a view. For more information, see Dependency injection into views.\n\nThis scenario only applies to Razor components ( ).\n\nThe directive specifies a layout for routable Razor components that have an directive. Layout components are used to avoid code duplication and inconsistency. For more information, see ASP.NET Core Blazor layouts.\n\nThis scenario only applies to MVC views and Razor Pages ( ).\n\nThe directive specifies the type of the model passed to a view or page:\n\nIn an ASP.NET Core MVC or Razor Pages app created with individual user accounts, contains the following model declaration:\n\nRazor exposes a property for accessing the model passed to the view:\n\nThe directive specifies the type of the property. The directive specifies the in that the generated class that the view derives from. If the directive isn't specified, the property is of type . For more information, see Strongly typed models and the @model keyword.\n• Sets the namespace of the class of the generated Razor page, MVC view, or Razor component.\n• Sets the root derived namespaces of a pages, views, or components classes from the closest imports file in the directory tree, (views or pages) or (Razor components).\n\nFor the Razor Pages example shown in the following table:\n• Each page has as the root of it's namespace.\n\nThe preceding relationships apply to import files used with MVC views and Razor components.\n\nWhen multiple import files have a directive, the file closest to the page, view, or component in the directory tree is used to set the root namespace.\n\nIf the folder in the preceding example has an imports file with (or the file contains ), the result is shown in the following table.\n\nThe directive has different effects depending on the type of the file where it appears. The directive:\n• In a file indicates that the file is a Razor Page. For more information, see Custom routes and Introduction to Razor Pages in ASP.NET Core.\n• Specifies that a Razor component should handle requests directly. For more information, see ASP.NET Core Blazor routing and navigation.\n\nThis scenario only applies to MVC views and Razor Pages ( ).\n\nThe directive is used in conjunction with MVC and Razor Pages layouts to enable views or pages to render content in different parts of the HTML page. For more information, see Layout in ASP.NET Core.\n\nThis scenario only applies to Razor components ( ).\n\nThe directive declares a generic type parameter for the generated component class:\n\nFor more information, see the following articles:\n\nThe directive adds the C# directive to the generated view:\n\nIn Razor components, also controls which components are in scope.\n\nRazor directive attributes are represented by implicit expressions with reserved keywords following the symbol. A directive attribute typically changes the way an element is compiled or functions.\n\nThis scenario only applies to Razor components ( ).\n\nallows a component to render non-declared attributes. For more information, see ASP.NET Core Blazor attribute splatting and arbitrary parameters.\n\nThis scenario only applies to Razor components ( ).\n\nData binding in components is accomplished with the attribute. For more information, see ASP.NET Core Blazor data binding.\n\nThis scenario only applies to Razor components ( ).\n\nUse the attribute with the attribute to provide a System.Globalization.CultureInfo for parsing and formatting a value. For more information, see ASP.NET Core Blazor globalization and localization.\n\nThis scenario only applies to Razor components ( ).\n\nRazor provides event handling features for components. For more information, see ASP.NET Core Blazor event handling.\n\nThis scenario only applies to Razor components ( ).\n\nPrevents the default action for the event.\n\nThis scenario only applies to Razor components ( ).\n\nThis scenario only applies to Razor components ( ).\n\nThe directive attribute causes the components diffing algorithm to guarantee preservation of elements or components based on the key's value. For more information, see Retain element, component, and model relationships in ASP.NET Core Blazor.\n\nThis scenario only applies to Razor components ( ).\n\nComponent references ( ) provide a way to reference a component instance so that you can issue commands to that instance. For more information, see ASP.NET Core Razor components.\n\nThis scenario only applies to MVC views and Razor Pages ( ).\n\nRazor templates allow you to define a UI snippet with the following format:\n\nThe following example illustrates how to specify a templated Razor delegate as a Func<T,TResult>. The dynamic type is specified for the parameter of the method that the delegate encapsulates. An object type is specified as the return value of the delegate. The template is used with a List<T> of that has a property.\n\nThe template is rendered with supplied by a statement:\n\nYou can also supply an inline Razor template as an argument to a method. In the following example, the method receives a Razor template. The method uses the template to produce HTML content with repeats of items supplied from a list:\n\nUsing the list of pets from the prior example, the method is called with:\n• Number of times to repeat each pet.\n• Inline template to use for the list items of an unordered list.\n\nThis scenario only applies to MVC views and Razor Pages ( ).\n\nThere are three directives that pertain to Tag Helpers.\n\nRazor keywords are escaped with (for example, ).\n\nC# Razor keywords must be double-escaped with (for example, ). The first escapes the Razor parser. The second escapes the C# parser.\n\nReserved keywords not used by Razor\n\nInspect the Razor C# class generated for a view\n\nThe Razor view engine performs case-sensitive lookups for views. However, the actual lookup is determined by the underlying file system:\n• File based source:\n• On operating systems with case insensitive file systems (for example, Windows), physical file provider lookups are case insensitive. For example, results in matches for , , and any other casing variant.\n• On case-sensitive file systems (for example, Linux, OSX, and with ), lookups are case-sensitive. For example, specifically matches .\n• Precompiled views: With ASP.NET Core 2.0 and later, looking up precompiled views is case insensitive on all operating systems. The behavior is identical to physical file provider's behavior on Windows. If two precompiled views differ only in case, the result of lookup is non-deterministic.\n\nDevelopers are encouraged to match the casing of file and directory names to the casing of:\n\nMatching case ensures the deployments find their views regardless of the underlying file system.\n\nThe following imports are generated by the ASP.NET Core web templates to support Razor Files:\n\nIntroduction to ASP.NET Web Programming Using the Razor Syntax provides many samples of programming with Razor syntax."
    },
    {
        "link": "https://codecademy.com/learn/asp-net-i/modules/asp-net-razor-syntax/cheatsheet",
        "document": "In a Razor view page (.cshtml), the directive indicates that the file is a Razor Page. In order for the page to be treated as a Razor Page, and have ASP.NET parse the view syntax with the Razor engine, the directive should be added at the top of the file. There can be empty space before the directive, but there cannot be any other characters, even an empty code block.\n\nThe page model class, i.e. the data and methods that hold the functionality associated with a view page, is made available to the view page via the directive. By specifying the model in the view page, Razor exposes a property for accessing the model passed to the view page. We can then access properties and functions from that model by using the keyword or render its property values on the browser by prefixing the property names with , e.g. .\n\nIn Razor Pages, you can use the property to pass data from a Page Model to its corresponding view page, as well as share it with the layout, and any partial views. is a dictionary that can contain key-value pairs where each key must be a string. The values can be accessed in the view page using the symbol. A huge benefit of using comes when working with layout pages. We can easily pass information from each individual view page such as the , into the layout by storing it in the dictionary in a view page: We can then access it in the layout like so: . This way, we don’t need to hardcode certain information on each individual view page.\n\nIn Razor Pages, you can reduce code duplication by sharing layouts between view pages. A default layout is set up for your application in the _Layout.cshtml file located in Pages/Shared/. Inside the _Layout.cshtml file there is a method call: . This method specifies the point at which the content from the view page is rendered relative to the layout defined. If you want your view page to use a specific Layout page you can define it at the top by specifying the filename without the file extension:\n\nIn Razor Pages, Tag Helpers change and enhance existing HTML elements by adding specific attributes to them. The elements they target are based on the element name, the attribute name, or the parent tag. ASP.NET provides us with numerous built-in Tag Helpers that can be used for common tasks - such as creating forms, links, loading assets, and more.\n\nThe _ViewImports.cshtml file is automatically generated under /Pages when we create a template with ASP.NET. Just like the _ViewStart.cshtml file, _ViewImports.cshtml is invoked for all your view pages before they are rendered. The purpose of the file is to write common directives that our view pages need. ASP.NET currently supports a few directives that can be added such as: , , , and amongst a few other ones. Instead of having to add them individually to each page, we can place the directives here and they’ll be available globally throughout the application."
    },
    {
        "link": "https://codecademy.com/learn/learn-asp-net/modules/asp-net-razor-syntax/cheatsheet",
        "document": "In a Razor view page (.cshtml), the directive indicates that the file is a Razor Page. In order for the page to be treated as a Razor Page, and have ASP.NET parse the view syntax with the Razor engine, the directive should be added at the top of the file. There can be empty space before the directive, but there cannot be any other characters, even an empty code block.\n\nThe page model class, i.e. the data and methods that hold the functionality associated with a view page, is made available to the view page via the directive. By specifying the model in the view page, Razor exposes a property for accessing the model passed to the view page. We can then access properties and functions from that model by using the keyword or render its property values on the browser by prefixing the property names with , e.g. .\n\nIn Razor Pages, you can use the property to pass data from a Page Model to its corresponding view page, as well as share it with the layout, and any partial views. is a dictionary that can contain key-value pairs where each key must be a string. The values can be accessed in the view page using the symbol. A huge benefit of using comes when working with layout pages. We can easily pass information from each individual view page such as the , into the layout by storing it in the dictionary in a view page: We can then access it in the layout like so: . This way, we don’t need to hardcode certain information on each individual view page.\n\nIn Razor Pages, you can reduce code duplication by sharing layouts between view pages. A default layout is set up for your application in the _Layout.cshtml file located in Pages/Shared/. Inside the _Layout.cshtml file there is a method call: . This method specifies the point at which the content from the view page is rendered relative to the layout defined. If you want your view page to use a specific Layout page you can define it at the top by specifying the filename without the file extension:\n\nIn Razor Pages, Tag Helpers change and enhance existing HTML elements by adding specific attributes to them. The elements they target are based on the element name, the attribute name, or the parent tag. ASP.NET provides us with numerous built-in Tag Helpers that can be used for common tasks - such as creating forms, links, loading assets, and more.\n\nThe _ViewImports.cshtml file is automatically generated under /Pages when we create a template with ASP.NET. Just like the _ViewStart.cshtml file, _ViewImports.cshtml is invoked for all your view pages before they are rendered. The purpose of the file is to write common directives that our view pages need. ASP.NET currently supports a few directives that can be added such as: , , , and amongst a few other ones. Instead of having to add them individually to each page, we can place the directives here and they’ll be available globally throughout the application."
    },
    {
        "link": "https://stackoverflow.com/questions/13312350/best-practice-for-mvc-razor-view-layout",
        "document": "Even the name should already give you a hint whether you should use it or not. Do you want help? If not, just write html from the scratch. It does not really matter how the html was generated: from the scratch or using html helper. What matter is that it was generated with correct names of the inputs so that model binder can bind these inputs to the model.\n\nFor example, suppose you have the following Model that will be passed to the view and that will be received on the POST:\n\nIn order to make sure that your inputs will be binded to the model you need three inputs on your page:\n\nHaving this html markup will assure proper model minding. However, you can achieve this markup by using HtmlHelpers, which is a lot easier:\n\nThis will not only give you proper attributes on every input, but also assign attributes accordingly so you don't have to do that all by your self.\n\nIt appears that the author from the second article suggests to never use HtmlHelpers for two reasons:\n• the learning purposes: I assume by saying \"web developers have to be comfortable writing HTML\" he means that developer should know exactly what html markup is required for proper model binding.\n• the fear of black box: It seem that author is afraid that improper html markup will be generated by using HtmlHelpers or he just does not know what html will be generated.\n\nI disagree with his phrase: \"HtmlHelpers whose only reason of living is hiding the HTML away\". I'd rather say \"HtmlHelpers whose only reason of living is helping writing Html markup\"\n\nSummary: HtmlHelpers help you write proper html markup, which is why I suggest you using it."
    },
    {
        "link": "https://stackoverflow.com/questions/6613626/razor-view-without-layout",
        "document": "Procedure 1 : Control Layouts rendering by using _ViewStart file in the root directory of the Views folder\n\nThis method is the simplest way for beginners to control Layouts rendering in your ASP.NET MVC application. We can identify the controller and render the Layouts as par controller, to do this we can write our code in _ViewStart file in the root directory of the Views folder. Following is an example shows how it can be done.\n\nOne the the great feature of ASP.NET MVC is that, we can override the default layout rendering by returning the layout from the ActionResult. So, this is also a way to render different Layout in your ASP.NET MVC application. Following code sample show how it can be done.\n\nProcedure 3 : View - wise Layout (By defining Layout within each view on the top)\n\nASP.NET MVC provides us such a great feature & faxibility to override the default layout rendering by defining the layout on the view. To implement this we can write our code in following manner in each View.\n\nProcedure 4 : Placing _ViewStart file in each of the directories\n\nThis is a very useful way to set different Layouts for each Controller in your ASP.NET MVC application. If we want to set default Layout for each directories than we can do this by putting _ViewStart file in each of the directories with the required Layout information as shown below:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/mvc/views/layout?view=aspnetcore-9.0",
        "document": "Pages and views frequently share visual and programmatic elements. This article demonstrates how to:\n\nThis document discusses layouts for the two different approaches to ASP.NET Core MVC: Razor Pages and controllers with views. For this topic, the differences are minimal:\n• Razor Pages are in the Pages folder.\n• Controllers with views uses a Views folder for views.\n\nMost web apps have a common layout that provides the user with a consistent experience as they navigate from page to page. The layout typically includes common user interface elements such as the app header, navigation or menu elements, and footer.\n\nCommon HTML structures such as scripts and stylesheets are also frequently used by many pages within an app. All of these shared elements may be defined in a layout file, which can then be referenced by any view used within the app. Layouts reduce duplicate code in views.\n\nBy convention, the default layout for an ASP.NET Core app is named . The layout files for new ASP.NET Core projects created with the templates are:\n\nThe layout defines a top level template for views in the app. Apps don't require a layout. Apps can define more than one layout, with different views specifying different layouts.\n\nThe following code shows the layout file for a template created project with a controller and views:\n\nRazor views have a property. Individual views specify a layout by setting this property:\n\nThe layout specified can use a full path (for example, or ) or a partial name (example: ). When a partial name is provided, the Razor view engine searches for the layout file using its standard discovery process. The folder where the handler method (or controller) exists is searched first, followed by the Shared folder. This discovery process is identical to the process used to discover partial views.\n\nBy default, every layout must call . Wherever the call to is placed, the contents of the view will be rendered.\n\nA layout can optionally reference one or more sections, by calling . Sections provide a way to organize where certain page elements should be placed. Each call to can specify whether that section is required or optional:\n\nIf a required section isn't found, an exception is thrown. Individual views specify the content to be rendered within a section using the Razor syntax. If a page or view defines a section, it must be rendered (or an error will occur).\n\nAn example definition in Razor Pages view:\n\nIn the preceding code, is added to the section on a page or view. Other pages or views in the same app might not require this script and wouldn't define a scripts section.\n\nThe following markup uses the Partial Tag Helper to render :\n\nThe preceding markup was generated by scaffolding Identity.\n\nSections defined in a page or view are available only in its immediate layout page. They cannot be referenced from partials, view components, or other parts of the view system.\n\nBy default, the body and all sections in a content page must all be rendered by the layout page. The Razor view engine enforces this by tracking whether the body and each section have been rendered.\n\nTo instruct the view engine to ignore the body or sections, call the and methods.\n\nThe body and every section in a Razor page must be either rendered or ignored.\n\nViews and pages can use Razor directives to import namespaces and use dependency injection. Directives shared by many views may be specified in a common file. The file supports the following directives:\n\nThe file doesn't support other Razor features, such as functions and section definitions.\n\nThe file for an ASP.NET Core MVC app is typically placed in the Pages (or Views) folder. A file can be placed within any folder, in which case it will only be applied to pages or views within that folder and its subfolders. files are processed starting at the root level and then for each folder leading up to the location of the page or view itself. settings specified at the root level may be overridden at the folder level.\n\nPages and views in the subfolder will have access to both Tag Helpers and the model.\n\nIf multiple files are found in the file hierarchy, the combined behavior of the directives are:\n• : the closest one to the view overrides any others\n• : the closest one to the view overrides any others\n• : the closest one to the view overrides any others\n• : all are included; duplicates are ignored\n• : for each property, the closest one to the view overrides any others with the same property name\n\nCode that needs to run before each view or page should be placed in the file. By convention, the file is located in the Pages (or Views) folder. The statements listed in are run before every full view (not layouts, and not partial views). Like ViewImports.cshtml, is hierarchical. If a file is defined in the view or pages folder, it will be run after the one defined in the root of the Pages (or Views) folder (if any).\n\nThe file above specifies that all views will use the layout.\n\nand are not typically placed in the /Pages/Shared (or /Views/Shared) folder. The app-level versions of these files should be placed directly in the /Pages (or /Views) folder."
    },
    {
        "link": "https://stackoverflow.com/questions/46829785/static-html-page-in-asp-net-mvc-that-does-not-use-layout",
        "document": "I have an entire Web Application built using ASP.NET MVC and have a page that specifies a Layout.\n\nThis works great for my entire site. However, I have a single prototype static HTML page that I just need to dump into a directory.\n\nI copied the HTML into a CSHTML file and fronted it with a controller. The problem is that when I go to this page, it is using the Layout.\n\nHow can I configure it so that I can just serve this page up as static, standalone content without the Layout from ?"
    },
    {
        "link": "https://reddit.com/r/dotnet/comments/kuneo2/possible_to_use_razor_pages_without_bootstrap",
        "document": "I'm interested in experimenting with a greenfield application leveraging Razor pages. It's very low stress so I figured I'd use it as an opportunity to sharpen my skills. I come from the asp.net core web api and angular spa background. As I look at Razor pages, I notice that bootstrap seems to be baked in. Any ideas or experience on how to use other styling such as Material instead of Bootstrap/jQuery? Or am I tied to Bootstrap/jQuery?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/razor-pages?view=aspnetcore-9.0",
        "document": "Razor Pages can make coding page-focused scenarios easier and more productive than using controllers and views.\n\nIf you're looking for a tutorial that uses the Model-View-Controller approach, see Get started with ASP.NET Core MVC.\n\nThis document provides an introduction to Razor Pages. It's not a step by step tutorial. If you find some of the sections too advanced, see Get started with Razor Pages. For an overview of ASP.NET Core, see the Introduction to ASP.NET Core."
    }
]