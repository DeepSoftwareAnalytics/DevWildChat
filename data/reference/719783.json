[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test",
        "document": "Unit testing C# in .NET using dotnet test and xUnit\n\nThis tutorial shows how to build a solution containing a unit test project and source code project. To follow the tutorial using a pre-built solution, view or download the sample code. For download instructions, see Samples and Tutorials.\n\nIn this section, a solution is created that contains the source and test projects. The completed solution has the following directory structure:\n\nThe following instructions provide the steps to create the test solution. See Commands to create test solution for instructions to create the test solution in one step.\n• The command creates a new solution in the unit-testing-using-dotnet-test directory.\n• The command creates a new class library project in the PrimeService folder. The new class library will contain the code to be tested.\n• None Replace the code in PrimeService.cs with the following code:\n• \n• Throws a NotImplementedException with a message indicating it's not implemented.\n• Is updated later in the tutorial.\n• None In the unit-testing-using-dotnet-test directory, run the following command to add the class library project to the solution:\n• None Create the PrimeService.Tests project by running the following command:\n• \n• Creates the PrimeService.Tests project in the PrimeService.Tests directory. The test project uses xUnit as the test library.\n• Configures the test runner by adding the following elements to the project file:\n• None Add the test project to the solution file by running the following command:\n• None Add the class library as a dependency to the PrimeService.Tests project:\n\nThis section summarizes all the commands in the previous section. Skip this section if you've completed the steps in the previous section.\n\nThe following commands create the test solution on a Windows machine. For macOS and Unix, update the command to the OS version of to rename a file:\n\nFollow the instructions for \"Replace the code in PrimeService.cs with the following code\" in the previous section.\n\nA popular approach in test driven development (TDD) is to write a (failing) test before implementing the target code. This tutorial uses the TDD approach. The method is callable, but not implemented. A test call to fails. With TDD, a test is written that is known to fail. The target code is updated to make the test pass. You keep repeating this approach, writing a failing test and then updating the target code to pass.\n• Replace the code in PrimeService_IsPrimeShould.cs with the following code:\n\nThe attribute declares a test method that's run by the test runner. From the PrimeService.Tests folder, run . The dotnet test command builds both projects and runs the tests. The xUnit test runner contains the program entry point to run the tests. starts the test runner using the unit test project.\n\nThe test fails because hasn't been implemented. Using the TDD approach, write only enough code so this test passes. Update with the following code:\n\nAdd prime number tests for 0 and -1. You could copy the test created in the preceding step and make copies of the following code to test 0 and -1. But don't do it, as there's a better way.\n\nCopying test code when only a parameter changes results in code duplication and test bloat. The following xUnit attributes enable writing a suite of similar tests:\n• represents a suite of tests that execute the same code but have different input arguments.\n\nRather than creating new tests, apply the preceding xUnit attributes to create a single theory. Replace the following code:\n\nwith the following code:\n\nIn the preceding code, and enable testing several values less than two. Two is the smallest prime number.\n\nAdd the following code after the class declaration and before the attribute:\n\nRun , and two of the tests fail. To make all of the tests pass, update the method with the following code:\n\nFollowing the TDD approach, add more failing tests, then update the target code. See the finished version of the tests and the complete implementation of the library.\n\nThe completed method is not an efficient algorithm for testing primality."
    },
    {
        "link": "https://xunit.net",
        "document": "xUnit.net is a free, open source, community-focused unit testing tool for the .NET Framework. Written by the original inventor of NUnit v2, xUnit.net is the latest technology for unit testing C#, F#, VB.NET and other .NET languages. xUnit.net works with command line tools, Visual Studio, Visual Studio Code, ReSharper/Rider, CodeRush, and NCrunch. It is part of the .NET Foundation, and operates under their code of conduct. It is licensed under Apache 2 (an OSI approved license).\n\nNew to xUnit.net? These guides will help you get started.\n• Getting started with the .NET SDK command line\n\n Includes running tests from the command line, Visual Studio, Visual Studio Code, and JetBrains Rider\n• Migrating from xUnit.net v2 for unit test authors and extensibility authors\n• What is the JSON schema for ?\n• Why did we build xUnit 1.0?\n• How do I use a CI build NuGet package?\n• What is the format of the XML generated by the test runners?\n• How does xUnit.net compare to other frameworks?\n• Where do I find code that used to live in ?\n\nThe following target frameworks are current supported:\n\nThe following target frameworks have been deprecated and are no longer supported:\n• TestDriven.NET is no longer officially supported in v3 Core Framework, and is only available in Visual Studio 2019 and earlier.\n• Visual Studio support includes the Visual Studio Test Explorer, Visual Studio Code, , and . Express editions of Visual Studio are not supported. Minimum target frameworks for are higher for v2 Core Framework users: NET Framework 4.6.2+ and .NET 6+.\n\nFor information on contributing to xUnit.net, please read the governance document.\n\nSpecial thanks to the .NET on AWS Open Source Software Fund for sponsoring the ongoing development of xUnit.net.\n\nHelp support this project by becoming a sponsor through GitHub Sponsors.\n\nPortions copyright The Legion Of The Bouncy Castle"
    },
    {
        "link": "https://xunit.net/docs/getting-started/v2/netfx/visual-studio",
        "document": "In this article, we will demonstrate getting started with xUnit.net, showing you how to write and run your first set of unit tests.\n\nNote: The examples were done with xUnit.net v2 2.4.1 and Visual Studio 2019. The version numbers, paths, and Visual Studio UI may differ for you, depending on which version you're using.\n\nStart Visual Studio, which will bring you to the start splash screen. Under \"Get Started\", click \"Create a new project\". This will bring you to the first step of the new project wizard, where you pick your project type:\n\nIn the drop down boxes, chooses your language (C#), your platform (All platforms), and your project type (Test). Scroll through the list if necessary until you find the item titled \"xUnit Test Project (.NET Core)\". Select it, then click \"Next\".\n\nWe're picking .NET Core even though we're planning to make a .NET Framework test project, because Visual Studio doesn't contain a test project template for xUnit.net for .NET Framework. We'll fix that in just a moment.\n\nThis leads you to the second part of the new project wizard:\n\nType a name into the \"Project name\" box (like \"MyFirstUnitTests\"). Click \"Create\".\n\nAfter a moment, Visual Studio will launch with your newly created project.\n\nFind the project in the Solution Explorer (it will be titled \"MyFirstUnitTests\"), right click it, then click \"Edit Project File\". This will launch the text editor for your project file. It should look something like this:\n\nWe need to make one quick change: use a target framework that indicates .NET Framework support. For example, if you want to support .NET Framework 4.8, change the element like so:\n\nAlso, if your your project file includes either of these lines:\n\nyou might get the build error \"Feature 'global using directive' is not available in C# 7.3. Please use language version 10.0 or greater.\" If this is the case, you need to remove either line, so it looks like the project file above.\n• specifies the target framework for your test project. We've already changed this to for .NET Framework 4.8. Later in this article, we will discuss running tests against multiple target frameworks.\n• is here, though it is redundant (unit test projects cannot be packed by default). You can safely remove this line if you wish.\n• The package brings in three child packages which include functionality that most developers want: (the testing framework itself), (the library which contains the class), and (which enables Roslyn analyzers to detect common issues with unit tests and xUnit.net extensibility).\n• The packages and are required for being able to run your test project inside Visual Studio as well as with .\n• The package allows collecting code coverage. If you don't intend to collect code coverage, you should remove this package reference.\n\nA single empty unit test was also generated into :\n\nLet's make sure everything builds. Choose from the main menu. Your project should build without issue, as shown in the output window:\n\nTest Explorer is the name of the window that lets you browse and run your tests from within Visual Studio. Open it by choosing from the main menu. You should be greeted with a window that contains a hierarchy of the tests in your project, which should look something like this:\n\nThe toolbar of Test Explorer has buttons in several groups:\n• The first group contains buttons that are used for running tests, including the ability to run all tests, run selected tests, re-run the last tests, and re-run only the failed tests.\n• The second group contains buttons which allow filtering the list of tests based on current state (which includes \"passed\", \"failed\", and \"not run\").\n• The third group contains buttons which configure Test Explorer, including advanced options like changing processor architecture (x86, x64, or Auto) and automatically running tests after every successful build.\n\nThe main window of Test Explorer is split into two panes:\n• The left pane contains a tree view of the tests in your project (grouping criteria can be changed as you see fit). Columns can be configured to show details about the test, including things like the current state, how long the test took to run, metadata (traits) related to the test, and more.\n• As you select items in the tree view on the left pane, the right pane will provide information about your current selection, including test counts, outcomes, links to the source of the test, test output, and exception messages and stack traces for failed tests.\n\nClick the left-most button on the Test Explorer toolbar (it looks like a double green arrow, titled \"Run All Tests In View\". This will run the single empty test, and the result should be success:\n\nNow that we've ensured everything is working, it's time to write our first real tests.\n\nEdit and replace the default file contents with this:\n\nNow let's go run the tests again and see what happens:\n\nWe purposefully wrote both a passing and failing test, and we can see that the results reflect that. By clicking on the failed test, we can see a link both to the top of the unit test (at line 14), but also the failure message (we expected 5 but got 4) as well as a link to the exact line where the failure occurred (line 16).\n\nWhen you edit the source file, also take note of the fact that CodeLens decorations show up which indicate not only test status (passed/failed) on the test themselves, but also on functions that are called by the code, indicating how often the code is called in tests, and a count of which of those tests have passed or failed:\n\nNow that we've gotten your first unit tests to run, let's introduce one more way to write tests: using theories.\n\nYou may have wondered why your first unit tests use an attribute named rather than one with a more traditional name like Test. xUnit.net includes support for two different major types of unit tests: facts and theories. When describing the difference between facts and theories, we like to say:\n\nA good example of this is testing numeric algorithms. Let's say you want to test an algorithm which determines whether a number is odd or not. If you're writing the positive-side tests (odd numbers), then feeding even numbers into the test would cause it fail, and not because the test or algorithm is wrong.\n\nLet's add a theory to our existing facts (including a bit of bad data, so we can see it fail):\n\nThis time when we run our tests, we see a second failure, for our theory that was given 6:\n\nAlthough we've only written 3 test methods, the test runner actually ran 5 tests; that's because each theory with its data set is a separate test. Note also that the runner tells you exactly which set of data failed, because it includes the parameter values in the name of the test. The Test Explorer UI even shows a new level in the tree, as each row of data becomes a test result underneath its test method.\n\nSometimes, you want to write tests and ensure they run against several target application platforms. The xUnit.net test runner that we've been using supports .NET Core 1.0 or later, .NET 5.0 or later, and .NET Framework 4.5.2 or later. With a single test project, we can have our tests run against multiple target frameworks. Open the file and make the following change.\n\nWhen you change a project file from to (or back), Visual Studio might show you a yellow \"alert bar\" which indicates that you have to reload the project for your changes to take effect. It's best to make this kind of change from a clean environment with no dirty text editors, to prevent the possibility of losing any changes.\n\nTest Explorer supports any combination of .NET Core (including .NET 5+) and .NET Framework targets. You can even include multiple versions of the same target framework (for example, it's legal to have something like ). Application authors will typically only use a single target framework, related to the target framework the application is intended to run on. Library authors are more likely to use several target frameworks, to ensure their tests run successfully on all supported target frameworks.\n\nThe Test Explorer tree view will now show your test project multiple times, once for each target framework. You can run individual tests from individual frameworks, or you can simply run all tests for all frameworks."
    },
    {
        "link": "https://auth0.com/blog/xunit-to-test-csharp-code",
        "document": "TL;DR: This article will guide you in creating automated tests with xUnit for your C# applications. You will learn the basics of automated tests and how to create unit and integration tests.\n\nThe full code you are going to develop throughout the article is available in this GitHub repository.\n\nTesting ensures that your application is doing what it's meant to do. It seems a trivial statement, but sometimes this statement is underrated, especially when you change your existing codebase. You have to make sure not only that your changes work as intended, but also that the untouched code continues to do its expected job.\n\nManual testing is a very demanding task, not only for performing the tests themselves but because you have to execute them a huge number of times. It is a repetitive task, and where there is a repetitive task, you need automation.\n\nTraditionally, a few different types of automated tests are available. Let's take a quick look at the definitions of the most common ones:\n• Unit tests. This type of test focuses on testing a unit of code: a building block of a software application, such as a function or a class. Unit tests ensure that an isolated component of a software application works as expected.\n• Integration tests. Unlike unit tests, integration tests help to discover any issues when the units of code are assembled together to create more complex components. In fact, even if each unit of code is working correctly in an isolated environment, you may discover some issues when you put them together to build your application.\n• End-to-end (E2E) tests. This is a type of test ensuring that a user-level function works as expected. To an extent, they are similar to integration tests. However, here the focus is on the functions that are directly accessible by the software's user or somehow from outside the application. An E2E test may involve many systems and aims to simulate a production scenario.\n\nMany other test definitions exist based on the test goals and the perspective with which you look at them. But the ones above represent the most common ones from the developer's point of view.\n\nOf course, each type of test brings value to ensuring the correctness of the software application, and each one has its strengths and weaknesses. For example, while the unit tests are usually executed really fast, the end-to-end tests are slower and may have various points of failure due to the interaction of multiple systems.\n\nWhen testing your system, you cannot pretend to be able to cover all possible use cases. You should limit them to a subset due in part to the growth of complexity when passing from a simple unit to a composition of systems, in part to the time required to execute the tests. Usually, the number of tests decreases while passing from unit to end-to-end tests, following the well-known Test Pyramid diagram:\n\nRegarding the way to structure your automated tests, a typical approach follows the so-called AAA pattern. The name comes from the initials of the three actions usually needed to perform a test:\n• Arrange. With this action, you prepare all the required data and preconditions.\n• Assert. This final action checks if the expected result has occurred.\n\nThroughout this article, you will use this pattern in writing your tests.\n\nYour First Unit Test with xUnit\n\nThe .NET Core platform supports different testing frameworks. However, xUnit has become the most popular due to its simplicity, expressiveness, and extensibility. The project is supported by the .NET Foundation, and it is part of the more recent versions of .NET Core. This means that you don't need to install anything but the .NET Core SDK.\n\nSetting up the project to test\n\nTo understand how to use xUnit to automate your tests, let's explore the basics by creating unit tests for an existing project.\n\nDownload from GitHub the project to test by typing the following command:\n\nThis command will clone only the\n\nbranch of the repository in your machine. After the command executes, you will find thefolder containing asubfolder. This subfolder contains thefolder with a project with the same name.\n• The password length must be at least eight characters and a maximum of twenty characters\n• The password must contain one or more uppercase characters\n• The password must contain one or more lowercase characters\n• The password must contain one or more numeric values\n• The password must contain one or more special characters in the list @#!$%\n\nproject is a very simple library to validate passwords with the following constraints:\n\nIts implementation is based on the following class defined in the\n\nAs you can see, the validation logic is implemented by the\n\nmethod through a regular expression. Theclass represents here a unit of code because it is self-contained and focused on one specific goal.\n\nTo ensure that the\n\nmethod is working as you expect, you need to set up a test project.\n\nMake sure to be in the\n\nfolder and write the following commands in a terminal window:\n\nThe first command creates the unit test project, while the second one adds to it a reference to the\n\nAt this point, rename the\n\nfile intoand replace its content with the following:\n\nHere you see the\n\nclass, which is hosting the unit tests for themethod of theclass. The only unit test currently implemented is themethod. This method is decorated with theattribute, which tells xUnit that this is a test. The statements in the body of themethod are organized to highlight the AAA pattern mentioned above.\n\nIn the Arrange step, you create an instance of the\n\nIn the Act step, you invoke the\n\nFinally, the Assert step verifies that the returned result is the expected one. This check uses the\n\nobject, which provides many methods to validate a result. In this case, you are using themethod, which is successful when its first argument is true. Otherwise, the test fails and displays the string provided as the second argument.\n\nTo run this first test, make sure to be in the\n\nfolder and type the following command in your terminal window:\n\nAfter building the test project and possibly the\n\nproject, you should see something similar to the following in your console:\n\nWhen you are testing your code, you shouldn't just verify the positive cases; that is, the cases where things are fine. You also have to verify negative cases. For the\n\nmethod, you have to verify a possible case where the password passed as an argument doesn't comply with the constraints. So, add the new unit test implemented by the methodto theclass, as shown below:\n\nIn this case, you are passing an invalid password, and in the Assert step, you expect that the value returned by the\n\nmethod is false. If you run the tests withyou will get two successful tests. Pretty easy!\n\nThe two cases of password validity tested by the unit tests are far from exhaustive. They are just two simple examples of positive and negative cases, but, of course, the possible cases to test are many more. You cannot expect to check every possible case, but you can test a significant subset of typical cases. This helps in having a greater code coverage for your production code. In the password validation example, this means that you should identify a representative set of valid and invalid passwords. For each password in these sets, you should apply one of the tests implemented above.\n\nThis approach should ensure significant confidence in the correct behavior of the\n\nmethod. But it requires to replicate the same code for each sample password to test. You know that code replication is not a good practice . Fortunately, xUnit can help you with this issue with. A theory is a parametric unit test that allows you to represent a set of unit tests sharing the same structure. Theories allow you to implement what is called data-driven testing , which is a testing approach heavily based on input data variation.\n\nSo, to have an idea of what theories are, replace the content of the\n\nfile with the following:\n\nThe code above shows one single method,\n\n, in place of the two methods implemented before. This method has two parameters:and. And the application of the Arrange-Act-Assert pattern is based on these parameters.\n\nIn addition, you see a set of attributes decorating the method. The first attribute marks the\n\nmethod as a theory. The otherattributes represent the data to pass to the method. Each attribute has a couple of values that are mapped to the method's parameters. So, basically, the first value of eachattribute is a possible password, and the second value is the boolean value expected as a result of themethod.\n\nIn other words, each\n\nattribute represents one invocation of thetest. In fact, if you launch thecommand, you will get a message saying that all eight tests passed.\n\nIn the previous section, you started familiarizing yourself with writing unit tests. Now, it's time to take a look at how you can implement integration tests with xUnit. From a syntax and semantics perspective, they are not so different from unit tests. The main difference with them lies in the implementation of what you want to test. While in the unit test case, you verify the behavior of a small and autonomous piece of code, the integration tests verify a more complex code, usually composed of a few units and sometimes with some dependency with external systems, like databases, file systems, and so on.\n\nSetting up the project to test\n\nTo better understand how to create integration tests, you will create a test project for an ASP.NET Core Web API that allows you to manage a glossary of terms. This application enables you to get terms definitions, create new ones, or update and delete the existing ones. The endpoint to get term definitions is public, while the other endpoints are protected with Auth0 authentication and authorization features.\n\nIf you want to know the details of the project implementation, you can check out the Building and Securing Web APIs with ASP.NET Core 3 article.\n\nSo, to prepare your environment, move to the\n\nfolder, and create a newfolder. Now, move to thefolder and type the following command in a terminal window:\n\nThis command will clone the glossary GitHub repository in your machine. So, you will find a\n\nsubfolder with the new project within thefolder. This is the project you are going to test in a minute.\n\nTo create the integration test project, move to the\n\nfolder, and type the following command:\n\nAs you already know, this command creates the basic xUnit test project in the\n\nfolder. Move to this new folder and run the command shown here:\n\nThe command above adds to the new test project the\n\npackage, which provides infrastructural support for testing ASP.NET-based applications. In practice, this package takes care of bootstrapping the project under test and allows you to change the application configuration for test purposes.\n\nThen, add to the test project a reference to the glossary project with the following command:\n\nfile in thefolder as, and replace its content with the following:\n\nWith this code, you are setting up the basic infrastructure to write and run your integration tests.\n\nWhen the testing framework creates an instance of the\n\nclass, it creates an instance of an HTTP server running the glossary project as well. This test server instance will be shared among all the tests that belong to theclass.\n\nIn particular, your\n\nclass implements theinterface. The class fixture is a xUnit feature that allows you to share an object instance among all tests in a test class. In this case, the shared object is an instance of theclass provided by thelibrary. This class creates a TestServer instance; that is, an in-memory server responding to HTTP requests. The TestServer is created upon the specified class:in this example.\n\nAlso, the test server instance provides us with the ability to get a preconfigured HTTP client through the\n\nmethod. In the code above, you are using this ability in the class constructor, where the HTTP client is assigned to the private variable\n\nWith this infrastructure, you are now ready to write your integration tests.\n\nAs a first step, you are going to test the public endpoint that allows you to get the list of term definitions. This endpoint responds to the\n\nURL and returns a list of terms in JSON format. The sample application you are testing returns a predefined set of term definitions, so this simplifies the Assert step of the test.\n\nSo, to implement this first test, add the following method to the\n\nLike you saw in the unit test example, the\n\nmethod is decorated with theattribute. You may notice that the code implementing the test is missing the Arrange step. Actually, in this specific case, the Assert step has been performed by the class constructor. In fact, it created the HTTP client instance for all the tests. So, in this test, you simply call the API and analyze the response, ensuring that it is as expected.\n\nAs usual, to run this test, type\n\nTesting the protected endpoints is somewhat more complicated. But let's do it in stages, starting with the negative cases and then tackling the positive one.\n\nFirst of all, since the Web API application you are testing is secured with Auth0, you need to configure it getting the required parameters from the Auth0 Dashboard. You need an Auth0 account to configure the application. If you haven't one, you can sign up for a free Auth0 account here. Then, follow the steps to configure the application, as explained in the article mentioned above.\n\nThe API you are going to test is the one that allows you to add a new term definition to the glossary. This operation is based on an HTTP POST request to the\n\nendpoint with a JSON-formatted body describing the new term definition. As said, the addition, change, and deletion of terms are protected, and only authorized users can perform them.\n\nStart testing the addition operation by ensuring that a request without an access token fails. You can do this by adding the following method to the\n\nHere, you create a request to add a term definition, send the HTTP POST request to the endpoint, and verify that the status code received from the server is\n\nAs a negative case, you should also verify that an attempt to add a new term with an invalid access token fails as well. You can accomplish this by adding the following test:\n\nThe only difference compared with the\n\ntest is that here you added a Bearer token with an invalid value to the HTTP POST request.\n\nAt this point, if you run\n\n, you should have all the three tests passing.\n\nAfter making sure that adding a new term to the glossary requires you to be authorized, you need to create a test to verify that an authorized request works correctly. So, to have a valid access token from Auth0, you should register your test project as a client application, and configure it with the appropriate parameters. Fortunately, Auth0 automatically generated a test client application for you when you registered the Web API. To find the related parameters, access the Auth0 Dashboard and move to the Applications section. Here, you will find an application named Glossary (Test Application). If you registered your Web API with a different name, you should find that name followed by (Test Application). Click the name of that application and take note of the Domain, Client ID, and Client Secret parameters:\n\nfile in the root folder of the test project () with the following content:\n\nIn this file, replace the placeholders with the respective values you've just got from the Auth0 Dashboard. The value for the YOUR_AUDIENCE placeholder is the string you associated with the Web API as its identifier (e.g.,\n\nTo make the configuration file available at runtime, add the following\n\nNow, to load these configuration data in your test project, apply the following changes to the code of the integration tests:\n\nYou add new references to a few namespaces marked with\n\nin thesection. Also, you add a new privatevariable, which will keep the Auth0 configuration values from thefile. The content from the configuration file is loaded in the class constructor.\n\nThe next step is to obtain an access token from Auth0. You can leverage the Auth0 Authentication API SDK to create an Auth0 client and easily request the needed token. So, run the following command to install the SDK:\n\nAfter the SDK is installed, add the\n\nmethod to theclass as shown below:\n\nThis method creates a request to the Auth0 authorization server for the Client Credentials Flow and returns the access token.\n\nFinally, you have what you need to test the authorized request to create a new glossary term definition. The following method implements this test:\n\nThe structure of this test is similar to the negative case ones. In this case, you get a valid access token by calling the\n\nmethod. Also, in the Assert step, you make sure that the status code and the reference to the newly created resource are as expected.\n\nThe integration tests you implemented so far work fine. They take into account negative and positive cases and make sure that results are the ones you expected. However, they are testing more than the Web API application code. They are also testing the integration with Auth0, which may be a good thing as an end-to-end test, but it could lead to some drawbacks. In fact, when you have one or more external system involved in the application you are testing, you should be aware at least of the following issues:\n• if there is an issue with the remote system or in the infrastructure that connects your application to the external system, your tests will fail with an exception\n• you may need to call the external system directly as part of your tests (as seen in the example above), increasing the number of dependencies required to run the test\n• access to the external system may affect the performance of your tests\n\nIf your goal is to test only the correctness of your source code, you should avoid involving external systems in your integration tests. This means that you want to test the integration of just the software components building up your application.\n\nFortunately, .NET Core provides you with some features that allow you to mock external systems and focus on testing just your application code. In this section, you are going to take a look at how to exclude the Auth0 integration from the integration tests you wrote so far.\n\nThe first step is to create a mock for the external system; in the Web API application you are testing, that is Auth0. To replace it, you need to build an entity that generates and provides support to validate tokens. For this purpose, add the\n\nfile to thefolder with the following content:\n\nclass provides the basic data you need to configure a JWT-based authorization system. The values for the properties, andare randomly generated. The class also provides themethod that provides you with a token generated from that values.\n\nThe Web API application is configured to use Auth0 for access control. So, you may wonder how to force it to use the Auth0 mock you build with the\n\nclass. Actually, you don't need to change the application you are testing. You are going to override its configuration.\n\nAs you remember, you used the\n\nclass to create a TestServer instance based on theclass. What you need is to be able to affect the TestServer instance creation so that you can inject your custom configuration to mock Auth0. You can get this result by creating a custom version of theclass.\n\nfile with the following code:\n\nThis class inherits from the\n\nclass and overrides themethod. This method receives the Web Host builder of the application and uses themethod to configure the TestServer. In particular, it overrides theconfiguration by assigning the values from themock.\n\nNow you can simplify your integration tests by getting rid of the\n\nconfiguration file and the code to manage it.\n\nfile and apply the changes shown below:\n\nYou removed a few unnecessary namespaces from the\n\nsection and replaced the reference to theclass with theclass. Also, you removed theprivate variable definition and the initialization of that variable in the constructor.\n\nIn addition, now you can remove the\n\nmethod since you don't need it anymore.\n\nFinally, replace the implementation of the\n\ntest with the following:\n\nThe only difference with the previous version of the test is how you get the access token. Instead of using the\n\nmethod, you now are invoking\n\nWith these changes, you will get all tests successful again, but now your code will be independent of the external system.\n\nAt the end of this article, you learned how to create different types of automated tests using xUnit. You started to create unit tests to verify the behavior of an isolated and autonomous piece of code. Then, you built a few integration tests involving Auth0 as an external system. Finally, you discovered how to mock external systems to get your integration tests more focused on your own code.\n\nYou can find the code implemented throughout this article on GitHub."
    },
    {
        "link": "https://ottorinobruni.com/how-to-use-xunit-for-unit-testing-in-dotnet-project-using-csharp-in-vscode",
        "document": "How to Use xUnit for Unit Testing in .NET Project Using C# in VSCode\n• Finding Bugs Early: Unit tests help you find problems early in the development process, before the software is fully integrated. This makes it easier and faster to fix issues.\n• Better Code Quality: Writing unit tests encourages you to write clean and well-organized code. When you know your code will be tested, you’re more likely to write good, understandable code.\n• Safe Refactoring: As you improve or change your code, unit tests help ensure that these changes don’t break existing functionality. This makes it safer to update and improve your software.\n• Documentation: Unit tests can also help explain how the code should work. They serve as examples of how to use the code correctly.\n• Team Collaboration: In a team, unit tests help make sure that everyone’s code works together smoothly. This is especially important in large projects where many people are working on different parts of the software.\n• Cost Efficiency: Finding and fixing bugs early is cheaper than fixing them later in the development process or after the software is released. Unit tests help save time and money by catching issues early.\n• Clarity: Good test names clearly describe what the test does and what behavior is expected. This makes it easier for others (and yourself) to understand the purpose of each test at a glance.\n• Maintenance: Consistent naming conventions help maintain the test suite. If the method name changes, having a clear and consistent naming convention helps in updating the test names accordingly.\n• Documentation: Test names can serve as documentation. They explain what conditions are being tested and what the expected outcomes are, which is helpful for both current and future developers.\n\nExample: How to Use xUnit for Unit Testing\n• .NET SDK: Download and install the .NET SDK if you haven’t already.\n• C# Extension for VSCode: Install the C# extension for VSCode to enable C# support.\n• Open a Terminal or Command Prompt: You can use the terminal in VSCode or any command prompt.\n• Create a New Solution: This command creates a new solution file named .\n• Create a New Console Application: This command creates a new directory called with a basic .NET console application.\n• Create the Class: In the project directory, create a new file named and add the following code: public class UserAccount { private string _email; public void SetEmail(string email) { if (string.IsNullOrWhiteSpace(email)) { throw new ArgumentException(\"Email cannot be null or empty\"); } _email = email; } public string GetEmail() { return _email; } }\n• Add the Console Application to the Solution: This command adds the console application project to the solution.\n• Create a New xUnit Test Project: This command creates a new directory called with a basic xUnit test project.\n• Add xUnit Package: Add the necessary NuGet packages for xUnit:\n• Reference the Console Application: Add a project reference from the test project to the console application:\n• Add the Test Project to the Solution: Navigate back to the solution root and add the test project:\n• Open the Test Project in VSCode: Ensure you have the project open in VSCode.\n• Create Your Test File: For example, create a file in the directory.\n• Write Your Tests: Here’s a sample test file using xUnit: using Xunit; using System; using UnitTestConsoleApp; namespace UnitTestConsoleApp.Tests { public class UserAccountTests { private UserAccount _userAccount; // This method is run before each test public UserAccountTests() { _userAccount = new UserAccount(); } [Fact] public void SetEmail_ValidEmail_EmailIsSet() { // Arrange string email = \"test@example.com\"; // Act _userAccount.SetEmail(email); // Assert Assert.Equal(email, _userAccount.GetEmail()); } [Fact] public void SetEmail_EmptyEmail_ThrowsArgumentException() { // Arrange string emptyEmail = \"\"; // Act and Assert var exception = Assert.Throws<ArgumentException>(() => _userAccount.SetEmail(emptyEmail)); Assert.Equal(\"Email cannot be null or empty\", exception.Message); } [Fact] public void GetEmail_NoEmailSet_ReturnsNull() { // Act string email = _userAccount.GetEmail(); // Assert Assert.Null(email); } [Theory] [InlineData(\"user@example.com\")] [InlineData(\"admin@domain.com\")] [InlineData(\"support@company.org\")] public void SetEmails_ValidEmail_EmailIsSet(string email) { // Act _userAccount.SetEmail(email); // Assert Assert.Equal(email, _userAccount.GetEmail()); } [Theory] [InlineData(\"\")] [InlineData(null)] [InlineData(\" \")] // Testing a single space as input public void SetEmail_InvalidEmail_ThrowsArgumentException(string invalidEmail) { // Act and Assert var exception = Assert.Throws<ArgumentException>(() => _userAccount.SetEmail(invalidEmail)); Assert.Equal(\"Email cannot be null or empty\", exception.Message); } } }\n• Run Tests Using the Command Line: From the root directory of your solution, execute: This command runs all the tests in your solution and displays the results in the terminal.\n• Run Tests in VSCode: You can also run tests directly within VSCode by using the Test Explorer extension or by running the tests from the terminal.\n• Early Detection of Bugs: Unit tests help catch errors in individual components before they propagate through the application.\n• Improved Code Quality: Writing tests encourages better design and more modular code, making it easier to understand and maintain.\n• Refactoring Confidence: With a robust suite of unit tests, you can refactor code with confidence, knowing that you have tests in place to catch unintended changes.\n• Documentation: Unit tests serve as a form of documentation, demonstrating how different parts of the application are expected to behave.\n\nIn software development, it’s crucial to make sure your code works correctly. One of the best ways to do this is through unit testing. Unit testing means testing small parts of your software, like a single function or method, to make sure they work as expected. In this article, we will learn how to use xUnit for unit testing in .NET projects. We will use C# and Visual Studio Code (VSCode) as our tools.Unit tests are small, automated tests that developers write and run. These tests check if a specific part of the software behaves correctly. Unit tests are “isolated,” which means they test just one piece of code without depending on other parts of the application, like databases or external services. This makes it easier to find and fix problems in the code. xUnit.net is a free, open-source unit testing framework designed for the .NET Framework. Developed by the original creator of NUnit v2, it is a modern tool for unit testing C# and F# applications, with support for other .NET languages, though they are not officially supported. xUnit.net integrates seamlessly with popular development tools like Visual Studio, Visual Studio Code, ReSharper, CodeRush, and TestDriven.NET. It is a project under the .NET Foundation and adheres to its code of conduct.In this guide, we’ll show you how to use xUnit to create unit tests in .NET projects. We will cover the basics and provide simple examples, so you can start using unit testing in your projects. Whether you’re new to unit testing or want to learn more, this article will help you understand the basics and start writing reliable tests.Naming conventions for tests are crucial for maintaining clarity and consistency in your test suite. A well-chosen convention helps ensure that tests are easy to understand and maintain, which is especially important as projects grow and evolve. Here’s a guide on how to approach naming your tests and a recommendation based on the conventions you’ve mentioned.There are various ways to name test methods, and the best approach can depend on the project’s requirements and context. For clarity and consistency, I will use theconvention in this blog.When writing unit tests, it’s common to encounter situations where only the input parameters differ between multiple tests. Copying and pasting test code to handle different inputs can lead to code duplication and increased maintenance overhead. Fortunately, xUnit provides attributes that help manage this scenario more efficiently.Theattribute is used in xUnit to denote a test method that runs with a variety of inputs. Instead of writing multiple test methods for each different input, you can write one test method and provide different inputs to it. This approach helps keep your test code concise and focused.Theattribute is used in conjunction withto specify the different sets of input data for the test method. Eachattribute represents a set of arguments that are passed to the test method. The test method will be executed once for each set of inputs.: This example is purely for educational purposes. There are better ways to write code and applications that can optimize this example. Use this as a starting point for learning, but always strive to follow best practices and improve your implementation.All the code is available in this GitHub repository . This repository will help you easily apply the new modifications to the previously created code thanks to the use of tags and branches. In this example, we’ll set up a .NET solution with two projects: a console application calledand a test project called. We’ll use xUnit for unit testing.Before starting, make sure you have the following installed:Writing unit tests is an essential practice in software development, but it’s important to remember that having a large number of unit tests does not guarantee bug-free code. Unit tests are a valuable tool for identifying issues early and ensuring that individual components of your code work as expected. However, they are just one part of a comprehensive testing strategy.In the next article, we will explore, a powerful library for creating mock objects in unit tests. Moq can help simulate various scenarios and interactions between components, allowing you to write more comprehensive and flexible tests. Stay tuned to learn how to leverage Moq to enhance your unit testing strategy. If you think your friends or network would find this article useful, please consider sharing it with them. Your support is greatly appreciated."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices",
        "document": "There are numerous benefits of writing unit tests. They help with regression, provide documentation, and facilitate good design. But when unit tests are hard to read and brittle, they can wreak havoc on your code base. This article describes some best practices for designing unit tests to support your .NET Core and .NET Standard projects. You learn techniques to keep your tests resilient and easy to understand.\n\nBy John Reese with special thanks to Roy Osherove\n\nThe following sections describe several reasons to write unit tests for your .NET Core and .NET Standard projects.\n\nFunctional tests are expensive. They typically involve opening the application and performing a series of steps that you (or someone else) must follow in order to validate the expected behavior. These steps might not always be known to the tester. They have to reach out to someone more knowledgeable in the area to carry out the test. Testing itself can take seconds for trivial changes, or minutes for larger changes. Lastly, this process must be repeated for every change that you make in the system. Unit tests, on the other hand, take milliseconds, can be run at the press of a button, and don't necessarily require any knowledge of the system at large. The test runner determines whether the test passes or fails, not the individual.\n\nRegression defects are errors that are introduced when a change is made to the application. It's common for testers to not only test their new feature but also test features that existed beforehand to verify that existing features still function as expected. With unit testing, you can rerun your entire suite of tests after every build or even after you change a line of code. This approach helps to increase confidence that your new code doesn't break existing functionality.\n\nIt might not always be obvious what a particular method does or how it behaves given a certain input. You might ask yourself: How does this method behave if I pass it a blank string or null? When you have a suite of well-named unit tests, each test should clearly explain the expected output for a given input. In addition, the test should be able to verify that it actually works.\n\nWhen code is tightly coupled, it can be difficult to unit test. Without creating unit tests for the code that you're writing, coupling might be less apparent. Writing tests for your code naturally decouples your code because it's more difficult to test otherwise.\n\nThere are several important characteristics that define a good unit test:\n• Fast: It's not uncommon for mature projects to have thousands of unit tests. Unit tests should take little time to run. Milliseconds.\n• Isolated: Unit tests are standalone, can run in isolation, and have no dependencies on any outside factors, such as a file system or database.\n• Repeatable: Running a unit test should be consistent with its results. The test always returns the same result if you don't change anything in between runs.\n• Self-Checking: The test should automatically detect if it passed or failed without any human interaction.\n• Timely: A unit test shouldn't take a disproportionately long time to write compared to the code being tested. If you discover that testing the code takes a large amount of time compared to writing the code, consider a more testable design.\n\nA high code coverage percentage is often associated with a higher quality of code. However, the measurement itself can't determine the quality of code. Setting an overly ambitious code coverage percentage goal can be counterproductive. Consider a complex project with thousands of conditional branches, and suppose you set a goal of 95% code coverage. Currently, the project maintains 90% code coverage. The amount of time it takes to account for all of the edge cases in the remaining 5% can be a massive undertaking, and the value proposition quickly diminishes.\n\nA high code coverage percentage isn't an indicator of success, and it doesn't imply high code quality. It just represents the amount of code covered by unit tests. For more information, see unit testing code coverage.\n\nSeveral terms are used frequently in the context of unit testing: fake, mock, and stub. Unfortunately, these terms can be misapplied, so it's important to understand the correct usage.\n• None Fake: A fake is a generic term that can be used to describe either a stub or a mock object. Whether the object is a stub or a mock depends on the context in which the object is used. In other words, a fake can be a stub or a mock.\n• None Mock: A mock object is a fake object in the system that decides whether or not a unit test passes or fails. A mock begins as a fake and remains a fake until it enters an operation.\n• None Stub: A stub is a controllable replacement for an existing dependency (or collaborator) in the system. By using a stub, you can test your code without dealing with the dependency directly. By default, a stub begins as a fake.\n\nConsider the following code:\n\nThis code shows a stub referred to as a mock. But in this scenario, the stub is truly a stub. The purpose of the code is to pass the order as a means to instantiate the (the system under test) object. The class name is misleading because the order is a stub and not a mock.\n\nThe following code shows a more accurate design:\n\nWhen the class is renamed to , the class is more generic. The class can be used as a mock or a stub, according to the requirements of the test case. In the first example, the class is used as a stub, and it isn't used during the operation. The code passes the class to the class just to satisfy the requirements of the constructor.\n\nTo use the class as a mock, you can update the code:\n\nIn this design, the code checks a property on the fake (asserting against it), and therefore, the class is a mock.\n\nThe main thing to remember about mocks versus stubs is that mocks are just like stubs, except for the process. You run operations against a mock object, but not against a stub.\n\nThere are several important best practices to follow when writing unit tests. The following sections provide examples that show how to apply the best practices to your code.\n\nTry not to introduce dependencies on infrastructure when writing unit tests. The dependencies make the tests slow and brittle and should be reserved for integration tests. You can avoid these dependencies in your application by following the Explicit Dependencies Principle and by using .NET dependency injection. You can also keep your unit tests in a separate project from your integration tests. This approach ensures your unit test project doesn't have references to or dependencies on infrastructure packages.\n\nThe name of your test should consist of three parts:\n• Name of the method being tested\n• Scenario under which the method is being tested\n• Expected behavior when the scenario is invoked\n\nNaming standards are important because they help to express the test purpose and application. Tests are more than just making sure your code works. They also provide documentation. Just by looking at the suite of unit tests, you should be able to infer the behavior of your code and not have to look at the code itself. Moreover, when tests fail, you can see exactly which scenarios don't meet your expectations.\n\nThe \"Arrange, Act, Assert\" pattern is a common approach for writing unit tests. As the name implies, the pattern consists of three main tasks:\n• Arrange your objects, create, and configure them as necessary\n• Assert that something is as expected\n\nWhen you follow the pattern, you can clearly separate what is being tested from the Arrange and Assert tasks. The pattern also helps to reduce the opportunity for assertions to intermix with code in the Act task.\n\nReadability is one of the most important aspects when writing a unit test. Separating each pattern action within the test clearly highlights the dependencies required to call your code, how your code is called, and what you're trying to assert. While it might be possible to combine some steps and reduce the size of your test, the overall goal is to make the test as readable as possible.\n\nThe input for a unit test should be the simplest information needed to verify the behavior you're currently testing. The minimalist approach helps tests become more resilient to future changes in the codebase and focus on verifying the behavior over the implementation.\n\nTests that include more information than required to pass the current test have a higher chance of introducing errors into the test and can make the intent of the test less clear. When writing tests, you want to focus on the behavior. Setting extra properties on models or using nonzero values when not required, only detracts from what you're trying to confirm.\n\nMagic strings are string values hard-coded directly in your unit tests without any code extra comment or context. These values make your code less readable and harder to maintain. Magic strings can cause confusion to the reader of your tests. If a string looks out of the ordinary, they might wonder why a certain value was chosen for a parameter or return value. This type of string value might lead them to take a closer look at the implementation details, rather than focus on the test.\n\nWhen you write your unit tests, avoid manual string concatenation, logical conditions, such as , , , and , and other conditions. If you include logic in your test suite, the chance of introducing bugs increases dramatically. The last place you want to find a bug is within your test suite. You should have a high level of confidence that your tests work, otherwise, you can't trust them. Tests that you don't trust, don't provide any value. When a test fails, you want to have a sense that something is wrong with your code and that it can't be ignored.\n\nUse helper methods instead of Setup and Teardown\n\nIf you require a similar object or state for your tests, use a helper method rather than and attributes, if they exist. Helper methods are preferred over these attributes for several reasons:\n• Less confusion when reading the tests because all code is visible from within each test\n• Less chance of setting up too much or too little for the given test\n• Less chance of sharing state between tests, which creates unwanted dependencies between them\n\nIn unit testing frameworks, the attribute is called before each and every unit test within your test suite. Some programmers see this behavior as useful, but it often results in bloated and hard to read tests. Each test generally has different requirements for setup and execution. Unfortunately, the attribute forces you to use the exact same requirements for each test.\n\nWhen you write your tests, try to include only one Act task per test. Some common approaches for implementing a single Act task include creating a separate test for each Act or using parameterized tests. There are several benefits to using a single Act task for each test:\n• You can easily discern which Act task is failing if the test fails.\n• You can ensure the test is focused on just a single case.\n• You gain a clear picture as to why your tests are failing.\n\nMultiple Act tasks need to be individually asserted, and you can't guarantee that all Assert tasks execute. In most unit testing frameworks, after an Assert task fails in a unit test, all subsequent tests are automatically considered as failing. The process can be confusing because some working functionality might be interpreted as failing.\n\nIn most cases, you don't need to test a private method in your code. Private methods are an implementation detail and never exist in isolation. At some point in the development process, you introduce a public-facing method to call the private method as part of its implementation. When you write your unit tests, what you care about is the end result of the public method that calls into the private one.\n\nConsider the following code scenario:\n\nIn terms of testing, your first reaction might be to write a test for the method to ensure it works as expected. However, it's possible the method manipulates the object in a way you don't expect. The unknown behavior might render your test against the method useless.\n\nA better test in this scenario is to verify the public-facing method:\n\nWhen you encounter a private method, locate the public method that calls the private method, and write your tests against the public method. Just because a private method returns an expected result, doesn't mean the system that eventually calls the private method uses the result correctly.\n\nOne principle of a unit test is that it must have full control of the system under test. However, this principle can be problematic when production code includes calls to static references (for example, ).\n\nCan you write a unit test for this code? You might try running an Assert task on the :\n\nUnfortunately, you quickly realize there are some problems with your test:\n• If the test suite runs on Tuesday, the second test passes, but the first test fails.\n• If the test suite runs on any other day, the first test passes, but the second test fails.\n\nTo solve these problems, you need to introduce a seam into your production code. One approach is to wrap the code that you need to control in an interface and have the production code depend on that interface:\n\nYou also need to write a new version of your test suite:\n\nNow the test suite has full control over the value, and can stub any value when calling into the method."
    },
    {
        "link": "https://medium.com/@codebob75/unit-testing-in-c-with-xunit-complete-guide-18ee2b919b05",
        "document": "You just finished coding your new feature, it’s great and it works!\n\nBut how do you prove that it actually works?\n\nI. Introduction\n\n- What are unit tests in .Net?\n\n- Why do we have to create unit tests?\n\n- What unit tests tools are there in .Net?\n\nII. Getting Started\n\n- Creating a xUnit Test project\n\n- NuGet Package\n\n- Why do unit test classes need to be public?\n\n- Test Method Naming Convention\n\n- What does the [Fact] attribute do?\n\n- How to build xUnit test methods?\n\nWhat are unit tests in .Net?\n\nUnit tests refer to testing “unit of works”, which basically means:\n• Code that has no external dependencies (isolated)\n\nUnit testing is a software testing methodology where individual units or components of a software application are tested in isolation to ensure they function correctly.\n\nIn comparison integration test 2 or more components that interact together (not isolated).\n\nEnd to End Test go even further and test an app through its UI# with tools like Selenium\n\nWhy do we have to create Unit tests?\n\nLike do we really need to go through this? If it works with manual testing, then why even write unit tests?\n\nAre there any developers who actually enjoy writing these things?\n\nIsn’t it why we have testers?\n\nSure, you can go debug mode, input some fake data and do a demo to the whole team to prove that it works.\n\nBut that’s not very time efficient, persuasive and a long term solution.\n\nIsn’t it convenient to have all these passing tests showing to yourself and everyone else that the code works?\n\nBasically, not only do you want to make sure that your current code works but also, your app is quite likely to change overtime and therefore you want to make sure that its other functionalities keep working as expected.\n\nSo that if you add or change code, the tests will always check whether the other functionalities you created before still work as they should.\n\nYou don’t want to manually have to manual test all the the time. That’s when tests come in handy, especially when automatically run in a pipeline!\n\nWhat unit tests tools are there in .Net?\n\nIts frameworks provide a framework for writing and running automated unit tests.\n\nIt is a project of the .NET Foundation. xUnit.net is the latest technology for unit testing .NET apps. It is free and open source.\n\nxUnit is now the Microsoft default and standard testing tool in Visual Studio for .Net Core.\n\nA nice feature of xUnit is the ability to test code from\n\nNUnit is a unit-testing framework for all .NET languages\n\nMSTest is the Microsoft test framework for all .NET languages\n\nNow that we understand the key concepts, let’s create a xUnit test project!\n\nKeep the global using.cs that will ensure that Xunit is used everywhere\n\nIf you create a xUnit project from VS, the package should already be added, otherwise you can manually add it\n\nAnd you will need this package to run tests in VS: xunit.runner.visualstudio\n\nName of cs file to be tested + Tests, e.g. BrandControllerTests\n\nWhy do unit test classes need to be public?\n\nIn C#, unit tests typically need to be declared as public because they need to be accessible by the testing framework.\n\nWhen you write unit tests using frameworks like NUnit, MSTest, xUnit, etc., these frameworks require that the test methods be public so that they can be discovered and executed.\n\nFirst thing first, a test method needs to be named right, it should consist of three parts:\n• The name of the method being tested.\n• The scenario under which it’s being tested.\n• The expected behaviour when the scenario is invoked.\n\nexample, original method to be tested\n\nAnother naming convention is to use\n\nWhat does the [Fact] attribute do?\n\nThe [Fact] attribute declares a test method that’s run by the test runner.\n\nTherefore it must be added on top of each test method like below\n\nHow to build xUnit tests? Using Moq and AAA\n\nThere are basically 4 steps into building a test:\n\nSo how to deal with dependencies? Well, we don’t! We simply simulate them by using a framework called Mock\n\nFirst, you will need to install the package Moq\n\nSo what does Mocking do?\n\nLet’s look at the below class\n\nYou can see that it takes one external dependencies\n\nHowever, a unit test should not rely on external objects.\n\nTherefore we need to stimulate the behaviour of this object.\n\nTo do so, we will mock it, like so:\n\nNow what we have our simulated object, so we can use it and its methods in our test code.\n\nThis is the method we want to test\n\nThe method GetBrandByID in the BrandController uses the _service (that we just mocked) that:\n\n2/ Arrange takes care of arranging the Mock object so it\n• calls the method passed in the class we are testing, using SetUp\n• returns the right object using Return\n\n3/ Act will actually call the method we are testing passing the mock object(s) to the class under test\n\n4/ Assert is when we check whether the test returns the expected value, in our test example we expect:\n• That it returns a object of type Brand_DTO\n• That the integer id we pass as parameter is correct\n\nAnd here is our complete xUnit test class!\n\nNow let’s delve deeper into each part of xUnit and look at multiple scenarios\n\nTheory enables you to add multiple inputs to the test one method.\n\nSo in the below method we are passing 3 inputs to one test method\n\nThe limitation of [InlineData] is that we can only apply it to one test method.\n\nIf you wish to share input data amongst classes use the [ClassData] attribute instead\n\nFor this you will need another class\n\nAlternatively you can also create your own attribute\n\nNow we can use this custom attribute in our test\n\nThese techniques might seem cumbersome, thankfully there is another option:\n\nFirst we use ClassData\n\nThen we create a class that’s way easier to set-up\n\nUseful for filtering and marking the type or group of tests, here:\n• the category name is integration\n\nThis is particularly useful to differenciate between test types (unit, integration, UI…)\n\nWhen would that be useful? Well, in pipelines for example!\n\nYou can now filter tests (credits: dateo-software.de)\n\nWhen creating Mocks, sometimes you want to make sure that the setup is exactly as it should, otherwise an error or exception should be thrown.\n\nThat’s when you want to use MockBehavior.Strict\n\nIf not and it doesn’t really matter whether the object behaves exactly as in real-life, such as with ILogger, then you can either keep as default or explicitly tag it as MockBehavior.Loose (the default behaviour)\n\nWith strict mocks, the mock object will strictly enforce that only the expected interactions are allowed. Any unexpected calls to methods that haven’t been explicitly set up will result in a test failure.\n\nLoose mocks, on the other hand, allow unexpected method calls to pass without failing the test. They are more permissive and lenient compared to strict mocks.\n\nIf any is passed in your original method, you will need to arrange them, aka set them up.\n\nThe SetUp part is perhaps the most important set in your whole test! If you don’t exactly (like exactly) simulate the original method, with the exact same dependencies and return type, you will get this error:\n\nMoq.MockException : invocation failed with mock behavior Strict. All invocations on the mock must have a corresponding setup.\n\nLet’s look at this example, this is the original method\n\nYou can see that it uses one object:\n\nThe test method will need the object to be mocked, i.e. simulated\n\nSo we need to simulate the _service object to return a ClubCollectionGetModel\n\nThis is how we create a setup:\n• .Return (the object or type want to be returned)\n\nHere are some examples visualised\n\nSee all SetUp Options in the Moq documentation below\n\nLet’s look at some parameter examples that you can pass in the SetUp Method being mocked:\n\nHere’s a compiled list of several setup and return options!\n\nReturns or ReturnsAsync and The Object(s) you want to return\n\nWhat about methods that actually don’t return anything?\n\nSee this example, we actually just perform a Task and only return an Ok (ActionResult), but the _service doesn’t return anything\n\nIn this case we just return Task.CompletedTask\n\nWhat about methods that should return null (e.g. for testing null exceptions)?\n\nSometime a method block throws an exception, so instead of returns we use .Throws\n\nUsing methods from the base class\n\nWhat if your class uses a base, like so\n\nYou’d need to Mock the mapper and logger to ensure good functioning of the class, and also pass them as Mock.Object in your class constructor.\n\nOtherwise you are quite likely to encounter the below exception\n\nMoq.MockException : IMapperBase.Map<BrandInClubAssortment>(BrandInClubAssortment_DTO) invocation failed with mock behavior Strict.\n\nAll invocations on the mock must have a corresponding setup.\n\nWhat if, even though you have set-up the base mock objects correctly, you still get this error?\n\nIf you look at the documentation, then you will see the recommendation to use .CallBase()\n\nHowever, this only works if the mock is created from a class, not an interface, and the method being called is not abstract. So, this won’t work\n\nIf the Mock is as follows\n\nThe solution is to set it up as a normal mock\n\nThe above is for explicit verification aka, we pass a method and expect a hardcoded object, the other way of doing this is just checking whether the method works regardless of what it returns using:\n\nOnce you have all dependencies setup, now it’s time to actually instantiate your class that you are testing\n\nThe trick is to pass the objects of the Mocks instead of the external dependencies to your class.\n\nFinally, it’s time to check if the method returns what we expect, we do this in the Assert\n\nWhat is the IFixture class in c# and how to use it with xUnit?\n\nSince you will most likely end-up with a lot of tests, instantiating a new object for each test method might not be the best in terms of resources.\n\nOne potential solution would be to instantiate your object in the constructor\n\nEven if you pass the object (example above “controller”) in the constructor of the test class, which will help in terms of code size, the amount of objects created will be the same.\n\nThis calls for the need of another solution, which is the fixture!\n\nHowever, most documentation provides examples that don’t include any external objects like so\n\nIn real life scenarios you’re quite likely to have several mock.Object within your constructor!\n\nSo let’s see how to go about it :)\n\nThe trick is to add the Mocks in the Fixture\n\nYes as you can see above you need to add all the mock manually, you might think that it is duplicating the original Mock in your test class but let’s see what comes next ;)\n\nNow, we need to add the fixture to our code\n\nWe now set up the fixture Mocks and then we use the _fixture to directly use the method.\n\nSo in the test constructor, we actually don’t need any Mock anymore!\n\nInitially we had this constructor for the test\n\nBut now we can just keep the _fixture :)\n\nUsing Fixture amongst several classes\n\nNow, let’s image that several of our classes actually use the _fixture.\n\nWhat we would need to do is:\n\n#1 Add the [Collection] attribute to all classes that use the _fixture\n\nYou can actually remove the following! : IClassFixture<BrandInClubAssortmentServiceTests.BrandInClubAssortmentServiceFixture> as [Collection] is now enough to use Fixture\n• Has the attribute[CollectionDefinition] with the matching name in the other classes\n\nWhether fixture is a feature you want to use is up to you.\n\nI believe there are certain advantages of using the Fixture feature:\n\nxUnit.net creates a new instance of the test class for every test. When using a class fixture, xUnit.net will ensure that the fixture instance will be created before any of the tests have run, and once all the tests have finished, it will clean up the fixture object by calling , if present.\n\nSet up your object once and reuse it everywhere in your test classes\n\nIn assert we check whether the test performs as it should.\n\nThis is a critical step as there are many things we can check, this where you want to cover all the paths possible.\n\nHere are some examples\n• Check whether the result returns anything (e.g. notnull or null)\n• Check whether the result returns the right values, types and amount of values\n• Check whether the methods used to come to the result have been called\n\nCheck whether mock methods were called, using VerifyAll() and VerifyNoOtherCalls()\n\nThis method verifies that all expected interactions with the mocked object have occurred.\n\nIn other words, it ensures that all the methods that were set up with expectations (such as calls in Moq) have been called during the test. If any of the expected interactions did not occur, this method typically throws an exception, indicating a test failure.\n\nThis method verifies that there were no additional unexpected calls made to the mocked object beyond those explicitly set up with expectations.\n\nThis may sound irrelevant but it is not. Other calls can simply cause side effects which is often the main cause of production issues\n\nIt's used to ensure that the test is not calling any methods on the mocked object that it shouldn't be. If there are unexpected calls, this method also typically throws an exception, indicating a test failure.\n\nUpon clicking run tests, xUnit will create an instance of the test class for every method test being executed.\n\nOr right click your test class and click “run tests”\n\nA nice GUI (Test explorer) with all your tests will appear\n\nYou can also access this GUI using the Test icon on the top in VS\n\nNow, once you have finished running your tests locally, you want to make sure that any time new code is being pushed, that the tests are always being run.\n\nYou will want to do this automatically, and this where pipelines shine!\n\nI suggest you check my other blog on how to do that :)\n\nSo you’ve run all your tests and you think, job’s done!\n\nWell, not so fast, first thing you want to ensure is that the tests cover most of your code.\n\nThis is referred to as code coverage.\n\nA code coverage report will give you how much percent of your code has been tested, whilst 100% is nice, a typical project aims for 80% code coverage\n\nCode Coverage is available through Coverlet\n\nCoverlet is a free and open-source tool, to use it install the following SDK to your test project\n\nIt should come by default with your xUnit project\n\nIn the command line in your test project run\n\nYou will then receive the following report\n\nAgain this is manual and I recommend using the test coverage in a pipeline as mentioned above in my other blog!\n\nJust as any normal code, one can actually debug your test, which is really useful to understand what input, argument or any setup that is missing.\n\nYou can do so manually by setting up a breakpoint and then selecting the Debug button\n\nNote that you will get into the class that is being tested once you instantiate the class object with the Mock objects (in the ACT phase)\n\nPress F11 and you will land in the tested class"
    },
    {
        "link": "https://medium.com/@eugene_s/better-unit-tests-in-c-with-xunit-part-2-mocking-5f024622b691",
        "document": "This is the continuation of Part 1 of the “Better Unit Tests in C# with xUnit” that will demonstrate how to write unit tests with mocking. First of all, what is mocking in the context of unit testing? Mocking is a substitution of a code dependency with the following aims:\n\n⦁ To isolate the code under test.\n\n⦁ To endow the substitution with such implementation, which will help to test the intended behavior of the code under test.\n\nIn practice, it often happens as the following: there is a method that takes an object of an interface type as one of its arguments. And later the method makes calls to the object according to a specific logic. In the method’s unit testing, we don’t want to pass the real implementation of the interface because the essence of unit testing is that only code under test should be run. But we want to test that the method’s logic uses the object in an expected way. To achieve this, we need to create such implementation of the interface, a mock, which will ensure, during the unit test run, that:\n• The interface methods/properties got called in an expected order.\n\nCreating mocks that will allow us to do that manually will be tedious. That’s why different libraries exist that help to create mocks. One of the most common such libraries for .NET is Moq, which we will use as well.\n\nIn Part 1 we defined a entity with the following behavior: a has size, it can be opened, closed, and with unique labels can be put into it until it has available space.\n\nTo demonstrate the usage of mocking in unit testing, we are going to define the operation whose purpose is to fill a box with things and to write messages into a log about the operation execution. The operation will not be a method of entity but a standalone operation instead. This operation will take an instance of a box, a set of things with labels, and an instance of a log writer as arguments. We want to test the operation implementation without being dependent on the implementations of a and a log writer. To achieve this we will define an interface for a box and delegate for log writing:\n\nYou may ask why a delegate is used for a log writer but not an interface. Delegates and interfaces are very similar: they both define a contract. A delegate can be seen as an interface with only one method and without an interface name. So if you have only one method you may prefer to use delegates instead of interfaces. I tend to use delegates quite often as such an approach better accomplishes S and I from the so-called SOLID principles of programming(maybe more on this in upcoming articles). And by the way, using interfaces/delegates instead of concrete types to avoid dependencies between implementations is the essence of the D principle.\n\nThe operation will be implemented as such:\n\nThe operation does the following sequence of actions:\n\n⦁ Write a message to log that the box is opened.\n\n⦁ Enumerate all passed things and try to put them into the box\n\n⦁ Write a message to log that the box is closed.\n\n⦁ Return things that were not put into the box.\n\nLet’s cover the logic with a unit test. According to the guidelines from Part 1, we will first create the folder with the file and static class within the file:\n\nThe class will have:\n\n- nested record to keep arguments for the method\n\n- nested class which will create data and mocks for the test.\n\nHere is what it will look like (implementation of is omitted for now):\n\nFor this unit test we will define only one test case:\n\nThe test case method has a descriptive name , the first part of which describes arguments passed to the method, the second part describes the expected actions the method should execute, and the rest describes the result expected to be returned.\n\nLet’s dive into the implementation of the test case method. First of all, we need to create mocks for and using the Moq library :\n\nTo test whether executes all required actions and does so in the proper order, we will use MockSequence:\n\nNote that we set up the mock to not put inside a with the label , the mock return in this case. Things that can not be put into a box should be returned as a return value according to the specification we defined above for the method. We will cover it with the unit test as well.\n\nThan the full implementation of the method will be as such:\n\nAnd the full list of code for the unit test is following:\n\nIt also can be found on GitHub.\n\nIt is the author’s opinion that following the guidelines defined in Part 1 should help you to write well-organized and maintainable code for unit tests. Following the D principle from the SOLID principles, as well as the S and I principles, will allow for writing code that is easier to cover with unit tests. Mocking allows to run a code under test in isolation from its dependencies and to ensure that it’s performed as expected."
    },
    {
        "link": "https://telerik.com/blogs/how-to-simplify-your-csharp-unit-testing-mocking-framework",
        "document": "The quickest way to take your unit testing to the next level is with a mocking framework. Let’s see how they work together.\n\nIt’s time to take your unit testing to the next level. You’ve implemented either NUnit or xUnit or MSTest in your projects. You’ve gotten your code coverage to 80+%. But there are just some things that are hard to test or validate in your project.\n\nHow do you test the “business logic” in your repository class? How do you test your dependent web service or database? Yeah, you can write special unit tests and create fake objects to mimic these dependencies, but why waste your time writing code that does not ship with the end product. Or write a lot of code with the attribute. 😊 Well this is where mocking comes in.\n\nMocking is a process that allows you to create a mock object that can be used to simulate the behavior of a real object. You can use the mock object to verify that the real object was called with the expected parameters, and to verify that the real object was not called with unexpected parameters. You can also verify that the real object was called the expected number of times. And you can verify that the real object was called with the expected parameters and that the real object was not called with unexpected parameters. The possibilities are endless.\n\nMocking comes in three flavors: fakes, stubs and mocks. The fakes are the simplest. They are used when you want to test the behavior of a class that has no dependencies. The stubs are used when you want to test the behavior of a class that has dependencies and you do not want to change the behavior. The mocks are used when you want to test the behavior of a class that has dependencies and potentially modify behaviors.\n\nFirst, you’ll need a mocking framework to get started as you don’t want to manage the life cycle of all mock objects. Something like Telerik JustMock or their free version JustMock Lite.\n\nA mocking framework is what you use to create the objects that “pretends” to be the object(s) you are testing.\n\nNow that you have a mocking framework, let’s get started with the primary parts of the unit testing process—Arrange, Act, Assert. Arrange, Act, Assert (or AAA) is a common term used to describe the process of setting up the test environment, executing the test, and verifying the results. It’s a best practice in unit testing. Basically, each of your unit tests should have these three parts:\n\nWhen I write tests, in this case using xUnit, I generally start with this “stub” pattern:\n\nThe method name follows a consistent format:\n• : This is the method you are testing.\n• : Whatever variables you are using, in this example, an invalid id.\n\nWhile this convention is not required, I tend to use it so when I am looking at the results, or another engineer is looking at the code, they can see the intent of the test.\n\nThere are a lot of different types of things to mock, like services, databases, queues and other types of dependencies. For this introductory example, I am going to demonstrate different ways to test a class that requires a dependency of a database. I’ll be using xUnit and Telerik JustMock for these examples.\n\nThe project used in this example can be found here. This project is a C# project that was built on my Twitch stream. The application provides a way to manage a list of contacts. It uses a variety of technologies including:\n\nWith all these dependencies, I needed a way to validate that these dependencies are working as expected. And before you ask, no, I am not testing the functionality of SQL Server or Azure Storage or Azure Functions. I am only testing the interaction with this service. That’s where mocking comes in. For the rest of this post, I’ll focus on testing the class and mocking the .\n\nBefore we get started, let’s take a look at the class. The implements the interface. This is what we are testing.\n\nFull code for this class can be found here.\n\nWe’ll be mocking the object which implements the interface.\n\nWhile objects that are being mocked don’t need to be interfaces, it certainly helps. The interface is a contract that defines the methods that interact with a contact. The class implements the interface, in this case. However, one thing to note is that the requires an dependency, which is what we are going to mock.\n\nThe interface defines the contract with the database, which we do not want to test. This is where mocking comes in. We want to be able to test that the logic in the class is working as expected without going back and forth with the database. This allows us to test things like validation or objects on save, returning the correct exceptions when things go wrong, etc.\n\nLet’s start with the most common test. Let’s validate that a call to returns a list of contacts. We’ll start with the simplest test, and then move to more complex tests.\n\nThe signature of is:\n\nIf we start with our template from above, we should stub out a test that looks like this:\n\nNow, let’s look at the arrange part. For the arrange part, we need to setup the mocks so that the mocking framework knows what to mimic or mock. Here’s the arrange part for the method:\n\nOn line 1, we create a variable, , that is the mock of the interface. Line 2, we create a mock of the method. Lines 3-6, we create a list of contacts and tell the mock framework to return this object when a call is made to . Finally, on line 7, we create a new object and pass in the mock object.\n\nIn this case, the act is trivial. We just call the method on the object.\n\nThis should return a list of contacts with two contacts with the ids of 1 and 2.\n\nLet’s validate that the list of contacts has two contacts.\n\nLine 1 is checking that the list of contacts is not null. Line 2 is checking that the list of contacts has two contacts.\n\nThere is a method in the called that requires an integer as a parameter. In our business case, the identifier of a contact is a positive number (integer). So let’s set up some test that makes sure a call to get with a negative number returns and a call to get with a positive number returns a contact.\n\nFor this, we’ll use a feature called matchers. Matchers let you ignore passing actual values as arguments used in mocks. Instead, they give you the possibility to pass just an expression that satisfies the argument type or the expected value range. This means that we don’t have to write a test for each possible value. We can just write a test for the range of values. We are going to use the matcher for our two tests.\n\nFor the test, where we expect a return, we would arrange the test like this:\n\nIn this arrangement, we are saying that when a call to is made with an argument that is in the range of to 0, inclusive, we should return .\n\nOur act and assert look like:\n\nFor the test, , we would arrange the test like this:\n\nThis one required a little bit more work because we needed to specify an object to return, lines 3 to 6, and a value for the contact id, line 9, to validate in our test.\n\nOur act and assert look like:\n\nThe method has an overload which expects two string parameters, one for first name and the other for last name. The method also requires that the first name and last name are not or empty. If so, it should throw an . Let’s create a test that validates that a call to with an empty first name and last name throws the exception.\n\nLet’s arrange the test like this:\n\nHere we are passing a for the parameter and using the matcher for the parameter which will match any string.\n\nOur act, which is also an assert, looks like this:\n\nHere we are creating a variable which is of type and then we are asserting that the method throws an when called with the parameter set to and the parameter set to .\n\nThen in the assert, we are checking that the exception message is correct.\n\nNote, JustMock supports an alternative way of testing that an exception is thrown. We can use when setting up the test to throw the exception. We can use the matcher to assert that an exception of a specific type is thrown.\n\nThe complete code for the class can be found here.\n\nThe complete code for the class can be found here.\n\nThis just scratches the surface of mocking. There are many more ways to mock using a mocking framework like JustMock. Maybe we’ll cover more in a future post."
    },
    {
        "link": "https://tech-on-diapers.hashnode.dev/a-beginners-guide-to-unit-testing-in-c-using-xunit",
        "document": ""
    }
]