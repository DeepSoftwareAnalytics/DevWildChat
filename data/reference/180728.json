[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.uribuilder?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe UriBuilder class provides a convenient way to modify the contents of a Uri instance without creating a new Uri instance for each modification.\n\nThe UriBuilder properties provide read/write access to the read-only Uri properties so that they can be modified."
    },
    {
        "link": "https://stackoverflow.com/questions/20164298/how-to-build-a-url",
        "document": "Are there any helper classes available in .NET to allow me to build a Url?\n\nFor example, if a user enters a string:\n\nand i try to pass that to an :\n\nIt will fail, because it is not a valid url (it has no scheme).\n\nWhat i want is to be able to parse the partial url the user entered:\n\nand then fix the missing pieces:\n\nDoes .NET have any classes that can be used to parse and manipulate Uri's?\n\nThe UriBuilder class can't do the job\n\nThe value that the user entered (e.g. ) is valid; i just need a class to pick it apart. i tried using the class:\n\nunfortunately, the UriBuilder class is unable to handle URIs:\n\nSo i need a class that can understand , which especially becomes important when it's not particularly , but could be.\n\nFrom the other question\n\nSome examples of URL's that require parsing:\n\nThe format of a Url is:\n\nJust to point out again that UriBuilder does not work:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-uri",
        "document": "This article provides supplementary remarks to the reference documentation for this API.\n\nA URI is a compact representation of a resource available to your application on the intranet or internet. The Uri class defines the properties and methods for handling URIs, including parsing, comparing, and combining. The Uri class properties are read-only; to create a modifiable object, use the UriBuilder class.\n\nRelative URIs (for example, \"/new/index.htm\") must be expanded with respect to a base URI so that they are absolute. The MakeRelativeUri method is provided to convert absolute URIs to relative URIs when necessary.\n\nThe Uri constructors do not escape URI strings if the string is a well-formed URI including a scheme identifier.\n\nThe Uri properties return a canonical data representation in escaped encoding, with all characters with Unicode values greater than 127 replaced with their hexadecimal equivalents. To put the URI in canonical form, the Uri constructor performs the following steps:\n• None Converts the host name to lowercase.\n• None If the host name is an IPv6 address, the canonical IPv6 address is used. ScopeId and other optional IPv6 data are removed.\n• None Converts implicit file paths without the file:// scheme (for example, \"C:\\my\\file\") to explicit file paths with the file:// scheme.\n• None Escaped characters (also known as percent-encoded octets) that don't have a reserved purpose are decoded (also known as being unescaped). These unreserved characters include uppercase and lowercase letters (%41-%5A and %61-%7A), decimal digits (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), and tilde (%7E).\n• None Canonicalizes the path for hierarchical URIs by compacting sequences such as /./, /../, and // (whether or not the sequence is escaped). Note that there are some schemes for which these sequences are not compacted.\n• None For hierarchical URIs, if the host is not terminated with a forward slash (/), one is added.\n• None By default, any reserved characters in the URI are escaped in accordance with RFC 2396. This behavior changes if International Resource Identifiers or International Domain Name parsing is enabled in which case reserved characters in the URI are escaped in accordance with RFC 3986 and RFC 3987.\n\nAs part of canonicalization in the constructor for some schemes, dot-segments and empty segments ( , , and ) are compacted (in other words, they are removed). The schemes for which Uri compacts segments include http, https, tcp, net.pipe, and net.tcp. For some other schemes, these sequences are not compacted. The following code snippet shows how compacting looks in practice. The escaped sequences are unescaped, if necessary, and then compacted.\n\nWhen this code executes, it returns output similar to the following text.\n\nYou can transform the contents of the Uri class from an escape encoded URI reference to a readable URI reference by using the ToString method. Note that some reserved characters might still be escaped in the output of the ToString method. This is to support unambiguous reconstruction of a URI from the value returned by ToString.\n\nSome URIs include a fragment identifier or a query or both. A fragment identifier is any text that follows a number sign (#), not including the number sign; the fragment text is stored in the Fragment property. Query information is any text that follows a question mark (?) in the URI; the query text is stored in the Query property.\n\nWeb addresses are typically expressed using uniform resource identifiers that consist of a very restricted set of characters:\n• Upper and lower case ASCII letters from the English alphabet.\n\nThe specifications for URIs are documented in RFC 2396, RFC 2732, RFC 3986, and RFC 3987 published by the Internet Engineering Task Force (IETF).\n\nIdentifiers that facilitate the need to identify resources using languages other than English and allow non-ASCII characters (characters in the Unicode/ISO 10646 character set) are known as International Resource Identifiers (IRIs). The specifications for IRIs are documented in RFC 3987 published by IETF. Using IRIs allows a URL to contain Unicode characters.\n\nIn .NET Framework 4.5 and later versions, IRI is always enabled and can't be changed using a configuration option. You can set a configuration option in the machine.config or in the app.config file to specify whether you want Internationalized Domain Name (IDN) parsing applied to the domain name. For example:\n\nEnabling IDN converts all Unicode labels in a domain name to their Punycode equivalents. Punycode names contain only ASCII characters and always start with the xn-- prefix. The reason for this is to support existing DNS servers on the Internet, since most DNS servers only support ASCII characters (see RFC 3940).\n\nEnabling IDN affects the value of the Uri.DnsSafeHost property. Enabling IDN can also change the behavior of the Equals, OriginalString, GetComponents, and IsWellFormedOriginalString methods.\n\nThere are three possible values for IDN depending on the DNS servers that are used:\n• This value will convert any Unicode domain names to their Punycode equivalents (IDN names).\n• This value will convert all Unicode domain names not on the local Intranet to use the Punycode equivalents (IDN names). In this case to handle international names on the local Intranet, the DNS servers that are used for the Intranet should support Unicode name resolution.\n• This value will not convert any Unicode domain names to use Punycode. This is the default value.\n\nNormalization and character checking are done according to the latest IRI rules in RFC 3986 and RFC 3987.\n\nIRI and IDN processing in the Uri class can also be controlled using the System.Configuration.IriParsingElement, System.Configuration.IdnElement, and System.Configuration.UriSection configuration setting classes. The System.Configuration.IriParsingElement setting enables or disables IRI processing in the Uri class. The System.Configuration.IdnElement setting enables or disables IDN processing in the Uri class.\n\nThe configuration setting for the System.Configuration.IriParsingElement and System.Configuration.IdnElement are read once when the first System.Uri class is constructed. Changes to configuration settings after that time are ignored.\n\nThe System.GenericUriParser class has also been extended to allow creating a customizable parser that supports IRI and IDN. The behavior of a System.GenericUriParser object is specified by passing a bitwise combination of the values available in the System.GenericUriParserOptions enumeration to the System.GenericUriParser constructor. The GenericUriParserOptions.IriParsing type indicates the parser supports the parsing rules specified in RFC 3987 for International Resource Identifiers (IRI).\n\nThe GenericUriParserOptions.Idn type indicates that the parser supports Internationalized Domain Name (IDN) parsing of host names. In .NET 5 and later versions (including .NET Core) and .NET Framework 4.5+, IDN is always used. In previous versions, a configuration option determines whether IDN is used.\n\nUri can also be used to represent local file system paths. These paths can be represented explicitly in URIs that begin with the file:// scheme, and implicitly in URIs that do not have the file:// scheme. As a concrete example, the following two URIs are both valid, and represent the same file path:\n\nThese implicit file paths are not compliant with the URI specification and so should be avoided when possible. When using .NET Core on Unix-based systems, implicit file paths can be especially problematic, because an absolute implicit file path is indistinguishable from a relative path. When such ambiguity is present, Uri default to interpreting the path as an absolute URI.\n\nBecause of security concerns, your application should use caution when accepting Uri instances from untrusted sources and with set to in the constructor. You can check a URI string for validity by calling the IsWellFormedOriginalString method.\n\nWhen dealing with untrusted user input, confirm assumptions about the newly created instance before trusting its properties. This can be done in the following way:\n\nThis validation can be used in other cases, like when dealing with UNC paths, by simply changing the :\n\nIf you use a Web.configfile that contains URIs to initialize your application, additional time is required to process the URIs if their scheme identifiers are nonstandard. In such a case, initialize the affected parts of your application when the URIs are needed, not at start time."
    },
    {
        "link": "https://stackoverflow.com/questions/1759881/c-sharp-url-builder-class",
        "document": "Flurl [disclosure: I'm the author] is a fluent URL builder that looks like this:\n\nIf you happen to be building URLs for the purpose of calling them, Flurl.Http is a companion lib that lets you do HTTP off the fluent chain:\n\nGet the full package on NuGet:\n\nor just the stand-alone URL builder:"
    },
    {
        "link": "https://code-maze.com/how-to-create-a-url-query-string",
        "document": "In web development, a query string is a crucial URL component that facilitates data exchange between clients and servers. In this article, we will learn how to build a query string for a URL in C#.\n\nAt its core, a query string is a string of characters appended to a URL, typically following a question mark ( ). It consists of key-value pairs separated by ampersands ( ). Each key is associated with a value and ampersands ( ) separate multiple key-value pairs.\n\nLet’s see an example of a query string:\n\nHere, for instance, the URL starts with the base address . After the question mark ( ), the query string begins with the first key-value pair: . Here, “author” is the key, and “rowling” is the value. The ampersand ( ) separates the first key-value pair from the second: .\n\nThere are several ways we can build a query string for a URL:\n\nLet’s look at each approach to build a query string.\n\nTo mimic a real API call using the query string, we can set up a simple API that accepts a query string for testing purposes. This API represents a book service that accepts and as query parameters and returns some book details.\n\nWe can construct a query string and then make an API call using it to test if it works. However, setting up the API is optional and not compulsory in this article. Please visit the code for more information about the API.\n\nTo begin with, let’s proceed to create a console app and define a class:\n\nHere, we declare a constant, which holds the base URL for an API endpoint.\n\nNow, let’s explore each section in detail.\n\nString concatenation is one of the traditional techniques for constructing query strings in C#. This technique combines multiple strings, including parameter names and values, to create a complete query string. While it offers control, it can be cumbersome when dealing with complex queries or numerous parameters.\n\nFirst, we’ll create a utility class. This class will contain various methods, each employing a different technique to construct query strings.\n\nNow, let’s create our first method to build a query string using string concatenation:\n\nFirst, inside the class, we define a method that accepts the and as the input parameters. We then use the LINQ method to transform the dictionary into a collection of formatted key-value pairs. Then, we use the method to concatenate these pairs with “&” as the separator.\n\nMoving forward, we concatenate the and the to form the complete URL and return it.\n\nIn this example, one of the primary challenges we face is the URI encoding of the query parameters. If we have an author name with special characters, we might end up with a malformed URL if we don’t encode the special characters when passing the name as a query parameter.\n\nLet’s see an example of how to encode the query parameters:\n\nHere, we use the method to encode both the and of the .\n\nWe start by initializing a object, which contains key-value pairs representing the query parameters for the API request. We pass “George Orwell” as the author and “english” as the language.\n\nFinally, we call the method, passing the and variables to build the complete URL.\n\nIt’s important to note that besides string concatenation, there are alternative manual techniques for building query strings in C#. Please visit these articles to learn more: String Interpolation and Different Ways to Concatenate String.\n\nThe UriBuilder class in C# provides a powerful and convenient way to construct and modify instances. We can create or manipulate URLs with various components like the scheme, host, port, path, and query string.\n\nThe class handles the URL encoding, ensuring that parameter names and values are correctly encoded for safe URL construction.\n\nLet’s create another method in the class to demonstrate using the class:\n\nWe start by creating an instance of the class and initialize it with a base API URL. Then, we concatenate the key-value pairs using method and set the property of the instance. Finally, we obtain the complete API URL by accessing the property of the instance and then retrieving its property.\n\nSo, let’s proceed to invoke the method:\n\nIn a similar fashion, we initialize a object that holds the query parameters. Then, we pass the and the variables to the method to get a complete URL. The class encodes the parameter value that contains a space.\n\nThe HttpUtility.ParseQueryString() method is part of the namespace in C#. This method is beneficial when we create or manipulate query strings in web applications.\n\nIt allows us to parse an existing query string into a collection of key-value pairs, modify those pairs, and generate a new query string.\n\nWe will create a new method within the class to demonstrate this technique:\n\nHere, we create an empty using the method.\n\nThis method internally creates an instance of , which is a non-publicly accessible overload of . Because it is an internal class, we have to use this non-standard method of initialization. The upside of this special collection is its automatic handling of values, along with proper URL encoding of all key-value pairs.\n\nOnce we have our collection, we add our key-value pairs to it. And finally, we build the complete URL by passing the separator ( ), , and the variable to the method.\n\nIf we provide multiple query parameters and one of them has a value, it will skip the query parameter with a value and print the rest in the query string when we call the method. However, if every query parameter passed has a value, an exception will be thrown. In this case, we assume no values will be passed.\n\nHere, we create the query parameters using the object and invoke the method to obtain the complete URL.\n\nThe is a utility class provided by the namespace. It includes the method that builds the query string by adding or appending parameters to an existing URL.\n\nThe QueryHelpers.AddQueryString() method ensures correct URL encoding of parameter names and values for proper URL formation.\n\nAs a first step, let’s include the as a in the .csproj file within an :\n\nAdding this reference ensures that we can use the method from the namespace.\n\nNow, let’s create a new method to demonstrate using the method:\n\nHere, we use the method to generate the query string. We pass the and the dictionary as input, and we get the complete URL.\n\nIn this method, we specifically accept the with nullable string values because of the method supports nullable values, providing flexibility in handling optional query parameters.\n\nSimilarly, we create a object that holds the query parameters and passes the and the variables to the method to build the complete URL.\n\nThe QueryBuilder class is part of the namespace and is used to construct a query string. In essence, the class allows us to build a query string by adding key-value pairs. It implements the interface, which means we can iterate over the key-value pairs contained within it.\n\nLet’s take a look at an example:\n\nHere, we create an instance of class, and we pass the to the constructor, which returns the instance of the class.\n\nWhen we concatenate a object with a string, it implicitly calls the method of the class. In the context of the class, it overrides the method to return the query string representation of the key-value pairs stored in the object.\n\nConsequently, we can concatenate the object with the to create a complete URL.\n\nHere, we initialize a object and pass the method to construct the complete URL.\n\nThe QueryString.Create() method is a convenient way to create a key-value pair query string object.\n\nThe method offers three overloads. The first overload, , allows us to create a query string with a single key-value pair.\n\nThe second overload, , accepts a collection of key-value pairs, where values are nullable strings.\n\nLastly, the third overload, , takes a collection of key-value pairs where the values are of type .\n\nLet’s create a new method in the class:\n\nHere, we define a method that accepts a , allowing nullable string values. This choice is made because the second overload of the method supports nullable values.\n\nAlthough this method doesn’t explicitly accept a , we can still pass a to it. This is possible because implements the interface. Then, we use the method and pass the dictionary object to build a query string.\n\nHere, we create a object to represent the query parameters and invoke the method to form the complete URL.\n\nIn this article, we have explored various approaches for building a query string in C#. The method we choose will depend on our specific needs and preferences.\n\nTo conclude, we can use string concatenation and other manual techniques if we need a straightforward way to build a query string. However, using the string concatenation technique, we must ensure that we properly encode the parameter names and values.\n\nOn the other hand, if we need to build complex queries or deal with numerous parameters, we may use a more robust method, such as the class, the ) method, the method, the class, or the method.\n\nWe do not need to manually encode the query string parameters when employing any of these methods. These methods handle URL encoding internally, ensuring secure and accurate URL formation."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions",
        "document": "Proper exception handling is essential for application reliability. You can intentionally handle expected exceptions to prevent your app from crashing. However, a crashed app is more reliable and diagnosable than an app with undefined behavior.\n\nThis article describes best practices for handling and creating exceptions.\n\nThe following best practices concern how you handle exceptions:\n• Use try/catch/finally blocks to recover from errors or release resources\n• Design classes so that exceptions can be avoided\n\nUse try/catch/finally blocks to recover from errors or release resources\n\nFor code that can potentially generate an exception, and when your app can recover from that exception, use / blocks around the code. In blocks, always order exceptions from the most derived to the least derived. (All exceptions derive from the Exception class. More derived exceptions aren't handled by a clause that's preceded by a clause for a base exception class.) When your code can't recover from an exception, don't catch that exception. Enable methods further up the call stack to recover if possible.\n\nClean up resources that are allocated with either statements or blocks. Prefer statements to automatically clean up resources when exceptions are thrown. Use blocks to clean up resources that don't implement IDisposable. Code in a clause is almost always executed even when exceptions are thrown.\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that avoids the exception. For example, if you try to close a connection that's already closed, you'll get an . You can avoid that by using an statement to check the connection state before trying to close it.\n\nIf you don't check the connection state before closing, you can catch the exception.\n\nThe approach to choose depends on how often you expect the event to occur.\n• None Use exception handling if the event doesn't occur often, that is, if the event is truly exceptional and indicates an error, such as an unexpected end-of-file. When you use exception handling, less code is executed in normal conditions.\n• None Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions. Up-front checks eliminate exceptions most of the time. However, there can be race conditions where the guarded condition changes between the check and the operation, and in that case, you could still incur an exception.\n\nIf the performance cost of exceptions is prohibitive, some .NET library methods provide alternative forms of error handling. For example, Int32.Parse throws an OverflowException if the value to be parsed is too large to be represented by Int32. However, Int32.TryParse doesn't throw this exception. Instead, it returns a Boolean and has an parameter that contains the parsed valid integer upon success. Dictionary<TKey,TValue>.TryGetValue has similar behavior for attempting to get a value from a dictionary.\n\nIt's better to catch OperationCanceledException instead of TaskCanceledException, which derives from , when you call an asynchronous method. Many asynchronous methods throw an OperationCanceledException exception if cancellation is requested. These exceptions enable execution to be efficiently halted and the callstack to be unwound once a cancellation request is observed.\n\nAsynchronous methods store exceptions that are thrown during execution in the task they return. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as ArgumentException, are still thrown synchronously. For more information, see Asynchronous exceptions.\n\nDesign classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, the FileStream class provides methods that help determine whether the end of the file has been reached. You can call these methods to avoid the exception that's thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception:\n\nAnother way to avoid exceptions is to return (or default) for most common error cases instead of throwing an exception. A common error case can be considered a normal flow of control. By returning (or default) in these cases, you minimize the performance impact to an app.\n\nFor value types, consider whether to use or as the error indicator for your app. By using , becomes instead of . Sometimes, adding can make it clearer when a value is present or absent. Other times, adding can create extra cases to check that aren't necessary and only serve to create potential sources of errors.\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nThe preceding method doesn't directly throw any exceptions. However, you must write the method so that the withdrawal is reversed if the deposit operation fails.\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nThis example illustrates the use of to rethrow the original exception, making it easier for callers to see the real cause of the problem without having to examine the InnerException property. An alternative is to throw a new exception and include the original exception as the inner exception.\n\nOnce an exception is thrown, part of the information it carries is the stack trace. The stack trace is a list of the method call hierarchy that starts with the method that throws the exception and ends with the method that catches the exception. If you rethrow an exception by specifying the exception in the statement, for example, , the stack trace is restarted at the current method and the list of method calls between the original method that threw the exception and the current method is lost. To keep the original stack trace information with the exception, there are two options that depend on where you're rethrowing the exception from:\n• If you rethrow the exception from within the handler ( block) that's caught the exception instance, use the statement without specifying the exception. Code analysis rule CA2200 helps you find places in your code where you might inadvertently lose stack trace information.\n• If you're rethrowing the exception from somewhere other than the handler ( block), use ExceptionDispatchInfo.Capture(Exception) to capture the exception in the handler and ExceptionDispatchInfo.Throw() when you want to rethrow it. You can use the ExceptionDispatchInfo.SourceException property to inspect the captured exception.\n\nThe following example shows how the ExceptionDispatchInfo class can be used, and what the output might look like.\n\nIf the file in the example code doesn't exist, the following output is produced:\n\nThe following best practices concern how you throw exceptions:\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n• If a property set or method call isn't appropriate given the object's current state, throw an InvalidOperationException exception.\n• If invalid parameters are passed, throw an ArgumentException exception or one of the predefined classes that derive from ArgumentException.\n\nIt's common for a class to throw the same exception from different places in its implementation. To avoid excessive code, create a helper method that creates the exception and returns it. For example:\n\nSome key .NET exception types have such static helper methods that allocate and throw the exception. You should call these methods instead of constructing and throwing the corresponding exception type:\n\nIf you're implementing an asynchronous method, call CancellationToken.ThrowIfCancellationRequested() instead of checking if cancellation was requested and then constructing and throwing OperationCanceledException. For more information, see CA2250.\n\nThe error message the user sees is derived from the Exception.Message property of the exception that was thrown, and not from the name of the exception class. Typically, you assign a value to the Exception.Message property by passing the message string to the argument of an Exception constructor.\n\nFor localized applications, you should provide a localized message string for every exception that your application can throw. You use resource files to provide localized error messages. For information on localizing applications and retrieving localized strings, see the following articles:\n• How to: Create user-defined exceptions with localized exception messages\n\nWrite clear sentences and include ending punctuation. Each sentence in the string assigned to the Exception.Message property should end in a period. For example, \"The log table has overflowed.\" uses correct grammar and punctuation.\n\nPlace throw statements where the stack trace will be helpful. The stack trace begins at the statement where the exception is thrown and ends at the statement that catches the exception.\n\nDon't raise exceptions in clauses. For more information, see code analysis rule CA2219.\n\nSome methods, such as , , and methods, static constructors, and equality operators, shouldn't throw exceptions. For more information, see code analysis rule CA1065.\n\nIn task-returning methods, you should validate arguments and throw any corresponding exceptions, such as ArgumentException and ArgumentNullException, before entering the asynchronous part of the method. Exceptions that are thrown in the asynchronous part of the method are stored in the returned task and don't emerge until, for example, the task is awaited. For more information, see Exceptions in task-returning methods.\n\nThe following best practices concern custom exception types:\n\nWhen a custom exception is necessary, name it appropriately and derive it from the Exception class. For example:\n\nUse at least the three common constructors when creating your own exception classes: the parameterless constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n• Exception(String, Exception), which accepts a string message and an inner exception.\n\nFor an example, see How to: Create user-defined exceptions.\n\nProvide additional properties for an exception (in addition to the custom message string) only when there's a programmatic scenario where the additional information is useful. For example, the FileNotFoundException provides the FileName property."
    },
    {
        "link": "https://stackoverflow.com/questions/14973642/how-using-try-catch-for-exception-handling-is-best-practice",
        "document": "First of all, the best practice should be don't throw exceptions for any kind of error, unless it's a blocking error.\n\nIf the error is blocking, then throw the exception. Once the exception is already thrown, there's no need to hide it because it's exceptional; let the user know about it (you should reformat the whole exception to something useful to the user in the UI).\n\nYour job as software developer is to endeavour to prevent an exceptional case where some parameter or runtime situation may end in an exception. That is, exceptions mustn't be muted, but these must be avoided.\n\nFor example, if you know that some integer input could come with an invalid format, use instead of . There is a lot of cases where you can do this instead of just saying \"if it fails, simply throw an exception\".\n\nIf, after all, an exception is thrown, instead of writing the exception to the log once it has been thrown, one of best practices is catching it in a first-chance exception handler. For example:\n\nMy stance is that local try/catches are better suited for handling special cases where you may translate an exception into another, or when you want to \"mute\" it for a very, very, very, very, very special case (a library bug throwing an unrelated exception that you need to mute in order to workaround the whole bug).\n\nFor the rest of the cases:\n• If this isn't possible: first-chance exception handlers.\n\nAnswering to @thewhiteambit on some comment...\n\nFirst of all, how an exception can't be even an error?\n• Invalid string format to parse to some type => exception\n• Trying to parse JSON and while input isn't actually JSON => exception\n• Some library has a bug => throws an unexpected exception\n• There's a socket connection and it gets disconnected. Then you try to send a message => exception\n\nWe might list 1k cases of when an exception is thrown, and after all, any of the possible cases will be an error.\n\nAn exception is an error, because at the end of the day it is an object which collects diagnostic information -- it has a message and it happens when something goes wrong.\n\nNo one would throw an exception when there's no exceptional case. Exceptions should be blocking errors because once they're thrown, if you don't try to fall into the use try/catch and exceptions to implement control flow they mean your application/service will stop the operation that entered into an exceptional case.\n\nAlso, I suggest everyone to check the fail-fast paradigm published by Martin Fowler (and written by Jim Shore). This is how I always understood how to handle exceptions, even before I got to this document some time ago.\n\nUsually exceptions cut some operation flow and they're handled to convert them to human-understandable errors. Thus, it seems like an exception actually is a better paradigm to handle error cases and work on them to avoid an application/service complete crash and notify the user/consumer that something went wrong.\n\nFor example in case of a missing Database-Connection the program could exceptionally continue with writing to a local file and send the changes to the Database once it is available again. Your invalid String-To-Number casting could be tried to parse again with language-local interpretation on Exception, like as you try default English language to Parse(\"1,5\") fails and you try it with German interpretation again which is completely fine because we use comma instead of point as separator. You see these Exceptions must not even be blocking, they only need some Exception-handling.\n• None If your app might work offline without persisting data to database, you shouldn't use exceptions, as implementing control flow using is considered as an anti-pattern. Offline work is a possible use case, so you implement control flow to check if database is accessible or not, you don't wait until it's unreachable.\n• None The parsing thing is also an expected case (not EXCEPTIONAL CASE). If you expect this, you don't use exceptions to do control flow!. You get some metadata from the user to know what his/her culture is and you use formatters for this! .NET supports this and other environments too, and an exception because number formatting must be avoided if you expect a culture-specific usage of your application/service.\n\nThis article is just an opinion or a point of view of the author.\n\nSince Wikipedia can be also just the opinion of articule author(s), I wouldn't say it's the dogma, but check what Coding by exception article says somewhere in some paragraph:\n\nIt also says somewhere:\n\nHonestly, I believe that software can't be developed don't taking use cases seriously. If you know that...\n• Your database can go offline...\n• Some file can be locked...\n• Some formatting might be not supported...\n• Your app should work in offline mode...\n\n...you won't use exceptions for that. You would support these use cases using regular control flow.\n\nAnd if some unexpected use case isn't covered, your code will fail fast, because it'll throw an exception. Right, because an exception is an exceptional case.\n\nIn the other hand, and finally, sometimes you cover exceptional cases throwing expected exceptions, but you don't throw them to implement control flow. You do it because you want to notify upper layers that you don't support some use case or your code fails to work with some given arguments or environment data/properties."
    },
    {
        "link": "https://stackoverflow.com/questions/26894234/exception-handling-in-async-methods-c-sharp",
        "document": "I know this question has been asked several times, but, I'm looking slightly at a different variant.\n\nIn the above code it may so happen that validation fails and exception is thrown even before the control enters async part of the method. Do we need to wrap the first call also around a try..catch block? My experiment showed that this is not useful. Instead, the task status is set to Faulted. So, I believe it is correct to check Task status and return data accordingly. Can C# pros comment on this?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements",
        "document": "You use the and statements to work with exceptions. Use the statement to throw an exception. Use the statement to catch and handle exceptions that might occur during execution of a code block.\n\nIn a statement, the result of expression must be implicitly convertible to System.Exception.\n\nYou can use the built-in exception classes, for example, ArgumentOutOfRangeException or InvalidOperationException. .NET also provides the following helper methods to throw exceptions in certain conditions: ArgumentNullException.ThrowIfNull and ArgumentException.ThrowIfNullOrEmpty. You can also define your own exception classes that derive from System.Exception. For more information, see Creating and throwing exceptions.\n\nInside a block, you can use a statement to re-throw the exception that is handled by the block:\n\nWhen an exception is thrown, the common language runtime (CLR) looks for the block that can handle this exception. If the currently executed method doesn't contain such a block, the CLR looks at the method that called the current method, and so on up the call stack. If no block is found, the CLR terminates the executing thread. For more information, see the How exceptions are handled section of the C# language specification.\n\nYou can also use as an expression. This might be convenient in a number of cases, which include:\n• None the conditional operator. The following example uses a expression to throw an ArgumentException when the passed array is empty: string first = args.Length >= 1 ? args[0] : throw new ArgumentException(\"Please supply at least one argument.\");\n• None the null-coalescing operator. The following example uses a expression to throw an ArgumentNullException when the string to assign to a property is : public string Name { get => name; set => name = value ?? throw new ArgumentNullException(paramName: nameof(value), message: \"Name cannot be null\"); }\n• None an expression-bodied lambda or method. The following example uses a expression to throw an InvalidCastException to indicate that a conversion to a DateTime value is not supported: DateTime ToDateTime(IFormatProvider provider) => throw new InvalidCastException(\"Conversion to a DateTime is not supported.\");\n\nYou can use the statement in any of the following forms: - to handle exceptions that might occur during execution of the code inside a block, - to specify the code that is executed when control leaves the block, and - as a combination of the preceding two forms.\n\nUse the statement to handle exceptions that might occur during execution of a code block. Place the code where an exception might occur inside a block. Use a catch clause to specify the base type of exceptions you want to handle in the corresponding block:\n\nYou can provide several catch clauses:\n\nWhen an exception occurs, catch clauses are examined in the specified order, from top to bottom. At maximum, only one block is executed for any thrown exception. As the preceding example also shows, you can omit declaration of an exception variable and specify only the exception type in a catch clause. A catch clause without any specified exception type matches any exception and, if present, must be the last catch clause.\n\nIf you want to re-throw a caught exception, use the statement, as the following example shows:\n\nAlong with an exception type, you can also specify an exception filter that further examines an exception and decides if the corresponding block handles that exception. An exception filter is a Boolean expression that follows the keyword, as the following example shows:\n\nThe preceding example uses an exception filter to provide a single block to handle exceptions of two specified types.\n\nYou can provide several clauses for the same exception type if they distinguish by exception filters. One of those clauses might have no exception filter. If such a clause exists, it must be the last of the clauses that specify that exception type.\n\nIf a clause has an exception filter, it can specify the exception type that is the same as or less derived than an exception type of a clause that appears after it. For example, if an exception filter is present, a clause doesn't need to be the last clause.\n\nIf an exception occurs in an async function, it propagates to the caller of the function when you await the result of the function, as the following example shows:\n\nIf an exception occurs in an iterator method, it propagates to the caller only when the iterator advances to the next element.\n\nIn a statement, the block is executed when control leaves the block. Control might leave the block as a result of\n• execution of a jump statement (that is, , , , or ), or\n• propagation of an exception out of the block.\n\nThe following example uses the block to reset the state of an object before control leaves the method:\n\nYou can also use the block to clean up allocated resources used in the block.\n\nExecution of the block depends on whether the operating system chooses to trigger an exception unwind operation. The only cases where blocks aren't executed involve immediate termination of a program. For example, such a termination might happen because of the Environment.FailFast call or an OverflowException or InvalidProgramException exception. Most operating systems perform a reasonable resource clean-up as part of stopping and unloading the process.\n\nYou use a statement both to handle exceptions that might occur during execution of the block and specify the code that must be executed when control leaves the statement:\n\nWhen an exception is handled by a block, the block is executed after execution of that block (even if another exception occurs during execution of the block). For information about and blocks, see The statement and The statement sections, respectively.\n\nFor more information, see the following sections of the C# language specification:"
    },
    {
        "link": "https://reddit.com/r/dotnet/comments/1cvtcpu/mastering_exception_handling_in_c_a_comprehensive",
        "document": "Exception handling is a critical component of software development in C#. It allows to gracefully manage errors, ensuring applications remain stable and user-friendly under unforeseen circumstances. This guide provides a comprehensive look at exception handling in C#, covering everything from basic try/catch blocks to throwing custom exceptions."
    }
]