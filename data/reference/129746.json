[
    {
        "link": "https://geeksforgeeks.org/turing-machine-as-comparator",
        "document": ""
    },
    {
        "link": "https://cs.stackexchange.com/questions/41416/turing-machine-for-unary-encoded-quadratic-numbers",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://cs.stackexchange.com/questions/122004/design-a-turing-machine-which-accepts-strings-x-y-where-x-ge-y",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/turing-machine-in-toc",
        "document": "Turing Machines (TM) play a crucial role in the Theory of Computation (TOC). They are abstract computational devices used to explore the limits of what can be computed. Turing Machines help prove that certain languages and problems have no algorithmic solution. Their simplicity makes them an effective tool for studying computational theory, yet they are as powerful as modern computers. Turing Machine was invented by Alan Turing in 1936 and it is used to accept Recursive Enumerable Languages (generated by Type-0 Grammar).\n• None A Turing Machine consists of an infinite tape, a read/write head, and a set of rules that determine how it reads, writes, and moves on the tape. Despite its simplicity, a TM can simulate any real-world computation, making it as powerful as modern computers but with infinite memory.\n• None The Turing machine’s behavior is determined by a finite state machine, which consists of a finite set of states, a transition function that defines the actions to be taken based on the current state and the symbol being read, and a set of start and accept states.\n• None The TM begins in the start state and performs the actions specified by the transition function until it reaches an accept or reject state. If it reaches an accept state, the computation is considered successful; if it reaches a reject state, the computation is considered unsuccessful.\n• None In the context of automata theory and the theory of computation, Turing machines are used to study the properties of algorithms and to determine what problems can and cannot be solved by computers. They provide a way to model the behavior of algorithms and to analyze their computational complexity, which is the amount of time and memory they require to solve a problem.\n\nTuring machines are an important tool for studying the limits of computation and for understanding the foundations of computer science. They provide a simple yet powerful model of computation that has been widely used in research and has had a profound impact on our understanding of algorithms and computation.\n\nWhile one might consider using programming languages like C to study computation, Turing Machines are preferred because:\n• None They are simpler to analyze.\n• None They possess infinite memory, making them even more powerful than real-world computers.\n\nA Turing Machine consists of a tape of infinite length on which read and writes operation can be performed. The tape consists of infinite cells on which each cell either contains input symbol or a special symbol called blank. It also consists of a head pointer which points to cell currently being read and it can move in both directions.\n\nWe construct a Turing Machine (TM) for the language L = {0ⁿ1ⁿ | n ≥ 1}, which accepts strings of equal 0s followed by equal 1s.\n\nLet us see how this turing machine works for 0011. Initially head points to 0 which is underlined and state is q0 as:\n\nThe move will be δ(q0, 0) = (q1, X, R). It means, it will go to state q1, replace 0 by X and head will move to right as:\n\nThe move will be δ(q1, 0) = (q1, 0, R) which means it will remain in same state and without changing any symbol, it will move to right as:\n\nThe move will be δ(q1, 1) = (q2, Y, L) which means it will move to q2 state and changing 1 to Y, it will move to left as:\n\nWorking on it in the same way, the machine will reach state q3 and head will point to B as shown:\n\nUsing move δ(q3, B) = halt, it will stop and accepted.\n• None In non-deterministic turing machine, there can be more than one possible move for a given state and tape symbol, but non-deterministic TM does not add any power.\n• None Every non-deterministic TM can be converted into deterministic TM.\n• None In multi-tape turing machine, there can be more than one tape and corresponding head pointers, but it does not add any power to turing machine.\n• None Every multi-tape TM can be converted into single tape TM.\n\nQuestion: A single tape Turing Machine M has two states q0 and q1, of which q0 is the starting state. The tape alphabet of M is {0, 1, B} and its input alphabet is {0, 1}. The symbol B is the blank symbol used to indicate end of an input string. The transition function of M is described in the following table.\n\nThe table is interpreted as illustrated below. The entry (q1, 1, R) in row q0 and column 1 signifies that if M is in state q0 and reads 1 on the current tape square, then it writes 1 on the same tape square, moves its tape head one position to the right and transitions to state q1. Which of the following statements is true about M?\n• None M does not halt on any string in (0 + 1)+\n• None M does not halt on any string in (00 + 1)*\n• None M halts on all string ending in a 0\n• None M halts on all string ending in a 1\n\nSolution: Let us see whether machine halts on string ‘1’. Initially state will be q0, head will point to 1 as:\n\nUsing δ(q0, 1) = (q1, 1, R), it will move to state q1 and head will move to right as:\n\nUsing δ(q1, B) = (q0, B, L), it will move to state q0 and head will move to left as:\n\nIt will run in the same way again and again and not halt.\n\nOption D says M halts on all string ending with 1, but it is not halting for 1. So, option D is incorrect.\n\nLet us see whether machine halts on string ‘0’. Initially state will be q0, head will point to 1 as:\n\nUsing δ(q0, 0) = (q1, 1, R), it will move to state q1 and head will move to right as:\n\nUsing δ(q1,B)=(q0,B,L), it will move to state q0 and head will move to left as:\n\nIt will run in the same way again and again and not halt.\n\nOption C says M halts on all string ending with 0, but it is not halting for 0. So, option C is incorrect.\n\nOption B says that TM does not halt for any string (00 + 1)*. But NULL string is a part of (00 + 1)* and TM will halt for NULL string. For NULL string, tape will be,\n\nUsing δ(q0, B) = halt, TM will halt. As TM is halting for NULL, this option is also incorrect. \n\nSo, option (A) is correct.\n\nWhat is the purpose of Multi-Tape Turing Machines?\n\nWhat is the Halting Problem?\n\nWhat are some limitations of Turing Machines?"
    },
    {
        "link": "https://cs.odu.edu/~zeil/cs390/s22/Public/turing-jflap/index.html",
        "document": "\n• Review the Turing machines section of the Automat help pages.\n• Construct the TM from examples 8.2/8.3. Use it to solve Exercise 8.2.1.\n• Construct your own Turing machine to solve Exercise 8.2.2a. (Note that this language is not a CFL.)\n\n2 New Ways to Solve Old Problems\n\nWe have previously designed this FA to accepts strings that contain .\n\nDesign a Turing machine for the same language\n\nHere is a FA for accepting strings that end with .\n\nIn this automaton, we can enter the accepting state many times (e.g., 101010) but only accept the string if we are in the accepting state AND have processed all of the input.\n\nDesign a TM to accept the same language.\n\nConsider the language of all strings of the form $0^n1^n$, i.e., some number of zeros followed by an equal number of ones. This is a typical “counting” problem for a PDA, as shown to the right.\n\nThe TMs in this section illustrate a number of “programing style” tips that are worth pointing out to people new to Turing machines:\n• The TM controller is a deterministic FA. So anything you can do with a DFA, you can translate directly to a TM, never changing anything on the tape. But sometimes TMs can do the same thing in a simpler fashion.\n• Unlike FAs, a TM can make multiple passes over the input data.\n• TM’s can make a “pass” over their data both from left-to-right and from right-to-left.\n• Many TM algorithms spend a lot of time bouncing back and forth from one end of the input string to the other.\n\nUse a combination of inspection and of running test cases on each of the following Turing machines to determine what it does.\n\nWhat language does this TM accept?\n\nOften we think of TMs not so much as acceptors of languages as computers of functions. The input to the function is the initial content of the tape and the output is the final content of the tape when the TM reaches an accepting state.\n\nWhat is the function computed by this TM when presented with inputs over the language ?\n\nWhat is the function computed by this TM?\n\nFor example, suppose that we had a string over ${a,b}^*$ and that we wanted to erase the first ‘a’. How would you write a TM to do this?\n\nYou may notice a symmetry in our shift-left pattern between the way that ‘a’ and ‘b’ are handled. If we wanted to do a shift-left for a language over three symbols instead of two, we would add another branch similar to $q_0 \\rightarrow q_1 \\rightarrow q_4$ and $q_0 \\rightarrow q_2 \\rightarrow q_4$. For a language over four characters, we would add yet another branch. Languages with larger alphabets add more states and transitions to this pattern, making everything just a little bit messier and hard to read.\n\nA shortcut discussed in your text and supported by Automat is to store one character in a “variable”, allowing it’s retrieval later. For example, a transition with an input labelled “a,b}w” means “accept input ‘a’ or ‘b’, storing whichever you actually see in the variable . Any later transition that mentions ”w\" is then assumed to be referring to the variable.\n\nHow would you use that to simplify our “delete-the-1st-a” TM?\n\nWhat is the function (over the alphabet $\\{a,b,c\\}$) computed by this TM?\n• It works from the middle out.\n• The language is over ${a,b,c}$. But this also uses tape symbols ${A, B, C}$ to denote the “abc” character that have already been “processed”.\n• At the end of processing, states 5 and 6 rewrite all of the upper-case characters back to their lower-case equivalent.\n\nThese TMs illustrate some more common programming tricks common to TMs:\n• Shifting data to one side or the other, often to make room to insert a symbol into the middle.\n• Using special symbols, that may or may not be part of the language’s alphabet, as markers to help the TM navigate.\n\nEarlier we saw ways to use TMs to accept languages that we had seen with earlier, less powerful automata.\n\nNext, we can consider problems that could not be solved using the automata we have had before.\n\nDesign a TM to recognize the language of strings of the form $0^n1^n2^n$.\n\nConsider the problem of designing a TM to compare two strings over $\\{a,b\\}$ to see if they are equal.\n\nAll input to the TM must be on the tape, so we could choose to separate the two strings by a blank, e.g.,\n\nI’m going to choose the latter.\n\nAnother way to view this machine is to say that it recognizes strings over of the form\n\nwhich is definitely not a CFL.\n\nWe can get an even simpler (IMO) TM by using multiple tapes.\n\nSolve the same problem using a multi-tape TM.\n\nThis isn’t quite as simple as we might hope. Our convention is that all input needs to be supplied on the first tape, and so the input will still be presented in the form: The procedure in this case is:\n• Copy the first string onto the second tape. At the end of this procedure, the head of the first tape will be pointing at ‘c’, the head of the second tape just past the end of the copied first string.\n• Leave the 2nd tape head where it is, and move the first tape head to the right until we hit the end of the second string.\n• Now start moving to the left, comparing corresponding characters in the two strings. If they match we keep going. If they don’t match, we fail. If we reach the beginning of both strings with all matching, we accept. Here is the TM for this new procedure. Whether this is simpler or not than the single-tape approach may be, I suppose, open to debate. After all, trying to envision two tapes is unfamiliar and adds a bit of complication of its own. However, what cannot be denied is that the multi-tape version is faster. Because of the need to repeatedly traverse back and forthe across the entire input, the single-tape machine runs in $O(n^2)$ time (where $n$ is the length of the longer of the two strings). This multi-tape TM makes exactly two passes over the input, and so does the same thing in $O(n)$ time.\n\nAs computer scientists, we are familiar with the fact that numbers and strings of symbols can be encoded in binary (base-2).\n\nArithmetic in Turing machines is often conducted in an even simpler form: unary encoding, where a single symbol is used (either ‘0’ or ‘1’) and the value of the number is indicated by the length of the string. For example, the decimal number 4 is 100 in binary, and 1111 in unary. The decimal number 6 is 110 in binary, but 111111 in unary.\n\nUnary encoding is often employed for TMs simply because it makes many elementary arithmetic operations nearly trivial\n\nSuppose that a tape contains an integer $k$ in unary form (i.e., a string of 1’s, where the value of the integer is the length of the string. Construct a TM to replace its input by the value of the function $f(k) = k+1$.\n\nSuppose that a tape contains pair of integers $m, k$ in unary form separated by a single ‘x’. Construct a TM to replace its input by the value of the function $f(m,k) = m+k$.\n\nThe convenience of unary does not mean that we can’t do binary arithmetic in TMs.\n\nSuppose that we have two binary integers on a tape, separated by a symbol ‘c’. Design a TM to compute the sum of those two integers.\n\nThis will be easiest to do with a multi-tape TM. As in our previous multi-tape example, we will start by copying the first string/number from tape 1 to tape 2, then position the heads of both tapes on the right-most symbol of each string.\n\nAfter that, we can enact a binary addition, working right to left, in much the way that you would do manually.\n\nFor example, given the input tape:\n\nwe will split the two inputs onto two tapes like this.\n\nWe will compute the sum and put it onto the first tape:\n\nThis is the most complicated TM we have attempted so far, so let’s take it in stages. First, let’s copy the 1st number onto the 2nd tape: Let’s take this in stages: Start by copying the 1st number to tape 2. Run this on to confirm that it works. Next, let’s shift the tape head on tape 1 to the end of the 2nd number, and then position both tape heads on the right-most digits. Run this on , using single-stepping to watch the movement of the tape heads, to confirm that it works. Now we are ready to start actually doing addition. If we see two zeros, we write a zero onto the answer in tape 1. If we see a one and a zero, we write a one onto the answer in tape 1. Either way, we then shift the tape heads left to the next higher pair of digits. Of course, that leaves the case of seeing a pair of ones. For that, we would write a ‘0’ and “carry the one”. to see how the single digits are handled. The idea of the “carry” reminds us that our prior rules (e.g., $1+0 \\rightarrow 1$) only apply when there is no carry. So we will use state $q_2$ to add digits with no carry, and a different state, $q_3$, will enact the rules for addition when we have a carry. Here we have added the “with carry” addition rules, including the case of adding $0+0$ with a carry, which gives us a sum of $1$ but returns us to the non-carry state $q_2$. Now it’s time to start thinking about how to end this.\n• If we are in state 2 (no carry), and looking at two empty cells, then we have finished adding the numbers and can stop.\n• If we are in state 3 (carry), and looking at two empty cells, then we would need to write the 1 from the carry onto the left of the answer.\n• If we are in either of those states and see only one empty cell, that means that one of our two numbers has more digits than the other. We would treat those empty cells as if they contained a zero. and convince yourself that we really have implemented binary addition."
    },
    {
        "link": "https://geeksforgeeks.org/turing-machine-in-toc",
        "document": "Turing Machines (TM) play a crucial role in the Theory of Computation (TOC). They are abstract computational devices used to explore the limits of what can be computed. Turing Machines help prove that certain languages and problems have no algorithmic solution. Their simplicity makes them an effective tool for studying computational theory, yet they are as powerful as modern computers. Turing Machine was invented by Alan Turing in 1936 and it is used to accept Recursive Enumerable Languages (generated by Type-0 Grammar).\n• None A Turing Machine consists of an infinite tape, a read/write head, and a set of rules that determine how it reads, writes, and moves on the tape. Despite its simplicity, a TM can simulate any real-world computation, making it as powerful as modern computers but with infinite memory.\n• None The Turing machine’s behavior is determined by a finite state machine, which consists of a finite set of states, a transition function that defines the actions to be taken based on the current state and the symbol being read, and a set of start and accept states.\n• None The TM begins in the start state and performs the actions specified by the transition function until it reaches an accept or reject state. If it reaches an accept state, the computation is considered successful; if it reaches a reject state, the computation is considered unsuccessful.\n• None In the context of automata theory and the theory of computation, Turing machines are used to study the properties of algorithms and to determine what problems can and cannot be solved by computers. They provide a way to model the behavior of algorithms and to analyze their computational complexity, which is the amount of time and memory they require to solve a problem.\n\nTuring machines are an important tool for studying the limits of computation and for understanding the foundations of computer science. They provide a simple yet powerful model of computation that has been widely used in research and has had a profound impact on our understanding of algorithms and computation.\n\nWhile one might consider using programming languages like C to study computation, Turing Machines are preferred because:\n• None They are simpler to analyze.\n• None They possess infinite memory, making them even more powerful than real-world computers.\n\nA Turing Machine consists of a tape of infinite length on which read and writes operation can be performed. The tape consists of infinite cells on which each cell either contains input symbol or a special symbol called blank. It also consists of a head pointer which points to cell currently being read and it can move in both directions.\n\nWe construct a Turing Machine (TM) for the language L = {0ⁿ1ⁿ | n ≥ 1}, which accepts strings of equal 0s followed by equal 1s.\n\nLet us see how this turing machine works for 0011. Initially head points to 0 which is underlined and state is q0 as:\n\nThe move will be δ(q0, 0) = (q1, X, R). It means, it will go to state q1, replace 0 by X and head will move to right as:\n\nThe move will be δ(q1, 0) = (q1, 0, R) which means it will remain in same state and without changing any symbol, it will move to right as:\n\nThe move will be δ(q1, 1) = (q2, Y, L) which means it will move to q2 state and changing 1 to Y, it will move to left as:\n\nWorking on it in the same way, the machine will reach state q3 and head will point to B as shown:\n\nUsing move δ(q3, B) = halt, it will stop and accepted.\n• None In non-deterministic turing machine, there can be more than one possible move for a given state and tape symbol, but non-deterministic TM does not add any power.\n• None Every non-deterministic TM can be converted into deterministic TM.\n• None In multi-tape turing machine, there can be more than one tape and corresponding head pointers, but it does not add any power to turing machine.\n• None Every multi-tape TM can be converted into single tape TM.\n\nQuestion: A single tape Turing Machine M has two states q0 and q1, of which q0 is the starting state. The tape alphabet of M is {0, 1, B} and its input alphabet is {0, 1}. The symbol B is the blank symbol used to indicate end of an input string. The transition function of M is described in the following table.\n\nThe table is interpreted as illustrated below. The entry (q1, 1, R) in row q0 and column 1 signifies that if M is in state q0 and reads 1 on the current tape square, then it writes 1 on the same tape square, moves its tape head one position to the right and transitions to state q1. Which of the following statements is true about M?\n• None M does not halt on any string in (0 + 1)+\n• None M does not halt on any string in (00 + 1)*\n• None M halts on all string ending in a 0\n• None M halts on all string ending in a 1\n\nSolution: Let us see whether machine halts on string ‘1’. Initially state will be q0, head will point to 1 as:\n\nUsing δ(q0, 1) = (q1, 1, R), it will move to state q1 and head will move to right as:\n\nUsing δ(q1, B) = (q0, B, L), it will move to state q0 and head will move to left as:\n\nIt will run in the same way again and again and not halt.\n\nOption D says M halts on all string ending with 1, but it is not halting for 1. So, option D is incorrect.\n\nLet us see whether machine halts on string ‘0’. Initially state will be q0, head will point to 1 as:\n\nUsing δ(q0, 0) = (q1, 1, R), it will move to state q1 and head will move to right as:\n\nUsing δ(q1,B)=(q0,B,L), it will move to state q0 and head will move to left as:\n\nIt will run in the same way again and again and not halt.\n\nOption C says M halts on all string ending with 0, but it is not halting for 0. So, option C is incorrect.\n\nOption B says that TM does not halt for any string (00 + 1)*. But NULL string is a part of (00 + 1)* and TM will halt for NULL string. For NULL string, tape will be,\n\nUsing δ(q0, B) = halt, TM will halt. As TM is halting for NULL, this option is also incorrect. \n\nSo, option (A) is correct.\n\nWhat is the purpose of Multi-Tape Turing Machines?\n\nWhat is the Halting Problem?\n\nWhat are some limitations of Turing Machines?"
    },
    {
        "link": "https://web.stanford.edu/class/archive/cs/cs103/cs103.1176/lectures/21/Small21.pdf",
        "document": ""
    },
    {
        "link": "https://introcs.cs.princeton.edu/java/52turing",
        "document": "The Turing machine is one of the most beautiful and intriguing intellectual discoveries of the 20th century. Turing machine is a simple and useful abstract model of computation (and digital computers) that is general enough to embody any computer program. It forms the foundation of theoretical computer science. Because of its simple description and behavior, it is amenable to mathematical analysis. This analysis has led to a deeper understanding of digital computers and computation, including the revelation that there are some computational problems that cannot be solved on computers at all, no matter how fast the processor, or how much memory is available.\n\nTuring machine simulator. This is a graphical Turing machine simulator that was written in Java by Tom Ventimiglia under the supervision of Bob Sedgewick and Kevin Wayne.\n• Executable jar (turing.jar). To execute, type from the command line.\n• OS X app (Turing.zip). To execute, double click Turing.zip file to unzip. Double click Turing.app to launch.\n\nYou are welcome to inspect and modify the source code for your own use.\n\nComponents. Alan Turing sought to describe the most primitive model of a mechanical device that had the same basic capabilities as a human \"computer.\" In his epoch making 1936 paper, Alan Turing introduced an abstract machine, which would later come to be known as a Turing machine. The machine consists of the following components:\n• The ticker-tape stores the input, the intermediate results, and the output. The tape is one arbitrarily long strip, divided into cells. Each cell stores one of a finite alphabet of symbols. In the example below, we use a 4 character alphabet consisting of 0, 1, A, X, and #.\n• The tape head of the Turing machine scans the tape one cell at a time. We refer to the cell being scanned as the active cell and the symbol it contains as the input symbol. At each time step, the tape head reads the input symbol, and leaves it either unchanged or overwrites it with a new symbol. At the end of each time step, the tape head moves one position to the left or right. We highlight the active cell in yellow. In the example below, the is replaced with an and the tape head moves one cell to the left.\n• The control unit is the analog of the CPU in modern day microprocessors. It consists of a state transition diagram, which is a finite table of instructions that specifies exactly what action the machine takes at each step. Each state represents one of the possible configurations of the machine. Depending on its current state and input symbol, the Turing machine overwrites the input symbol with a new symbol and moves to a new state. Each transition connects one state, say s, to another state, say t, and is labeled with two symbols, say A and X: this means that if the Turing machine is in state s and the input symbol is A, then it overwrite the A with an X and transitions to state t. Each state is labeled with one of five designations: L (left), R (right), Y (yes), N (no), or H (halt). Upon entering a state, the Turing machine either moves its tape head or halts according to the state's designation. Below is an illustration of the state transition diagram for a machine with four states.\n\nExecution. Initially the Turing machine starts in one distinguished state called the start state, and the tape head points to one distinguished cell called the start cell. There is at most one possible transition corresponding to each combination of state and input symbol; thus, the actions of the machine are completely determined in advance. (If there is no possible transition from a state with some input symbol, then the Turing machine remains in the same state and does not overwrite the input symbol.) Each step in a Turing machine proceeds as follows:\n• Read the input symbol from the active cell.\n• Look up the transition rule associated with the current state and input symbol.\n• Overwrite the input symbol with the new symbol.\n• Change the current state according to the transition rule.\n• Shift the tape head one cell to the left or right, according to the new state's designation.\n\nThese steps are repeated until the current state is labeled H for halt, Y (in which case the machine answers yes) or N (in which case the machine answers no). It is possible that the machine runs forever without ever reaching one of these terminating states.\n\nComputation must allow repetitive actions - do action A over and over until a certain condition is met. This amounts to staying in a state (and moving the tape head left or right) until a certain condition is met. Computation must also allow adaptive actions - if a certain condition is met, do action A; otherwise do action B. This is captured by state transitions according to the contents of the tape head at a particular location.\n\nAn example: unary to binary conversion. We consider the 4 state Turing machine illustrated below. The current state and input symbol are highlighted in yellow. We trace its execution.\n\nSince the input symbol is A, the Turing machine follows the appropriate transition arrow leaving the current state - the one labeled A : X. The Turing machine overwrites the input symbol with an X, changes state to the bottom right state, and moves the tape head one position to the left (since the new state is labeled with L). The illustration below shows the Turing machine at the end of this first step.\n\nSince the input symbol is now #, the Turing machine follows the appropriate transition arrow leaving the current state -- the one labeled # : 1. This overwrites the current cell with a 1, changes the state back to the bottom left state, and moves the tape head one position to the right (since the new state is labeled with R).\n\nHere are the contents of the tape after the next several steps.\n\nOnce all of the As are overwritten with Xs, the Turing machine erases all of the Xs (overwriting them with #s).\n\nWhat it does and why it works. The Turing machine described above converts from unary to binary. That is, if the input consists of n consecutive A's, then the Turing machine prints the number n in binary to the left of sequence of A's (and overwrites the A's with X's). In the example above, the input consists of 6 A's and the Turing machine writes the binary number 110 to the tape.\n\nTo describe how this is accomplished, we first review an algorithm for incrementing a binary integer by 1: scan the bits from right to left, changing 1's to 0's until you see a 0. Then change the 0 to a 1.\n\nThe Turing machine repeatedly knocks off one A at a time and increments the binary number. Our Turing machine mimics this strategy. The initial state seeks out the next A, overwrites it with an X, and then transitions to the Increment state. The Increment state increments the binary integer by one (leaving the X's alone, changing 1's to 0's, until seeing a 0 or #, which it changes to a 1), and then transitions back to the Initial state. When all of the A's are overwritten with X's, the Cleanup state replaces all of the X's with #'s, and the transitions to the Halt state.\n• The tape. Program is an ADT that represents an unbounded Turing machine tape. It supports the following operations: move tape head left, move tape head right, read the symbol in the current cell, and write a symbol to the current cell. To implement it, we use two stacks (one to store all of the symbols to the left of the tape head, and one to the right). To print out the contents of the tape, we print out the reverse of the first stack, the current element, then the second stack.\n• The states. Each state has a name and a type (halt, left, right, accept, or reject).\n• The transitions. Each transition has the name of the initial state, the name of the final state, and the symbol to be written to the tape.\n• The Turing machine. We implement a Turing machine as a tape, a symbol table of states, and a symbol table of transitions.\n\nWe encapsulate each of the main Turing machine components (tape, transition, control) using good OOP principles.\n\nNon-terminating Turing machines. From a theoretical standpoint, we are primarily concerned with machines that perform finite computations and then halt. However, many practical applications involve programs that are designed never to terminate (operating system, air traffic control system, nuclear reactor control system) or produce an infinite amount of output (web browser, program that computes the digits of π = 3.1415...). The Turing machine model of computation extends to handle such non-terminating situations as well.\n• What does the following Turing machine do when started with the given tape ...\n• Equal number of a's and b's.\n• Unary-to-binary. How many steps does the 3-state unary-to-binary Turing machine make to convert N to binary? Answer: proportional to N^2.\n• Unary-to-binary. Design a 6-state unary-to-binary Turing machine that converts the unary number N to binary in time proportional to N log N. Hint: cross out every other A. If the number of A's is odd, write a 1; otherwise write a 0. Repeat with the uncrossed out A's remaining.\n• Swap two cells on a Turing machine. Use the state to encode the temporary symbol.\n• Hex-to-binary. Design a Turing machine that converts from hexadecimal to binary.\n• Comparator. Create a Turing machine that takes as input two binary integers, separate by a # character, and accepts the input if the first string is strictly less than the second. How many steps does the Turing machine in the previous question take to compare two N-bit integers? (Each step is one move of the tape head.)\n• Efficient comparator. Create a comparator that runs in time polynomial in N.\n• Bitwise OR. Create a Turing machine that computes the bitwise OR of its two binary inputs of length N.\n• Doubling. Write a Turing machine that transform an input consisting of k consecutive 1's to an input that consists of 2k consecutive 1's. (unary multiplication by 2) Hint: write two 1's on the left, and delete one 1 on the right.\n• Copying. Write a Turing machine that transform an input consisting of 0's and 1's instead two copies of the original input, separated by the symbol #.\n• Langtons Ant. Write a program that simulates a two dimensional Turing machine known as Langton's Ant, and animate the results using Turtle graphics.\n• Turmites. Create some other two dimensional Turing machines or Turmites that produce interesting patterns.\n• Turing tape. Write a program Tape.java that implement a one-dimensional Turing tape. The tape consists of a sequence of cells, each of which stores an integer (that is initialized to 0). At any instant, there is a tape head which points to one of the cells. Support the following interface methods: to move the tape head one cell to the left, to move the tape head one cell to the right, to return the contents of the active cell, and to change the contents of the active cell to . Hint: use an for the active cell, and two stacks for the left and right parts of the tape.\n• Turing machine simulator. Write a program TuringMachine.java that simulates a Turing machine. Design your program as follows: Tape.java, State.java, Transition.java.\n• Collatz Turing machine. Design a Turing machine that takes as input the binary representation of a binary integer and repeatedly divides it by 2 (if even) or multiplies by 3 and adds 1 (if odd) until it equals 1. Famous open conjecture that this machine will terminates for inputs."
    },
    {
        "link": "http://multiwingspan.co.uk/a23.php?page=turing",
        "document": "Turing machines are abstract computational devices first proposed by Alan Turing in 1937. A Turing machine is a theoretical device that manipulates symbols on a strip of imaginary tape. It is an abstract representation of a computing machine that was originally used to explore the limitations and capabilities of computing machines in general.\n\nA Turing machine is an automaton consisting of,\n\nA Tape - the tape is divided into sections or cells, each one capable of storing a symbol. The tape has a left end but can be extended infinitely to the right. Cells without symbols written on them are blank and will contain the blank cell symbol, . The tape can have symbols read from it and written to it.\n\nA Read-Write Head - the head can read symbols from and write them to the tape. The head can move the tape one cell to the left or right at a time. In diagrams, the head is often more likely to move than the tape -- the effect is the same.\n\nA (Finite) Table Of Instructions - the instructions are the transition function for this machine. Given the current state of the machine, and the symbol currently under the read-write head, the table must show what the machine must do from the following list,\n• Write a symbol or erase (write a blank) a symbol on the tape\n• Move the head one place to the left or right, or stay in the current position\n• Assume the new state - this can be the same state as before\n\nA Set Of Possible States - this set would include the current state of the machine, other states that the machine can assume and must include a set of halting states (accepting states).\n\nThe following example is based on the first Turing machine that Alan Turing proposed. The machine has the task of writing 1 0 1 0 1 0... on the tape. The 1s and 0s alternate with an empty cell in between them. We can describe that using the following state transition diagram. Note, there is no halting state in this example - it will carry on writing in this pattern forever,\n\nThere are 4 states for the machine. State A is the starting point. In State A, the machine reads from the tape, it should read an empty cell. It writes a 1 in that cell, moves one cell to the right and assumes state B. In State B, a blank cell is read from the tape, a blank cell is written back to the tape, the tape moves one to the right and assumes state C. And so on,\n\nThe table of instructions for this Turing Machine is as follows,\n\nWe could write the transition rules for this machine as follows,\n\nThe delta symbol represents the transition function. It is followed by the current state and input symbol. To the right of the equals sign is the next state, symbol to write and direction in which to move the tape.\n\nThis conceptual model of a computing machine is as basic as they get. You cannot divide these operations any futher. This means that any computing machine can be reduced to an equivalent Turing machine. The Turing machine, therefore, can describe the operation of any computing machine. It does this independently of any hardware.\n\nTuring machines are particularly useful for exploring what is and is not computable.\n\nThe busy beaver function is defined as the largest number of 1s that can be written to a tape by a Turing machine with n states that halts at some point.\n\nThere is no algorithm that can calculate whether or not a given Turing machine will halt (see next section for proof).\n\nIf you make a one-state Turing machine - one state leading to a stop state which is not counted as part of the busy beaver function, you get exactly one 1 on the tape. This outcome is described symbolically as B(1) = 1. The busy beaver number for a 1-state machine is 1. A two-state Turing machine is described in the diagram below,\n\nAssuming that our tape is padded out with 0s or blank symbols, 'executing' this machine would have the following effect,\n\nA two-state busy beaver machine can write four 1s onto the tape, B(2) = 4.\n\nA four-state busy beaver leaves 13 marks on the tape. A five state busy beaver produces at least 4098 marks. B(6) is at least 1.29 x 10 865. The numbers become too large to work with from this point onwards.\n\nWhen Alan Turing first proposed the idea of the Universal Turing Machine (UTM), it was quite a revelation. The idea is that you have a machine which we will call U. On its tape, it has has the transition rules for another machine which we will call M. It also has on the tape the input data for machine M. Turing's assertion was that machine U would then be able to compute the exact same sequence as M. Machine U simulates the behaviour of other Turing machines when given their transition rules and the input data.\n\nU will probably not execute as quickly as M. By 1966, it was discovered that U would only need be slower than M by a logarithmic factor.\n\nThis is similar to the way that an interpreter works on a modern computer. When you point your browser at a PHP web page, a program on the server interprets the instructions in the script, producing the output specified in the program. The web page you see is the result of this interpretation of the instructions written in the script.\n\nThe UTM concept is quite powerful when you stop taking for granted the advances in technology that have occurred since that time. One implication is that programs and data are really the same thing - the tape in a UTM contains both the program and the data as a series of symbols. This links very strongly with the stored program concept that we looked at in Comp 2. We see this principle of universality at work with the computers that we use. New applications can be written to enable all sorts of different tasks to be performed by the same machine."
    },
    {
        "link": "https://sciencedirect.com/topics/mathematics/turing-machine",
        "document": ""
    }
]