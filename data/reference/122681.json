[
    {
        "link": "https://legacy.reactjs.org/docs/components-and-props.html",
        "document": "Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a detailed component API reference here.\n\nConceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.\n\nThe simplest way to define a component is to write a JavaScript function:\n\nThis function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “function components” because they are literally JavaScript functions.\n\nYou can also use an ES6 class to define a component:\n\nThe above two components are equivalent from React’s point of view.\n\nFunction and Class components both have some additional features that we will discuss in the next sections.\n\nPreviously, we only encountered React elements that represent DOM tags:\n\nHowever, elements can also represent user-defined components:\n\nWhen React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object “props”.\n\nFor example, this code renders “Hello, Sara” on the page:\n\nTry it on CodePen\n\nLet’s recap what happens in this example:\n• We call with the element.\n• React calls the component with as the props.\n• Our component returns a element as the result.\n\nComponents can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.\n\nFor example, we can create an component that renders many times:\n\nTry it on CodePen\n\nTypically, new React apps have a single component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like and gradually work your way to the top of the view hierarchy.\n\nDon’t be afraid to split components into smaller components.\n\nFor example, consider this component:\n\nTry it on CodePen\n\nIt accepts (an object), (a string), and (a date) as props, and describes a comment on a social media website.\n\nThis component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.\n\nFirst, we will extract :\n\nThe doesn’t need to know that it is being rendered inside a . This is why we have given its prop a more generic name: rather than .\n\nWe recommend naming props from the component’s own point of view rather than the context in which it is being used.\n\nWe can now simplify a tiny bit:\n\nNext, we will extract a component that renders an next to the user’s name:\n\nThis lets us simplify even further:\n\nTry it on CodePen\n\nExtracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times ( , , ), or is complex enough on its own ( , , ), it is a good candidate to be extracted to a separate component.\n\nWhether you declare a component as a function or a class, it must never modify its own props. Consider this function:\n\nSuch functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs.\n\nIn contrast, this function is impure because it changes its own input:\n\nReact is pretty flexible but it has a single strict rule:\n\nAll React components must act like pure functions with respect to their props.\n\nOf course, application UIs are dynamic and change over time. In the next section, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule."
    },
    {
        "link": "https://react.dev/reference/react/Component",
        "document": "\n• Alternatives\n• Migrating a component with state from a class to a function\n• Migrating a component with lifecycle methods from a class to a function\n• Migrating a component with context from a class to a function\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nOnly the method is required, other methods are optional.\n\nSee more examples below.\n\nThe context of a class component is available as . It is only available if you specify which context you want to receive using .\n\nA class component can only read one context at a time.\n\nThe props passed to a class component are available as .\n\nThe state of a class component is available as . The field must be an object. Do not mutate the state directly. If you wish to change the state, call with the new state.\n\nThe constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:\n\nA constructor should not contain any side effects or subscriptions.\n\nshould not return anything.\n• Do not run any side effects or subscriptions in the constructor. Instead, use for that.\n• Inside a constructor, you need to call before any other statement. If you don’t do that, will be while the constructor runs, which can be confusing and cause bugs.\n• Constructor is the only place where you can assign directly. In all other methods, you need to use instead. Do not call in the constructor.\n• When you use server rendering, the constructor will run on the server too, followed by the method. However, lifecycle methods like or will not run on the server.\n• When Strict Mode is on, React will call twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the .\n\nIf you define , React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\n\nTypically, it is used together with which lets you update state in response to an error and display an error message to the user. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n• : An object containing additional information about the error. Its field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n\nshould not return anything.\n• In the past, it was common to call inside in order to update the UI and display the fallback error message. This is deprecated in favor of defining .\n• Production and development builds of React slightly differ in the way handles errors. In development, the errors will bubble up to , which means that any or will intercept the errors that have been caught by . In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nIf you define the method, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement , you usually need to implement other lifecycle methods to avoid bugs. For example, if reads some state or props, you also have to implement to handle their changes, and to clean up whatever was doing.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with and :\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n• : If you implemented , will contain the value you returned from that method. Otherwise, it will be .\n\nshould not return anything.\n• will not get called if is defined and returns .\n• The logic inside should usually be wrapped in conditions comparing with , and with . Otherwise, there’s a risk of creating infinite loops.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside should “mirror” the logic inside . For example, if sets up a subscription, should clean up that subscription. If the cleanup logic in your reads some props or state, you will usually also need to implement to clean up resources (such as subscriptions) corresponding to the old props and state.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n\nUsually, this is not necessary. If your component’s method only reads from , , or , it will re-render automatically when you call inside your component or one of its parents. However, if your component’s method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what lets you do.\n\nTry to avoid all uses of and only read from and in .\n• optional If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• If you call , React will re-render without calling .\n\nIf you implement , React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\nIn the above example, it is important to read the property directly in . It is not safe to read it in , , or because there is a potential time gap between these methods getting called and React updating the DOM.\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n\nYou should return a snapshot value of any type that you’d like, or . The value you returned will be passed as the third argument to .\n• will not get called if is defined and returns .\n\nThe method is the only required method in a class component.\n\nThe method should specify what you want to appear on the screen, for example:\n\nReact may call at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the method should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the method can read , , and .\n\nYou should write the method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like .\n\ndoes not take any parameters.\n\ncan return any valid React node. This includes React elements such as , strings, numbers, portals, empty nodes ( , , , and ), and arrays of React nodes.\n• should be written as a pure function of props, state, and context. It should not have side effects.\n• will not get called if is defined and returns .\n• When Strict Mode is on, React will call twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the method.\n• There is no one-to-one correspondence between the call and the subsequent or call. Some of the call results may be discarded by React when it’s beneficial.\n\nCall to update the state of your React component.\n\nenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.\n\nYou can also pass a function to . It lets you update state based on the previous state:\n\nYou don’t have to do this, but it’s handy if you want to update state multiple times during the same event.\n• : Either an object or a function.\n• If you pass an object as , it will be shallowly merged into .\n• If you pass a function as , it will be treated as an updater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into . React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n• optional : If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• Think of as a request rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in , but this may hurt performance.\n• does not update immediately. This makes reading right after calling a potential pitfall. Instead, use or the setState argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to as described above.\n\nIf you define , React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped.\n\nReact calls before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n• : The next context that the component is about to render with. Compare to to determine what changed. Only available if you specify .\n\nReturn if you want the component to re-render. That’s the default behavior.\n\nReturn to tell React that re-rendering can be skipped.\n• This method only exists as a performance optimization. If your component breaks without it, fix that first.\n• Consider using instead of writing by hand. shallowly compares props and state, and reduces the chance that you’ll skip a necessary update.\n• We do not recommend doing deep equality checks or using in . It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n• Returning does not prevent child components from re-rendering when their state changes.\n• Returning does not guarantee that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n\nIf you define , React will call it immediately after the . It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• To initialize state, declare as a class field or set inside the .\n• If you need to run a side effect or set up a subscription, move that logic to instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\ndoes not take any parameters.\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will get mounted if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go into .\n• is the only lifecycle method that runs during server rendering. For all practical purposes, it is identical to , so you should use the for this type of logic instead.\n\nIf you define , React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to instead.\n• If you need to avoid re-computing some data only when a prop changes, use a memoization helper instead.\n• If you need to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\n• If you need to “adjust” some state when a prop changes, check whether you can compute all the necessary information from props alone during rendering. If you can’t, use instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to receive from its parent component. Compare to to determine what changed.\n• : The next context that the component is about to receive from the closest provider. Compare to to determine what changed. Only available if you specify .\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will receive those props if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props than the last time. You need to compare and yourself to check if something changed.\n• React doesn’t call with initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, calling doesn’t generally trigger inside the same component.\n\nIf you define , React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to instead.\n• If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in later, read it inside instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n\nshould not return anything.\n• will not get called if is defined and returns .\n• will not get called if the component implements or .\n• It’s not supported to call (or any method that leads to being called, like dispatching a Redux action) during .\n• Despite its naming, does not guarantee that the component will update if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props or state than the last time. You need to compare with and with yourself to check if something changed.\n• React doesn’t call with initial props and state during mounting.\n\nIf you want to read from your class component, you must specify which context it needs to read. The context you specify as the must be a value previously created by .\n\nYou can define to set the default props for the class. They will be used for and missing props, but not for props.\n\nFor example, here is how you define that the prop should default to :\n\nIf the prop is not provided or is , it will be set by default to :\n\nIf you define , React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with which lets you send the error report to some analytics service. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n\nshould return the state telling the component to display the error message.\n• should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement .\n\nIf you define , React will call it right before calling , both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, this component resets the state when the prop changes:\n\nNote that this pattern requires you to keep a previous value of the prop (like ) in state (like ).\n• : The next props that the component is about to render with.\n• : The next state that the component is about to render with.\n\nreturn an object to update the state, or to update nothing.\n• This method is fired on every render, regardless of the cause. This is different from , which only fires when the parent causes a re-render and not as a result of a local .\n• This method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nReact will call your method whenever it needs to figure out what to display on the screen. Usually, you will return some JSX from it. Your method should be a pure function: it should only calculate the JSX.\n\nSimilarly to function components, a class component can receive information by props from its parent component. However, the syntax for reading props is different. For example, if the parent component renders , then you can read the prop from , like :"
    },
    {
        "link": "https://react.dev/learn/passing-props-to-a-component",
        "document": "React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.\n• How to pass props to a component\n• How to read props from a component\n• How to specify default values for props\n• How to pass some JSX to a component Props are the information that you pass to a JSX tag. For example, , , , , and are some of the props you can pass to an :\n\nThe props you can pass to an tag are predefined (ReactDOM conforms to the HTML standard). But you can pass any props to your own components, such as , to customize them. Here’s how! In this code, the component isn’t passing any props to its child component, : You can give some props in two steps. First, pass some props to . For example, let’s pass two props: (an object), and (a number): If double curly braces after confuse you, recall they’re merely an object inside the JSX curlies. Now you can read these props inside the component. You can read these props by listing their names separated by the commas inside and directly after . This lets you use them inside the code, like you would with a variable. Add some logic to that uses the and props for rendering, and you’re done. Now you can configure to render in many different ways with different props. Try tweaking the values!\n\nProps let you think about parent and child components independently. For example, you can change the or the props inside without having to think about how uses them. Similarly, you can change how the uses these props, without looking at the . You can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, props are the only argument to your component! React component functions accept a single argument, a object: Usually you don’t need the whole object itself, so you destructure it into individual props. Don’t miss the pair of and curlies inside of and when declaring props: This syntax is called “destructuring” and is equivalent to reading properties from a function parameter: Specifying a default value for a prop If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting and the default value right after the parameter: Now, if is rendered with no prop, the will be set to . The default value is only used if the prop is missing or if you pass . But if you pass or , the default value will not be used. Sometimes, passing props gets very repetitive: There’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how this does with . Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax: This forwards all of ’s props to the without listing each of their names. Use spread syntax with restraint. If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next! It is common to nest built-in browser tags: Sometimes you’ll want to nest your own components the same way: When you nest content inside a JSX tag, the parent component will receive that content in a prop called . For example, the component below will receive a prop set to and render it in a wrapper div:\n\nTry replacing the inside with some text to see how the component can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places. You can think of a component with a prop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use the prop for visual wrappers: panels, grids, etc.\n\nThis example illustrates that a component may receive different props over time. Props are not always static! Here, the prop changes every second, and the prop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning. However, props are immutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it different props—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them. Don’t try to “change props”. When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about in State: A Component’s Memory.\n• To pass props, add them to the JSX, just like you would with HTML attributes.\n• To read props, use the destructuring syntax.\n• You can specify a default value like , which is used for missing and props.\n• You can forward all props with JSX spread syntax, but don’t overuse it!\n• Nested JSX like will appear as component’s prop.\n• Props are read-only snapshots in time: every render receives a new version of props.\n• You can’t change props. When you need interactivity, you’ll need to set state."
    },
    {
        "link": "https://geeksforgeeks.org/reactjs-functional-components",
        "document": "In ReactJS, functional components are a core part of building user interfaces. They are simple, lightweight, and powerful tools for rendering UI and handling logic. Functional components can accept props as input and return JSX that describes what the component should render.\n\nReactJS functional components are JavaScript functions that return a JSX element, which is a template used to define the component’s structure. JSX looks similar to HTML, but it has a special syntax that lets it be converted into JavaScript code.\n• Stateless (before hooks) : Originally, functional components were stateless and used only for rendering UI based on props.\n• Simpler Syntax: They are defined as JavaScript functions, leading to cleaner and more readable code.\n• No, this keyword: Unlike class components, functional components do not have a this context.\n• Hooks: With hooks, functional components can manage state and side effects, making them just as powerful as class components.\n\nIn the example above:\n• None MyComp is a functional component that takes props as an argument.\n• None It returns a JSX element (<div>Hello, {props.name}!</div>), which will be rendered to the screen.\n\nWhen a functional component receives input and is rendered, React uses props and updates the virtual DOM to ensure the UI reflects the current state.\n\nHere’s a breakdown of how this process works:\n• Props: Functional components receive input data through props, which are objects containing key-value pairs.\n• Processing Props: After receiving props, the component processes them and returns a JSX element that defines the component’s structure and content.\n• Virtual DOM: When the component is rendered, React creates a virtual DOM tree that represents the current state of the application.\n• Re-rendering: If the component’s props or state change, React updates the virtual DOM tree accordingly and triggers the component to re-render.\n• Simplicity: Functional components are simpler and easier to read than class components, making them ideal for small to medium-sized projects.\n• Performance: Functional components are faster than class components because they don’t use the this keyword, which can slow down rendering.\n• Testability: Functional components are easier to test because they are stateless and don’t rely on lifecycle methods.\n• Reusability: Functional components can be reused across multiple projects, making them a great choice for building component libraries.\n\nWhen to Use ReactJS Functional Components\n\nFunctional components should be used whenever possible because they are simpler, easier to test, and more performant than class components. However, there are a few cases where functional components may not be suitable:\n• Stateful components: Functional components cannot hold state on their own. Therefore, if you need to maintain state within your component, you may need to use a class component.\n• Lifecycle methods: If you need to use lifecycle methods such as componentDidMount, componentDidUpdate, or componentWillUnmount, you will need to use a class component.\n\nHow to Pass Props to a ReactJS Functional Component\n\nProps are used to pass data from a parent component to a child component. Props are read-only and allow you to make a component dynamic by passing different values into it.\n• None In the App.js component, we are passing a name prop to the Greeting component.\n• None In Greeting.js, the name prop is accessed using props.name, and it is used to dynamically display the greeting message.\n\nAre functional components better than class components?"
    },
    {
        "link": "https://reactnative.dev/docs/intro-react",
        "document": "React Native runs on React, a popular open source library for building user interfaces with JavaScript. To make the most of React Native, it helps to understand React itself. This section can get you started or can serve as a refresher course.\n\nWe’re going to cover the core concepts behind React:\n\nIf you want to dig deeper, we encourage you to check out React’s official documentation.\n\nThe rest of this introduction to React uses cats in its examples: friendly, approachable creatures that need names and a cafe to work in. Here is your very first Cat component:\n\nHere is how you do it: To define your component, first use JavaScript’s to import React and React Native’s Core Component:\n\nYou can think of components as blueprints. Whatever a function component returns is rendered as a React element. React elements let you describe what you want to see on the screen.\n\nHere the component will render a element:\n\nYou can export your function component with JavaScript’s for use throughout your app like so:\n\nNow take a closer look at that statement. is using a kind of JavaScript syntax that makes writing elements convenient: JSX.\n\nReact and React Native use JSX, a syntax that lets you write elements inside JavaScript like so: . The React docs have a comprehensive guide to JSX you can refer to learn even more. Because JSX is JavaScript, you can use variables inside it. Here you are declaring a name for the cat, , and embedding it with curly braces inside .\n\nAny JavaScript expression will work between curly braces, including function calls like :\n\nYou can think of curly braces as creating a portal into JS functionality in your JSX!\n\nYou’ve already met React Native’s Core Components. React lets you nest these components inside each other to create new components. These nestable, reusable components are at the heart of the React paradigm.\n\nFor example, you can nest and inside a below, and React Native will render them together:\n\nYou can render this component multiple times and in multiple places without repeating your code by using :\n\nAny component that renders other components is a parent component. Here, is the parent component and each is a child component.\n\nYou can put as many cats in your cafe as you like. Each renders a unique element—which you can customize with props.\n\nProps is short for “properties”. Props let you customize React components. For example, here you pass each a different for to render:\n\nMost of React Native’s Core Components can be customized with props, too. For example, when using , you pass it a prop named to define what image it shows:\n\nhas many different props, including , which accepts a JS object of design and layout related property-value pairs.\n\nYou can build many things with props and the Core Components , , and ! But to build something interactive, you’ll need state.\n\nWhile you can think of props as arguments you use to configure how components render, state is like a component’s personal data storage. State is useful for handling data that changes over time or that comes from user interaction. State gives your components memory!\n\nThe following example takes place in a cat cafe where two hungry cats are waiting to be fed. Their hunger, which we expect to change over time (unlike their names), is stored as state. To feed the cats, press their buttons—which will update their state.\n\nYou can add state to a component by calling React’s Hook. A Hook is a kind of function that lets you “hook into” React features. For example, is a Hook that lets you add state to function components. You can learn more about other kinds of Hooks in the React documentation.\n\nFirst, you will want to import from React like so:\n\nThen you declare the component’s state by calling inside its function. In this example, creates an state variable:\n• it creates a “state variable” with an initial value—in this case the state variable is and its initial value is\n• it creates a function to set that state variable’s value—\n\nIt doesn’t matter what names you use. But it can be handy to think of the pattern as .\n\nNext you add the Core Component and give it an prop:\n\nNow, when someone presses the button, will fire, calling the . This sets the state variable to . When is false, the ’s prop is set to and its also changes:\n\nNow that you’ve covered both React and React Native’s Core Components, let’s dive deeper on some of these core components by looking at handling ."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/example-intro",
        "document": "This is a minimal setup to get you started. If you want to see a description of what each line does, scroll down to the annotated version. Scroll down to Full Example to see a more advanced test setup.\n\nSee the following sections for a detailed breakdown of the test\n\nOur example here uses axios to make its API calls. If your application uses to make its API calls, then be aware that by default JSDOM does not include fetch. If you are using vitest as your test runner, it will be included for you. For jest you may wish to manually polyfill or use the jest-fixed-jsdom environment which includes fetch.\n\nUse the function from to mock an API request that our tested component makes.\n\nThe method renders a React element into the DOM.\n\nThe method allows you to fire events to simulate user actions."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/api",
        "document": "re-exports everything from as well as these methods:\n\nRender into a container which is appended to .\n\nYou won't often need to specify options, but if you ever do, here are the available options which you could provide as a second argument to .\n\nBy default, will create a and append that to the and this is where your React component will be rendered. If you provide your own HTMLElement via this option, it will not be appended to the automatically.\n\nFor example: If you are unit testing a element, it cannot be a child of a . In this case, you can specify a as the render .\n\nIf the is specified, then this defaults to that, otherwise this defaults to . This is used as the base element for the queries as well as what is printed when you use .\n\nIf hydrate is set to true, then it will render with ReactDOM.hydrate. This may be useful if you are using server-side rendering and use ReactDOM.hydrate to mount your components.\n\nBy default we'll render with support for concurrent features (i.e. ). However, if you're dealing with a legacy app that requires rendering like in React 17 (i.e. ) then you should enable this option by setting .\n\nCallback called when React catches an error in an Error Boundary. Behaves the same as in .\n\nCallback called when React automatically recovers from errors. Behaves the same as in .\n\nPass a React Component as the option to have it rendered around the inner element. This is most useful for creating reusable custom render functions for common data providers. See setup for examples.\n\nQueries to bind. Overrides the default set from unless merged.\n\nSee helpers for guidance on using utility functions to create custom queries.\n\nCustom queries can also be added globally by following the custom render guide.\n\nThe method returns an object that has a few properties:\n\nThe most important feature of is that the queries from DOM Testing Library are automatically returned with their first argument bound to the baseElement, which defaults to .\n\nThe containing DOM node of your rendered React Element (rendered using ). It's a . This is a regular DOM node, so you can call etc. to inspect the children.\n\nThe containing DOM node where your React Element is rendered in the container. If you don't specify the in the options of , it will default to .\n\nThis is useful when the component you want to test renders something outside the container div, e.g. when you want to snapshot test your portal component which renders its HTML directly in the body.\n\nThis method is a shortcut for .\n\nThis is a simple wrapper around which is also exposed and comes from .\n\nIt'd probably be better if you test the component that's doing the prop updating to ensure that the props are being updated correctly (see the Guiding Principles section). That said, if you'd prefer to update the props of a rendered component in your test, this function can be used to update props of the rendered component.\n\nThis will cause the rendered component to be unmounted. This is useful for testing what happens when your component is removed from the page (like testing that you don't leave event handlers hanging around causing memory leaks).\n\nReturns a of your rendered component. This can be useful if you need to avoid live bindings and see how your component reacts to events.\n\nUnmounts React trees that were mounted with render.\n\nFor example, if you're using the ava testing framework, then you would need to use the hook like so:\n\nFailing to call when you've called could result in a memory leak and tests which are not \"idempotent\" (which can lead to difficult to debug errors in your tests).\n\nThis is a light wrapper around the function. All it does is forward all arguments to the act function if your version of react supports . It is recommended to use the import from over for consistency reasons.\n\nThis is a convenience wrapper around with a custom test component. The API emerged from a popular testing pattern and is mostly interesting for libraries publishing hooks. You should prefer since a custom test component results in more readable and robust tests since the thing you want to test is not hidden behind an abstraction.\n\nDeclares the props that are passed to the render-callback when first invoked. These will not be passed if you call without props.\n\nCallback called when React catches an error in an Error Boundary. Behaves the same as in .\n\nCallback called when React automatically recovers from errors. Behaves the same as in .\n\nThe method returns an object that has a few properties:\n\nHolds the value of the most recently committed return value of the render-callback:\n\nNote that the value is held in . Think of as a ref for the most recently committed value.\n\nRenders the previously rendered render-callback with the new props:\n\nChanges global options. Basic usage can be seen at Configuration Options.\n\nWhen enabled, is rendered around the inner element. Defaults to ."
    },
    {
        "link": "https://jestjs.io/docs/tutorial-react",
        "document": "At Facebook, we use Jest to test React applications.\n\nIf you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add for rendering snapshots.\n\nIf you have an existing application you'll need to install a few packages to make everything work well together. We are using the package and the babel preset to transform our code inside of the test environment. Also see using babel.\n\nYour should look something like this (where is the actual latest version number for the package). Please add the scripts and jest configuration entries:\n\nAnd you're good to go!\n\nNow let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:\n\nWhen you run or , this will produce an output file like this:\n\nThe next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with to overwrite the existing snapshot.\n\nThe code for this example is available at examples/snapshot.\n\nThere's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:\n\nThen you will see warnings in the console:\n\nReact 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:\n• Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:\n• Render as a custom element. DOM \"custom elements\" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.\n• Use . The test renderer doesn't care about element types and will happily accept e.g. . You could check snapshots using the test renderer, and check component behavior separately using Enzyme.\n• Disable warnings all together (should be done in your jest setup file): This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.\n\nIf you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use .\n\nLet's implement a checkbox which swaps between two labels:\n\nThe code for this example is available at examples/react-testing-library.\n\nIf you need more advanced functionality, you can also build your own transformer. Instead of using , here is an example of using :\n\nDon't forget to install the and packages for this example to work.\n\nTo make this work with Jest you need to update your Jest configuration with this: .\n\nIf you'd like to build a transformer with babel support, you can also use to compose one and pass in your custom configuration options:\n\nSee dedicated docs for more details."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/setup",
        "document": "does not require any configuration to be used. However, there are some things you can do when configuring your testing framework to reduce some boilerplate. In these docs we'll demonstrate configuring Jest, but you should be able to do similar things with any testing framework (React Testing Library does not require that you use Jest).\n\nAdding options to your global test config can simplify the setup and teardown of tests in individual files.\n\nIt's often useful to define a custom render method that includes things like global context providers, data stores, etc. To make this available globally, one approach is to define a utility file that re-exports everything from . You can replace React Testing Library with this file in all your imports. See below for a way to make your test util file accessible without using relative paths.\n\nThe example below sets up data providers using the option to .\n\nYou can define your own custom queries as described in the Custom Queries documentation, or via the helper. Then you can use them in any render call using the option. To make the custom queries available globally, you can add them to your custom render method as shown below.\n\nIn the example below, a new set of query variants are created for getting elements by , a \"test ID\" convention mentioned in the Cypress.io documentation.\n\nYou can then override and append the new queries via the render function by passing a option.\n\nIf you want to add custom queries globally, you can do this by defining your customized , and methods:\n\nYou can then use your custom queries as you would any other query:\n\nTo make your custom test file accessible in your Jest test files without using relative imports ( ), add the folder containing the file to the Jest option.\n\nThis will make all the files in the test-utils directory importable without .\n\nIf you're using TypeScript, merge this into your . If you're using Create React App without TypeScript, save this to instead.\n\nIf you're using Jest 28 or later, jest-environment-jsdom package now must be installed separately.\n\nis also no longer the default environment. You can enable globally by editing :\n\nOr if you only need in some of your tests, you can enable it as and when needed using docblocks:\n\nIf you're using a recent version of Jest (27), is no longer the default environment. You can enable globally by editing :\n\nOr if you only need in some of your tests, you can enable it as and when needed using docblocks:\n\nIf you're using the Jest testing framework version 24 or lower with the default configuration, it's recommended to use package as Jest uses a version of the jsdom environment that misses some features and fixes, required by React Testing Library.\n\nThen specify as the :\n\nIf you're running your tests in the browser bundled with webpack (or similar) then should work out of the box for you. However, most people using React Testing Library are using it with the Jest testing framework with the set to (which is the default configuration with Jest 26 and earlier).\n\nis a pure JavaScript implementation of the DOM and browser APIs that runs in Node. If you're not using Jest and you would like to run your tests in Node, then you must install jsdom yourself. There's also a package called which can be used to setup the global environment to simulate the browser APIs.\n\nWith mocha, the test command would look something like this:\n\nis called after each test automatically by default if the testing framework you're using supports the global (like mocha, Jest, and Jasmine). However, you may choose to skip the auto cleanup by setting the env variable to 'true'. You can do this with like so:\n\nTo make this even easier, you can also simply import which will do the same thing. Just make sure you do this before importing . You could do this with Jest's configuration:\n\nAlternatively, you could import in all your tests that you don't want the to run and the won't be setup automatically.\n\nWhen using Mocha in watch mode, the globally registered cleanup is run only the first time after each test. Therefore, subsequent runs will most likely fail with a TestingLibraryElementError: Found multiple elements error.\n\nTo enable automatic cleanup in Mocha's watch mode, add a cleanup root hook. Create a file with the following contents:\n\nAnd register it using mocha's flag:\n\nIf you're using Vitest and want automatic cleanup to work, you can enable globals through its configuration file:\n\nIf you don't want to enable globals, you can import and call it manually in a top-level hook:"
    },
    {
        "link": "https://taniarascia.com/how-to-test-useeffect-api-call",
        "document": "Ever since Hooks were released in React, we've been using the hook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to test with both successful and failed API calls.\n• Set up a very simple React app with testing using Jest and React Testing Library\n• Write a test for when the API call succeeds\n• Write a test for when the API call fails\n\nSetting up the Application and Test Environment\n\nFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.\n\nI know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!\n\nWhat I ended up with looked like this:\n\nI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.\n\nFor the application, React + React DOM was necessary, as well as a few Babel packages.\n\nFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.\n\nAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.\n\nSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.\n\nOf course, there's the Babel config file, the same one you've probably been using for years.\n\nAnd the webpack config file. It makes most of the decisions by default, such as using as an entry point and outputting to a folder. I just needed to add a module to tell it to use .\n\nAs for the Jest config file, I just needed it to use and set the right directories.\n\nFinally, in , we just want to enable and import the Jest DOM.\n\nAdding a script to that just runs allows you to test the build and ensure the application is running. I also added a command for the test. Everything else is just the packages brought in by the commands.\n\nSo that's everything as far as config for both the application and testing, now to set up the simple app.\n\nNot too much has changed as far as the React index file goes. The import and API is slightly different from the last time I used it, and seems to be the default mode, so I'm just rendering to the and pulling in a component.\n\nSo now comes the code we're going to be testing, . I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done in , but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.\n\nI'm going to use JSON Placeholder for the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.\n\nSo I'll start off with a title and a message, and start setting up the state we'll use: for the data coming in, and in case an error gets thrown. I could have added in some state, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.\n\nNow I'll add in the that fetches data from the API and updates the data state, otherwise updates the error state.\n\nFinally, I'm just displaying the error if one exists, and displaying the users if they loaded.\n\nOkay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.\n\nI use in the folder to test the output of an application quickly.\n\nYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.\n\nNow to get started writing the tests. I opted to put them in , but of course there are differing opinions on where tests should live (which I discussed a bit in the React Architecture article). I'm just putting them in a folder for the sake of this example.\n\nTo set up, we'll use and from the React Testing Library. As implied by the names, is responsible for rendering your app to the JS Dom, and allows you to interact with it and see what's there.\n\nI'm putting everything in a block for , and making sure resets between each test.\n\nFirst, I'll write the test for when the API call succeeds.\n\nUsing , I'll mock the resolved value of the JSON Placeholder API with a list of fake users.\n\nNow, what we want is to see what happens after the successful , which is the users displayed and the \"No users found\" message not to be there.\n\nThis can be done using a combination of and , which uses behind the scenes to wait for the event to happen:\n\nHowever, the query is a combination of and , so we can simplify that even more into a one liner:\n\nSo here's our code to mock the , render the , ensure the data is rendered, and ensure nothing we don't want to see is visible:\n\nUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.\n\nNow that both tests are written, we just need to run them.\n\nUsing the command, we can run the tests. You can also add the flag to see if the tests are catching everything.\n\nAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.\n\nWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to test or get their environment set up!"
    }
]