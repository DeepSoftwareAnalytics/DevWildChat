[
    {
        "link": "https://geeksforgeeks.org/static-keyword-cpp",
        "document": "The static keyword in C++ has different meanings when used with different types. In this article, we will learn about the static keyword in C++ along with its various uses.\n\nIn C++, a static keyword can be used in the following context:\n\nIn a function, when a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call.\n\nLet’s take a look at an example:\n\nYou can see in the above program that the variable count is declared static. So, its value is carried through the function calls. The variable count is not getting initialized every time the function is called. As a side note, Java doesn’t allow static local variables in functions.\n\nThe static variables in a function have the following applications:\n• None or any other application where the previous state of function needs to be stored.\n\nAs the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static member variables in a class are shared by the objects. There cannot be multiple copies of the same static variables for different objects. Also because of this reason static variables cannot be initialized using constructors.\n\nLet’s take a look at an example:\n\nExplanation: You can see in the above program that we have tried to create multiple copies of the static variable i for multiple objects. But this didn’t happen.\n\nSo, a static variable inside a class should be initialized explicitly by the user using the class name and scope resolution operator outside the class as shown below:\n\nExplanation: We were able to access the static variable when is was initialized globally outside the class. Moreover, we can access the static data member without creating the object of the class.\n\nThe static data members can be used to implement the following:\n• None Ensure a class has only one instance by using static members.\n\nJust like the static data members or static variables inside the class, static member functions also do not depend on the object of the class. We are allowed to invoke a static member function using the object and the ‘.’ operator but it is recommended to invoke the static members using the class name and the scope resolution operator. Static member functions are allowed to access only the static data members or other static member functions, they cannot access the non-static data members or member functions of the class.\n\nLet’s take a look at an example:\n\nThe static member functions have the following uses in C++:\n• None Implement helper functions that do not depend on specific instances.\n• None Factory Methods to create and return objects without requiring an instance of the class.\n\nA global static variable in C++ is a static variable declared outside of any class or function. Unlike regular global variables, a global static variable has internal linkage, meaning it is accessible only within the file where it is defined. This ensures that its scope is limited to the current translation unit, preventing conflicts with variables in other files that may have the same name.\n\nLet’s take a look at an example:\n\nThe global static variables have the following uses in C++:\n• None Limiting variable scope to a file to prevent conflicts by ensuring the variable is accessible only within the file.\n• None Store settings or values that are specific to the functionality implemented in a single file.\n• None Use for shared resources in scenarios where frequent initialization and destruction can be avoided.\n• None Comparison of static keyword in C++ and Java"
    },
    {
        "link": "https://stackoverflow.com/questions/5019856/initialize-static-variables-in-c-class",
        "document": "I have noticed that some of my functions in a class are actually not accessing the object, so I made them . Then the compiler told me that all variables they access must also be static – well, quite understandable so far. I have a bunch of string variables such as\n\nand so on in the class. I have then made them all because they never change. However, my program only compiles if I move them out of the class: Otherwise, MSVC++2010 complains \"Only static constant integral variables may be initialized within a class\".\n\nWell that's unfortunate. Is there a workaround? I would like to leave them inside the class they belong to."
    },
    {
        "link": "https://tutorialspoint.com/cplusplus/cpp_static_members.htm",
        "document": "We can define class members static using static keyword. When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static member.\n\nA static member is shared by all objects of the class. All static data is initialized to zero when the first object is created, if no other initialization is present. We can't put it in the class definition but it can be initialized outside the class as done in the following example by redeclaring the static variable, using the scope resolution operator :: to identify which class it belongs to.\n\nLet us try the following example to understand the concept of static data members −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nBy declaring a function member as static, you make it independent of any particular object of the class. A static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator ::.\n\nA static member function can only access static data member, other static member functions and any other functions from outside the class.\n\nStatic member functions have a class scope and they do not have access to the this pointer of the class. You could use a static member function to determine whether some objects of the class have been created or not.\n\nLet us try the following example to understand the concept of static function members −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nHere are the following use cases:\n• A singleton pattern is a design pattern that makes sure that a class has only one instance and provides a global point of access to it. Here static members are perfect for implementing this pattern because they allow to maintenance of a single shared instance of the class.\n• Static members are often used to manage shared resources or counters that should be shared across all instances of a class.\n• Static members can be used to store global configuration settings or constants, useful for managing a pool of resources (e.g., a cache, database connection pool, etc.) and implementing a logging system that is shared across instances. which is shared across all instances of a class.\n• Static members can be used for Tracking Method calls."
    },
    {
        "link": "https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c",
        "document": "In order to clarify the question, I would rather categorize the usage of 'static' keyword in three different forms:\n\nthe explanation follows below for each of the subheadings:\n\nThis one can be little tricky however if explained and understood properly, it's pretty straightforward.\n\nTo explain this, first it is really useful to know about the scope, duration and linkage of variables, without which things are always difficult to see through the murky concept of static keyword\n\n1. Scope : Determines where in the file, the variable is accessible. It can be of two types: (i) Local or Block Scope. (ii) Global Scope\n\n2. Duration : Determines when a variable is created and destroyed. Again it's of two types: (i) Automatic Storage Duration (for variables having Local or Block scope). (ii) Static Storage Duration (for variables having Global Scope or local variables (in a function or a in a code block) with static specifier).\n\n3. Linkage: Determines whether a variable can be accessed (or linked ) in another file. Again ( and luckily) it is of two types: (i) Internal Linkage (for variables having Block Scope and Global Scope/File Scope/Global Namespace scope) (ii) External Linkage (for variables having only for Global Scope/File Scope/Global Namespace Scope)\n\nLet's refer an example below for a better understanding of plain global and local variables (no local variables with static storage duration) :\n\nNow comes the concept of Linkage. When a global variable defined in one file is intended to be used in another file, the linkage of the variable plays an important role.\n\nThe Linkage of global variables is specified by the keywords: (i) static , and, (ii) extern\n\nstatic keyword can be applied to variables with local and global scope, and in both cases, they mean different things. I will first explain the usage of 'static' keyword in variables with global scope ( where I also clarify the usage of keyword 'extern') and later the usage for those with local scope.\n\nGlobal variables have static duration, meaning they don't go out of scope when a particular block of code (e.g main() ) in which it is used ends . Depending upon the linkage, they can be either accessed only within the same file where they are declared (for static global variable), or outside the file even outside the file in which they are declared (extern type global variables)\n\nIn the case of a global variable having extern specifier, and if this variable is being accessed outside the file in which it has been initialized, it has to be forward declared in the file where it's being used, just like a function has to be forward declared if it's definition is in a file different from where it's being used.\n\nIn contrast, if the global variable has static keyword, it cannot be used in a file outside of which it has been declared.\n\nnow any variable in c++ can be either a const or a non-const and for each 'const-ness' we get two cases of default c++ linkage, in case none is specified:\n\n(i) If a global variable is non-const, its linkage is extern by default, i.e, the non-const global variable can be accessed in another .cpp file by forward declaration using the extern keyword (in other words, non const global variables have external linkage ( with static duration of course)). Also, usage of extern keyword in the original file where it has been defined is redundant. In this case, to make a non-const global variable inaccessible to external file, use the specifier 'static' before the type of the variable.\n\n(ii) If a global variable is const, its linkage is static by default, i.e a const global variable cannot be accessed in a file other than where it is defined, (in other words, const global variables have internal linkage (with static duration of course)). Also, usage of static keyword to prevent a const global variable from being accessed in another file is redundant. Here, to make a const global variable have an external linkage, use the specifier 'extern' before the type of the variable\n\nHere's a summary of global scope variables with various linkages\n\nNext, we investigate how the above global variables behave when accessed in a different file.\n\nUpdates (August 2019) on static keyword for variables in local scope\n\nThis further can be subdivided in two categories :\n\n(i) static keyword for variables within a function block, and (ii) static keyword for variables within an unnamed local block.\n\nEarlier, I mentioned that variables with local scope have automatic duration, i.e they come to exist when the block is entered ( be it a normal block, be it a function block) and cease to exist when the block ends, long story short, variables with local scope have automatic duration and automatic duration variables (and objects) have no linkage meaning they are not visible outside the code block.\n\nIf static specifier is applied to a local variable within a function block, it changes the duration of the variable from automatic to static and its lifetime is the entire duration of the program which means it has a fixed memory location and its value is initialized only once prior to program start up as mentioned in cpp reference(initialization should not be confused with assignment)\n\nlets take a look at an example.\n\nLooking at the above criterion for static local variables and static global variables, one might be tempted to ask, what the difference between them could be. While global variables are accessible at any point within the code (in the same as well as different translation units depending upon the const-ness and extern-ness), a static variable defined within a function block is not directly accessible. The variable has to be returned by the function value or reference. Lets demonstrate this by using an example:\n\nMore explanation about choice of static global and static local variables could be found on this stackoverflow thread\n\n(ii) static keyword for variables within an unnamed local block.\n\nstatic variables within a local block (not a function block) cannot be accessed outside the block once the local block goes out of scope. No caveats to this rule.\n\nC++11 introduced the keyword which guarantees the evaluation of an expression at compile time and allows the compiler to optimize the code. Now if the value of a static const variable within a scope is known at compile time, the code is optimized similarly to the one with . Here's a small example\n\nI recommend readers also to look up the difference between and for variables in this stackoverflow thread. this concludes my explanation for the static keyword applied to variables.\n\nin terms of functions, the static keyword has a straightforward meaning. Here, it refers to linkage of the function Normally all functions declared within a cpp file have external linkage by default, i.e a function defined in one file can be used in another cpp file by forward declaration.\n\nusing a static keyword before the function declaration limits its linkage to internal , i.e a static function cannot be used within a file outside of its definition.\n\nC. Static Keyword used for member variables and functions of classes\n\nI start directly with an example here\n\nIn this example, the static variable m_designNum retains its value and this single private member variable (because it's static) is shared b/w all the variables of the object type DesignNumber\n\nAlso like other member variables, static member variables of a class are not associated with any class object, which is demonstrated by the printing of anyNumber in the main function\n\n(i) non-const class static member variables In the previous example the static members (both public and private) were non constants. ISO standard forbids non-const static members to be initialized in the class. Hence as in previous example, they must be initialized after the class definition, with the caveat that the static keyword needs to be omitted\n\n(ii) const-static member variables of class this is straightforward and goes with the convention of other const member variable initialization, i.e the const static member variables of a class can be initialized at the point of declaration and they can be initialized at the end of the class declaration with one caveat that the keyword const needs to be added to the static member when being initialized after the class definition.\n\nI would however, recommend to initialize the const static member variables at the point of declaration. This goes with the standard C++ convention and makes the code look cleaner\n\nfor more examples on static member variables in a class look up the following link from learncpp.com http://www.learncpp.com/cpp-tutorial/811-static-member-variables/\n\nJust like member variables of classes can be static, so can member functions of classes. Normal member functions of classes are always associated with a object of the class type. In contrast, static member functions of a class are not associated with any object of the class, i.e they have no *this pointer.\n\nSecondly since the static member functions of the class have no *this pointer, they can be called using the class name and scope resolution operator in the main function (ClassName::functionName(); )\n\nThirdly static member functions of a class can only access static member variables of a class, since non-static member variables of a class must belong to a class object.\n\nfor more examples of static member functions in a class, look up the following link from learncpp.com\n\nLambda expressions follow normal name lookup rules and hence the scope (local vs global) and storage class (static vs automatic) affect how the variables are available to the lambda expressions\n• non-static global variable is available to lambda expression within a local scope.\n• Non-Static local variable is not available to lambda expression that appears within the same or a different scope. In this case, as we're mostly used to, the variables have to be captured by value or by reference\n• Static variables locally scoped static variables can be captured by lambda expressions within the same or lower/child scope\n\nHowever static variables in unnamed scope cannot be accessed outside the scope as explained previously"
    },
    {
        "link": "https://geeksforgeeks.org/declare-static-variable-in-class-in-cpp",
        "document": "How to Declare a Static Variable in a Class in C++?\n\nIn C++, a static variable is initialized only once and exists independently of any class objects so they can be accessed without creating an instance of the class. In this article, we will learn how to declare a static variable in a class in C++.\n\nStatic Variable in a Class in C++\n\nTo declare a static variable within a class we can use the static keyword in the definition while defining a static variable.\n\nSyntax to Declare Static Variable in C++\n\nTo declare a static variable in a class use the below syntax:\n\nC++ Program to Declare Static Variables in a Class\n\nThe below example demonstrates how we can declare static variables in a class in C++.\n\nStatic variables belongs to the class so we do not need to create an object to access the value of the static variables."
    },
    {
        "link": "https://geeksforgeeks.org/friend-class-function-cpp",
        "document": "A friend class can access private and protected members of other classes in which it is declared as a friend. It is sometimes useful to allow a particular class to access private and protected members of other classes. For example, a LinkedList class may be allowed to access private members of Node.\n\nWe can declare a friend class in C++ by using the friend keyword.\n\nLike a friend class, a friend function can be granted special access to private and protected members of a class in C++. They are not the member functions of the class but can access and manipulate the private and protected members of that class for they are declared as friends.\n\nWe can declare any global function as a friend function. The following example demonstrates how to declare a global function as a friend function in C++:\n\nIn the above example, we have used a global function as a friend function. In the next example, we will use a member function of another class as a friend function.\n\n2. Member Function of Another Class as Friend Function\n\nWe can also declare a member function of another class as a friend function in C++. The following example demonstrates how to use a member function of another class as a friend function in C++:\n• None A friend function is a special function in C++ that in spite of not being a member function of a class has the privilege to access private and protected data\n• None A friend function is a non-member function or ordinary function of a class, which is declared as a friend using the keyword “ friend ” inside the class. By declaring a function as a friend, all the access permissions are given to the function.\n• None The keyword “friend” is placed only in the function declaration of the friend function and not function definition or call.\n• None A friend function is called like an ordinary function. It cannot be called using the object name and dot operator. However, it may accept the object as an argument whose value it wants to access.\n• None A friend function can be declared in any section of the class i.e. public or private or protected.\n\nBelow are some more examples of friend functions in different scenarios:\n\nThe friend function provides us with a way to access private data but it also has its demerits. Following is the list of advantages and disadvantages of friend functions in C++:\n• None A friend function is able to access members without the need of inheriting the class.\n• None The friend function acts as a bridge between two classes by accessing their private data.\n• None It can be used to increase the versatility of overloaded operators.\n• None It can be declared either in the public or private or protected part of the class.\n• None Friend functions have access to private members of a class from outside the class which violates the law of data hiding.\n• None Friend functions cannot do any run-time polymorphism in their members.\n• None Friends should be used only for limited purposes. Too many functions or external classes are declared as friends of a class with protected or private data access lessens the value of encapsulation of separate classes in object-oriented programming.\n• not mutual . If class A is a friend of B, then B doesn’t become a friend of A automatically.\n• None Friendship is not inherited. (See\n• None The concept of friends is not in Java."
    },
    {
        "link": "https://programiz.com/cpp-programming/friend-function-class",
        "document": "Data hiding is a fundamental concept of object-oriented programming. It restricts the access of private members from outside of the class.\n\nSimilarly, protected members can only be accessed by derived classes and are inaccessible from outside. For example,\n\nHowever, there is a feature in C++ called friend functions that break this rule and allow us to access member functions from outside the class.\n\nSimilarly, there is a friend class as well, which we will learn later in this tutorial.\n\nA friend function can access the private and protected data of a class. We declare a friend function using the keyword inside the body of the class.\n\nHere, is a friend function that can access both private and public data members.\n\nThough this example gives us an idea about the concept of a friend function, it doesn't show any meaningful use.\n\nA more meaningful use would be operating on objects of two different classes. That's when the friend function can be very helpful.\n\nExample 2: Add Members of Two Different Classes\n\nIn this program, and have declared as a friend function. Thus, this function can access private data of both classes.\n\nOne thing to notice here is the friend function inside is using the . However, we haven't defined at this point.\n\nFor this to work, we need a forward declaration of in our program.\n\nWe can also use a friend Class in C++ using the keyword. For example,\n\nWhen a class is declared a friend class, all the member functions of the friend class become friend functions.\n\nSince is a friend class, we can access all members of from inside .\n\nHowever, we cannot access members of from inside . It is because friend relation in C++ is only granted, not taken.\n\nHere, is a friend class of . So, has access to the members of .\n\nIn , we have created a function that returns the sum of and .\n\nSince is a friend class, we can create objects of inside of ."
    },
    {
        "link": "https://tutorialspoint.com/cplusplus/cpp_friend_functions.htm",
        "document": "A friend function of a class is defined outside that class scope but it has the right to access all private and protected members of the class. Even though the prototypes for friend functions appear in the class definition, friends are not member functions.\n\nA friend can be a function, function template, member function, or a class or class template, in which case the entire class and all of its members are friends.\n\nTo declare a function as a friend of a class, precede the function prototype in the class definition with the keyword friend as follows\n\nTo declare all member functions of class ClassTwo as friends of class ClassOne, place a following declaration in the definition of class ClassOne −\n\nHere is the following code for Function Friend in C++:\n\nWhen the above code is compiled and executed, it produces the following result −\n\nThe private and protected members of a class are not accessible outside of the class. Still, if you want to access them, you can use the friend function. The friend function provides the ability to directly access the class's private and protected members.\n\nThe following example demonstrates accessing private and protected members of a class using the friend function:\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIn C++, both friend functions and member functions are used to access and manipulate the data of a class, but still, they have significant differences in their scope and usage.\n\nA friend Function is a non-member function that is declared inside a class using the \"friend\" keyword, it has special access to the class's private and protected members. Since it's not a member it is not bound to a specific object, can't overloaded based on objects, not use this pointer, and cannot be inherited by derived classes. They are defined outside the class but declared inside it.\n\nWhereas the member function is defined within the class and operates using this pointer. It can access all members of the class (private, protected, and public), and as it is tied to class objects, it can be overloaded and inherited by derived classes.\n\nIn C++, a friend class is a class that gives access to private and protected members of another class. When a class declares another class as a friend, the second class (the friend) can directly access the private and protected members of the first class.\n\nThis concept is similar to friend functions, but here the friend is an entire class rather than a specific function.\n\nHere is the following syntax for the friend class in C++:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/friend-cpp?view=msvc-170",
        "document": "In some circumstances, it's useful for a class to grant member-level access to functions that aren't members of the class, or to all members in a separate class. These free functions and classes are known as friends, marked by the keyword. Only the class implementer can declare who its friends are. A function or class can't declare itself as a friend of any class. In a class definition, use the keyword and the name of a nonmember function or other class to grant it access to the private and protected members of your class. In a template definition, a type parameter can be declared as a .\n\nIf you declare a function that wasn't previously declared, that function is exported to the enclosing nonclass scope.\n\nFunctions declared in a declaration are treated as if they had been declared using the keyword. For more information, see .\n\nAlthough functions with global scope can be declared as functions prior to their prototypes, member functions can't be declared as functions before the appearance of their complete class declaration. The following code shows how such a declaration fails:\n\nThe preceding example enters the class name into scope, but the complete declaration (specifically, the portion that declares the function ) isn't known. the declaration in class generates an error.\n\nIn C++11, there are two forms of friend declarations for a class:\n\nThe first form introduces a new class F if no existing class by that name was found in the innermost namespace. C++11: The second form doesn't introduce a new class; it can be used when the class has already been declared, and it must be used when declaring a template type parameter or a as a .\n\nUse when the referenced type hasn't been declared yet:\n\nAn error occurs if you use with a class type that hasn't been declared:\n\nIn the following example, refers to the class that is declared outside the scope of NS.\n\nUse to declare a template parameter as a friend:\n\nUse to declare a typedef as friend:\n\nTo declare two classes that are friends of one another, the entire second class must be specified as a friend of the first class. The reason for this restriction is that the compiler has enough information to declare individual friend functions only at the point where the second class is declared.\n\nA function is a function that isn't a member of a class but has access to the class's private and protected members. Friend functions aren't considered class members; they're normal external functions that are given special access privileges. Friends aren't in the class's scope, and they aren't called using the member-selection operators (. and ->) unless they're members of another class. A function is declared by the class that is granting access. The declaration can be placed anywhere in the class declaration. It isn't affected by the access control keywords.\n\nThe following example shows a class and a friend function, . The function has access to the private data member of the object it receives as a parameter.\n\nClass member functions can be declared as friends in other classes. Consider the following example:\n\nIn the preceding example, only the function is granted access to class . Therefore, access to the private member is correct in of class but not in .\n\nA class is a class all of whose member functions are functions of a class, that is, whose member functions have access to the other class's private and protected members. Suppose the declaration in class had been:\n\nIn that case, all member functions in class would have been granted access to class . The following code is an example of a class:\n\nFriendship isn't mutual unless explicitly specified as such. In the above example, member functions of can't access the private members of .\n\nA managed type (in C++/CLI) can't have any functions, classes, or interfaces.\n\nFriendship isn't inherited, meaning that classes derived from can't access 's private members. Friendship isn't transitive, so classes that are friends of can't access 's private members.\n\nThe following figure shows four class declarations: , , , and . Only class has direct access to the private members of (and to any members might have inherited).\n\nFriend functions can be defined (given a function body) inside class declarations. These functions are inline functions. Like member inline functions, they behave as though they were defined immediately after all class members have been seen, but before the class scope is closed (at the end of the class declaration). Friend functions that are defined inside class declarations are in the scope of the enclosing class."
    },
    {
        "link": "https://mygreatlearning.com/blog/friend-functions-in-cpp",
        "document": "In the domain of C++ programming, understanding the concept of friend functions is crucial for mastering classes and their interactions. \n\n\n\nIn this blog, we delve into the essence of friend functions in C++, exploring what they are, their significance, and how they operate within the framework of classes. \n\n\n\nIf you’re wondering, “What is friend function in C++?” or seeking clarity on the workings of C++ friend class, you’ve come to the right place. \n\n\n\nThrough clear explanations and illustrative examples, we’ll demystify the role of friend functions and classes, empowering you to use them effectively in your C++ projects.\n\nWhat is a Friend Function in C++?\n\nIn C++, a friend class allows one Class to access another class’s private and protected members. This means that the friend class can access the private and protected members of the Class, and it is declared as a friend, just like a member function of that Class.\n• This declaration allows ClassName2 to access the private and protected members of ClassName1.\n• After the friend keyword, ClassName2 is specified, indicating that ClassName2 has access to ClassName1‘s private and protected members.\n\nExample of C++ Code using Friend Class\n• In this example, we have two classes: Class A and Class B.\n• ClassB is declared a friend class inside ClassA, which allows ClassB to access ClassA’s private member numA.\n• Inside ClassB, the setValue function modifies the private member numA of ClassA directly, demonstrating the friend class’s ability to access private members.\n• The display function of ClassB also accesses ClassA’s member function display, demonstrating that friend classes can also access member functions of the Class they are friends with.\n• In the main function, objB calls setValue to modify objA.numA to 100, and then objB.display is called to display both numB and numA.\n\nLearners Tip: Friend classes or functions have the flexibility to be declared within any segment of the base class body, irrespective of its designation as private, protected, or public. This rule applies consistently across all declarations.\n\nJoin our “Introduction to C++” course today and learn how to become a proficient C++ developer!\n\nA friend function in C++ is a non-member function that has access to a class’s private and protected members. This means that a friend function can manipulate a class’s private and protected members as if it were a member function of that Class. \n\n\n\nHere is the friend function in C++ syntax to refer\n\nIn the syntax above:\n• The friend keyword precedes the declaration of the friend function inside the Class.\n• return_type specifies the data type returned by the friend function.\n• functionName is the name of the friend function.\n• Parameters are the variables passed to the function as arguments.\n\nBy declaring a function as a friend of a class, that function gains access to all private and protected class members, enabling it to operate on them directly. This concept is beneficial in scenarios where a function needs access to class members but isn’t logically a class member.\n\nAlso, explore “C++ Inheritance” and learn how to extend the functionality of your classes effortlessly!\n\nThe Different Types Of C++ Friend Functions\n\nGlobal function as a friend function in C++ is declared outside of any class but granted access to a class’s private and protected members through the friend keyword. This allows the global function to manipulate these members as if it were a class member function.\n\nWhy we use it?\n• Global functions, such as friend functions, are handy when a function needs access to private or protected members of a class but doesn’t logically belong to that Class.\n• They promote encapsulation by providing controlled access to class internals without exposing them through public member functions.\n\nExample of declaring a global function as a friend function in C++:\n• In the example, MyClass contains a private member num.\n• The global function globalFunction is declared a friend of MyClass, allowing it to access MyClass’s private member num.\n• Inside globalFunction, we can directly access MyClass’s private member num using an object of MyClass.\n• In the main function, an object obj of MyClass is created and passed to globalFunction, demonstrating how the global function accesses the private member of MyClass.\n• The output confirms that globalFunction successfully accessed and displayed the private member num of MyClass.\n\n“Get hands-on experience with these practical C++ Projects To Work On and sharpen your skills!”\n\n2. Member Function of Another Class as Friend Function\n\nA member function of another class as a friend function in C++ refers to a scenario where a member function of one Class is declared a friend of another. This grants the friend member function access to the private and protected members of the Class, which is declared as a friend of, just like a member function of that Class.\n\nWhy we use it?\n• It enables specific member functions of one Class to access private or protected members of another class, fostering controlled interaction between classes.\n• This approach is practical when certain functionalities of one Class require direct access to the internals of another class, promoting encapsulation and modularity.\n\nExample of declaring a member function of another class as a friend function in C++:\n• In this example, ClassA contains a private member numA.\n• This declaration allows ClassB display access to ClassA’s private member number.\n• In the main function, an object objA of ClassA and an object objB of ClassB are created.\n• When objB.display(objA) is called, ClassB display successfully accesses and displays the private member numA of objA.\n\nMore Examples of C++ Friend Function in Use\n\nHere are more examples to explain the friend function with examples in C++:\n\nExplanation: Here, calculateAverage is declared as a friend function of AverageCalculator, allowing it to access num1 and num2 directly to calculate the average.\n\nExplanation: Here, addMatrices is declared a friend function of Matrix, enabling it to access the private member mat of m1 and m2 to perform matrix addition.\n\nExplanation: In this example, increment is declared as a friend function of Number, allowing it to modify the private member value to increment the number directly.\n• In this example, we have classes A and B, each with a private member.\n• The function displayBoth has declared a friend to both ClassA and ClassB, allowing it to access both classes’ private members, numA and numB.\n• In the main function, objects objA and objB of ClassA and ClassB are created, respectively.\n• The displayBoth function is called with objA and objB as arguments, demonstrating how a single function can access private members of multiple classes.\n\nThe sequence in which the friend function is declared concerning another class is critical and necessitates careful consideration. It is vital to establish both classes before defining the function, thus prompting the Use of out-of-class function definition.\n\nFurthermore, read “C++ Functions” now to see how functions contribute to code organization and reusability in C++!\n• Versatility in Overloaded Operators: Friend functions allow overloaded operators to access private members of a class, enhancing flexibility in defining custom behavior for operators like +, -, etc.\n• Interclass Interactions: Friend facilitates seamless communication between different classes by granting access to private and protected members, promoting modularity and encapsulation.\n• Serialization: friend function C++ plays a vital role in serialization, enabling classes to efficiently serialize and deserialize their private data without compromising encapsulation.\n• Type Conversion: Friend functions enable type conversion by accessing private members. This allows for smooth conversion between different data types, enhancing code flexibility and readability.\n• Domain-Specific Language: Friend functions empower developers to create domain-specific languages within C++ programs, enhancing expressiveness and readability by enabling custom syntax and semantics.\n• Limited Polymorphism: Friend functions are not polymorphic, limiting their usage in scenarios requiring dynamic behavior based on the object’s runtime type.\n• Inheritance: Friend functions can’t access private members of derived classes, potentially complicating inheritance hierarchies and violating the principle of least privilege.\n• Code Complexity: Excessive Use of friend functions can lead to increased code complexity and reduced maintainability due to tight coupling between classes and functions. It can also hinder code comprehension and debugging.\n\nAccelerate your C++ programming skills with our curated selection of top book recommendations designed to accelerate your learning curve.\n\nThrough this exploration, you’ve gained insights into the significance and syntax of friend method C++, understanding their role in enabling interactions between classes while maintaining encapsulation. \n\n\n\nWhether you’re just starting to grasp the fundamentals or seeking to deepen your expertise in C++ programming, exploring Great Learning’s free C++ tutorial and software engineering course can be immensely beneficial. \n\n\n\nOur resources offer a structured pathway from understanding the basics of friend functions in C++ to mastering advanced concepts, empowering you with invaluable skills for software engineering endeavors. To continue your journey and explore structured learning materials, visit our platform offering free online courses in programming and much more.\n\n\n\nJoin Great Learning‘s community of learners and master C++ programming today.\n\nQ: Can a friend function be declared within a class? A: No, a friend function C++, cannot be declared within a class. Friend functions are declared outside the Class but can be granted access to its private and protected members through a declaration inside the Class using the friend keyword. Q: Can friend functions be defined inside a namespace? A: Yes, friend functions can be defined inside a namespace. They can be declared as friends of classes within the same namespace or outside the namespace. Defining friend functions inside a namespace allows for better organization and encapsulation of related functionalities. Q: Can friend functions be declared in a header file? A: Yes, friend functions can be declared in a header file like any other function. When declaring a friend function in a header file, it provides visibility to different source files that include the header file, allowing them to access the private and protected members of the Class. However, the friend function definition should be implemented in a source file (.cpp) to avoid multiple definition errors. Q: Can a friend function be virtual? A: No, friend functions cannot be virtual. Virtual functions are member functions of a class and participate in dynamic dispatch, which allows them to be overridden in derived classes. On the other hand, friend functions are not members of a class and do not participate in polymorphism. Q: Do derived classes inherit friend functions? A: No, friend functions are not inherited by derived classes. Inheritance in C++ does not affect friend relationships. Each Class must explicitly declare friend functions if they need access to private or protected members."
    },
    {
        "link": "https://stackoverflow.com/questions/77938306/implementation-of-c-singleton-class",
        "document": "For everyone considering using global singletons, do not do that. It will be bad for unit testing!\n\nThis is an example of how to completely avoid needing a global singleton variable for logging using dependency injection instead. And yes it might seem \"a lot of work\" now, but for larger systems this (dependency injection) is an important design pattern."
    },
    {
        "link": "https://stackoverflow.com/questions/1008019/how-do-you-implement-the-singleton-design-pattern",
        "document": "My main question is, how do I implement it in the right way?\n\nFrom this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.\n\nRecently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):\n\nWe went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf. These notes (and quotations I give in this answer) were created by my Professor, David Kieras. There are two ways that I know to create a Singleton class correctly. Implement it similar to the way you have it in your example. As for destruction, \"Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.\" However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton. class Singleton { public: static Singleton* get_instance(); // disable copy/move -- this is a Singleton Singleton(const Singleton&) = delete; Singleton(Singleton&&) = delete; Singleton& operator=(const Singleton&) = delete; Singleton& operator=(Singleton&&) = delete; friend class Singleton_destroyer; private: Singleton(); // no one else can create one ~Singleton(); // prevent accidental deletion static Singleton* ptr; }; // auxiliary static object for destroying the memory of Singleton class Singleton_destroyer { public: ~Singleton_destroyer { delete Singleton::ptr; } }; // somewhere in code (Singleton.cpp is probably the best place) // create a global static Singleton_destroyer object Singleton_destoyer the_destroyer; The Singleton_destroyer will be created on program startup, and \"when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.\" This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable. This is neat because the value returned is by reference and you can use syntax instead of to access member variables. \"Compiler automatically builds code that creates 's' first time through the declaration, not thereafter, and then deletes the static object at program termination.\" Note also that with the Meyers Singleton you \"can get into very difficult situation if objects rely on each other at the time of termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.\"\n\nIt is indeed probably allocated from the heap, but without the sources there is no way of knowing. The typical implementation (taken from some code I have in emacs already) would be: ...and rely on the program going out of scope to clean up afterwards. If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine. Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the \"if\" before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.\n\nIn addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something... struct Store{ std::array<Something, 1024> data; size_t get(size_t idx){ /* ... */ } void incr_ref(size_t idx){ /* ... */} void decr_ref(size_t idx){ /* ... */} }; template<Store* store_p> struct ItemRef{ size_t idx; auto get(){ return store_p->get(idx); }; ItemRef() { store_p->incr_ref(idx); }; ~ItemRef() { store_p->decr_ref(idx); }; }; Store store1_g; Store store2_g; // we don't restrict the number of global Store instances Now somewhere inside a function (such as ) you can do: The refs don't need to store a pointer back to their respective because that information is supplied at compile-time. You also don't have to worry about the 's lifetime because the compiler requires that it is global. If there is indeed only one instance of then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the class can even be made a of (you can have templated friends!). If itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature: The user can now create a type (and global instance) for each global instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using )."
    },
    {
        "link": "https://medium.com/better-programming/3-tips-for-using-singletons-in-c-c6822dc42649",
        "document": "3 Tips for Using Singletons in C++\n\nSingletons serve a wide variety of purposes in almost any programming language. In C++, singletons allow encapsulating logical that exists globally within a program. Instead of passing around a heap allocated object across function calls, a singleton’s unique instance can be accessed anywhere. However, it’s important to be careful of initialization order problems when singletons are used. Singletons may also be constructed at different points at runtime, depending on the desired behavior. This article will detail each of these tips and how to best use singletons.\n\nFirst, let’s define what exactly a singleton is. A singleton is an object with only a single instance that exists within a program. Typically, it cannot be destructed, and lives until the end of the program once constructed.\n\nSingletons are not directly supported in the C++ language but must be implemented using primitive guarantees of initialization behavior.\n\nLet’s take a simple struct, , and make it into a singleton. Then, the example will demonstrate:\n\nHere, is a singleton struct with the member . The method of returns the singular instance of the struct. The inside the method uses deferred initialization.\n\nAs of C++11, the standard guarantees that objects within functions only get initialized the first time the function is called, not before gets called, like most other static storage objects do.\n\nNot only that, but there’s also a guarantee that the initialization only happens once. But to double check on that claim, let’s test it. Take 2 threads, make them retrieve the singleton instance a bunch of times, and confirm the constructor only runs once for a single thread.\n\nThis test, when run, should print something like:\n\nWhere the main thread id is different than the thread that constructs the singleton. This shows that the singleton construction is in fact deferred to when the child threads first call .\n\nSingletons allow grouping and encapsulation of global access patterns that would be very difficult to do without them.\n\nOne example of a global access pattern is a shared queue, where multiple parts of a program may enqueue or dequeue an object, such as a job. Ideally, such a queue should be thread-safe, and use a mutex. Using the singleton pattern explained before, here’s what the job queue looks like\n\nFirst of all, this singleton uses r-value references, as opposed to l-value references. Jobs are moved onto the queue as opposed to being copied onto the queue.\n\nThe behavior of movement not only helps avoid unnecessary copying, it shapes the idea that a job should only be on the queue or not on the queue, never in both states at the same time.\n\nAnytime, anywhere that is called, the global size of the job queue increases. Any subsequent call to always reflects the last state from the enqueue call. The initialization of the queue and its thread safety is totally encapsulated within the singleton.\n\nIn terms of data variables and members, there are two main types of initialization. Deferred initialization is what we described earlier, that a given variable will be initialized the first time it is accessed.\n\nDynamic initialization is vastly different as it is unordered. This means that the point in time in which the variable is initialized is undetermined. All that one can know is that it will be initialized before is called.\n\nOne way to think of that is a dynamically initialized boolean would be indeterminate, it’s unknown if it’s been initialized to , or yet to be initialized. Here’s what the C++ reference mentions:\n\nThe biggest problem with dynamic initialization is the lack of order presents the risk of using an uninitialized variable. This happens when one dynamically initialized variable depends on some other dynamically initialized variable.\n\nSince both will be constructed at some point before , there’s no guarantee that the order the programmer may intend for them to be constructed in would in fact be the order used. Here’s an example of a design pattern that’s at risk for that:\n\nIn the above, each instance depends on the availability of being constructed and initialized. Since there’s no guarantee of such order, this design could encounter a static initialization ordering bug.\n\nThus, the solution here would be to convert the use of to a singleton that’s deferred initialized. This would ensure that for any , there’s always the instance that’s available.\n\nThere’s one important exception toward the definition of dynamic initialization. You may have noticed that compiling and running the program with and objects doesn’t run into problems.\n\nThat exception takes place when the relationship between data members are contained within a single translation unit during the compilation process. If that condition is true, then the dynamic initialization does take place, but only in the order in which those variables appear syntactically. Specifically:\n\nAlthough the above is true, it’s a very unreliable and error prone design choice. That’s because the build steps of a C++ program are external to the language itself. Looking at preprocessor statements like does not indicate whether or not a variable is in a separate translation unit or not.\n\nSome build tools like unity builds paste many files into a single file before compilation. Regardless, the point is one should not create a dependency on a particular build arrangement of files in a project that isn’t visible from the language itself.\n\nA potential problem with using non-local static initialization, is the order in which those variables are initialized is undefined. If two or more non-local statics reference each other , there’s a possibility they won’t be initialized in the order the program intends them to be. This fiasco is especially true when using objects with static constructors.\n\nConsider the case where one object depends on a static instance of another in its constructor, where you first have a base, container like class.\n\nand a node type class, that adds itself to the base list upon construction.\n\nThere’s no guarantee is initialized before the first object is.\n\nSimilarly to no defined order to initialization, there’s also no defined order to the destruction of static objects. Non-local static objects that are also statically allocated have exit handlers that are called upon exit. This can be true for common types like or . Having a at the non local scope leads to a situation where that object can be destructed before it’s done being used.\n\nA solution to both the problems of the ordering of initialization and destruction for static objects is pairing dynamic allocation with deferred initialization. What this means is, we want to use to allocate the object, but do it in the function level scope so it will be initialized in a thread safe manner the first time that function is called. When this happens, the static object will instead be a pointer to heap memory rather than allocated statically, and thus, will not undergo any automatic destruction."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/2rvepj/the_best_implementation_of_singleton_in_c",
        "document": "I implemented the Singleton pattern by overloading the \"new\" operator to get the same reference each time:\n\nIs there a better way of implementing this? And whats is considered to be the best solution, this one or a one when you will use Singleton.GetInstance() ?"
    },
    {
        "link": "https://refactoring.guru/design-patterns/singleton/cpp/example",
        "document": "Singleton is a creational design pattern, which ensures that only one object of its kind exists and provides a single point of access to it for any other code. Singleton has almost the same pros and cons as global variables. Although they’re super-handy, they break the modularity of your code. You can’t just use a class that depends on a Singleton in some other context, without carrying over the Singleton to the other context. Most of the time, this limitation comes up during the creation of unit tests.\n\nUsage examples: A lot of developers consider the Singleton pattern an antipattern. That’s why its usage is on the decline in C++ code.\n\nIdentification: Singleton can be recognized by a static creation method, which returns the same cached object.\n\nIt’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method. The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class. /** * The Singleton class defines the `GetInstance` method that serves as an * alternative to constructor and lets clients access the same instance of this * class over and over. */ class Singleton { /** * The Singleton's constructor should always be private to prevent direct * construction calls with the `new` operator. */ protected: Singleton(const std::string value): value_(value) { } static Singleton* singleton_; std::string value_; public: /** * Singletons should not be cloneable. */ Singleton(Singleton &other) = delete; /** * Singletons should not be assignable. */ void operator=(const Singleton &) = delete; /** * This is the static method that controls the access to the singleton * instance. On the first run, it creates a singleton object and places it * into the static field. On subsequent runs, it returns the client existing * object stored in the static field. */ static Singleton *GetInstance(const std::string& value); /** * Finally, any singleton should define some business logic, which can be * executed on its instance. */ void SomeBusinessLogic() { // ... } std::string value() const{ return value_; } }; Singleton* Singleton::singleton_= nullptr;; /** * Static methods should be defined outside the class. */ Singleton *Singleton::GetInstance(const std::string& value) { /** * This is a safer way to create an instance. instance = new Singleton is * dangeruous in case two instance threads wants to access at the same time */ if(singleton_==nullptr){ singleton_ = new Singleton(value); } return singleton_; } void ThreadFoo(){ // Following code emulates slow initialization. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); Singleton* singleton = Singleton::GetInstance(\"FOO\"); std::cout << singleton->value() << \"\n\n\"; } void ThreadBar(){ // Following code emulates slow initialization. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); Singleton* singleton = Singleton::GetInstance(\"BAR\"); std::cout << singleton->value() << \"\n\n\"; } int main() { std::cout <<\"If you see the same value, then singleton was reused (yay!\n\n\" << \"If you see different values, then 2 singletons were created (booo!!)\n\n\n\n\" << \"RESULT:\n\n\"; std::thread t1(ThreadFoo); std::thread t2(ThreadBar); t1.join(); t2.join(); return 0; } If you see the same value, then singleton was reused (yay! If you see different values, then 2 singletons were created (booo!!) RESULT: BAR FOO To fix the problem, you have to synchronize threads during the first creation of the Singleton object. /** * The Singleton class defines the `GetInstance` method that serves as an * alternative to constructor and lets clients access the same instance of this * class over and over. */ class Singleton { /** * The Singleton's constructor/destructor should always be private to * prevent direct construction/desctruction calls with the `new`/`delete` * operator. */ private: static Singleton * pinstance_; static std::mutex mutex_; protected: Singleton(const std::string value): value_(value) { } ~Singleton() {} std::string value_; public: /** * Singletons should not be cloneable. */ Singleton(Singleton &other) = delete; /** * Singletons should not be assignable. */ void operator=(const Singleton &) = delete; /** * This is the static method that controls the access to the singleton * instance. On the first run, it creates a singleton object and places it * into the static field. On subsequent runs, it returns the client existing * object stored in the static field. */ static Singleton *GetInstance(const std::string& value); /** * Finally, any singleton should define some business logic, which can be * executed on its instance. */ void SomeBusinessLogic() { // ... } std::string value() const{ return value_; } }; /** * Static methods should be defined outside the class. */ Singleton* Singleton::pinstance_{nullptr}; std::mutex Singleton::mutex_; /** * The first time we call GetInstance we will lock the storage location * and then we make sure again that the variable is null and then we * set the value. RU: */ Singleton *Singleton::GetInstance(const std::string& value) { std::lock_guard<std::mutex> lock(mutex_); if (pinstance_ == nullptr) { pinstance_ = new Singleton(value); } return pinstance_; } void ThreadFoo(){ // Following code emulates slow initialization. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); Singleton* singleton = Singleton::GetInstance(\"FOO\"); std::cout << singleton->value() << \"\n\n\"; } void ThreadBar(){ // Following code emulates slow initialization. std::this_thread::sleep_for(std::chrono::milliseconds(1000)); Singleton* singleton = Singleton::GetInstance(\"BAR\"); std::cout << singleton->value() << \"\n\n\"; } int main() { std::cout <<\"If you see the same value, then singleton was reused (yay!\n\n\" << \"If you see different values, then 2 singletons were created (booo!!)\n\n\n\n\" << \"RESULT:\n\n\"; std::thread t1(ThreadFoo); std::thread t2(ThreadBar); t1.join(); t2.join(); return 0; } If you see the same value, then singleton was reused (yay! If you see different values, then 2 singletons were created (booo!!) RESULT: FOO FOO"
    }
]