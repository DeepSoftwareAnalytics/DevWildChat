[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API",
        "document": "WebGL (Web Graphics Library) is a JavaScript API for rendering high-performance interactive 3D and 2D graphics within any compatible web browser without the use of plug-ins. WebGL does so by introducing an API that closely conforms to OpenGL ES 2.0 that can be used in HTML elements. This conformance makes it possible for the API to take advantage of hardware graphics acceleration provided by the user's device.\n\nSupport for WebGL is present in all modern browsers (see the compatibility tables below); however, the user's device must also have hardware that supports these features.\n\nThe WebGL 2 API introduces support for much of the OpenGL ES 3.0 feature set; it's provided through the interface.\n\nThe element is also used by the Canvas API to do 2D graphics on web pages."
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-use-the-html5-canvas-element-for-graphics",
        "document": "The HTML5 Canvas element is a powerful tool for creating graphics directly in the browser. Whether you’re making a game, drawing graphs, or creating animations, the Canvas element can do it all. This guide will walk you through everything you need to know about using the HTML5 Canvas element for graphics, in a way that’s easy to understand and follow.\n\nWhat is the Canvas Element?\n\nThe Canvas element is like a drawing board that you can use to create graphics with JavaScript. It doesn’t have any inherent drawing capabilities on its own but provides the space where you can draw.\n\nYou can think of it as an empty sheet of paper.\n\nTo start using the Canvas element, you first need to include it in your HTML file. Here’s a basic example of how to set up a Canvas:\n\nIn this example, we create a Canvas element with an ID of and set its width and height to 500 pixels. The tag points to a JavaScript file where we’ll write our drawing code.\n\nTo draw on the Canvas, you need to get its context. The context is what you use to actually draw the graphics. You can get the context with JavaScript like this:\n\nThis code selects the Canvas element by its ID and gets its 2D drawing context. The variable is now your drawing tool.\n\nRectangles are one of the simplest shapes you can draw on the Canvas. You can draw a rectangle with the method:\n\nThis code sets the fill color to blue and draws a rectangle at (50, 50) with a width of 100 pixels and a height of 150 pixels.\n\nFor more complex shapes, you need to draw paths. Here’s how you can draw a triangle:\n\nThis code starts a new path, moves the pen to (100, 100), draws lines to (150, 200) and (50, 200), and then closes the path. Finally, it fills the triangle with red color.\n\nYou can set the colors for both filling and stroking (outlining) shapes. Here’s how to set different colors:\n\nsets the color for the interior of shapes, while sets the color for the outlines.\n\nYou can also use gradients and patterns to fill shapes. Here’s an example of a linear gradient:\n\nThis code creates a gradient that goes from blue to white and uses it to fill a rectangle.\n\nYou can draw text on the Canvas using the and methods. Here’s how to draw filled text:\n\nThis code sets the font to 30px Arial, sets the fill color to black, and draws the text at (50, 50).\n\nYou can control the alignment of the text with properties like and . Here’s an example:\n\nThis code centers the text both horizontally and vertically on the Canvas.\n\nDrawing lines is a fundamental part of using the Canvas. You can draw lines by defining a path and then stroking it.\n\nThis code starts a path at (100, 100), draws a line to (200, 200), sets the stroke color to purple, the line width to 5 pixels, and then strokes the path.\n\nTo draw arcs or circles, you use the method. Here’s how to draw a circle:\n\nThis code creates a path for a circle with a center at (150, 150), a radius of 75 pixels, and fills it with orange.\n\nBezier and quadratic curves allow for more complex shapes. Here’s an example of a quadratic curve:\n\nAnd here’s an example of a Bezier curve:\n\nScaling changes the size of the shapes you draw. Here’s how to scale a rectangle:\n\nThe and methods are used to save and restore the context’s state, so the scaling only affects the rectangle.\n\nYou can rotate shapes using the method. Here’s an example:\n\nThis code translates the origin to (100, 100) and then rotates the context by 45 degrees (π/4 radians).\n\nTranslating moves the origin of the Canvas to a new position. Here’s how to translate:\n\nThis code moves the origin to (100, 100) and draws a rectangle there.\n\nCreating animations involves repeatedly drawing shapes with slight changes. Here’s a basic example of an animation:\n\nThis code moves a rectangle from left to right, looping back when it goes off the Canvas.\n\nYou can make your Canvas interactive by responding to user input. Here’s an example that changes the color of a rectangle when it’s clicked:\n\nThis code checks if the click is within the rectangle and changes its color if it is.\n\nYou can draw images on the Canvas using the method. Here’s how you can load and draw an image:\n\nThis code creates a new image object, sets its source to your image file, and draws it on the Canvas once it’s loaded.\n\nYou can also manipulate images by accessing the pixel data with the and methods. Here’s a basic example of changing the color of an image:\n\nThis code inverts the colors of the image by modifying its pixel data.\n\nYou can save the content of the Canvas as an image file. Here’s how to do it:\n\nThis code gets a data URL representing the image in PNG format. You can set this URL as the source of an image element or open it in a new tab to save it.\n\nTo allow users to download the Canvas content, you can create a download link:\n\nThis code creates an anchor element, sets the download attribute to the desired file name, sets the href to the Canvas data URL, and programmatically clicks the link to trigger the download.\n\nFor more complex animations, you can use a technique called frame-by-frame animation. Here’s an example of an animated sprite:\n\nThis code draws one frame of the sprite at a time, cycling through the frames to create an animation.\n\nFabric.js is a powerful library that simplifies working with the Canvas. Here’s a basic example of how to use Fabric.js:\n\nThis code creates a Fabric.js canvas and adds a red rectangle to it. Fabric.js provides many features for creating and manipulating shapes, images, and text, making it easier to work with the Canvas.\n\nClipping regions allow you to define an area where drawings are confined. Here’s an example of how to use clipping:\n\nThis code creates a circular clipping region. Only the part of the rectangle that lies within the circle will be visible.\n\nYou can use global composite operations to control how drawings are blended together. Here’s an example:\n\nThis code sets the global composite operation to ‘multiply’, which blends the colors of the overlapping rectangles.\n\nYou can use images to create repeating patterns. Here’s how to create a pattern:\n\nThis code uses an image to create a repeating pattern and fills the entire Canvas with it.\n\nRadial gradients are circular gradients that transition from one color to another. Here’s an example:\n\nThis code creates a radial gradient that transitions from yellow to red and uses it to fill a rectangle.\n\nYou can outline text using the method. Here’s an example:\n\nThis code sets the font, stroke color, and line width, then draws the outlined text.\n\nText shadows add a visual effect to text. Here’s how to add a shadow:\n\nThis code sets the shadow color, offset, and blur, and then draws the text with a shadow.\n\nYou can use external data to create dynamic graphics. Here’s an example of drawing a bar chart from an array of values:\n\nThis code iterates over an array of data values and draws a bar for each value.\n\nYou can integrate the Canvas with external APIs to create dynamic content. Here’s an example of fetching data from an API and drawing it:\n\nThis code fetches data from an API, then draws bars based on the data.\n\nGSAP is a popular library for animations. Here’s an example of how to animate a shape with GSAP:\n\nThis code uses GSAP to animate a rectangle moving across the Canvas.\n\nOffscreenCanvas is a powerful feature for performing graphics operations off the main thread. Here’s an example:\n\nThis code creates an offscreen Canvas, draws on it, and then transfers the drawing to the main Canvas.\n\nYou can handle mouse events to create interactive Canvas applications. Here’s how to handle mouse clicks:\n\nThis code adds an event listener for mouse down events and draws a green square where the user clicks.\n\nFor mobile devices, you can handle touch events. Here’s an example:\n\nThis code adds an event listener for touch start events and draws a purple square where the user touches the Canvas.\n\nAlthough the Canvas itself doesn’t directly handle keyboard events, you can use the document object to listen for them:\n\nThis code listens for the ‘a’ key press and draws a blue square at (100, 100) when the key is pressed.\n\nTo detect if a user clicks inside a shape, you can use simple math to check the coordinates. Here’s how to detect if a click is inside a rectangle:\n\nThis code checks if the click coordinates fall within the bounds of the rectangle.\n\nFor more complex shapes, you can use the object to define and detect hits:\n\nThis code defines a triangle using and detects clicks inside the triangle.\n\nHigh-DPI displays can cause your Canvas graphics to look blurry. To fix this, you can scale the Canvas to match the device’s pixel ratio:\n\nThis code scales the Canvas to match the device’s pixel ratio, ensuring sharp graphics on high-DPI displays.\n\nWebGL (Web Graphics Library) is a JavaScript API for rendering 2D and 3D graphics in a web browser. It allows you to leverage the GPU for more complex graphics. Here’s a basic example of setting up a WebGL context:\n\nThis code initializes a WebGL context and checks if WebGL is supported.\n\nWebGL requires more setup than the 2D context. Here’s a simple example of drawing a triangle:\n\nThis code sets up a basic WebGL program and draws a red triangle.\n\nYou can combine Canvas with SVG (Scalable Vector Graphics) to leverage the strengths of both. For example, you can draw complex shapes with SVG and then render them on the Canvas:\n\nThis code creates an SVG rectangle and draws it on the Canvas.\n\nWeb Workers allow you to run scripts in background threads. You can use them with Canvas to perform heavy computations without blocking the main thread:\n\nThis code uses a Web Worker to generate image data and then renders it on the Canvas.\n\nTo ensure your Canvas content looks good on different screen sizes, you can make the Canvas responsive. Here’s how to achieve a responsive Canvas:\n\nThis code resizes the Canvas to match the window size and redraws the content whenever the window is resized.\n\nAccessibility is crucial for reaching a broader audience. Although Canvas doesn’t inherently support accessibility, you can enhance it with ARIA attributes and alternative text:\n\nAdding an and a descriptive paragraph helps screen readers understand the content of the Canvas.\n\nReact is a popular JavaScript library for building user interfaces. Here’s how to integrate Canvas with a React component:\n\nThis code uses the and hooks to access the Canvas element and draw on it within a React component.\n\nAngular is another popular framework for building web applications. Here’s an example of integrating Canvas with an Angular component:\n\nThis code uses Angular’s decorator to get a reference to the Canvas element and draw on it after the view initializes.\n\nMinimize the number of draw calls by grouping multiple drawing operations together. Instead of clearing and redrawing the entire Canvas frequently, update only the parts that have changed:\n\nFor complex drawings, use multiple Canvas elements as layers. This way, you can update one layer without affecting others:\n\nThis code uses two Canvas elements to separate static and dynamic content, improving performance by only updating the necessary layer.\n\nShadows and gradients can make your graphics look more polished and visually appealing. Here’s how to add shadows:\n\nAnd here’s how to create and use a gradient:\n\nCSS filters can be applied to Canvas elements to add visual effects like blur or grayscale:\n\nThis code applies a blur filter to the Canvas, making the red rectangle appear blurred.\n\nChart.js is a popular library for creating charts. Here’s how to create a simple bar chart with Chart.js:\n\nThis code creates a bar chart with different colored bars representing data points.\n\nCanvas is well-suited for developing 2D games. Use game loops, collision detection, and sprite animations to create engaging gameplay experiences. Libraries like Phaser.js can simplify game development:\n\nThis code sets up a basic Phaser.js game with a background image and a bouncing star.\n\nUse Canvas to create interactive data visualizations like charts and graphs. Libraries like D3.js can help you create complex visualizations with ease:\n\nThis code uses D3.js to create a simple bar chart from an array of data.\n\nThe HTML5 Canvas element is a versatile and powerful tool for creating graphics directly in the browser. It supports a wide range of capabilities, from drawing simple shapes and text to creating complex animations and interactive applications. By leveraging techniques such as responsive design, performance optimization, and integration with other technologies like React, Angular, and WebGL, you can enhance the functionality and visual appeal of your web projects.\n\nUnderstanding and mastering the Canvas API opens up endless possibilities for creative and engaging web content. Whether you’re developing games, data visualizations, or any other interactive graphics, Canvas provides the flexibility and performance to bring your ideas to life effectively.\n• The Importance of Code Reviews in Frontend Development\n• How to Use TypeScript for Better JavaScript Development\n• Best Practices for Accessibility in Frontend Development\n• How to Integrate Frontend Testing into Your Workflow"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_usage",
        "document": "Let's start this tutorial by looking at the HTML element itself. At the end of this page, you will know how to set up a canvas 2D context and have drawn a first example in your browser.\n\nAt first sight a looks like the element, with the only clear difference being that it doesn't have the and attributes. Indeed, the element has only two attributes, and . These are both optional and can also be set using DOM properties. When no and attributes are specified, the canvas will initially be 300 pixels wide and 150 pixels high. The element can be sized arbitrarily by CSS, but during rendering the image is scaled to fit its layout size: if the CSS sizing doesn't respect the ratio of the initial canvas, it will appear distorted. Note: If your renderings seem distorted, try specifying your and attributes explicitly in the attributes, and not using CSS. The attribute isn't specific to the element but is one of the global HTML attributes which can be applied to any HTML element (like for instance). It is always a good idea to supply an because this makes it much easier to identify it in a script. The element can be styled just like any normal image ( , , …). These rules, however, don't affect the actual drawing on the canvas. We'll see how this is done in a dedicated chapter of this tutorial. When no styling rules are applied to the canvas it will initially be fully transparent.\n\nThe element, like the , , , and elements, must be made accessible by providing fallback text to be displayed when the media doesn't load or the user is unable to experience it as intended. You should always provide fallback content, captions, and alternative text, as appropriate for the media type. Providing fallback content is very straightforward: just insert the alternate content inside the element to be accessed by screen readers, spiders, and other automated bots. Browsers, by default, will ignore the content inside the container, rendering the canvas normally unless isn't supported. For example, we could provide a text description of the canvas content or provide a static image of the dynamically rendered content. This can look something like this: Telling the user to use a different browser that supports canvas does not help users who can't read the canvas at all. Providing useful fallback text or sub DOM adds accessibility to an otherwise non-accessible element.\n\nAs a consequence of the way fallback is provided, unlike the element, the element requires the closing tag ( ). If this tag is not present, the rest of the document would be considered the fallback content and wouldn't be displayed. If fallback content is not needed, a simple is fully compatible with all browsers that support canvas at all. This should only be used if the canvas is purely presentational.\n\nThe element creates a fixed-size drawing surface that exposes one or more rendering contexts, which are used to create and manipulate the content shown. In this tutorial, we focus on the 2D rendering context. Other contexts may provide different types of rendering; for example, WebGL uses a 3D context based on OpenGL ES. The canvas is initially blank. To display something, a script first needs to access the rendering context and draw on it. The element has a method called , used to obtain the rendering context and its drawing functions. takes one parameter, the type of context. For 2D graphics, such as those covered by this tutorial, you specify to get a . The first line in the script retrieves the node in the DOM representing the element by calling the method. Once you have the element node, you can access the drawing context using its method.\n\nHere is a minimalistic template, which we'll be using as a starting point for later examples. Note: It is not good practice to embed a script inside HTML. We do it here to keep the example concise. The script includes a function called , which is executed once the page finishes loading; this is done by listening for the event on the document. This function, or one like it, could also be called using , , or any other event handler, as long as the page has been loaded first. Here is how a template would look in action. As shown here, it is initially blank."
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2012/january/building-html5-applications-using-html5-canvas-for-data-visualization",
        "document": "In the early days online, when the Web was little more than a collection of static text and links, there was growing interest in supporting other types of content. In 1993, Marc Andreessen, creator of the Mosaic browser, which would evolve into Netscape Navigator, proposed the IMG tag as a standard for embedding images inline with the text on a page. Soon after, the IMG tag became the de facto standard for adding graphical resources to Web pages—a standard that’s still in use today. You could even argue that, as we’ve moved from the Web of documents to the Web of applications, the IMG tag is more important than ever.\n\nMedia, in general, is certainly more important than ever, and though the need for media on the Web has evolved over the past 18 years, the image has remained static. Web authors have increasingly sought to use dynamic media such as audio, video, and interactive animations in their sites and applications and, until recently, the primary solution was a plug-in like Flash or Silverlight.\n\nNow, with HTML5, media elements in the browser get a nice kick in the pants. You’ve probably heard of the new Audio and Video tags, both of which allow these types of content to function as first-class citizens in the browser, no plug-ins required. Next month’s article will cover both of these elements and their APIs in depth. You’ve probably also heard of the canvas element, a drawing surface with a rich set of JavaScript APIs that give you the power to create and manipulate images and animations on the fly. What IMG did for static graphical content, canvas has the potential to do for dynamic and scriptable content.\n\nAs exciting as the canvas element is, though, it suffers from a bit of a perception problem. Because of its power, canvas is usually demonstrated via complex animations or games, and while these do convey what’s possible, they can also lead you to believe that working with canvas is complicated and difficult, something that should be attempted only for complex cases, like animation or games.\n\nIn this month’s article, I’d like to take a step back from the glitz and complexity of canvas and show you some simple, basic uses of it, all with the goal of positioning the canvas as a powerful option for data visualization in your Web applications. With that in mind, I’ll focus on how you can get started with canvas, and how to draw simple lines, shapes and text. Then I’ll talk about how you can work with gradients in your shapes, as well as how to add external images to a canvas. Finally, and as I’ve done throughout this series, I’ll wrap up with a brief discussion on polyfilling canvas support for older browsers.\n\nAccording to the W3C HTML5 specification (https://www.w3.org/TR/html-markup/canvas.html), the canvas element “provides scripts with a resolution-dependent bitmap canvas, which can be used for rendering graphs, game graphics or other visual images on the fly.” Canvas is actually defined across two W3C specifications. The first is as a part of the HTML5 core specification, where the element itself is defined in detail. This specification covers how to use the canvas element, how to obtain its drawing context, APIs for exporting canvas content and security considerations for browser vendors. The second is the HTML Canvas 2D Context (w3.org/TR/2dcontext), which I’ll get to in a moment.\n\nGetting started with canvas is as simple as adding a <canvas> element to HTML5 markup, like so:\n\nThough I now have a canvas eleme­­nt in the DOM, placing this markup on the page does nothing, as the canvas element has no content until you add it. That’s where the drawing context comes in. To show you where my blank canvas is located, I can use CSS to style it, so I’ll add a dotted blue line around the blank element.\n\nThe result, when my page is opened in Internet Explorer 9+, Chrome, Firefox, Opera or Safari, is depicted in Figure 1.\n\nWhen using canvas, you’ll do most of your work in JavaScript, where the exposed APIs of a canvas drawing context can be leveraged to manipulate each pixel of the surface. To obtain the canvas drawing context, you need to get your canvas element from the DOM and then call the getContext method of that element.\n\nGetContext returns an object with an API that you can use to draw on the canvas in question. The first argument to that method (in this case, “2d”) specifies the drawing API that we want to use for the canvas. “2d” refers to the HTML Canvas 2D Context I mentioned earlier. As you might guess, 2D means that this is a two-dimensional drawing context. As of this writing, the 2D Context is the only widely supported drawing context, and it’s what we’ll use for this article. There’s ongoing work and experimentation around a 3D drawing context, so canvas should provide even more power for our applications in the future.\n\nNow that we have a canvas element on our page and we’ve obtained its drawing context in JavaScript, we can begin to add content. Because I want to focus on data visualization, I’m going to use the canvas to draw a bar chart to represent the current month’s sales data for a fictional sporting goods store. This exercise will require drawing lines for the axes; shapes and fills for the bars; and text for the labels on each axis and bar.\n\nLet’s start with the lines for the x- and y-axes. Drawing lines (or paths) with the canvas context is a two-step process. First, you “trace” the lines on the surface using a series of lineTo(x, y) and moveTo(x, y) calls. Each method takes x- and y-coordinates on the canvas object (starting from the top-left corner) to use when performing the operation (as opposed to coordinates on the screen itself). The moveTo method will move to the coordinates you specify, and lineTo will trace a line from the current coordinates to the coordinates you specify. For example, the following code will trace our y-axis on the surface:\n\nIf you add this code to your script and run it in the browser, you’ll notice that nothing happens. Because this first step is merely a tracing step, nothing is drawn on the screen. Tracing merely instructs the browser to take note of a path operation that will be flushed to the screen at some point in the future. When I’m ready to draw paths to the screen, I optionally set the strokeStyle property of my context, and then call the stroke method, which will fill in the invisible lines. The result is depicted in Figure 2.\n\nBecause defining lines (lineTo, moveTo) and drawing lines (stroke) are decoupled, you can actually batch a series of lineTo and moveTo operations and then output those to the screen all at once. I’ll do this for both the x- and y-axes and the operations that draw arrows as the end of each axis. The complete function for drawing the axes is shown in Figure 3 and the result in Figure 4.\n\nWe have our axes, but we should probably label them to make them more useful. The 2D canvas context specifies APIs for adding text to canvas elements, so you don’t need to fiddle with messy hacks like floating text over the canvas element. That said, canvas text doesn’t provide a box model, nor does it accept CSS styles defined for page-wide text, and so forth. The API does provide a font attribute that works the same as a CSS font rule—as well as textAlign and textBaseline properties to give you some control over position relative to the provided coordinates—but other than that, drawing text on the canvas is a matter of picking an exact point on the canvas for the text you supply.\n\nThe x-axis represents products in our fictional sporting goods store, so we should label that axis accordingly:\n\nIn this code snippet, I’m setting the optional font property and providing a string to draw on the surface, along with the x- and y-coordinates to use as the start position of the string. In this example, I’ll draw the word “Product” in the middle of my canvas, 20 pixels up from the bottom, which leaves room for the labels for each product on my bar chart. I’ll do something similar for the y-axis label, which contains the sales data for each product. The result is depicted in Figure 5.\n\nNow that we have a framework for our chart, we can add the bars. Let’s create some dummy sales data for the bar chart, which I’ll define as a JavaScript array of object literals.\n\nWith this data in hand, we can use fillRect and fillStyle to draw our bars on the chart.\n\nfillRect(x, y, width, height) will draw a rectangle on the canvas at the x- and y-coordinates, with the width and height you specify. It’s important to note that fillRect draws shapes starting from the top-left radiating outward, unless you specify negative width and height values, in which case the fill will radiate in the opposite direction. For drawing tasks like charting, that means we’ll be drawing the bars from the top down, as opposed to the bottom up.\n\nTo draw the bars, we can loop through the array of sales data and call fillRect with the appropriate coordinates:\n\nIn this code, the width of each bar is standard, while the height is taken from the sales property for each product in the array. The result of this code is seen in Figure 6.\n\nNow, we have a chart that’s technically accurate, but those solid black bars leave something to be desired. Let’s spruce them up with some color, and then add a gradient effect.\n\nWhen the fillRect method of a drawing context is called, the context will use the current fillStyle property to style the rectangle as its being drawn. The default style is a solid black, which is why our chart looks as it does in Figure 6. fillStyle accepts named, hexadecimal and RGB colors, so let’s add some functionality to style each bar before it is drawn:\n\nFirst, we create an array of colors. Then, as we loop through each product, we’ll use one of these colors as the fill style for that element. The result is depicted in Figure 7.\n\nThis looks better, but fillStyle is very flexible and lets you use linear and radial gradients instead of just solid colors. The 2D drawing context specifies two gradient functions, createLinerGradient and createRadialGradient, both of which can enhance the style of your shapes through smooth color transitions.\n\nFor this example, I’m going to define a createGradient function that will accept the x- and y-coordinates for the gradient, a width and the primary color to use:\n\nAfter calling createLinearGradient with my start and end coor­dinates, I’ll add two color stops to the gradient object returned by the drawing context. The addColorStop method will add color transitions along the gradient; it can be called any number of times with first parameter values between 0 and 1. Once I’ve set up my gradient, I’ll return it from the function.\n\nThe gradient object can then be set as the fillStyle property on my context, in place of the hex and RGB strings I specified in the previous example. I’ll use those same colors as my starting point, and then fade them into a light gray.\n\nThe result of the gradient option can be seen in Figure 8.\n\nAt this point, we have a pretty good-looking chart, which we’ve been able to render in the browser using a few dozen lines of JavaScript. I could stop here, but there’s still one basic canvas API related to working with images I want to cover. Not only does canvas let you replace static images with script-based and interactive content, but you can also use static images to enhance your canvas visualizations.\n\nFor this demo, I’d like to use images as the bars on the bar chart. And not just any images, but pictures of the items themselves. With that in goal in mind, my Web site has a folder that contains JPG images for each product—in this case, basketballs.jpg, baseballs.jpg and footballs.jpg. All I need to do is position and size each image appropriately.\n\nThe 2D drawing context defines a drawImage method with three overloads, accepting three, five or nine parameters. The first parameter is always the DOM element image to draw. The simplest version of drawImage also accepts x- and y-coordinates on the canvas and draws the image as is in that location. You can also provide width and height values as the last two parameters, which will scale the image to that size prior to drawing it on the surface. Finally, the most complex use of drawImage allows you to crop an image down to a defined rectangle, scale it to a given set of dimensions and, finally, draw it on the canvas at the specified coordinates.\n\nBecause the source images I have are large-scale images used elsewhere on my site, I’m going to take the latter approach. In this example, rather than calling fillRect for each item as I loop through the salesData array, I’ll create an Image DOM element, set its source to one of my product images, and render a cropped version of that image onto my chart, as Figure 9 shows.\n\nBecause I’m creating these images dynamically, as opposed to adding them manually to my markup at design time, I shouldn’t assume that I can set the image source, then immediately draw that image to my canvas. To ensure that I draw each image only when it’s fully loaded, I’ll add my drawing logic to the onload event for the image, then wrap that code in a self-invoking function, which creates a closure with variables pointing to the correct product category, sales and positioning variables. You can see the result in Figure 10.\n\nAs you may know, versions of Internet Explorer prior to 9, as well as older versions of other browsers, do not support the canvas element. You can see this for yourself by opening the demo project in Internet Explorer and hitting F12 to open the developer tools. From the F12 tools, you can change the Browser Mode to Internet Explorer 8 or Internet Explorer 7 and refresh the page. What you’re likely to see is a JavaScript exception with the message “Object doesn’t support property of method getContext.” The 2D drawing context isn’t available, nor is the canvas element itself. It’s also important to know that, even in Internet Explorer 9, canvas isn’t available unless you specify a DOCTYPE. As I mentioned in the first article of this series (msdn.microsoft.com/magazine/hh335062), it’s always a good idea to use <!DOCTYPE html> at the top of all your HTML pages to ensure that the latest features in the browser are available.\n\nThe simplest course of action you can take for users whose browsers don’t support canvas is to use a fallback element such as image or text. For instance, to display a fallback image to users, you can use markup that looks like this:\n\nAny content you place inside of the <canvas> tag will be rendered only if the user’s browser doesn’t support canvas. That means that you can place images or text inside of your canvas as a simple, zero-checks fallback for your users.\n\nIf you want to take fallback support further, the good news is that a variety of polyfilling solutions exist for canvas, so you can feel comfortable using it with older browsers as long as you carefully vet potential solutions and stay aware of the limitations of a given polyfill. As I’ve stated in other articles in this series, your starting point for finding a polyfill for any HTML5 technology should be the HTML5 Cross Browser Polyfills page in the Modernizr wiki on GitHub (bit.ly/nZW85d). As of this writing, there are several canvas polyfills available, including two that fall back to Flash and Silverlight.\n\nIn the downloadable demo project for this article, I use explorercanvas (code.google.com/p/explorercanvas), which uses Internet Explorer-supported Vector Markup Language (VML) to create close approximations of canvas functionality, and canvas-text (code.google.com/p/canvas-text), which adds additional support for rendering text in older browsers.\n\nAs illustrated in previous articles, you can use Modernizr to feature-detect support for canvas (and canvastext) in a browser by calling Modernizr.canvas and then use Modernizr.load to asynchronously load explorercanvas when needed. For more information, see modernizr.com.\n\nIf you don’t want to use Modenrizr, there’s another way to conditionally add explorercanvas for older versions of IE: conditional comments:\n\nWhen Internet Explorer 8 or older versions encounter a comment formatted as such, they will execute the block as an if statement and include the explorercanvas and canvas-text script files. Other browsers, including Internet Explorer 10, will treat the entire block as a comment and ignore it altogether.\n\nWhen evaluating a potential polyfill for your application, be sure to look into how much of the 2D drawing context a given polyfill supports. Few of them provide full support for every use, though nearly all can handle the basic cases we looked at in this article.\n\nThough I couldn’t cover everything here, there’s a lot more you can do with canvas, from responding to click (and other) events and changing canvas data, to animating the drawing surface, rendering and manipulating images pixel-by-pixel, saving state, and exporting the entire surface as its own image. In fact, there are entire books on canvas out there. You don’t have to be a game developer to experience the power of canvas, and I hope I convinced you of that as I walked through the basics in this article. I encourage you to read the specifications for yourself, and jump in to this exciting new graphics technology with both feet.\n\nIf you’re looking for more information on canvas support in Internet Explorer 9, check out the IE9 Developer Guide online (msdn.microsoft.com/ie/ff468705). Also, be sure to check out the Canvas Pad demos available at the IE Test Drive site (bit.ly/9v2zv5). For a list of a few other cross-browser polyfills for canvas, check out the complete polyfilling list at (bit.ly/eBMoLW).\n\nFinally, all of the demos for this article—which are available online—were built using WebMatrix, a free, lightweight Web development tool from Microsoft. You can try WebMatrix out for yourself at aka.ms/webm.\n\nBrandon Satrom works as a developer evangelist for Microsoft outside of Austin. You can follow him on Twitter at twitter.com/BrandonSatrom.\n\nThanks to the following technical experts for reviewing this article: Jatinder Mann and Clark Sell"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web",
        "document": "Matrices can be used to represent transformations of objects in space, and are used for performing many key types of computation when constructing images and visualizing data on the Web. This article explores how to create matrices and how to use them with CSS transforms and the transform type. While this article uses CSS to simplify explanations, matrices are a core concept used by many different technologies including WebGL, the WebXR (VR and AR) API, and GLSL shaders. This article is also available as an MDN content kit. The live examples use a collection of utility functions available under a global object named .\n\nThere are many types of matrices, but the ones we are interested in are the 3D transformation matrices. These matrices consist of a set of 16 values arranged in a 4×4 grid. In JavaScript, it is easy to represent a matrix as an array. Let's begin by considering the identity matrix. This is a special transformation matrix which functions much like the number 1 does in scalar multiplication; just like n * 1 = n, multiplying any matrix by the identity matrix gives a resulting matrix whose values match the original matrix. The identity matrix looks like this in JavaScript: What does multiplying by the identity matrix look like? The easiest example is to multiply a single point by the identity matrix. Since a 3D point only needs three values ( , , and ), and the transformation matrix is a 4×4 value matrix, we need to add a fourth dimension to the point. By convention, this dimension is called the perspective, and is represented by the letter . For a typical position, setting to 1 will make the math work out. After adding the component to the point, notice how neatly the matrix and the point line up: The component has some additional uses that are out of scope for this article. Check out the WebGL model view projection article for a look into how it comes in handy.\n\nIn our example code we have defined a function to multiply a matrix and a point — : // point\n• matrix function multiplyMatrixAndPoint(matrix, point) { // Give a simple variable name to each part of the matrix, a column and row number let c0r0 = matrix[0], c1r0 = matrix[1], c2r0 = matrix[2], c3r0 = matrix[3]; let c0r1 = matrix[4], c1r1 = matrix[5], c2r1 = matrix[6], c3r1 = matrix[7]; let c0r2 = matrix[8], c1r2 = matrix[9], c2r2 = matrix[10], c3r2 = matrix[11]; let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15]; // Now set some simple names for the point let x = point[0]; let y = point[1]; let z = point[2]; let w = point[3]; // Multiply the point against each part of the 1st column, then add together let resultX = x * c0r0 + y * c0r1 + z * c0r2 + w * c0r3; // Multiply the point against each part of the 2nd column, then add together let resultY = x * c1r0 + y * c1r1 + z * c1r2 + w * c1r3; // Multiply the point against each part of the 3rd column, then add together let resultZ = x * c2r0 + y * c2r1 + z * c2r2 + w * c2r3; // Multiply the point against each part of the 4th column, then add together let resultW = x * c3r0 + y * c3r1 + z * c3r2 + w * c3r3; return [resultX, resultY, resultZ, resultW]; } Note: Our examples on this page use row vectors to represent points and right-multiplication to apply transformation matrices. That is, the above does where is a 4x1 row vector. If you want to use column vectors and left-multiplication, you need to adjust the multiplication function accordingly, and transpose each matrix introduced below. For example, the introduced below originally looks like: After transposition, it would look like: Now using the function above we can multiply a point by the matrix. Using the identity matrix it should return a point identical to the original, since a point (or any other matrix) multiplied by the identity matrix is always equal to itself: Returning the same point is not very useful, but there are other types of matrices that can perform helpful operations on points. The next sections will demonstrate some of these matrices.\n\nA translation matrix is based upon the identity matrix, and is used in 3D graphics to move a point or object in one or more of the three directions ( , , and/or ). The easiest way to think of a translation is like picking up a coffee cup. The coffee cup must be kept upright and oriented the same way so that no coffee is spilled. It can move up in the air off the table and around the air in space. You can't actually drink the coffee using only a translation matrix, because to drink it, you have to be able to tilt or rotate the cup to pour the coffee into your mouth. We'll look at the type of matrix (cleverly called a rotation matrix) you use to do this later. let x = 50; let y = 100; let z = 0; let translationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1]; Place the distances along the three axes in the corresponding positions in the translation matrix, then multiply it by the point or matrix you need to move through 3D space.\n\nA rotation matrix is used to rotate a point or object. Rotation matrices look a little bit more complicated than scaling and transform matrices. They use trigonometric functions to perform the rotation. While this section won't break the steps down into exhaustive detail (check out this article on Wolfram MathWorld for that), take this example for illustration. First, here's code that rotates a point around the origin without using matrices. // Manually rotating a point about the origin without matrices let point = [10, 2]; // Calculate the distance from the origin let distance = Math.sqrt(point[0] * point[0] + point[1] * point[1]); // The equivalent of 60 degrees, in radians let rotationInRadians = Math.PI / 3; let transformedPoint = [ Math.cos(rotationInRadians) * distance, Math.sin(rotationInRadians) * distance, ]; It is possible to encode these type of steps into a matrix, and do it for each of the , , and dimensions. Below is the representation of a counterclockwise rotation about the Z axis in a left-handed coordinate system: let sin = Math.sin; let cos = Math.cos; // NOTE: There is no perspective in these transformations, so a rotation // at this point will only appear to only shrink the div let a = Math.PI * 0.3; //Rotation amount in radians // Rotate around Z axis let rotateZMatrix = [ cos(a), -sin(a), 0, 0, sin(a), cos(a), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, ]; Here are a set of functions that return rotation matrices for rotating around each of the three axes. One big note is that there is no perspective applied, so it might not feel very 3D yet. The flatness is equivalent to when a camera zooms in really close onto an object in the distance — the sense of perspective disappears.\n\nThe real power of matrices comes from matrix composition. When matrices of a certain class are multiplied together they preserve the history of the transformations and are reversible. This means that if a translation, rotation, and scale matrix are all combined together, when the order of the matrices is reversed and re-applied, then the original points are returned. The order that matrices are multiplied in matters. When multiplying numbers, a * b = c, and b * a = c are both true. For example 3 * 4 = 12, and 4 * 3 = 12. In math, these numbers would be described as commutative. Matrices are not guaranteed to be the same if the order is switched, so matrices are non-commutative. Another mind-bender is that matrix multiplication in WebGL and CSS needs to happen in the reverse order that the operations intuitively happen. For instance, to scale something down by 80%, move it down 200 pixels, and then rotate about the origin 90 degrees would look something like the following in pseudocode.\n\nThe function that we will be using to compose our matrices is , which is part of the set of utility functions introduced near the top of this article. It takes an array of matrices and multiplies them together, returning the result. In WebGL shader code, this is built into the language and the operator can be used. Additionally this example uses and functions, which return matrices as defined above. let transformMatrix = MDN.multiplyArrayOfMatrices([ rotateAroundZAxis(Math.PI * 0.5), // Step 3: rotate around 90 degrees translate(0, 200, 0), // Step 2: move down 200 pixels scale(0.8, 0.8, 0.8), // Step 1: scale down ]); Finally, a fun step to show how matrices work is to reverse the steps to bring the matrix back to the original identity matrix. let transformMatrix = MDN.multiplyArrayOfMatrices([ scale(1.25, 1.25, 1.25), // Step 6: scale back up translate(0, -200, 0), // Step 5: move back up rotateAroundZAxis(-Math.PI * 0.5), // Step 4: rotate back rotateAroundZAxis(Math.PI * 0.5), // Step 3: rotate around 90 degrees translate(0, 200, 0), // Step 2: move down 200 pixels scale(0.8, 0.8, 0.8), // Step 1: scale down ]);"
    },
    {
        "link": "https://mathjs.org/docs/datatypes/matrices.html",
        "document": "Math.js supports multi dimensional matrices and arrays. Matrices can be created, manipulated, and used in calculations. Both regular JavaScript arrays as well as the matrix type implemented by math.js can be used interchangeably in all relevant math.js functions. math.js supports both dense and sparse matrices.\n• , a regular JavaScript array. A multi dimensional array can be created by nesting arrays.\n• , a matrix implementation by math.js. A is an object wrapped around a regular JavaScript , providing utility functions for easy matrix manipulation such as , , , , and more.\n\nIn most cases, the type of matrix output from functions is determined by the function input: An as input will return an , a as input will return a . In case of mixed input, a is returned. For functions where the type of output cannot be determined from the input, the output is determined by the configuration option , which can be a string (default) or .\n\nA matrix can be created from an array using the function . The provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be created.\n\nMath.js supports regular Arrays. Multiple dimensions can be created by nesting Arrays in each other.\n\nMatrices can contain different types of values: numbers, complex numbers, units, or strings. Different types can be mixed together in a single matrix.\n\nThere are a number of functions to create a matrix with a specific size and content: , , .\n\nThe functions , , and also accept a single array or matrix containing the dimensions for the matrix. When the input is an Array, the functions will output an Array. When the input is a Matrix, the output will be a Matrix. Note that in case of numbers as arguments, the output is determined by the option as discussed in section Arrays and matrices.\n\nRanges can be created using the function . The function is called with parameters start and end, and optionally a parameter step. The start of the range is included, the end of the range is excluded.\n\nMost functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via .\n\nFunctions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.\n\nAny index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.\n\nIt’s not possible to broadcast in cases where the size in that dimension is higher than one.\n• A matrix is two or multi-dimensional.\n\nThe size of a matrix can be calculated with the function . Function returns a or , depending on the configuration option . Furthermore, matrices have a function as well, which always returns an Array.\n\nNote that the dimensions themselves do not have a meaning attached. When creating and printing a two dimensional matrix, the first dimension is normally rendered as the column, and the second dimension is rendered as the row. For example:\n\nIf you have a matrix where the first dimension means and the second means , this will look confusing since is printed as column (vertically) and as row (horizontally).\n\nMatrices can be resized using their function. This function is called with an Array with the new size as the first argument, and accepts an optional default value. By default, new entries will be set to , but it is possible to pass a different default value like to clearly indicate that the entries haven’t been explicitly set.\n\nOuter dimensions of a matrix can be squeezed using the function . When getting or setting a single value in a matrix using , the value is automatically squeezed or unsqueezed too.\n\nSubsets of a matrix can be retrieved or replaced using the function . Matrices have a function, which is applied to the matrix itself: . For both matrices and arrays, the static function can be used. When parameter is provided, the function will replace a subset in the matrix, and if not, a subset of the matrix will be returned.\n\nA subset can be defined using an . An contains a single value or a set of values for each dimension of a matrix. An can be created using the function . When getting a single value from a matrix, will return the value itself instead of a matrix containing just this value.\n\nThe function normally returns a subset, but when getting or setting a single value in a matrix, the value itself is returned.\n\nMatrix indexes in math.js are zero-based, like most programming languages including JavaScript itself. Note that mathematical applications like Matlab and Octave work differently, as they use one-based indexes.\n\nGetting and setting a value in a matrix #\n\nThere are two methods available on matrices that allow to get or set a single value inside a matrix. It is important to note that the method will mutate the matrix.\n\nWhen setting a value at a location outside of the current matrix size using the method , the matrix will be resized. By default, new items will be initialized with zero, but it is possible to specify an alternative value using the optional third argument .\n\nBoolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.\n\nFor example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.\n\nThe same can be accomplished in the parser in a much more compact manner. Please note that everything after are comments.\n\nThe expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.\n\nMatrices contain functions and to iterate over all elements of the (multidimensional) matrix. The callback function of and has three parameters: (the value of the currently iterated element), (an array with the index value for each dimension), and (the matrix being iterated). This syntax is similar to the and functions of native JavaScript Arrays, except that the index is no number but an Array with numbers for each dimension.\n\nYou can iterate over multiple matrices or arrays by using the function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.\n\nTo iterate over multiple matrices, you can use the function. The function applies a given function to each element of the matrices and returns a new matrix with the results.\n\nHere’s an example of iterating over two matrices and adding their corresponding elements:\n\nIn this example, the function takes matrices as the first two arguments and a callback function as the third argument. The callback function is applied to each element of the matrices, where represents the corresponding element from matrix and represents the corresponding element from matrix . The result is a new matrix with the element-wise sum of the two matrices.\n\nBy using broadcasting and the function, you can easily iterate over multiple matrices and perform element-wise operations.\n\nIt’s also possible to provide a callback with an index and the broadcasted arrays. Like or even . There is no specific limit for the number of matrices that can be mapped. Thus, the callback can have arguments, arguments in the case of including the index, or arguments in the case of including the index and the broadcasted matrices in the callback.\n\nAt this moment doesn’t include the same functionality.\n\nMath.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.\n• Dense matrix ( , ) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n\nThe type of matrix can be selected when creating a matrix using the construction functions , , , , and .\n\nYou can also coerce an array or matrix into sparse storage format with the function.\n\nCaution: called on a JavaScript array of n plain numbers produces a matrix with one column and n rows – in contrast to , which produces a 1-dimensional matrix object with n entries, i.e., a vector (not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain vector of length n).\n\nAll relevant functions in math.js support Matrices and Arrays. Functions like and , handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:\n• Functions like and , , , and to create a matrix.\n• Functions like and to get or replace a part of a matrix\n• Functions like and to manipulate matrices.\n\nA full list of matrix functions is available on the functions reference page.\n\nTwo types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible."
    },
    {
        "link": "https://github.com/greggman/wgpu-matrix",
        "document": "\n• Most other 3D math libraries are designed for WebGL, not WebGPU\n• WebGPU uses clip space Z 0 to 1, vs WebGL -1 to 1. So , , are different\n• Many other 3D math libraries are overly verbose\n• note that if you want to pre-create matrices you can still do this in wgpu-matrix\n\nNote: for translation, rotation, and scaling there are 2 versions of each function. One generates a translation, rotation, or scaling matrix. The other translates, rotates, or scales a matrix.\n\nFunctions take an optional destination to hold the result.\n\nThere is also the minified version\n\nNote: You're unlikely to need any thing except , , , , , and but, there are 3 sets of functions, each one returning a different default\n\nJust to be clear, , like most functions, takes a destination so\n\nThe only difference between the sets of functions is what type they default to returning.\n\n, , and all return matrices with Z clip space from 0 to 1 (unlike most WebGL matrix libraries which return -1 to 1)\n\nmakes an all zero matrix if passed no parameters. If you want an identity matrix call\n\nuses the space of 12 elements\n\nThis is because WebGPU requires mat3s to be in this format and since this library is for WebGPU it makes sense to match so you can manipulate mat3s in TypeArrays directly.\n\nin this library uses 3 floats per but be aware that an array of in a Uniform Block or other structure in WGSL, each vec3 is padded to 4 floats! In other words, if you declare\n\nthen bar[0] is at byte offset 0, bar[1] at byte offset 16, bar[2] at byte offset 32.\n\nSee the WGSL spec on alignment and size.\n\nWebGPU follows the same conventions as OpenGL, Vulkan, Metal for matrices. Some people call this \"column major\". The issue is the columns of a traditional \"math\" matrix are stored as rows when declaring a matrix in code.\n\nTo put it another way, the translation vector is in elements 12, 13, 14\n\nThis issue has confused programmers since at least the early 90s 😌\n\nMost functions take an optional destination as the last argument. If you don't supply it, a new one (vector, matrix) will be created for you.\n\nFor me, most of the stuff I do in WebGPU, the supposed performance I might lose from using the convenient style is so small as to be unmeasurable. I'd prefer to stay convenient and then, if and only if I find a performance issue, then I might bother to switch to the performant style.\n\nAs the saying goes premature optimization is the root of all evil. 😉\n\nIn JavaScript there should be no difference in the API except for the removable of .\n\nIn TypeScript, 3.x should mostly be type compatible with 2.x. 3.x is an attempt to fix the casting that was necessary in 2.x.\n\nIn TypeScript the differences are as follows\n\nIn 3.x each function has a default type but if you pass it a destination it returns the type of the destination\n\nThis is means code like this\n\nNo longer works because is a .\n\nBUT, functions take any of the normal types as an argument just like they used to\n\nIf you really want types for each concrete type there's\n\nNote: that in general you're unlikely to need any of these. Just use the same ones you were using in 2.x\n• changed from a \"camera matrix\" to a \"view matrix\" (same as gluLookAt). If you want a matrix that orients an something in world space see . Sorry about this change but people are used to lookAt making a a view matrix and it seemed prudent to make this change now and save more people from frustration going forward.\n\nYou can run tests in the browser by starting a local server\n\nNow go to wherever your server serves pages. In the case of that's probably http://localhost:8080/test/.\n\nBy default the tests test the minified version. To test the source use as in http://localhost:8080/test/?src=true.\n\nTo limit which tests are run use . For example http://localhost:8080/test/?src=true&grep=mat3.*?translate runs only tests with followed by in the name of test."
    },
    {
        "link": "https://npmjs.com/package/math3d",
        "document": "\n• Only the necessary classes and functions for 3D graphics.\n\nAs I used this project later on with Unity3D, I tried to keep everything as similar as possible. The coordinate system is the same as in Unity: y-Axis up, x-Axis right, z-Axis forward. The rotation order for Euler angles (used in Quaternion) is z then x then y.\n\nA three-dimensional vector with x, y, z values; used for positions, directions or scales in 3D space.\n• homogeneous: Returns the homogeneous Vector4 with w value 1 (readonly)\n• values: An array containing the x, y, z values (readonly)\n• vector4: Returns the responding Vector4 with w value 0 (readonly)\n• Vector3([x: Number], [y: Number], [z: Number])\n• Creates a Vector3 from the given x, y, z components\n• All parameters are optional with default value 0\n• Vector3.FromVector4(vector4)\n• Creates a Vector3 from a Vector4 by clipping the w value\n• add(vector3: Vector3) -> Vector3\n• Returns the sum of two vectors\n• average(vector3: Vector3) -> Vector3\n• Returns the average of two vectors\n• distanceTo(vector3: Vector3) -> Number\n• Distance from one vector to another\n• equals(vector3: Vector3) -> Boolean\n• Returns true if two vectors are equal\n• negate() -> Vector3\n• Returns a vector with the opposite direction (multiplied by -1)\n• scale(vector3: Vector3) -> Vector3\n• Scales the vector component by component with the given vector\n• sub(vector3: Vector3) -> Vector3\n• Subtracts one vector from another (this - vector3)\n• toString() -> String\n• A string responding to the vector in form (x,y,z)\n\nA four-dimensional vector with x, y, z, w values. Used mostly for homogeneous coordinates.\n• values: An array containing the x, y, z, w values (readonly)\n• Vector4([x: Number], [y: Number], [z: Number], [w: Number])\n• Creates a Vector4 from the given x, y, z, w components\n• All parameters are optional with default value 0\n• add(vector4: Vector4) -> Vector4\n• Returns the sum of two vectors\n• distanceTo(vector4: Vector4) -> Number\n• Distance from one vector to another\n• equals(vector4: Vector4) -> Boolean\n• Returns true if two vectors are equal\n• negate() -> Vector4\n• Returns a vector with the opposite direction (multiplied by -1)\n• sub(vector4: Vector4) -> Vector3\n• Subtracts one vector from another (this - vector4)\n• toString() -> String\n• A string responding to the vector in form (x,y,z,w)\n\nEach quaternion is composed of a vector (xyz) and a scalar rotation (w). Although their values are not very intuitive, they are used instead of the Euler angles to:\n• avoid multiple representation of the same rotation\n\nIt is advised not to use the x, y, z, w values directly, unless you really know what you are doing.\n• angleAxis: Angle Axis representation of the quaternion in form {axis: (Vector3), angle: Number} (readonly)\n• eulerAngles: Euler angles responding to the quaternion in form {x: Number, y: Number, z: Number} (readonly)\n• Quaternion([x: Number], [y: Number], [z: Number], [w: Number])\n• Creates a quaternion from the given x, y, z, w values\n• All values are optional with default value 0 for x, y, z and 1 for w\n• Quaternion.Euler(x: Number, y: Number, z: Number)\n• Creates a quaternion that is rotated /z/ degrees around z-axis, /x/ degrees around x-axis and /y/ degrees around y-axis, in that exact order\n• Quaternion.AngleAxis(axis: Vector3, angle: Number)\n• Creates a quaternion that responds to a rotation of /angle/ degrees around /axis/\n• angleTo(quaternion: Quaternion) -> Number\n• Angle between two quaternions in degrees (0 - 180)\n• conjugate() -> Quaternion\n• Returns the conjugate of the quaternion (defined as (-x, -y, -z, w))\n• distanceTo(quaternion: Quaternion) -> Number\n• A notion to measure the similarity between two quaternions (quick)\n• The return value varies between 0 and 1. Same quaternions return 0.\n• dot(quaternion: Quaternion) -> Number\n• Dot (inner) product of two quaternions\n• equals(quaternion: Quaternion) -> Boolean\n• Returns true if two quaternions are equal\n• inverse() -> Quaternion\n• Returns the inverse of the quaternion (inverse = conjugate)\n• mul(quaternion: Quaternion) -> Quaternion\n• Right multiplies the quaternion in the argument (this * quaternion)\n• mulVector3(vector3: Vector3) -> Vector3\n• Multiplies the quaternion with the vector (applies rotation)\n• toString() -> String\n• A string responding to the quaternion in form (x,y,z,w)\n\nA 4x4 matrix with some required functions for translation, rotation and scaling.\n• columns: An two-dimensional array containing the columns of a matrix (readonly)\n• m11: first element of first row\n• m12: second element of first row\n• m13: third element of first row\n• m21: first element of second row\n• m22: second element of second row\n• m23: third element of second row\n• m31: first element of third row\n• m32: second element of third row\n• m33: third element of third row\n• rows: An two-dimensional array containing the rows of a matrix (readonly)\n• size: Size (number of rows and columns) of a matrix in form {rows: Number, columns: Number} (readonly)\n• values: A one-dimensional array containing the elements of the matrix (rows first) (readonly)\n• Matrix4x4(data: Array)\n• Creates a 4x4 matrix with the given number array\n• If the length of the array is smaller, the rest is filled with zeros\n• Matrix4x4.FlipMatrix(flipX: Boolean, flipY: Boolean, flipZ: Boolean)\n• Creates a matrix that changes the direction of the axii that are chosen to be flipped\n• Matrix4x4.ScaleMatrix(scale: Number|Vector3)\n• Creates a scaling matrix with the given scale factor\n• Scale factor can also be given as a number, a uniform vector of it will be created automatically\n• Matrix4x4.RotationMatrix(quaternion: Quaternion)\n• Creates a rotation matrix for the given quaternion\n• Matrix4x4.TranslationMatrix(translation: Vector3)\n• Creates a translation matrix from the given vector\n• Matrix4x4.LocalToWorldMatrix(position: Vector3, rotation: Quaternion, scale: Number|Vector3)\n• Creates a matrix that transforms from a local space to the world space\n• The local coordinate system is at /position/ with /rotation/ according to the world space\n• Matrix4x4.WorldToLocalMatrix(position: Vector3, rotation: Quaternion, scale: Number|Vector3)\n• Creates a matrix that transforms from world space to a local space\n• The local coordinate system is at /position/ with /rotation/ according to the world space\n• inverse() -> Matrix4x4|undefined\n• Inverse of the matrix, undefined if it is not unique\n• negate() -> Matrix4x4\n• The negative matrix computed by multiplying the matrix by -1\n• add(matrix4x4: Matrix4x4) -> Matrix4x4\n• Returns the sum of two matrices\n• sub(matrix4x4: Matrix4x4) -> Matrix4x4\n• Subtracts one matrix from another (this - matrix4x4)\n• mul(matrix4x4: Matrix4x4) -> Matrix4x4\n• Right multiplies with the given matrix (this * matrix4x4)\n• mulVector3(vector3: Vector3) -> Vector3\n• Multiplies the matrix with the given vector\n• Uses the homogeneous vector representation for the multiplication\n\nA class to contain the position and the rotation of an object and create an object hierarchy.\n• Space: An enumeration to decide in which coordinate system to operate\n• Self: Applies transformation relative to the local coordinate system\n• localToWorldMatrix: A matrix to transform points from local space to world space (readonly)\n• name: Name of the object (default: \"object\")\n• parent: Parent transform of the object (undefined if none)\n• right: Right vector in world coordinate system (readonly)\n• root The topmost transform in the hierarchy (readonly)\n• up: Up vector in world coordinate system (readonly)\n• worldToLocalMatrix: A matrix to transform points from world space to local space (readonly)\n• Transform([position: Vector3], [rotation: Quaternion])\n• Creates a transform object at the given position and rotation\n• Parameters are optional with default values Vector3.zero and Quaternion.identity respectively\n• translate(translation: Vector3, [relativeTo: Transform.Space]) -> Transform\n• /relativeTo/ is optional with default value Transform.Space.Self\n• rotate(x: Number, y: Number, z: Number, [relativeTo: Transform.Space]) -> Transform\n• Rotates /z/ degrees around z-axis, /x/ degrees around x axis and /y/ degrees around y-axis relative to /relativeTo/ in that exact order\n• /relativeTo/ is optional with default value Transform.Space.Self"
    },
    {
        "link": "https://mathjs.org/docs/reference/functions/rotationMatrix.html",
        "document": "Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians). Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3)."
    }
]