[
    {
        "link": "https://stackoverflow.com/questions/9397288/dynamically-allocate-memory-for-struct",
        "document": "This assignment requires you to have a not completely initialized object around until you can update it with the information provided by the user. That is a very bad idea in general, because the mere possibility of having a not completely initialized object (e.g. in this case lacking a proper id value) makes the code using that object more complex because it has to check whether, for example, there is a proper id value. And that complexity for proper use, plus failures to recognize that the complexity is needed for proper use, attracts bugs like mad – ungood.\n\nThat is why C++, extending C, provided a very strong coupling between allocation and initialization. With a C++ expression you get either both a successful allocation and a successful complete initialization, or else neither (it cleans up on failure). That is what the question should better teach!\n\nSo instead of the given question quoted above, I'm going to teach you acceptable C++ practice (although using is generally to be avoided), which means answering this modified question:\n\nOK, here goes:\n\nFor each executed expression (which does allocation and initialization) there should ideally be a corresponding execution of a expression, which cleans up and deallocates the memory block so that it can be reused. And the expression should ideally be executed even if something fails and throws an exception. Hence the and .\n\nHowever, coding it like that is error prone and verbose.\n\nInstead, in more idiomatic C++ programming one will use a smart pointer, an object that holds a pointer and provides pointer operations (so it looks like it is a pointer), and whose destructor automatically executes a expression when the pointer is no longer used. The C++ standard library has several such smart pointer classes. As a general rule, use the most restrictive smart pointer that you can, because it has least overhead and will most likely support conversion to more general smart pointers, while the opposite is much less likely, downright unlikely.\n\nSo in this case, you can use e.g. C++11 or if your compiler is old, C++03 , both from the header:\n\nBut, except for the assignment's requirement to use dynamic allocation, a program with the functionality above would be written without any dynamic allocation or smart pointers. The function would just return a object by value, copying. It is almost a paradox, but modern C++ is very heavily based on copying, and still yields pretty fast programs!\n\nOf course, under the hood there are a large number of dirty tricks to avoid that the copying actually happens in the machine code."
    },
    {
        "link": "https://stackoverflow.com/questions/28767839/memory-management-for-linked-list-and-tree-programs-in-c",
        "document": "I solve algoritm questions from sites like leetcode, hacker rank or cracking the coding interview. I do most if the questions in c++. So for most of them i have a node struct as below\n\nthen i have a function(s) which implements the algorithm\n\nand finally i create the nodes in the main\n\nI want to incorporate memory management in this kind of solutions. If i use c++11 shared_ptr do i need to provide a destructor ? if yes what should i write in the destructor ? But i found that shared_ptr makes code overly complex and un-understandbale for such small programs.\n\nIn general what is the best way to make solving such questions memory safe ?"
    },
    {
        "link": "https://geeksforgeeks.org/binary-tree-data-structure",
        "document": "A Binary Tree Data Structure is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. It is commonly used in computer science for efficient storage and retrieval of data, with various operations such as insertion, deletion, and traversal.\n• None Removing an edge divides in two halves ?\n• None All possible binary trees with given Inorder\n• None Convert a tree to forest of even nodes\n• None Root to leaf paths without using recursion\n• None Check if Preorder, Inorder and Postorder are of same tree\n• None Maximum sum with no two adjacent\n• None Distance between two given keys\n• None Modify a binary tree to get Preorder traversal using right pointers\n• None Full Binary Tree using its Preorder and Mirror's Preorder\n• None Check if there is a root to leaf path with given sequence\n• None Remove all nodes which don’t lie in any path with sum>= k\n• None Sum of nodes at k-th level in a tree represented as string\n• None Sum of all the numbers that are formed from root to leaf paths\n• None Merge Two Binary Trees by doing Node Sum (Recursive and Iterative)\n• None Root of the tree from children ID sums"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/2l1rit/c_dynamic_memory_allocation_in_binary_search_trees",
        "document": "I was watching a video about binary search trees, and I noticed their code was using \"new\" statements, but they never put any \"delete\" statements.\n\nI was always taught that every \"new\" statement had to have a corresponding \"delete\" statement.\n\nHere's the link their github page for the source.\n\nI looked at other BST implementations, and all of those also had \"new\" statements without matching \"delete\" statements. Is there a reason why they're not deleting it at the end, or have I been looking at bad code? Or am I just an idiot and not understanding something basic?"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/369995/optimal-way-of-storing-sorted-tree-in-memory",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://stackoverflow.com/questions/574543/writing-all-program-output-to-a-txt-file-in-c",
        "document": "I need to write all my program output to a text file. I believe it's done this way,\n\nwhere sOutFile is the ofstream object that creates the file like this:\n\nWhen I insert the stdout into the sOutFile object, I get some code which seems to resemble [hexadecimal] code or an address of some kind in the text file that I created.\n\nBut what's confusing to me is that in my program I use cout several times. Mostly just literal statement. If I'm not mistaken that is the program output.\n\nIf this code is an address, would it contain all of my output? Could I read it back in to the program and find out that way?\n\nWhat can I do to get ALL of my program output written to a text file?"
    },
    {
        "link": "https://cplusplus.com/forum/beginner/222542",
        "document": "I decided to play around with it, to see if control characters such as \n\n and \\t worked, which they do. Obviously saving to the same filename every time is not desirable, so I thought I'd try to include code to ask for a filename and allocate it to a variable and replace the filename in the code with the variable. Unfortunately, it doesn't work.\n\n \n\n std; main () { string a, b, fileName; cout << ; cin fileName; ofstream txtOut; txtOut.open (fileName); txtOut << ; txtOut << ; a = ; b = ; txtOut << b+a; // this demonstrates the use of tabs txtOut << b << << a; txtOut.close(); 0; } \n\n \n\n It works with CodeBlocks but not with wxDev-C++ nor with Falcon IDE. What is wrong and what needs to be done to correct it? After spending time trying to find out how to direct output to a printer (I use a wireless printer) without success, I decided to look at printing to a text file instead. I found this code on cplusplus by googling and this works.I decided to play around with it, to see if control characters such as \n\n and \\t worked, which they do. Obviously saving to the same filename every time is not desirable, so I thought I'd try to include code to ask for a filename and allocate it to a variable and replace the filename in the code with the variable. Unfortunately, it doesn't work.It works with CodeBlocks but not with wxDev-C++ nor with Falcon IDE. What is wrong and what needs to be done to correct it?\n\nIt works with CodeBlocks but not with wxDev-C++ nor with Falcon IDE. What is wrong and what needs to be done to correct it? \n\n Since this is a C++11 feature you need to insure you're compiling code using a C++11 or higher compatible compiler. You could also try using a C-string when opening the file (ofstream txtOut(fileName.c_str);)\n\n \n\n Since this is a C++11 feature you need to insure you're compiling code using a C++11 or higher compatible compiler. You could also try using a C-string when opening the file (ofstream txtOut(fileName.c_str);)\n\n@jlb\n\n They are all using Gcc but wxDev-C++ and Falcon IDE also use MingW. They are all recent installs, so I assume all are C++11 or higher. Using your suggestion results in error for all IDEs.\n\n \n\n @AbstractionAnon\n\n The original code works Ok and the later code works in Codeblocks. It comes up with errors for line 13 and doesn't compile.\n\n \n\n Codeblocks worked without the #include <string> header. It made no difference to the other two IDEs.\n\n I've no idea why the >> operator was missing in line 10. It's there in my code and I did a copy and paste. Obviously, it won't work without it.\n\n \n\n is it likely to be anything to do with MingW? I mainly use Codeblocks, but I would like it to work in the other two.\n\n \n\n Thanks very much for your help.\n\nMost IDEs don't do much configuration of the compiler by default, so you probably need to have the IDE tell the compiler to use C++11 or higher, depending on the version of the compiler. Until fairly recently g++ defaulted to gnu98 \"standard\", so you may need to add a compile switch (-std=c++11) to insure C++11 compiling. You'll need to read your IDE documentation to see how to accomplish this."
    },
    {
        "link": "https://stackoverflow.com/questions/48611578/c-ofstream-writing-variables-into-a-text-file",
        "document": "I wasn't able to find any obvious answers to this, and I'm pretty stumped.\n\nDo I need to do something different when I want to write a variable string into a text document compared to what I need to do when I want to write just a set string into said document?\n\nThis code would properly write \"set string\" on 8 individual lines on newfile.txt (and create it).\n\nBut this would leave the file completely empty, even if line_vector[i] itself has strings within it (and cout can print them)\n\nI tried to look at the documentation and do it the same way as they had done, but I'm having no success here. Obviously because of my own failure, but I just can't figure out where I'm in the wrong here.\n\nThe only difference with those two codes are in the lines where I'm trying to write into the document\n\nmain() that I tried to trim down so it has less dynamic functionality (no manual inputs) but still does not work:\n\nThe text file \"a.txt\" has just a couple of lines of random strings\n\nAnd the function itself"
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    }
]