[
    {
        "link": "https://geeksforgeeks.org/python-using-2d-arrays-lists-the-right-way",
        "document": "Python | Using 2D arrays/lists the right way\n\nPython provides powerful data structures called lists, which can store and manipulate collections of elements. Also provides many ways to create 2-dimensional lists/arrays. However one must know the differences between these ways because they can create complications in code that can be very difficult to trace out. In this article, we will explore the right way to use 2D arrays/lists in Python.\n\nUsing 2D arrays/lists the right way\n\nUsing 2D arrays/lists the right way involves understanding the structure, accessing elements, and efficiently manipulating data in a two-dimensional grid. When working with structured data or grids, 2D arrays or lists can be useful. A 2D array is essentially a list of lists, which represents a table-like structure with rows and columns.\n\nIn Python, Initializing a collection of elements in a linear sequence requires creating a 1D array, which is a fundamental process. Although Python does not have a built-in data structure called a ‘1D array’, we can use a list that can achieve the same functionality. Python lists are dynamic and versatile, making them an excellent choice for representing 1D arrays. Let’s start by looking at common ways of creating a 1d array of size N initialized with 0s.\n\nManually initializing and populating a list without using any advanced features or constructs in Python is known as creating a 1D list using “Naive Methods”.\n\nHere we are multiplying the number of rows by the empty list and hence the entire list is created with every element zero.\n\nUsing 2D arrays/lists the right way involves understanding the structure, accessing elements, and efficiently manipulating data in a two-dimensional grid. By mastering the use of 2D arrays, you can significantly improve your ability to handle complex data and efficiently perform various operations.\n\nHere we are multiplying the number of columns and hence we are getting the 1-D list of size equal to the number of columns and then multiplying it with the number of rows which results in the creation of a 2-D list.\n\nNote: Using this method can sometimes cause unexpected behaviors. In this method, each row will be referencing the same column. This means, even if we update only one element of the array, it will update the same column in our array.\n\nHere we are basically using the concept of list comprehension and applying a loop for a list inside a list and hence creating a 2-D list.\n\nHere we are appending zeros as elements for a number of columns times and then appending this 1-D list into the empty row list and hence creating the 2-D list.\n\nThe provided code demonstrates two different approaches to initializing a 2D array in Python. First, the array is initialized using a 2D list comprehension, where each row is created as . The entire array is created as a list of references to the same inner list, resulting in aliasing. Any change made to an element in one row will be reflected in all rows. The code then shows another approach using a nested list comprehension to create the 2D array . This method avoids aliasing by creating a new list for each row, resulting in a proper 2D array.\n\nWe expect only the first element of the first row to change to 1 but the first element of every row gets changed to 1 in method 2a. This peculiar functioning is because Python uses shallow lists which we will try to understand.\n\nIn method 1a, Python doesn’t create 5 integer objects but creates only one integer object, and all the indices of the array arr point to the same int object as shown.\n\n\n\nIf we assign the 0th index to another integer say 1, then a new integer object is created with the value of 1 and then the 0th index now points to this new int object as shown below\n\nSimilarly, when we create a 2d array as “arr = [[0]*cols]*rows” we are essentially extending the above analogy.\n• None Only one integer object is created.\n• None A single 1d list is created and all its indices point to the same int object in point 1.\n• None Now, arr[0], arr[1], arr[2] …. arr[n-1] all point to the same list object above in point 2.\n\nThe above setup can be visualized in the image below.\n\nNow lets change the first element in first row of “arr” as arr[0][0] = 1\n• None arr[0] points to the single list object we created we above.(Remember arr[1], arr[2] …arr[n-1] all point to the same list object too).\n• None The assignment of arr[0][0] will create a new int object with the value 1 and arr[0][0] will now point to this new int object.(and so will arr[1][0], arr[2][0] … arr[n-1][0])\n\nThis can be clearly seen in the below image.\n\n\n\nSo when 2d arrays are created like this, changing values at a certain row will affect all the rows since there is essentially only one integer object and only one list object being referenced by the all the rows of the array.\n\nAs you would expect, tracing out errors caused by such usage of shallow lists is difficult. Hence the better way to declare a 2d array is\n\nThis method creates 5 separate list objects, unlike method 2a. One way to check this is by using the ‘is’ operator which checks if the two operands refer to the same object.\n\nPython | Using 2D arrays/lists the right way – FAQs\n\nHow to convert 2D array to list in Python?\n\nHow to store 2D array in Python list?\n\nHow do you navigate a 2D list in Python?\n\nHow to get data from 2D array in Python?\n\nHow to read data from 2D array?\n\nHow to get value in 2D array?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://numpy.org/devdocs/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    },
    {
        "link": "https://ioflood.com/blog/python-2d-array",
        "document": "Are you needing to use 2D arrays in Python, but don’t know where to start? Many developers find themselves puzzled when it comes to handling 2D arrays in Python, but we’re here to help.\n\nThink of Python’s 2D arrays as a multi-storey building – allowing us to store data in multiple dimensions, providing a versatile and handy tool for various tasks.\n\nIn this guide, we’ll walk you through the process of working with 2D arrays in Python, from their creation, manipulation, and usage. We’ll cover everything from the basics of multi-dimensional arrays to more advanced techniques, as well as alternative approaches.\n\nTL;DR: How Do I Create a 2D Array in Python?\n\nIn this example, we’ve created a 2D array (or a matrix) with three rows and three columns. Each inner list , , and represents a row in the 2D array. When we print the array, we get the output as a nested list, which is the Pythonic way of representing a 2D array.\n\nIn Python, a 2D array is essentially a list of lists. The outer list represents the rows, and each inner list represents a row of elements, similar to how a row works in a matrix. Let’s dive into the basics of creating, accessing, modifying, and iterating over a 2D array in Python.\n\nFirst, let’s create a 2D array. As mentioned in the TL;DR section, we can create a 2D array by nesting lists within a list. Here’s an example:\n\nIn this example, we’ve created a 2D array with three rows and three columns. Each inner list represents a row in the 2D array.\n\nTo access elements in a 2D array, you need two indices – one for the row and one for the column. The first index refers to the row number and the second index refers to the column number.\n\nLet’s access the element in the second row, third column (remember, Python indexing starts at 0):\n\nModifying elements in a 2D array is similar to accessing elements. You specify the row and column indices of the element you want to modify. Let’s change the value in the first row, first column to 10:\n\nTo iterate over a 2D array, you can use a nested for loop. The outer loop iterates over the rows, and the inner loop iterates over each row’s elements. Here’s an example:\n\nIn this example, we printed each element in the 2D array, with each row’s elements separated by a space and each row separated by a new line.\n\nOnce you’ve grasped the basics of 2D arrays in Python, you can start exploring more complex uses. This section dives into multi-dimensional arrays and nested list comprehensions.\n\nPython allows you to create arrays with more than two dimensions. These are called multi-dimensional arrays. They are created and used similarly to 2D arrays but with an extra level of nesting for each additional dimension. Let’s create a 3D array:\n\nIn this example, we have a 3D array with two 2D arrays, each containing two rows of three elements. To access an element, we need three indices – one for the 2D array, one for the row, and one for the column.\n\nPython’s list comprehensions provide a concise way to create lists. You can also use them to create 2D arrays. Here’s an example of creating a 2D array using a nested list comprehension:\n\nIn this example, we’ve created a 2D array where each element is the product of its row and column indices (starting from 1). The outer list comprehension ( ) creates the rows, and the inner list comprehension ( ) creates the elements within each row.\n\nPython’s built-in list structure is versatile and powerful, but when it comes to numerical computations and handling large 2D arrays, there’s a more efficient alternative – the numpy library.\n\nNumpy is a Python library used for numerical computations and has a built-in 2D array object that offers more functionalities than the native Python 2D array. Let’s create a 2D array using numpy:\n\nAccessing and modifying elements in a numpy 2D array is similar to Python’s native 2D array. However, numpy provides more advanced features like element-wise operations, mathematical functions, and more.\n\nWhile numpy 2D arrays offer more functionalities and are more efficient for large-scale computations, they come with their own limitations. Numpy arrays are homogeneous, which means all elements must be of the same type. If you need to store different types of data, Python’s native 2D array (list of lists) would be more suitable.\n\nIf you’re working with numerical data, especially large data sets, numpy is a great choice due to its efficiency and additional functionalities. However, for general use and when working with mixed data types, Python’s native 2D arrays would be more suitable.\n\nWhile working with 2D arrays in Python, you might encounter a few common issues. This section will discuss these problems and how to overcome them.\n\nOne common issue is the ‘IndexError: list index out of range’ error. This occurs when you try to access an element at an index that doesn’t exist in the array. For example:\n\nIn this example, we tried to access the element in the fourth row, first column. However, our array only has three rows, so we get an ‘IndexError’.\n\nTo avoid this error, always ensure that the indices you’re using to access elements are within the range of the array’s dimensions.\n\nAnother common issue is trying to modify an element in an array of immutable elements, like strings. Python’s strings are immutable, so if you try to change a character in a string within a 2D array, you’ll get a ‘TypeError’.\n\nTo overcome this issue, you can create a new string with the desired changes and replace the old string in the array.\n\nWhen working with large 2D arrays, memory can become a concern. Python’s native 2D arrays (list of lists) can consume a lot of memory due to their flexible nature. If you’re working with large 2D arrays, you might want to consider using numpy 2D arrays, which are more memory-efficient.\n\nBefore we delve deeper into the intricacies of 2D arrays in Python, it’s essential to understand the fundamental concept of arrays and their implementation in Python.\n\nAn array is a data structure that stores a fixed-size sequence of elements of the same type. It’s like a container that holds a specific number of items, and all items are of the same type. This structure is beneficial when you want to store multiple items of the same type, like a list of integers or a list of strings.\n\nIn Python, arrays can be created using the ‘array’ module, but more often than not, lists are used instead due to their flexibility and functionality. In fact, Python’s ‘array’ module arrays are quite limited compared to lists, and are only used when you need to perform some operation that requires a specific functionality provided by these arrays.\n\nIn Python, arrays are implemented as lists. A list in Python is an ordered collection of items, and these items can be of any type. This is different from the traditional concept of arrays, where all elements must be of the same type.\n\nHere’s an example of a Python list:\n\nAs you can see, Python lists (or arrays) are very flexible. They can store items of different types, and they can be resized dynamically (items can be added or removed).\n\nIn the broader context of Python’s data structures, arrays (or lists) are just one of many. Python also provides other data structures like tuples, sets, and dictionaries, each with its own advantages and use cases.\n\nHowever, when it comes to storing and manipulating a collection of related items, arrays are one of the most commonly used data structures due to their flexibility and the wide range of operations they support.\n\nExpanding Your Knowledge: 2D Arrays and Beyond\n\nUnderstanding 2D arrays is just the beginning. They are the stepping stones to more complex data structures and techniques. The concept of 2D arrays is not limited to small scripts but is widely used in larger projects, data analysis, machine learning, and more. Let’s explore some of these related concepts.\n\nOnce you’re comfortable with 2D arrays, you might want to explore 3D arrays. These are arrays of 2D arrays, adding an extra level of complexity and usefulness. They are particularly useful in fields like physics and computer graphics.\n\nMatrices, which are a mathematical concept, can be represented as 2D arrays in Python. You can perform various matrix operations using Python’s numpy library.\n\nPandas is a Python library used for data manipulation and analysis. It provides data structures and functions needed to manipulate structured data.\n\nIt includes two primary data structures, Series (1-dimensional) and DataFrame (2-dimensional), to handle a vast majority of typical use cases in finance, statistics, social science, and engineering.\n\nTo deepen your understanding of Python arrays and related concepts, here are some resources you might find useful:\n• Python Data Types Tutorial: Getting Started – Learn how Python handles integers, floats, and complex numbers for numerical processing.\n• None Simplifying Variable Usage in Python – Learn how to declare and manipulate variables in Python for effective programming.\n• None Set Modification in Python Explained – Master the art of modifying sets in Python to perform set operations effectively.\n• None Python’s official documentation provides a comprehensive overview of data structures, including lists (or arrays).\n• None Numpy’s official documentation is a great resource for understanding numpy arrays and the operations you can perform on them.\n• None Pandas’ official documentation is a must-read if you’re interested in data analysis or data manipulation in Python.\n\nIn this comprehensive guide, we’ve delved into the world of Python 2D arrays, exploring their creation, manipulation, and usage. From basic operations to advanced techniques, we’ve covered a wide range of topics to give you a solid understanding of 2D arrays in Python.\n\nWe began with the basics, learning how to create a 2D array, access and modify its elements, and iterate over it. We then ventured into more advanced territory, exploring multi-dimensional arrays and nested list comprehensions.\n\nAlong the way, we tackled common issues you might encounter when working with 2D arrays in Python, such as out of range errors and memory considerations, providing you with solutions and workarounds for each issue.\n\nWe also looked at alternative approaches to handling 2D arrays, introducing the numpy library and its advantages and disadvantages. Here’s a quick comparison of these methods:\n\nWhether you’re a beginner just starting out with Python 2D arrays or an experienced developer looking to level up your skills, we hope this guide has given you a deeper understanding of 2D arrays in Python and their capabilities. Happy coding!"
    },
    {
        "link": "https://dev.to/m__mdy__m/a-deep-dive-into-two-dimensional-arrays-techniques-and-use-cases-44f3",
        "document": "A two-dimensional array is essentially an array of arrays, providing a way to store data in a matrix-like structure. This concept extends the idea of a one-dimensional array, where data is stored in a linear order, to two dimensions, allowing data to be organized in rows and columns. Two-dimensional arrays are particularly useful for representing data that naturally forms a grid, such as digital images or game boards.\n\nOne-Dimensional Array:\n\n A one-dimensional array is a list of elements stored in a single row. Each element in this list can be accessed using a single index. For example:\n\n\n\nHere, is a simple array containing four integers. Each element is accessed using its index, starting from 0. To access the third element (which has the value 2), you use:\n\n\n\nTwo-Dimensional Array:\n\n A two-dimensional array, on the other hand, is an array of arrays. Each element in a two-dimensional array is itself an array that can be accessed using two indices: one for the row and one for the column. For example:\n\n\n\nThis array can be visualized as a grid:\n\n\n\nTo access the element in the third row and second column (which has the value 5), you use:\n\n\n\nTwo-dimensional arrays can be initialized in various ways. One common method is to use nested loops to assign values to each element:\n\n\n\nThis creates a 4x4 array and initializes all elements to 0. Another way to initialize a two-dimensional array is to directly specify the values, as shown in the previous example.\n\nTwo-dimensional arrays are extremely useful in applications where data needs to be represented in a grid. For example, a grayscale image can be stored as a two-dimensional array, where each element represents the intensity of a pixel:\n\n\n\nHere, each number represents the brightness of a pixel, with 0 being black and 255 being white.\n\nTo iterate through every element of a two-dimensional array, nested loops are used. This allows you to access and manipulate each element by its row and column indices:\n\n\n\nThis example initializes each element to the sum of its row and column indices.\n\nA program can be written to create and display a grayscale image using a two-dimensional array. Each pixel's brightness is determined by the value stored in the array:\n\n\n\nIn this code, a 200x200 pixel canvas is created, and each pixel is assigned a random grayscale value. The loop then sets the color of each pixel accordingly.\n\nTwo-dimensional arrays can also store objects, making them useful for creating grids of objects in visual programs. For example, consider a grid of objects, where each cell's brightness oscillates over time:\n\n\n\nThis code creates a 10x10 grid of objects. Each cell oscillates in brightness over time, creating a dynamic visual effect.\n\nTwo-dimensional arrays are a powerful data structure that allow for the representation and manipulation of data in a matrix format. They extend the concept of one-dimensional arrays by adding an extra dimension, making them ideal for applications involving grids or matrices, such as images or game boards. Through the use of nested loops, elements in a two-dimensional array can be efficiently accessed and modified, enabling complex operations and visual representations.\n• \n• Perfect for data that is naturally organized in a grid, like images, game boards, or spreadsheets.\n• \n• Accessing and modifying elements using row and column indices is straightforward and efficient.\n• \n• Useful in various fields, from computer graphics and digital image processing to mathematical computations and simulations.\n• \n• Care must be taken to avoid accessing elements outside the defined array boundaries, which can cause runtime errors.\n• \n• Two-dimensional arrays can consume significant memory, especially for large datasets, so it's important to consider memory limitations.\n• \n• Operations on large two-dimensional arrays can be computationally intensive, so performance optimizations may be necessary for real-time applications.\n\nWhile two-dimensional arrays are highly effective, other data structures may be better suited for certain tasks:\n• \n• In languages like Python, lists of lists can provide more flexibility and dynamic sizing.\n• \n• For large grids with mostly empty values, sparse matrix representations can save memory.\n• \n• Depending on the specific application, custom data structures tailored to the problem may offer better performance or usability.\n\nUnderstanding and utilizing two-dimensional arrays can significantly enhance your ability to handle complex data structures and develop more sophisticated programs. Whether you're working on simple grid-based games or complex image processing tasks, mastering two-dimensional arrays is an essential skill for any programmer.\n\nExcited to delve deeper into the world of non-linear array addressing and beyond? My GitHub repository, Algorithms & Data Structures, offers a treasure trove of algorithms and data structures for you to explore.\n• Dive into: A diverse collection of algorithms and data structures awaits your exploration, providing ample opportunity to practice, solidify your knowledge, and refine your understanding.\n• Continuous Growth: While some sections are actively under development as part of my ongoing learning journey (estimated completion: 2-3 years), the repository is constantly expanding with new content.\n\nThe quest for knowledge doesn't end with exploration! I actively encourage feedback and collaboration. Encountered a challenge? Have a suggestion for improvement? Eager to discuss algorithms and performance optimization? Reach out and let's connect!\n• Join the Conversation:\n• Telegram: Join my channel here: https://t.me/medishn (Note: This is the preferred channel for the most up-to-date discussions)\n\nTogether, let's build a vibrant learning community where we can share knowledge and push the boundaries of our understanding."
    },
    {
        "link": "https://geeksforgeeks.org/get-unique-values-from-a-column-in-pandas-dataframe",
        "document": "In Pandas, retrieving unique values from DataFrame is used for analyzing categorical data or identifying duplicates. Let’s learn how to get unique values from a column in Pandas DataFrame.\n\nGet the Unique Values of Pandas using unique()\n\nThe.unique()method returns a NumPy array. It is useful for identifying distinct values in a column, which can be helpful when working with categorical data or detecting outliers. The order of the unique values is preserved based on their first occurrence.\n\nConsider the following example: we are retrieving and printing the unique values from the ‘B’ column using the unique() method.\n\nFind the unique values in a column using nunique()\n\nLet’s use .nunique() method to get the count of unique values in each column of the above dataframe.\n\nIn addition to the .unique() method, there are other ways to retrieve unique values from a Pandas DataFrame, including:\n\nGet Unique values from a Column in Pandas DataFrame using .drop_duplicates()\n\nThe .drop_duplicates() method removes duplicate values in the specified column, returning a DataFrame with only the unique values.\n\nExample: Get unique values from column ‘C’\n\nThis method returns the unique values as a Series and preserves the index of the original DataFrame.\n\nThe .value_counts() method counts the occurrences of each unique value in the column and returns the result as a Series.\n\nExample: Get unique values from column ‘D’ along with their counts\n\nThis method provides both the unique values and the frequency of each value. To extract just the unique values, you can use .index on the result.\n\nGet Unique values from a column in Pandas DataFrame using set()\n\nYou can also use Python’s built-in set() function, which converts the column values into a set, automatically removing duplicates.\n\nExample: Get unique values from column ‘D’\n\nUsing set() does not preserve the order of the unique values, but it is a quick way to get distinct values.\n• .unique() method returns a NumPy array of unique values, preserving their order of appearance.\n• .value_counts() method provides both the unique values and their frequency count.\n• set() function quickly returns unique values but does not preserve their order.\n\nGet unique values from a column in Pandas DataFrame – FAQs\n\nHow to get unique values from a column in a Pandas DataFrame?\n\nWhat methods are available for getting unique values in Pandas?\n\nHow to count unique values in a Pandas DataFrame?\n\nWhat is the difference between\n\nHow to handle NaN values when getting unique data in Pandas?"
    },
    {
        "link": "https://stackoverflow.com/questions/39403705/mean-of-values-in-a-column-for-unique-values-in-another-column",
        "document": "I am using Python 2.7 (Anaconda) for processing tabular data. I have loaded a textfile with two columns, e.g.\n\nmy goal is to calculate the mean over all values in the second column which match the unique values in the first one, e.g. the mean value for 1 would be 8.5, for 2 it would be two, for 3 it would be 4. First, I filtered out the unique values in the first column by extracting the column and applying np.unique() resulting in the array \"unique\". I created a loop that works when I define the unique value:\n\nwhere first and second are the specific columns. Now I want to make this not so specific. I tried\n\nbut it only returns the original second column. Does anybody have an idea on how to make this code non-specific? In reality, I have about 70k rows, so I cannot do it manually."
    },
    {
        "link": "https://stackoverflow.com/questions/63555186/compute-a-mean-of-an-array-group-by-unique-values-in-python",
        "document": "If I have an array\n\nHow can I compute the mean by each unique value in the array using .\n\nI'd like to have not using count or len but only\n\nI am just starting with Python."
    },
    {
        "link": "https://hackerearth.com/practice/machine-learning/data-manipulation-visualisation-r-python/tutorial-data-manipulation-numpy-pandas-python/tutorial",
        "document": "The pandas library has emerged into a power house of data manipulation tasks in python since it was developed in 2008. With its intuitive syntax and flexible data structure, it's easy to learn and enables faster data computation. The development of numpy and pandas libraries has extended python's multi-purpose nature to solve machine learning problems as well. The acceptance of python language in machine learning has been phenomenal since then.\n\nThis is just one more reason underlining the need for you to learn these libraries now. Published in early 2017, this blog claimed that python jobs outnumbered R jobs.\n\nIn this tutorial, we'll learn about using numpy and pandas libraries for data manipulation from scratch. Instead of going into theory, we'll take a practical approach.\n\nFirst, we'll understand the syntax and commonly used functions of the respective libraries. Later, we'll work on a real-life data set.\n\nNote: This tutorial is best suited for people who know the basics of python. No further knowledge is expected. Make sure you have python installed on your laptop.\n• 6 Important things you should know about Numpy and Pandas\n\n6 Important things you should know about Numpy and Pandas\n• The data manipulation capabilities of pandas are built on top of the numpy library. In a way, numpy is a dependency of the pandas library.\n• Pandas is best at handling tabular data sets comprising different variable types (integer, float, double, etc.). In addition, the pandas library can also be used to perform even the most naive of tasks such as loading data or doing feature engineering on time series data.\n• Numpy is most suitable for performing basic numerical computations such as mean, median, range, etc. Alongside, it also supports the creation of multi-dimensional arrays.\n• Numpy library can also be used to integrate C/C++ and Fortran code.\n• Remember, python is a zero indexing language unlike R where indexing starts at one.\n• The best part of learning pandas and numpy is the strong active community support you'll get from around the world.\n\nJust to give you a flavor of the numpy library, we'll quickly go through its syntax structures and some important commands such as slicing, indexing, concatenation, etc. All these commands will come in handy when using pandas as well. Let's get started!\n\nNumpy arrays are homogeneous in nature, i.e., they comprise one data type (integer, float, double, etc.) unlike lists.\n\nThe important thing to remember is that indexing in python starts at zero.\n\nNow, we'll learn to access multiple or a range of elements from an array.\n\nMany a time, we are required to combine different arrays. So, instead of typing each of their elements manually, you can use array concatenation to handle such tasks easily.\n\nUntil now, we used the concatenation function of arrays of equal dimension. But, what if you are required to combine a 2D array with 1D array? In such situations, np.concatenate might not be the best option to use. Instead, you can use np.vstack or np.hstack to do the task. Let's see how!\n\nAlso, we can split the arrays based on pre-defined positions. Let's see how!\n\nIn addition to the functions we learned above, there are several other mathematical functions available in the numpy library such as sum, divide, multiple, abs, power, mod, sin, cos, tan, log, var, min, mean, max, etc. which you can be used to perform basic arithmetic calculations. Feel free to refer to numpy documentation for more information on such functions.\n\nLet's move on to pandas now. Make sure you following each line below because it'll help you in doing data manipulation using pandas.\n\nRemember, describe() method computes summary statistics of integer / double variables. To get the complete information about the data set, we can use info() function.\n\nWe can sort the data by not just one column but multiple columns as well.\n\nOften, we get data sets with duplicate rows, which is nothing but noise. Therefore, before training the model, we need to make sure we get rid of such inconsistencies in the data set. Let's see how we can remove duplicate rows.\n\nHere, we removed duplicates based on matching row values across all columns. Alternatively, we can also remove duplicates based on a particular column. Let's remove duplicate values from the k1 column.\n\nNow, we will learn to categorize rows based on a predefined criteria. It happens a lot while data processing where you need to categorize a variable. For example, say we have got a column with country names and we want to create a new variable 'continent' based on these country names. In such situations, we will require the steps below:\n\nNow, we want to create a new variable which indicates the type of animal which acts as the source of the food. To do that, first we'll create a dictionary to map the food to the animals. Then, we'll use map function to map the dictionary's values to the keys. Let's see how is it done.\n\nAnother way to create a new variable is by using the assign function. With this tutorial, as you keep discovering the new functions, you'll realize how powerful pandas is.\n\nLet's remove the column animal2 from our data frame.\n\nWe frequently find missing values in our data set. A quick method for imputing missing values is by filling the missing value with any random number. Not just missing values, you may find lots of outliers in your data set, which might require replacing. Let's see how can we replace values.\n\nNow, let's learn how to rename column names and axis (row names).\n\nNext, we'll learn to categorize (bin) continuous variables.\n\nWe'll divide the ages into bins such as 18-25, 26-35,36-60 and 60 and above.\n\nAlso, we can pass a unique name to each label.\n\nLet's proceed and learn about grouping data and creating pivots in pandas. It's an immensely important data analysis method which you'd probably have to use on every data set you work with.\n\nNow, let's see how to slice the data frame.\n\nSimilarly, we can do Boolean indexing based on column values as well. This helps in filtering a data set based on a pre-defined condition.\n\nWe can also use a query method to select columns based on a criterion. Let's see how!\n\nPivot tables are extremely useful in analyzing data using a customized tabular format. I think, among other things, Excel is popular because of the pivot table option. It offers a super-quick way to analyze data.\n\nUp till now, we've become familiar with the basics of pandas library using toy examples. Now, we'll take up a real-life data set and use our newly gained knowledge to explore it.\n\nWe'll work with the popular adult data set.The data set has been taken from UCI Machine Learning Repository. You can download the data from here. In this data set, the dependent variable is \"target.\" It is a binary classification problem. We need to predict if the salary of a given person is less than or more than 50K.\n\nWe see that, the train data has 32561 rows and 15 columns. Out of these 15 columns, 6 have integers classes and the rest have object (or character) classes. Similarly, we can check for test data. An alternative way of quickly checking rows and columns is\n\nNow, let's check the missing values (if present) in this data.\n\nWe should be more curious to know which columns have missing values.\n\nLet's count the number of unique values from character variables.\n\nSince missing values are found in all 3 character variables, let's impute these missing values with their respective modes.\n\nLet's check again if there are any missing values left.\n\nNow, we'll check the target variable to investigate if this data is imbalanced or not.\n\nWe see that 75% of the data set belongs to <=50K class. This means that even if we take a rough guess of target prediction as <=50K, we'll get 75% accuracy. Isn't that amazing? Let's create a cross tab of the target variable with education. With this, we'll try to understand the influence of education on the target variable.\n\nWe see that out of 75% people with <=50K salary, 27% people are high school graduates, which is correct as people with lower levels of education are expected to earn less. On the other hand, out of 25% people with >=50K salary, 6% are bachelors and 5% are high-school grads. Now, this pattern seems to be a matter of concern. That's why we'll have to consider more variables before coming to a conclusion.\n\nIf you've come this far, you might be curious to get a taste of building your first machine learning model. In the coming week we'll share an exclusive tutorial on machine learning in python. However, let's get a taste of it here.\n\nWe'll use the famous and formidable scikit learn library. Scikit learn accepts data in numeric format. Now, we'll have to convert the character variable into numeric. We'll use the labelencoder function.\n\nIn label encoding, each unique value of a variable gets assigned a number, i.e., let's say a variable color has four values ['red','green','blue','pink'].\n\nLabel encoding this variable will return output as: red = 2 green = 0 blue = 1 pink = 3\n\nLet's check the changes applied to the data set.\n\nAs we can see, all the variables have been converted to numeric, including the target variable.\n\nNow, let's make prediction on the test set and check the model's accuracy.\n\nHurrah! Our learning algorithm gave 85% accuracy. Well, we can do tons of things on this data and improve the accuracy. We'll learn about it in future articles. What's next?\n\nIn this tutorial, we divided the train data into two halves and made prediction on the test data. As your exercise, you should use this model and make prediction on the test data we loaded initially. You can perform same set of steps we did on the train data to complete this exercise. In case you face any difficulty, feel free to share it in Comments below.\n\nThis tutorial is meant to help python developers or anyone who's starting with python to get a taste of data manipulation and a little bit of machine learning using python. I'm sure, by now you would be convinced that python is actually very powerful in handling and processing data sets. But, what we learned here is just the tip of the iceberg. Don't get complacent with this knowledge.\n\nTo dive deeper in pandas, check its documentation and start exploring. If you get stuck anywhere, you can drop your questions or suggestions in Comments below. Hope you found this tutorial useful."
    },
    {
        "link": "https://codecademy.com/article/introduction-to-numpy-and-pandas",
        "document": "pandas and NumPy are very useful libraries in Python. Let's learn how to use them!\n\nA pandas DataFrame can be easily changed and manipulated. Pandas has helpful functions for handling missing data, performing operations on columns and rows, and transforming data. If that wasn’t enough, a lot of SQL functions have counterparts in pandas, such as join, merge, filter by, and group by. With all of these powerful tools, it should come as no surprise that pandas is very popular among data scientists.\n\nPandas is a very popular library for working with data (its goal is to be the most powerful and flexible open-source tool, and in our opinion, it has reached that goal). DataFrames are at the center of pandas. A DataFrame is structured like a table or spreadsheet. The rows and the columns both have indexes, and you can perform operations on rows or columns separately.\n\nLearn about NumPy, a Python library used to store arrays of numbers, organize large amounts of data, and perform statistical calculations. Try it for free\n\nNumPy is an open-source Python library that facilitates efficient numerical operations on large quantities of data. There are a few functions that exist in NumPy that we use on pandas DataFrames. For us, the most important part about NumPy is that pandas is built on top of it. So, NumPy is a dependency of Pandas.\n\nIf you have Anaconda installed, NumPy and pandas may have been auto-installed as well! If they haven’t been, or if you want to update to the latest versions, you can open a terminal window and run the following commands:\n\nIf you don’t have Anaconda installed, you can alternatively install the libraries using by running the following commands from your terminal:\n\nOnce you’ve installed these libraries, you’re ready to open any Python coding environment (we recommend Jupyter Notebook). Before you can use these libraries, you’ll need to import them using the following lines of code. We’ll use the abbreviations and , respectively, to simplify our function calls in the future.\n\nNumPy arrays are unique in that they are more flexible than normal Python lists. They are called ndarrays since they can have any number (n) of dimensions (d). They hold a collection of items of any one data type and can be either a vector (one-dimensional) or a matrix (multi-dimensional). NumPy arrays allow for fast element access and efficient data manipulation.\n\nTo convert this to a one-dimensional ndarray with one row and four columns, we can use the function:\n\nTo get a two-dimensional ndarray from a list, we must start with a Python list of lists:\n\nIn the above output, you may notice that the NumPy array print-out is displayed in a way that clearly demonstrates its multi-dimensional structure: two rows and three columns.\n\nMany operations can be performed on NumPy arrays which makes them very helpful for manipulating data:\n\nMathematical operations can be performed on all values in a ndarray at one time rather than having to loop through values, as is necessary with a Python list. This is very helpful in many scenarios. Say you own a toy store and decide to decrease the price of all toys by €2 for a weekend sale. With the toy prices stored in an ndarray, you can easily facilitate this operation.\n\nIf, however, you had stored your toy prices in a Python list, you would have to manually loop through the entire list to decrease each toy price.\n\nJust as the ndarray is the foundation of the NumPy library, the Series is the core object of the pandas library. A pandas Series is very similar to a one-dimensional NumPy array, but it has additional functionality that allows values in the Series to be indexed using labels. A NumPy array does not have the flexibility to do this. This labeling is useful when you are storing pieces of data that have other data associated with them. Say you want to store the ages of students in an online course to eventually figure out the average student age. If stored in a NumPy array, you could only access these ages with the internal ndarray indices . With a Series object, the indices of values are set to by default, but you can customize the indices to be other values such as student names so an age can be accessed using a name. Customized indices of a Series are established by sending values into the Series constructor, as you will see below.\n\nA Series holds items of any one data type and can be created by sending in a scalar value, Python list, dictionary, or ndarray as a parameter to the pandas Series constructor. If a dictionary is sent in, the keys may be used as the indices.\n\nWhen printing a Series, the data type of its elements is also printed. To customize the indices of a Series object, use the argument of the constructor.\n\nSeries objects provide more information than NumPy arrays do. Printing a NumPy array of ages does not print the indices or allow us to customize them.\n\nAnother important type of object in the pandas library is the DataFrame. This object is similar in form to a matrix as it consists of rows and columns. Both rows and columns can be indexed with integers or String names. One DataFrame can contain many different types of data types, but within a column, everything has to be the same data type. A column of a DataFrame is essentially a Series. All columns must have the same number of elements (rows).\n\nThere are different ways to fill a DataFrame such as with a CSV file, a SQL query, a Python list, or a dictionary. Here we have created a DataFrame using a Python list of lists. Each nested list represents the data in one row of the DataFrame. We use the keyword to pass in the list of our custom column names.\n\nThis is how the DataFrame is displayed:\n\nThe default row indices are , but these can be changed. For example, they can be set to be the elements in one of the columns of the DataFrame. To use the column as indices instead of the default numerical values, we can run the following command on our DataFrame:\n\nDataFrames are useful because they make it much easier to select, manipulate, and summarize data. Their tabular format (a table with rows and columns) also makes it easier to label, simpler to read, and easier to export data to and from a spreadsheet. Understanding the power of these new data structures is the key to unlocking many new avenues for data manipulation, exploration, and analysis!"
    }
]