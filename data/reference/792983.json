[
    {
        "link": "https://realpython.com/iterate-through-dictionary-python",
        "document": "Python offers several ways to iterate through a dictionary, such as using to access key-value pairs directly and to retrieve values only. By understanding these techniques, you’ll be able to efficiently access and manipulate dictionary data.\n\nBy the end of this tutorial, you’ll understand that:\n• You can directly iterate over the keys of a Python dictionary using a loop and access values with .\n• You can iterate through a Python dictionary in different ways using the dictionary methods , , and .\n• You should use to access key-value pairs when iterating through a Python dictionary.\n• The fastest way to access both keys and values when you iterate over a dictionary in Python is to use with tuple unpacking.\n\nTo get the most out of this tutorial, you should have a basic understanding of Python dictionaries, know how to use Python loops, and be familiar with comprehensions. Knowing other tools like the built-in and functions, as well as the and modules, is also a plus.\n\nDictionaries are a cornerstone of Python. Many aspects of the language are built around dictionaries. Modules, classes, objects, , and are all examples of how dictionaries are deeply wired into Python’s implementation. Here’s how the Python official documentation defines a dictionary: An associative array, where arbitrary keys are mapped to values. The keys can be any object with and methods. (Source) There are a couple of points to notice in this definition:\n• Dictionaries map keys to values and store them in an array or collection. The key-value pairs are commonly known as items.\n• Dictionary keys must be of a hashable type, which means that they must have a hash value that never changes during the key’s lifetime. Unlike sequences, which are iterables that support element access using integer indices, dictionaries are indexed by keys. This means that you can access the values stored in a dictionary using the associated key rather than an integer index. The keys in a dictionary are much like a , which is a collection of hashable and unique objects. Because the keys need to be hashable, you can’t use mutable objects as dictionary keys. On the other hand, dictionary values can be of any Python type, whether they’re hashable or not. There are literally no restrictions for values. You can use anything as a value in a Python dictionary. Note: The concepts and topics that you’ll learn about in this section and throughout this tutorial refer to the CPython implementation of Python. Other implementations, such as PyPy, IronPython, and Jython, could exhibit different dictionary behaviors and features that are beyond the scope of this tutorial. Before Python 3.6, dictionaries were unordered data structures. This means that the order of items typically wouldn’t match the insertion order: Note how the order of items in the resulting dictionary doesn’t match the order in which you originally inserted the items. In Python 3.6 and greater, the keys and values of a dictionary retain the same order in which you insert them into the underlying dictionary. From 3.6 onward, dictionaries are compact ordered data structures: Keeping the items in order is a pretty useful feature. However, if you work with code that supports older Python versions, then you must not rely on this feature, because it can generate buggy behaviors. With newer versions, it’s completely safe to rely on the feature. Another important feature of dictionaries is that they’re mutable data types. This means that you can add, delete, and update their items in place as needed. It’s worth noting that this mutability also means that you can’t use a dictionary as a key in another dictionary.\n\nUnderstanding How to Iterate Through a Dictionary in Python As a Python developer, you’ll often be in situations where you need to iterate through an existing dictionary while you perform some actions on its key-value pairs. So, it’s important for you to learn about the different options for dictionary iteration in Python. When it comes to iterating through a dictionary in Python, the language provides some great tools and techniques to help you out. You’ll learn about several of these tools and techniques in this tutorial. To start off, you’ll learn the basics of iterating over dictionaries and their keys, values, and items using loops. Python’s dictionaries have some special methods that Python uses internally to perform some operations. These methods use the naming convention of adding a double underscore at the beginning of and at the end of the method’s name. You can use the built-in function to get a list of methods and attributes that any Python object provides. If you run with an empty dictionary as an argument, then you’ll get all the methods and attributes of the class: A closer look at the previous output reveals the entry, which is a method that Python automatically calls when you require an iterator for a container data type. This method should return a new iterator object, which allows you to iterate through all the items in the underlying container type. For Python dictionaries, allows direct iteration over the keys by default. This means that if you use a dictionary directly in a loop, Python will automatically call on that dictionary, and you’ll get an iterator that goes over its keys: Python is smart enough to know that is a dictionary and that it implements . In this example, Python calls automatically, and this allows you to iterate over the keys of without further effort on your side. This is the primary way to iterate through a dictionary in Python. You just need to put the dictionary directly into a loop, and you’re done! If you use this approach along with the operator, then you can access the values of your dictionary while you loop through the keys: In this example, you use and at the same time to access your target dictionary’s keys and the values, respectively. This technique enables you to perform different operations on both the keys and the values of . Even though iterating through a dictionary directly is pretty straightforward in Python, you’ll often find that dictionaries provide more convenient and explicit tools to achieve the same result. That’s the case with the method, which defines a quick way to iterate over the items or key-value pairs of a dictionary. When you’re working with dictionaries, iterating over both the keys and values at the same time may be a common requirement. The method allows you to do exactly that. The method returns a view object containing the dictionary’s items as key-value tuples: Dictionary view objects provide a dynamic view of the dictionary’s items. Here, dynamic means that when the dictionary changes, the views reflect those changes. Views are iterable, so you can iterate through the items of a dictionary using the view object that results from calling , as you can see in the example below: In this example, returns a view object that yields key-value pairs one at a time and allows you to iterate through them. If you take a closer look at the individual items that yields, then you’ll note that they’re objects: In this updated loop, you use the built-in function to check the data type of every item that yields. As you can confirm in the loop’s output, all the items are tuples. Once you know this, you can use unpacking to iterate through the keys and values in parallel. To achieve parallel iteration through keys and values, you just need to unpack the elements of every item into two different variables, one for the key and another for the value: The and variables in the header of your loop do the unpacking. Every time the loop runs, gets a reference to the current key, and gets a reference to the value. This way, you have more control over the dictionary content. Therefore, you’ll be able to process the keys and values separately in a readable and Pythonic manner. Python dictionaries offer a second way for you to iterate through their keys. Apart from using the target dictionary directly in a loop, you can also use the method. This method returns a view object containing only the dictionary keys: The method returns an object that provides a dynamic view of the keys in . You can use this view object to iterate through the dictionary keys. To do this, call in the header of a loop: When you call on , you get a view of keys. Python knows that view objects are iterable, so it starts looping. You might wonder why you’d use instead of just iterating over the dictionary directly. The quick answer is that using explicitly allows you to better communicate the intention of iterating over the keys only. Another common need that you’ll face when iterating through dictionaries is to loop over the values only. The way to do that is to use the method, which returns a view with the values in the underlying dictionary: In this code, returns a view object that yields values from . As with other view objects, the result of is also iterable, so you can use it in a loop: Using , you only have access to the values of your target dictionary, . Note that this iteration tool doesn’t give you access to the key associated with each value. So, you should use this technique if you only need to access the values in the target dictionary.\n\nSo far, you’ve learned the basic ways to iterate through a dictionary in Python. You now know how to iterate over dictionary keys, values, and items using different tools and techniques. It’s time to move on and write some examples of what you can do with the content of a dictionary while you iterate through it in a loop. Note: In the section on comprehension examples, you’ll learn that you can also use comprehensions to solve the same problems in a more concise way. To kick things off, you’ll start with an example of how to filter dictionary items by value using a loop. Filtering Items by Their Value Sometimes, you’ll be in situations where you have a dictionary and want to create a new one that only contains the data that satisfies a given condition. You can do this with a conditional statement while you traverse the dictionary. Consider the following toy example: In this example, you filter the items with a value less than and add them to your dictionary. This new dictionary only contains the items that satisfy the condition , which is your filtering condition. There’s another technique that you can use to filter items from a dictionary. Key view objects are like Python sets. So, they support operations, such as union, intersection, and difference. You can take advantage of this set-like behavior to filter certain keys from a dictionary. For example, in the code below, you use a set difference to filter out the citrus from your dictionary: When you run , you’re really running a difference operation. You can use this trick to create a new dictionary without citrus fruits: In this example, you build a new dictionary out of the set of keys that you get from computing the difference between your dictionary’s keys and a set of unwanted keys. The fact that key view objects behave like sets is a little-known feature that can be useful in some situations. So, keep it in your tool kit. Running calculations with a dictionary’s values while you iterate through the dictionary itself is another common task. Suppose you’ve stored the data for your company’s sales in a dictionary, and now you want to know the year’s total income. To solve this problem, you can use an accumulator variable with an initial value of zero. Then, you can accumulate every value in your dictionary in that variable: Here, you iterate through the values in your dictionary and sequentially accumulate them in . The augmented assignment does the magic, and at the end of the loop, you get the total income for the year. As with many tasks in Python, you’ll have a better way to do the same computation, as in the example below. You can use the built-in function: In this example, you pass the values in your dictionary directly as an argument to . The function implicitly iterates over the values and computes their sum in the process. Even though the solution is concise, fast, and readable, the loop solution is more generic and allows you to perform computations other than just summing up the values. Suppose you have a dictionary and need to turn keys into values and values into keys. In this situation, you can use a loop to iterate through the original dictionary while you build the new one with swapped keys and values: {1: 'one', 2: 'two', 3: 'three', 4: 'four'} The expression does the hard work for you by swapping the keys and values in a new dictionary. Note that for this code to work, the data stored in the values of your original dictionary must be of a hashable data type. Otherwise, you’ll get an error. Again, Python has other tools that allow you to write the previous example in a more concise way. This time, you can use the built-in function along with the constructor: {1: 'one', 2: 'two', 3: 'three', 4: 'four'} In this example, you use to generate tuples of value-key pairs. To do that implicitly iterates over the values and keys of your dictionary. Then you use the resulting tuples as arguments to and build the desired dictionary.\n\nA dictionary comprehension is a compact way to process and transform data in order to produce a new dictionary as a result. In contrast to list comprehensions, dictionary comprehensions need a key that maps to a value. You can first provide two expressions separated by a colon ( ). After this, you’ll provide a clause, and you can also include an optional clause. To illustrate how dictionary comprehensions work, suppose that you have two lists of data, and you need to create a new dictionary from them. In this case, you can use the built-in to loop over the elements of both lists in parallel: In this example, receives two iterables, and , as arguments and makes an iterator that aggregates elements from each iterable. The objects that generates are then unpacked into and , which you finally use to create the new desired dictionary. Note: The above example demonstrates how dictionary comprehensions work in Python. Still, a better way to write the example would be the following: The function generates the key-value pairs from the original lists, while the constructor creates the new dictionary for you. Isn’t that cool? Dictionary comprehensions open up a wide spectrum of new possibilities and provide you with a great tool to iterate through and transform dictionaries in Python. Filtering Items by Their Value: Revisited To filter items in a dictionary with a comprehension, you just need to add an clause that defines your filtering condition. Earlier, you worked with the condition . You can get the same result with a dictionary comprehension: Now your resulting dictionary contains only the items that satisfy your condition. Compared to the previous section’s solution, this one is more concise and efficient. You can also approach the problem of swapping keys and values using a dictionary comprehension. With this tool, you can write a more concise, Pythonic solution that’s also more efficient. Here’s how: {1: 'one', 2: 'two', 3: 'three', 4: 'four'} With this comprehension, you create a new dictionary where the keys have taken the place of the values and vice versa. This new approach gives you the ability to write more readable, succinct, and efficient code. Again, the condition for this code to work is the same one you saw before: the values must be hashable objects. Otherwise, you won’t be able to use them as keys for your new dictionary.\n\nSometimes, you may need to iterate through a dictionary in sorted order. You can do this by using the built-in function. When you call this function with an iterable as an argument, you get a of items in sorted order. Note: To dive deeper into sorting Python dictionaries, check out Sorting a Python Dictionary: Values, Keys, and More. Iterating over a dictionary in reverse order can also be a common requirement in code. In this case, you can use the built-in function, which takes an iterable as an argument and yields its items in reverse order. In the following sections, you’ll learn how to use these tools to iterate through a Python dictionary in sorted and reverse order, respectively. If you need to iterate through the keys of a dictionary in sorted order, then you can pass your dictionary as an argument to . You’ll get a list containing the keys in sorted order. This list will allow you to traverse your dictionary sorted by keys: In this example, you sort the keys by calling with your dictionary as an argument. Note that you could’ve also used to get the same result. In both cases, you’ll get a containing the keys of your dictionary in sorted order. Note that the sorting order will depend on the data type of your keys and the internal rules that Python uses to sort that specific data type. In this example, Python sorts the keys using its internal rules for sorting strings. These rules are based on the characters’ Unicode code points. A further explanation of these internal rules is out of this tutorial’s scope. You may also need to iterate through a Python dictionary with its items sorted by values. To do this, you can use too. This time, you’ll need to use a second argument called when you call . This keyword-only argument specifies a one-argument function to extract a comparison key from the items that you’re processing. To iterate through dictionary items sorted by value, you can write a function that returns the value of each item and then use this function as the argument to . In the example below, you do this with a short function: In this example, you define a function and use it to sort the items of by value with . The function tells to sort by the second element of each item, , which is the income value. You may also want to iterate through the values of a dictionary in sorted order without considering the keys. In that case, you can use to provide the augment for . Here’s a quick example: Calling with as an argument returns the values of your dictionary in sorted order. Remember that the keys won’t be accessible if you use . That’s okay. Sometimes, you don’t need the keys, just the values, and this is a quick way to access them. What if you need to sort an existing dictionary and build a sorted one? As you already know, since Python 3.6, dictionaries remember the insertion order of their items. This feature allows you to sort the items of a dictionary using while you build a new dictionary with a comprehension: These comprehensions allow you to create new dictionaries with their items sorted by key and value, respectively. In both cases, the comprehension iterates over the original dictionary in sorted order and builds a new dictionary. If you need to traverse your dictionaries in reverse-sorted order, then you can use the argument to . This argument takes a Boolean value. If you use , then the items are sorted in reverse order: In this example, you iterate over the keys of in reverse-sorted order by using the argument to in the header of your loop. This example sorts the keys. Why don’t you try writing an example that sorts the values in reverse order? Another possibility that Python offers when it comes to iterating through dictionaries is to use the built-in function. This function takes an iterable as an argument and returns an iterator that yields items in reverse order. Using , you can traverse your dictionaries in reverse order: In this example, the call to yields items from in reverse order. This enables you to iterate through your dictionary from right to left, which can be useful in some situations.\n\nUsing Built-in Functions to Implicitly Iterate Through Dictionaries Python provides some built-in functions that are useful when you’re working with collections like dictionaries. These functions are a sort of iteration tool because they implement an internal loop. Because of their internal loop, you can use these functions to iterate through a dictionary implicitly. In the following sections, you’ll explore two of these functions: and . With , you can apply a given transformation to all the items in a dictionary and build a new one. With , you can extract the desired items into a new dictionary. Python’s function takes a function object and an iterable as arguments. It returns an iterator that results from applying the input function to every item in the input iterable. You can use to iterate through dictionaries in Python by taking advantage of the function’s implicit loop. Say you want to apply a price discount to all the products in your dictionary. In this case, you can define a function that manages the discount and then use that function as the first argument to . Then you can use to provide the iterable object: In this code snippet, you define a function named , which applies a discount to the price of a given product. Then it returns a tuple containing the product and its new price. The first call to iterates through the items of the dictionary, , and applies the default 5 percent discount to each fruit. In this case, you use the constructor to generate a new dictionary from the data that returns. In the second and third calls to , you wrap in a function so that you can provide a different discount value to . This is a common technique that you can use when a tool like requires a function with a given number of arguments and your target function doesn’t match that number. The built-in function is another tool that you can use to implicitly iterate through a dictionary and filter its items according to a given condition. This tool also takes a function object and an iterable as arguments. It returns an iterator from those elements of the input iterable for which the function returns . Say that you want to extract the products with a price lower than from your dictionary. To do this, you can define a function to determine if the price satisfies that condition and pass the function as the first argument to . Again, the second argument can be . Here’s the code to achieve this: You iterate through the items of with . The function compares the item’s price with a target price and returns if the item’s price is less than the target. Otherwise, it returns . As a result, you get only the items whose price is lower than the target. To provide a different target price, you can use a function as you did in the previous section. Go ahead and give it a try.\n\nThe and modules from the Python standard library provide a couple of useful tools that allow you to iterate through multiple dictionaries in one go. In , you’ll find the class, which allows you to create a dictionary-like object by combining multiple existing dictionaries. With , you can iterate through several dictionaries as if they were a single one. In , you’ll find a function called that allows you to iterate over multiple Python dictionaries one at a time. In the following sections, you’ll learn how to use these two tools for iterating over multiple dictionaries in a single loop. You’ll also learn how both tools differ from each other. The module from the standard library provides a specialized container type called . It’s a dictionary-like class that you can use to create a single, updateable view out of multiple existing dictionaries. The resulting object will logically appear and behave as a single dictionary. doesn’t merge the input dictionaries together. Instead, it keeps them in an internal list. The input dictionaries can have duplicate keys. However, only the first instance of a duplicated key will be accessible in lookup and update operations. Now, suppose you have two dictionaries containing different categories of products and their prices. You need to iterate through them together as one dictionary. To achieve this, you can create a object and initialize it with your dictionaries: After importing from , you need to create a object with the dictionaries that you want to chain. Then you can freely iterate through the resulting object as you would do with a regular dictionary. objects have the same interface as regular dictionaries, so you can use , , and to iterate through their different components. When using to iterate over multiple dictionaries in one go, you must keep in mind that if you have duplicate keys, then you’ll only be able to access the first instance of them. Consider the following example: In this example, the loop only went through the first instances of and . Therefore, you don’t get data from the duplicate instances of these keys. Iterating Through a Chain of Dictionaries With The module provides the function, which can take multiple iterable objects as arguments and make an iterator that yields elements from all of them. To do its job, starts yielding items from the first iterable until exhaustion, then the function yields items from the next iterable, and so on until all the input iterable objects are exhausted. This behavior allows you to iterate through multiple dictionaries in a chain that goes through all the keys, even if there are repeated ones: In the above code, returns an iterator that yields items from and . Note that unlike , the function gives you access to all the keys from your input dictionaries, even the duplicated ones.\n\nYou now have some experience iterating through dictionaries in Python. Below, you’ll find a few questions and answers that sum up the most important concepts you’ve covered in this tutorial. You can use these questions to check your understanding or to recap and solidify what you’ve just learned. After each question, you’ll find a brief explanation hidden in a collapsible section. Click the Show/Hide toggle to reveal the answer. What's the difference between iterating with and ?Show/Hide Using returns a view of the dictionary’s keys, allowing you to iterate through them. Conversely, returns a view of the dictionary’s values. If you only need to work with keys or values, you can choose the appropriate method to make your code more explicit and readable. How do you iterate over a dictionary's keys and values in Python?Show/Hide You can iterate over a dictionary’s keys and values using the method. This method returns a view object containing key-value pairs as tuples, which you can unpack directly in a loop: In this example, you use to unpack the tuples that you create during the iteration with . Can I iterate over a dictionary while modifying its content?Show/Hide Yes, you can! If you only need to update or modify the values of an existing dictionary, then you can safely do it in a loop because dictionaries are mutable, and you can change their values in place. On the other hand, if you need to remove key-value pairs from a dictionary while you’re looping through it, then you’d need to use a copy for the iteration and remove the values from the original dictionary. To create a shallow copy of a dictionary, you can use the method. You can also use a loop and the method to remove consecutive items from a dictionary without needing to make a copy beforehand. Sometimes, a better option is to use a dictionary comprehension to create a new dictionary with transformed values. How can I iterate through a dictionary in a specific order?Show/Hide If you want to iterate through a dictionary in sorted order, for example, then you can use the built-in function. If you feed this function with the result of , then you’ll get a list of key-value tuples that you can traverse in a loop as usual. Additionally, you can use the built-in function to iterate through a Python dictionary in reverse order. How can I iterate through multiple dictionaries in one go?Show/Hide The and standard-library modules provide the class and the function, respectively. Both tools allow you to combine multiple dictionaries and iterate through them in a chain. You’ll find a subtle behavior difference between these tools, though. When the input dictionaries have duplicate keys, only gives you access to the first instance of a key, while gives you access to all the instances of a repeated key. Finally, you can also use the dictionary unpacking operator ( ) to merge multiple dictionaries together and iterate over the resulting dictionary. In this case, if the input dictionaries have duplicate keys, the last instance of every repeated key will prevail. How did you do? Are you ready to challenge yourself further with dictionary iteration? Would you like to take a quick quiz to evaluate your new skills? If so, click the link below: Test your knowledge with our interactive “Python Dictionary Iteration” quiz. You’ll receive a score upon completion to help you track your learning progress: Dictionaries are one of the most important and useful data structures in Python. Learning how to iterate through a Dictionary can help you solve a wide variety of programming problems in an efficient way. Test your understanding on how you can use them better!"
    },
    {
        "link": "https://stackoverflow.com/questions/69205854/iterating-over-dictionary-in-python-and-using-each-value",
        "document": "I am trying to iterate over a dictionary that looks like this:\n\nThe goal is to use each ID to scrape some data, therefor I got a method that takes the corresponding userID and gets the data from it. At first I had a method for every ID in the dict, but now I want to change it so that I got one method which iterates over the dictionary, takes one ID at a time and makes the API request, if finished the next is made and so on.\n\nThe problem is I can't iterate over the dictionary, I always just access the first one in here.\n\nI am relatively new to Python since I mainly used Java. Maybe dictionary is the wrong data structure for this task?\n\nThis is my old code to iterate over the dictionary:\n\nI then continue with using the id in this function:\n\nBut I always only use the first one. I think in Java it wouldn't be a problem for me since I can just use an index to iterate from 0 to n, but is there something similar for dictionaries? I also want to run the get_latest_data method every time a new ID is chosen from the dict"
    },
    {
        "link": "https://geeksforgeeks.org/iterate-over-a-dictionary-in-python",
        "document": "In this article, we will cover How to Iterate Through a Dictionary in Python. To Loop through values in a dictionary you can use built-in methods like values(), items() or even directly iterate over the dictionary to access values with keys.\n\nHow to Loop Through a Dictionary in Python\n\nThere are multiple ways to iterate through a dictionary, depending if you need key, value or both key-value pairs.\n\nTo iterate through all values of a dictionary in Python using .values(), you can employ a for loop, accessing each value sequentially. This method allows you to process or display each individual value in the dictionary without explicitly referencing the corresponding keys.\n\nExample: In this example, we are using the values() method to print all the values present in the dictionary.\n\nIn Python, just looping through the dictionary provides you its keys. You can also iterate keys of a dictionary using built-in `.keys()` method.\n\nIterate through both keys and values\n\nYou can use the built-in items() method to access both keys and items at the same time. items() method returns the view object that contains the key-value pair as tuples.\n\nThe method accesses keys in a dictionary using `map()` and `dict.get()`. It applies the `dict.get` function to each key, returning a map object of corresponding values. This allows direct iteration over the dictionary keys, efficiently obtaining their values in a concise manner.\n\nExample: In this example, the below code uses the `map()` function to create an iterable of values obtained by applying the `get` method to each key in the `statesAndCapitals` dictionary. It then iterates through this iterable using a `for` loop and prints each key.\n\nUsing `zip()` in Python, you can access the keys of a dictionary by iterating over a tuple of the dictionary’s keys and values simultaneously. This method creates pairs of keys and values, allowing concise iteration over both elements.\n\nExample: In this example, the zip() function pairs each state with its corresponding capital, and the loop iterates over these pairs to print the information\n\nDictionary iteration in Python by unpacking the dictionary\n\nTo access keys using unpacking of a dictionary, you can use the asterisk (*) operator to unpack the keys into a list or another iterable.\n\nExample: In this example, you will see that we are using * to unpack the dictionary. The *dict method helps us to unpack all the keys in the dictionary.\n\nIterating through the dictionary is an important task if you want to access the keys and values of the dictionary. In this tutorial, we have mentioned several ways to iterate through all items of a dictionary. Important methods like values(), items(), and keys() are mentioned along with other techniques.\n• None Iterate through a list of dictionaries in Python\n• None How to Iterate over nested dictionary\n• None Delete items from the dictionary while iterating\n\nHow can we iterate over keys in a Python dictionary?\n\nHow to access values while iterating over a Python dictionary?\n\nWhat method is used to iterate over both keys and values in Python?\n\nHow to modify values during iteration in a Python dictionary?\n\nAre there any Python modules that enhance dictionary iteration?\n\nYes, there are Python modules and functions that can enhance dictionary iteration. One such module is , which provides additional data structures like and . Additionally, tools from the module can be useful. from collections import defaultdict # Example defaultdict my_dict = defaultdict(int, {'a': 1, 'b': 2, 'c': 3}) for key, value in my_dict.items(): print(f\"Key: {key}, Value: {value}\") from collections import OrderedDict # Example OrderedDict my_dict = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) for key, value in my_dict.items(): print(f\"Key: {key}, Value: {value}\") Key: a, Value: 1 Key: b, Value: 2 Key: c, Value: 3 import itertools # Example dictionary my_dict = {'a': 1, 'b': 2, 'c': 3} # Iterating with itertools for key, value in itertools.zip_longest(my_dict.keys(), my_dict.values()): print(f\"Key: {key}, Value: {value}\")"
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary",
        "document": "A Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can’t be repeated and must be immutable.\n\nExample: Here, The data is stored in key:value pairs in dictionaries, which makes it easier to find values.\n\nIn Python, a dictionary can be created by placing a sequence of elements within curly {} braces, separated by a ‘comma’.\n• Dictionary keys are case sensitive: the same name but different cases of Key will be treated distinctly.\n• Keys must be immutable: This means keys can be strings, numbers, or tuples but not lists.\n• Keys must be unique: Duplicate keys are not allowed and any duplicate key will overwrite the previous value.\n• None . Hence, operations like search, insert, delete can be performed in Constant Time\n\nWe can access a value from a dictionary by using the key within square brackets orget()method.\n\nWe can add new key-value pairs or update existing keys by using assignment.\n\nWe can remove items from dictionary using the following methods:\n• None : Removes an item by key and returns its value.\n• None : Removes and returns the last key-value pair.\n\nWe can iterate over keys [using keys() method] , values [using values() method] or both [using item() method] with a for loop.\n\nRead in detail – Ways to Iterating Over a Dictionary\n• None Check if two arrays are equal or not\n• None Max distance between two occurrences in array\n• None Count all pairs with absolute difference equal to k\n• None Remove minimum elements such that no common elements exist in two arrays\n• None Count distinct elements in every window of size k\n\nHow to use dictionaries in Python?\n\nHow to print dictionaries in Python?\n\nHow to declare a dictionary in Python?\n\nWhat are dictionary keys and values in Python?"
    },
    {
        "link": "https://w3schools.com/python/python_dictionaries_loop.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://realpython.com/python-f-strings",
        "document": "Python f-strings offer a concise and efficient way to interpolate variables, objects, and expressions directly into strings. By prefixing a string with or , you can embed expressions within curly braces ( ), which are evaluated at runtime.\n\nThis makes f-strings faster and more readable compared to older approaches like the modulo ( ) operator or the string method. Additionally, f-strings support advanced string formatting using Python’s string format mini-language.\n\nBy the end of this tutorial, you’ll understand that:\n• An f-string in Python is a string literal prefixed with or , allowing for the embedding of expressions within curly braces .\n• To include dynamic content in an f-string, place your expression or variable inside the braces to interpolate its value into the string.\n• An f-string error in Python often occurs due to syntax issues, such as unmatched braces or invalid expressions within the string.\n• Python 3.12 improved f-strings by allowing nested expressions and the use of backslashes.\n\nThis tutorial will guide you through the features and advantages of f-strings, including interpolation and formatting. By familiarizing yourself with these features, you’ll be able to effectively use f-strings in your Python projects.\n\nBefore Python 3.6, you had two main tools for interpolating values, variables, and expressions inside string literals: You’ll get a refresher on these two string interpolation tools in the following sections. You’ll also learn about the string formatting capabilities that these tools offer in Python. The modulo operator ( ) was the first tool for string interpolation and formatting in Python and has been in the language since the beginning. Here’s what using this operator looks like in practice: In this quick example, you use the operator to interpolate the value of your variable into a string literal. The interpolation operator takes two operands:\n• A string literal containing one or more conversion specifiers\n• The object or objects that you’re interpolating into the string literal The conversion specifiers work as replacement fields. In the above example, you use the combination of characters as a conversion specifier. The symbol marks the start of the specifier, while the letter is the conversion type and tells the operator that you want to convert the input object into a string. If you want to insert more than one object into your target string, then you can use a tuple. Note that the number of objects in the tuple must match the number of format specifiers in the string: In this example, you use a tuple of values as the right-hand operand to . Note that you’ve used a string and an integer. Because you use the specifier, Python converts both objects to strings. You can also use dictionaries as the right-hand operand in your interpolation expressions. To do this, you need to create conversion specifiers that enclose key names in parentheses: This syntax provides a readable approach to string interpolation with the operator. You can use descriptive key names instead of relying on the positional order of values. When you use the operator for string interpolation, you can use conversion specifiers. They provide some string formatting capabilities that take advantage of conversion types, conversion flags, and some characters like the period ( ) and the asterisk ( ). Consider the following example: In the first example, you use the conversion specifier to represent currency values. The letter tells the operator to convert to a floating-point number. The part defines the precision to use when converting the input. In the second example, you use to align the age value five positions to the right. Note: Formatting with the modulo operator is inspired by formatting used in C and many other programming languages. Even though the operator provides a quick way to interpolate and format strings, it has a few issues that lead to common errors. For example, it’s difficult to interpolate tuples in your strings: : not all arguments converted during string formatting In this example, the operator fails to display the tuple of data because it interprets the tuple as two separate values. You can fix this issue by wrapping the data in a single-item tuple: This syntax fixes the issue, and now your string successfully shows the tuple of data. However, the syntax is hard to read, understand, and remember, isn’t it? Another issue with the operator is its limited formatting capabilities and the lack of support for Python’s string formatting mini-language, which provides a powerful tool to format your strings. The method is an improvement compared to the operator because it fixes a couple of issues and supports the string formatting mini-language. With , curly braces delimit the replacement fields: For the method to work, you must provide replacement fields using curly brackets. If you use empty brackets, then the method interpolates its arguments into the target string based on position. You can manually specify the interpolation order by referencing the position of each argument to using zero-based indices. For example, the code below switches the arguments to in the target string: In this example, you use numeric indices to manually define the order in which you want to interpolate the values that you pass as arguments to . You can also use keyword arguments in the call to the method and enclose the argument names in your replacement fields: This example showcases how interpolates keyword arguments by their names into the target string. This construct considerably improves your code’s readability compared to the previous example and to the examples using the operator. Finally, the method allows you to use dictionaries to provide the values that you want to interpolate into your strings: In this example, you use a dictionary containing the data to interpolate. Then, you use the dictionary unpacking operator ( ) to provide the arguments to . The method supports format specifiers. These are strings that you insert into replacement fields to format the values that you want to interpolate. Consider the following examples: In the first example, you use the format specifier. This specifier tells to format the input value as a floating-point number with a precision of two. This way, you can represent currency values. In the second example, you use the format specifier. In this case, you’re telling to format the input value using the symbol as a filler character. The symbol centers the input value by inserting symbols on both sides to reach thirty characters. Format specifiers provide a remarkable improvement over the limited formatting capabilities of the operator. These specifiers have a straightforward syntax that makes up the string formatting mini-language. Thankfully, f-strings also support the string formatting mini-language, which is another cool feature of theirs. So, you won’t have to use if you don’t need to. In the upcoming sections, you’ll write a few more examples of formatting strings using the mini-language with f-strings.\n\nDoing String Interpolation With F-Strings in Python F-strings joined the party in Python 3.6 with PEP 498. Also called formatted string literals, f-strings are string literals that have an before the opening quotation mark. They can include Python expressions enclosed in curly braces. Python will replace those expressions with their resulting values. So, this behavior turns f-strings into a string interpolation tool. In the following sections, you’ll learn about f-strings and use them to interpolate values, objects, and expressions in your string literals. F-strings make the string interpolation process intuitive, quick, and concise. The syntax is similar to what you used with , but it’s less verbose. You only need to start your string literal with a lowercase or uppercase and then embed your values, objects, or expressions in curly brackets at specific places: Look how readable and concise your string is now that you’re using the f-string syntax. You don’t need operators or methods anymore. You just embed the desired objects or expressions in your string literal using curly brackets. It’s important to note that Python evaluates f-strings at runtime. So, in this example, both and are interpolated into the string literal when Python runs the line of code containing the f-string. Python can only interpolate these variables because you defined them before the f-string, which means that they must be in scope when Python evaluates the f-string. You can embed almost any Python expression in an f-string. This allows you to do some nifty things. You could do something pretty straightforward, like the following: When Python runs this f-string, it multiplies by and immediately interpolates the resulting value into the final string. The example above is quite basic. However, f-strings are more powerful than that. You could also use other Python expressions, including function and method calls, and even comprehensions or other more complex expressions: In the first f-string, you embed a call to the string method in the first replacement field. Python runs the method call and inserts the uppercased name into the resulting string. In the second example, you create an f-string that embeds a list comprehension. The comprehension creates a new list of powers of .\n\nThe expressions that you embed in an f-string are evaluated at runtime. Then, Python formats the result using the special method under the hood. This method supports the string formatting protocol. This protocol underpins both the method, which you already saw, and the built-in function: The function takes a value and a format specifier as arguments. Then, it applies the specifier to the value to return a formatted value. The format specifier must follow the rules of the string formatting mini-language. Just like the method, f-strings also support the string formatting mini-language. So, you can use format specifiers in your f-strings too: Note that the format specifiers in these examples are the same ones that you used in the section on . In this case, the embedded expression comes before the format specifier, which always starts with a colon. This syntax makes the string literals readable and concise. You can create a wide variety of format specifiers. Some common formats include currencies, dates, and the representation of numeric values. Consider the following examples of string formatting: \"Comma as thousand separators and two decimals: 'Comma as thousand separators and two decimals: 1,234,567.99' These examples show how flexible the format specifiers can be. You can use them to create almost any string format. Note how in the second example, you’ve used curly brackets to embed variables or expressions in your format specifiers. This possibility allows you to create dynamic specifiers, which is pretty cool. In the last example, you format a which can be formatted with special date format specifiers.\n\nSo far, you’ve learned that f-strings provide a quick and readable way to interpolate values, objects, and expressions into string literals. They also support the string formatting mini-language, so you can create format specifiers to format the objects that you want to insert into your strings. In the following sections, you’ll learn about a few additional features of f-strings that may be relevant and useful in your day-to-day coding. Using an Object’s String Representations in F-Strings Python’s f-strings support two flags with special meaning in the interpolation process. These flags are closely related to how Python manages the string representation of objects. These flags are: Interpolates the string representation from the method Interpolates the string representation from the method The special method generally provides a user-friendly string representation of an object, while the method returns a developer-friendly representation. To illustrate how these methods work under the hood, consider the following class: This class has two instance attributes, and . The method returns a string that consists of an informative message for users of your class. This message should be useful for end users rather than developers. Note: To dive deeper into the and methods, check out When Should You Use. vs in Python? In contrast, the method returns a string that’s a developer-friendly representation of the object. In short, the representation tells the developer how the current instance was created. Ideally, the developer should be able to copy this string representation and create an equivalent object. How does this discussion about string representation affect f-strings? When you create your f-strings, you can choose which string representation to use with the and flags: In the first f-string, you use the tag to interpolate the string representation that returns. In the second f-string, you use the flag to interpolate the developer-friendly string representation of your current object. These two flags are pretty relevant for you as a Python developer. Depending on your code’s intended audience, you can decide which one to use. In general, it should be the one that provides more value to your users. It’s important to note that the operator also supports equivalent conversion types, and , which work the same as the and flags in f-strings. F-strings have another cool feature that can be useful, especially during your debugging process. The feature helps you self-document some of your expressions. For example, say that you’re dealing with a minor bug or issue in your code, and you want to know the value of a variable at a given moment in the code’s execution. For this quick check, you can insert a call to like the following: You can use a variable name followed by an equal sign ( ) in an f-string to create a self-documented expression. When Python runs the f-string, it builds an expression-like string containing the variable’s name, the equal sign, and the variable’s current value. This f-string feature is useful for inserting quick debugging checks in your code. Note that the whitespaces around the equal sign aren’t required but they are reflected in the output: Even though the whitespaces aren’t required, they can improve your code’s readability and the output’s format. F-strings are a bit faster than both the modulo operator ( ) and the method. That’s another cool characteristic. In the script below, you use the module to measure the execution time that it takes to build a string using the modulo operator, the method, and an f-string: In this script, the function takes care of measuring the execution time of the three different string interpolation tools. The function inside the loop runs each interpolation tool a million times and returns the total execution time. Then, the function prints the result to the screen. Note how your f-string in the call to takes advantage of format specifiers to conveniently format the code’s output. If you run the script from your command line, then you’ll get an output similar to the following. Of course, the numbers will be different for you: This output shows that f-strings are a bit faster than the operator and the method, which is the slowest tool because of all the required function calls. So, f-strings are readable, concise, and also fast.\n\nNow that you’ve learned why f-strings are great, you’re probably eager to get out there and start using them in your code. However, you need to know that f-strings up to Python 3.11 have a few limitations regarding the expressions that you can embed in curly brackets and a few other details. Fortunately, Python 3.12 lifted those limitations by removing the old f-string parser and providing a new implementation of f-strings based on the PEG parser of Python 3.9. In the following sections, you’ll learn about the limitations and how Python 3.12 fixed them. Python supports several different types of quotation marks as delimiters in string literals. You can use single ( ) and double quotes ( ). You can also use triple single ( ) and triple double quotes ( ). All these string delimiters work for f-strings as well. This feature allows you to insert quotation marks in f-strings. It also lets you introduce string literals in the embedded expressions and even create nested f-strings. A typical use case of using different quotation marks in an f-string is when you need to use an apostrophe or access a dictionary key in an embedded expression: In this example, you have a dictionary with a person’s data. To define the f-string, you use double quotes. To access the dictionary key, you use single quotes. In the contraction, you use a single quote as an apostrophe. So, where’s the quote-related limitation of f-strings up to Python 3.11? The problem is that you can’t reuse quotation marks in an f-string: In this example, when you try to reuse double quotes to access the dictionary key, your f-string fails, and Python raises a exception. Fortunately, the new f-strings in Python 3.12 solved this issue, allowing you to reuse quotes: In this example, you reuse the double quotes in your embedded expressions, and the f-string works correctly. The limitation is gone. However, it may not be clear if reusing quotations in this example is cleaner than differentiating nested strings with different quotation marks. There’s another f-string limitation that’s closely related to quotation marks. You can only nest as many f-strings as there are quote delimiters in Python: The number of nesting levels in an f-string up to Python 3.11 is limited by the available string delimiters, which are , , , and . So, you only have four delimiters that you can use to differentiate your levels of nesting. In Python 3.12, this limitation is removed because you can reuse quotation marks: Before the new f-string implementation, there was no formal limit on how many levels of nesting you could have. However, the fact that you couldn’t reuse string quotes imposed a natural limit on the allowed levels of nesting in f-string literals. Starting with Python 3.12, you can reuse quotes, so there are no limits for nesting f-strings. Another limitation of f-strings before 3.12 is that you can’t use backslash characters in embedded expressions. Consider the following example, where you try to concatenate strings using the newline ( ) escape sequence: In this example, you get a because f-strings don’t allow backslash characters inside expressions delimited by curly brackets. Again, the new f-string implementation that comes with Python 3.12 solves the issue: The new f-string implementation lifted the limitation of using backslash characters in embedded expressions, so you can now use escape sequences in your f-strings. F-strings up to Python 3.11 don’t allow you to use the symbol in embedded expressions. Because of that, you can’t insert comments in embedded expressions. If you try to do it, then you’ll get a syntax error: When you use to introduce a comment in an f-string, you get a . Fortunately, the new f-strings in Python 3.12 also fix this problem: Now you can add inline comments if you ever need to clarify something in the embedded expressions of an f-string. Another improvement is that you can add line breaks inside the curly braces, similar to what you can do inside parentheses outside f-strings. You don’t even need to use the triple-quoted multiline strings to do this. Python’s new PEG parser opens the door to many improvements in the language. From the user’s perspective, one of the most valuable improvements is that you now have better error messages. These enhanced error messages weren’t available for f-strings up to Python 3.11 because they didn’t use the PEG parser. So, the error messages related to f-strings were less specific and clear. Python 3.12 came along to fix this issue, too. Take a look at the following example, which compares the error message for an incorrect f-string in both 3.11 and 3.12: File , line File , line : f-string: expecting '=', or '!', or ':', or '}' The error message in the first example is generic and doesn’t point to the exact location of the error within the offending line. Additionally, the expression is surrounded by parentheses, which adds noise to the problem because the original code doesn’t include parentheses. In Python 3.12, the error message is more verbose. It signals the exact location of the problem in the affected line. Additionally, the exception message provides some suggestions that might help you fix the issue. In this specific example, the suggestions aren’t that useful because they focus on an operator that’s possibly wrong. However, having the exact location where the problem happened gives you a strong clue. You have a missing operand in the embedded expression.\n\nEven though f-strings are a pretty cool and popular Python feature, they’re not the one-size-fits-all solution. Sometimes the modulo operator ( ) or the method provides a better solution. Sometimes, they’re your only option. It all depends on your specific use case. In the following sections, you’ll learn about a few situations where f-strings may not be the best option. To kick things off, you’ll start with a use case that’s closely related to your code’s readability. That’s when you want to interpolate values from a dictionary into a given string. Interpolating dictionary values into a string may be a common requirement in your code. Because you now know that f-strings are neat, you may think of using them for this task. You end up with a piece of code that looks like the following: That’s great! The code works just fine. However, it doesn’t look clean because of all those dictionary key lookups embedded in the string. The f-string looks cluttered and may be hard to read. How about using the method? Here’s a new version of your code: In this example, you use direct names instead of dictionary lookups in the replacement fields. The only additional requirement is that you need to use the dictionary unpacking operator ( ) in the call to . Now, the string looks cleaner and is also a bit shorter than the version using an f-string. As an additional gain, it’s important to note that the number of replacement fields in the string doesn’t have to match the number of keys in the input dictionary. The method will ignore unnecessary keys. You also have the option of using the modulo operator, though: This time, the string is even shorter. You use direct names in the replacement fields and don’t have to use the dictionary unpacking operator because the modulo operator unpacks the dictionary for you. However, some may say that the replacement fields aren’t that readable and that the modulo operator has limited formatting capabilities. So, what version do you prefer? Share your thoughts in the comments! Providing logging messages is a common example of those use cases where you shouldn’t use f-strings or . The module runs string interpolation lazily to optimize performance according to the selected logging level. For example, you may have a hundred debugging messages but only ten warning messages in your code. If you use an f-string or the method to construct your logging messages, then Python will interpolate all the strings regardless of the logging level that you’ve chosen. However, if you use the operator and provide the values to interpolate as arguments to your logging functions, then you’ll optimize the interpolation process. The module will only interpolate those strings that belong to the current and higher logging levels. Consider the following example: In this example, you use the modulo operator syntax to create the logging message. Then, you pass the value that you want to interpolate as an argument to the logging functions. Because is the default logging level, only the messages at this level and higher will be logged. That’s why the function doesn’t generate any output. In the above call to , the string interpolation never happens because you’re using a higher logging level. However, if you use like in the code below, then the interpolation will always happen: If you call a million times inside a loop, then Python will eagerly evaluate its argument, and the interpolation will happen a million times. This behavior will add performance overhead to your code. That’s why the module does the interpolation lazily. The lazy nature of how does string formatting can make a difference, and it’s only possible using the modulo operator. Using any string interpolation tool is a bad idea when you’re building SQL queries with dynamic parameters. In this scenario, interpolation tools invite SQL injection attacks. To illustrate the problem, say that you’re working with a PostgresSQL database using the Psycopg 2 adapter, and you want to run a query to get all the users with a given role or set of privileges. You come up with one of the following queries: All of these strings directly insert the query parameter into the final query without any validation or security check. If you run any of these queries using the method, then the database won’t be able to perform any security checks on the parameters, which makes your code prone to SQL injection attacks. Note: The code in the above example doesn’t run because of the missing library and the assumption of a certain database structure and setup. It’s a demonstrative code example only. To avoid the risk of SQL injection, you can use the operator syntax to build the query template and then provide the query parameter as the second argument to the method in a tuple or list: In this example, you use the operator syntax to create the query template. Then, you provide the parameters as an independent argument to . In this case, the database system will use the specified type and value of when executing the query. This practice offers protection against SQL injection. Note: You should only use the modulo operator syntax in the string literal that represents the query template. You shouldn’t use the operator and the actual sequence of parameters to build the final query. Just let do the hard work and build the final query for you in a safer way. In short, you must avoid using any string interpolation tool to build dynamic queries beforehand. Instead, use the operator syntax to build the query template and pass the query parameters to in a sequence. When you want to provide internationalization and localization in a Python project, the method is the way to go: You can support multiple languages using string templates. Then, you can handle localized string formatting based on the user’s locale. The method will allow you to dynamically interpolate the appropriate strings depending on the user’s language selection.\n\nIf you’re working on porting a legacy codebase to modern Python, and one of your goals is to convert all your strings into f-strings, then you can use the project. This tool allows you to convert traditional strings into f-strings quickly. To use , you need to install it first: This command downloads and installs in your current Python environment. Once you have it installed, you can use the command against your code files. For example, say that you have the following Python file: If you want to update this file and start using f-strings instead of the operator, then you can just run the following command: This command tells to update the content of your file by replacing strings that use the operator and the method with equivalent f-strings. Note that this command will modify your files in place. So, after running the command, will look something like the following: That’s cool, isn’t it? You can also run against a complete directory containing a large Python codebase. It’ll scan every file and convert the old strings into f-strings. So, the tool is quite useful if you’re modernizing your codebase."
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "http://cissandbox.bentley.edu/sandbox/wp-content/uploads/2022-02-10-Documentation-on-f-strings-Updated.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/42097052/can-i-import-pythons-3-6s-formatted-string-literals-f-strings-into-older-3-x",
        "document": "The new Python 3.6 f-strings seem like a huge jump in string usability to me, and I would love to jump in and adopt them whole heartedly on new projects which might be running on older interpreters. 2.7, 3.3-3.5 support would be great but at the very least I would like to use these in Python 3.5 code bases. How can I import 3.6's formatted string literals for use by older interpreters?\n\nI understand that formatted string literals like are not breaking changes, so would not be included in a call. But the change is not back-ported (AFAIK) I would need to be sure that whatever new code I write with f-strings is only ran on Python 3.6+ which is a deal breaker for a lot of projects."
    }
]