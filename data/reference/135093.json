[
    {
        "link": "https://developer.android.com/guide/navigation/integrations/ui",
        "document": "The Navigation component includes a class. This class contains static methods that manage navigation with the top app bar, the navigation drawer, and bottom navigation.\n\nThe top app bar provides a consistent place along the top of your app for displaying information and actions from the current screen.\n\ncontains methods that automatically update content in your top app bar as users navigate through your app. For example, uses the destination labels from your navigation graph to keep the title of the top app bar up-to-date.\n\nWhen using with the top app bar implementations discussed below, the label you attach to destinations can be automatically populated from the arguments provided to the destination by using the format of in your label.\n\nprovides support for the following top app bar types:\n\nFor more information on app bars, see Set up the app bar.\n\nuses an object to manage the behavior of the Navigation button in the upper-left corner of your app's display area. The Navigation button’s behavior changes depending on whether the user is at a top-level destination.\n\nA top-level destination is the root, or highest level destination, in a set of hierarchically-related destinations. Top-level destinations do not display an Up button in the top app bar because there is no higher level destination. By default, the start destination of your app is the only top-level destination.\n\nWhen the user is at a top-level destination, the Navigation button becomes a drawer icon if the destination uses a . If the destination doesn't use a , the Navigation button is hidden. When the user is on any other destination, the Navigation button appears as an Up button . To configure the Navigation button using only the start destination as the top-level destination, create an object, and pass in the corresponding navigation graph, as shown below:\n\nIn some cases, you might need to define multiple top-level destinations instead of using the default start destination. Using a is a common use case for this, where you may have sibling screens that are not hierarchically related to each other and may each have their own set of related destinations. For cases like these, you can instead pass a set of destination IDs to the constructor, as shown below:\n\nTo create a Toolbar with , first define the bar in your main activity, as shown:\n\nNext, call from your main activity's method, as shown in the following example:\n\nTo configure the Navigation button to appear as an Up button for all destinations, pass an empty set of destination IDs for your top-level destinations when building your . This can be useful if, for example, you have a second activity that should display an Up button in the on all destinations. This allows the user to navigate back to the parent activity when there are no other destinations on the back stack. You can use to control the fallback behavior for when would otherwise do nothing, as shown in the following example:\n\nTo include a with your Toolbar, first define the Toolbar and surrounding layout in your activity, as shown below:\n\nNext, call from your main activity's method, as shown below:\n\nTo add navigation support to the default action bar, call from your main activity's method, as shown below. Note that you need to declare your outside of , since you also use it when overriding :\n\nNext, override to handle Up navigation:\n\nAdding the top app bar to your activity works well when the app bar’s layout is similar for each destination in your app. If, however, your top app bar changes substantially across destinations, then consider removing the top app bar from your activity and defining it in each destination fragment, instead.\n\nAs an example, one of your destinations may use a standard , while another uses an to create a more complex app bar with tabs, as shown in figure 2.\n\nTo implement this example within your destination fragments using , first define the app bar in each of your fragment layouts, beginning with the destination fragment that uses a standard toolbar:\n\nNext, define the destination fragment that uses an app bar with tabs:\n\nThe navigation configuration logic is the same for both of these fragments, except that you should call from within each fragment's method, instead of initializing them from the activity:\n\nalso provides helpers for tying destinations to menu-driven UI components. contains a helper method, , which takes a along with the that hosts the associated destination. If the of the matches the of the destination, the can then navigate to that destination.\n\nAs an example, the XML snippets below define a menu item and a destination with a common , :\n\nIf your menu was added via the Activity's , for example, you can associate the menu items with destinations by overriding the Activity's to call , as shown in the following example:\n\nNow, when a user clicks the menu item, the app automatically navigates to the corresponding destination with the same .\n\nThe navigation drawer is a UI panel that shows your app's main navigation menu. The drawer appears when the user touches the drawer icon in the app bar or when the user swipes a finger from the left edge of the screen.\n\nThe drawer icon is displayed on all top-level destinations that use a .\n\nTo add a navigation drawer, first declare a as the root view. Inside the , add a layout for the main UI content and another view that contains the contents of the navigation drawer.\n\nFor example, the following layout uses a with two child views: a to contain the main content and a for the contents of the navigation drawer.\n\nNext, connect the to your navigation graph by passing it to , as shown in the following example:\n\nNext, in your main activity class, call from your main activity's method, as shown below:\n\nStarting in Navigation 2.4.0-alpha01, the state of each menu item is saved and restored when you use .\n\ncan also handle bottom navigation. When a user selects a menu item, the calls and automatically updates the selected item in the bottom navigation bar.\n\nTo create a bottom navigation bar in your app, first define the bar in your main activity, as shown below:\n\nNext, in your main activity class, call from your main activity's method, as shown below:\n\nStarting in Navigation 2.4.0-alpha01, the state of each menu item is saved and restored when you use .\n\nInteracting with the is the primary method for navigating between destinations. The is responsible for replacing the contents of the with the new destination. In many cases, UI elements—such as a top app bar or other persistent navigation controls like a —live outside of the and need to be updated as you navigate between destinations.\n\noffers an interface that is called when the 's current destination or its arguments change. A new listener can be registered via the method. Note that when calling , if the current destination exists, it's immediately sent to your listener.\n\nuses to make these common UI components navigation-aware. Note, however, that you can also use on its own to make any custom UI or business logic aware of navigation events.\n\nAs an example, you might have common UI elements that you intend to show in some areas of your app while hiding them in others. Using your own , you can selectively show or hide these UI elements based on the target destination, as shown in the following example:\n\nAs an alternative, you can also use arguments with default values within the navigation graph, which can be used by the appropriate UI controller to update its state. For example, rather than base the logic in the on the destination ID as per the previous example, we can create an argument in the :\n\nThis argument isn't used when navigating to the destination, but rather as a way to attach additional information to the destination by using the . In this case, the value indicates whether the app bar should be shown when on this destination.\n\nWe can now add an in the :\n\nThe invokes this callback whenever the navigation destination changes. The can now update the state or visibility of the UI components that it owns based upon the arguments received in the callback.\n\nOne advantage of this approach is that the sees only the arguments in the navigation graph and doesn't know individual roles and responsibilities. Similarly, the individual fragments do not know about the containing and the UI components that it owns.\n\nTo learn more about navigation, see the following additional resources.\n• LiveData with SnackBar, Navigation and other events (the SingleLiveEvent case)\n• 10 Best Practices for Moving to a Single Activity\n• Single Activity: Why, When, and How (Android Dev Summit '18)"
    },
    {
        "link": "https://m2.material.io/components/bottom-navigation/android",
        "document": ""
    },
    {
        "link": "https://developer.android.com/design/ui/mobile/guides/foundations/system-bars",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nTogether, the status bar, caption bar, and navigation bar are called the system bars. They display important information such as battery level, the time, and notification alerts, and provide direct device interaction from anywhere.\n\nIt's critical to take the prominence of system bars into account, whether you're designing UI for interactions with the Android OS, input methods, or other device capabilities.\n• None Include system bars when designing your app. Account for UI safe zones, system interactions, input methods, display cutouts, status bars, caption bars, navigation bars, and other device capabilities.\n• None Keep the system status and navigation bars transparent or translucent and draw content behind these bars to go edge-to-edge.\n\nOn Android, the status bar contains notification icons and system icons. The user interacts with the status bar by pulling it down to access the notification shade. Status bar styles can be transparent or translucent.\n\nStatus bar icons can appear differently depending on the context, time of day, user-set preferences or themes, and other parameters. For more information, see System bar icons.\n\nWhen a notification arrives, an icon usually appears in the status bar. This signals to the user that there's something to see in the notification drawer. This can be your app icon or symbol to represent the channel. See Notifications design.\n\nMake the status bar transparent or translucent to ensure your app content spans the entire screen. Then, set the style of your system bar icons so that the icons have proper contrast.\n\nEdge-to-edge is enforced on Android 15 making the status bar transparent by default. Call for backward compatibility.\n\nIn the following left-side image, the status bar is transparent and the 's green background draws behind the status bar.\n\nTransparent status bars are ideal when the UI doesn't appear underneath the status bar or an image draws underneath the status bar. Translucent status bars are ideal when the UI scrolls underneath the status bar. For more on gradient protection see Edge-to-edge design.\n• Home transitions out of the app and to the device's home screen.\n\nUsers can choose from various navigation bar configurations including gesture navigation (recommended) and three-button navigation. To deliver the best experience, account for multiple types of navigation.\n\nWe recommend that you use gesture navigation, unless the user selects otherwise in their preferences. Gesture navigation doesn't use buttons for back, home, and overview, instead it shows a single gesture handle for affordance. Users interact by swiping from the left or right edge of the screen to go back and up from the bottom to go home. Swiping up and holding opens the overview.\n\nGesture navigation is a more scalable navigation pattern for designing across mobile and larger screens. To provide the best user experience, account for gesture navigation by doing the following:\n\nFor more information, see Add support for gesture navigation.\n\nThree-button navigation provides three buttons for back, home, and overview.\n\nDepending on Android version and device other navigation bar configurations may be available to your users. Two-button navigation, for example, provides two buttons for home and back.\n\nNavigation bar icons can also appear differently depending on user-set preferences or themes. For more information, see System bar icons.\n\nAndroid handles visual protection of the user interface in gesture navigation mode and in the button modes. The system applies dynamic color adaptation, in which the contents of the system bars change color based on the content behind them.\n\nAfter targeting Android 15 or calling on the , the system draws a transparent gesture navigation bar and applies dynamic color adaptation. In the following example, the handle in the navigation bar changes to a dark color if it's placed above light content, and vice-versa.\n\nAfter targeting Android 15 or calling on the , the system applies a translucent scrim behind button navigation bars, which you can remove by setting to false.\n\nWe recommend transparent three button navigation bars when there is a bottom app bar or bottom app navigation bar, or when the UI doesn't scroll underneath the three button navigation bar. To get a transparent navigation bar, set to false and pad bottom app bars to draw underneath system navigation bars, as seen in Figure 7, 8, and 9. See System bar protection for more information.\n\nUse a translucent three-button navigation for scrolling content. For more on translucent navigation bar considerations, see .\n\nEach navigation type reacts appropriately to the on-screen keyboard to allow the user to perform actions such as dismissing or even changing the keyboard type. To ensure a smooth transition that synchronizes the transition of the app with the keyboard sliding up and down from the bottom of the screen, use .\n\nA display cutout is an area on some devices that extends into the display surface to provide space for front-facing sensors. Display cutouts can vary depending on the manufacturer. Consider how display cutouts will interact with content, orientation, and edge-to-edge.\n\nYou can hide system bars when you need a full-screen experience, for example when the user is watching a movie. The user should still be able to tap to reveal system bars and navigate or interact with system controls. Learn more about designing for full screen modes, or read about how to hide the system bars for immersive mode."
    },
    {
        "link": "https://stackoverflow.com/questions/49280788/customize-bottom-navigation-view",
        "document": "I have developed an android application using OpenCV. The user interface has a bottom navigation view. When I pressed items in the Bottom Navigation View it applies different filters to the JavaCameraView in real time.\n\nMy problem is that the bottom navigation looks flat. I want to make the items like buttons, elevated from their positions, so they are not in the same plane as the rest of the User Interface.\n\nI am aware of the Bottom sheet, but that won't help me. I have already fully developed the app and finalized the design. I can't use any View other than Bottom Navigation View.\n\nIs there any XML attribute or any method I can use on the BottomNavigationView object to make the Items elevated from their positions?"
    },
    {
        "link": "https://reddit.com/r/Android/comments/4ag5jw/material_design_spec_updated_with_new_guidance",
        "document": "r/Android Android news, reviews, tips, and discussions about rooting, tutorials, and apps. General discussion about devices is welcome. Please direct technical support, upgrade questions, buy/sell, app recommendations, and carrier-related issues to other subreddits.\n\nMaterial Design spec updated with new guidance for bottom navigation (Navigation Bar design)\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n• There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n• You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://stackoverflow.com/questions/14390331/android-sqlite-database-schema",
        "document": "You can do it with code. Sqlite has a table called \"sqlite_master \" which holds the schema information.\n\nA more simple way is to run it on the emulator .\n• Click the pull from db button on top right shown in picture."
    },
    {
        "link": "https://medium.com/@peternjuguna76/mastering-data-storage-in-android-sqlite-sharedpreferences-and-file-storage-9e41078ef089",
        "document": "In the world of Android app development, effectively managing data is paramount to creating functional and user-friendly applications. From user preferences and configuration settings to structured data, there are various mechanisms available for storing data in Android. In this article, we will explore three fundamental data storage methods: SQLite databases, SharedPreferences, and file storage, delving into their use cases, implementation, and best practices.\n\nSQLite is a lightweight relational database management system embedded within Android. It’s the preferred choice for managing structured data such as user profiles, product catalogs, and messaging histories.\n\nImagine you are building a task management app. Each task has properties like a title, description, due date, and priority level. SQLite databases are perfect for storing and querying this structured data efficiently.\n\nSharedPreferences provide a straightforward mechanism for storing simple data types like booleans, integers, floats, and strings. They are commonly used for user preferences and configuration settings.\n\nSuppose you are developing a weather app, and users can set their preferred units (e.g., Celsius or Fahrenheit) and notification preferences. SharedPreferences are an excellent choice for storing these settings.\n• Use a unique name for each SharedPreferences file.\n• Consider the apply() method for asynchronous data saving.\n\nFile storage is versatile for handling various types of unstructured data like images, audio files, and user-generated content.\n\nLet’s say you’re developing a note-taking app that allows users to attach images to their notes. Storing these images as files in the app’s private directory is a suitable approach.\n• Use the getExternalStorageDirectory() for files accessible to other apps.\n\nEffective data storage is a crucial aspect of Android app development. SQLite databases are the go-to choice for structured data, while SharedPreferences simplify the management of key-value pairs. File storage offers versatility for unstructured data like images and audio. Understanding when and how to use these data storage methods is essential to building efficient and user-friendly Android applications.\n\nAs you embark on your Android development journey, keep in mind the specific use cases and best practices associated with each data storage method. With the right approach, your app can efficiently manage and utilize data, enhancing the overall user experience.\n\nThanks for reading! Share this and follow me for upcoming awesome articles for you."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-sqlite-database-example-tutorial",
        "document": "Welcome to Android SQLite Example Tutorial. Android SQLite is the mostly preferred way to store data for android applications. For many applications, SQLite is the apps backbone whether it’s used directly or via some third-party wrapper. Below is the final app we will create today using Android SQLite database.\n\nAndroid SQLite is a very lightweight database which comes with Android OS. Android SQLite combines a clean SQL interface with a very small memory footprint and decent speed. For Android, SQLite is “baked into” the Android runtime, so every Android application can create its own SQLite databases. Android SQLite native API is not JDBC, as JDBC might be too much overhead for a memory-limited smartphone. Once a database is created successfully its located in data/data//databases/ accessible from Android Device Monitor. SQLite is a typical relational database, containing tables (which consists of rows and columns), indexes etc. We can create our own tables to hold the data accordingly. This structure is referred to as a schema.\n\nAndroid has features available to handle changing database schemas, which mostly depend on using the class. SQLiteOpenHelper is designed to get rid of two very common problems.\n• When the application runs the first time - At this point, we do not yet have a database. So we will have to create the tables, indexes, starter data, and so on.\n• When the application is upgraded to a newer schema - Our database will still be on the old schema from the older edition of the app. We will have option to alter the database schema to match the needs of the rest of the app.\n\nwraps up these logic to create and upgrade a database as per our specifications. For that we’ll need to create a custom subclass of implementing at least the following three methods.\n• Constructor : This takes the Context (e.g., an Activity), the name of the database, an optional cursor factory (we’ll discuss this later), and an integer representing the version of the database schema you are using (typically starting from 1 and increment later).\n• onCreate(SQLiteDatabase db) : It’s called when there is no database and the app needs one. It passes us a object, pointing to a newly-created database, that we can populate with tables and initial data.\n• onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) : It’s called when the schema version we need does not match the schema version of the database, It passes us a SQLiteDatabase object and the old and new version numbers. Hence we can figure out the best way to convert the database from the old schema to the new one.\n\nWe define a class to perform all database CRUD(Create, Read, Update and Delete) operations.\n\nBefore performing any database operations like insert, update, delete records in a table, first open the database connection by calling getWritableDatabase() method as shown below:\n\nThe dbHelper is an instance of the subclass of . To close a database connection the following method is invoked.\n\nThe following code snippet shows how to insert a new record in the android SQLite database.\n\nContent Values creates an empty set of values using the given initial size. We’ll discuss the other instance values when we jump into the coding part.\n\nThe following snippet shows how to update a single record.\n\nWe just need to pass the id of the record to be deleted as shown below.\n\nA Cursor represents the entire result set of the query. Once the query is fetched a call to cursor.moveToFirst() is made. Calling moveToFirst() does two things:\n• It allows us to test whether the query returned an empty set (by testing the return value)\n• It moves the cursor to the first result (when the set is not empty)\n\nThe following code is used to fetch all records:\n\nAnother way to use a Cursor is to wrap it in a . Just as adapts arrays, adapts Cursor objects, making their data available to an like a . Let’s jump to our project that uses SQLite to store some meaningful data.\n\nIn this application we wish to create records that store Country names and their respective currencies in the form of a ListView. We cover all the features discusses above.\n\nThe application consists of 5 classes. We begin with defining with DatabaseHelper, which is a subclass of SQLiteOpenHelper as follows:\n\nAs discussed above we have overridden the and methods besides the constructor. We’ve assigned the names to the database and the table as JOURNALDEV_COUNTRIES.DB and COUNTRIES respectively. The index column is auto incremented whenever a new row is inserted. The column names for country and currency are “subject” and “description”. The DBManager classes is where the DatabaseHelper is initialized and the CRUD Operations are defined. Below is the code for this class:\n\nThe class is the activity which is launched when the application starts. Below is layout defined for it:\n\nHere a ListView component is defined to included the records stored in the database. Initially the ListView would be empty hence a TextView is used to display the same.\n\nIn this activity the DBManager object is invoked to perform the CRUD Operations. A SimpleCursorAdapter is defined to add elements to the list from the query results that are returned in an Cursor Object. On list item click an intent is performed to open the ModifyCountryActivity class. The menu contains an item to add a new record from the ActionBar. Here again an intent is performed to open the AddCountryActivity class. Below is code.\n\nThe xml layout and code of file are defined below:\n\nTwo EditText components that take the inputs for country and currency along with a button to add the values to the database and display it in the ListView are defined.\n\nThe CRUD operation performed here is adding a new record to the database. The xml layout and code of ModifyCountryActivity.java file are defined below:\n\nIt’s similar to the previous layout except that modify and delete buttons are added.\n\nThe CRUD operations performed here are updating and deleting a record. The below images are the screenshots of the final output of our project. The first image is the output seen when the application is launched for the first time. The second image is the result of clicking the menu option from the ActionBar to add a new record as shown below. The third image shows an output when 3 records are added : The fourth image shows the output when any list item is clicked to modify or delete a record : The final image is the output when a record is deleted. In this example we delete the first record :\n\nAs we’ve discussed earlier in this tutorial, the database file is stored in the internal storage that is accessible from the Android Device Monitor as visible in the pic below. To view this database we need to pull this file from the device to our desktop. This is done by clicking the menu option in the top right as seen in the image below : To open this file download the SQLiteBrowser from this link. The snippets below show the schema and tables in the browser. To view the table go to the Browse Data tab on top. The following image is seen: This brings an end to Android SQLite tutorial. The final Android SQLite Project is downloadable from the below link."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-and-add-data-to-sqlite-database-in-android",
        "document": "How to Create and Add Data to SQLite Database in Android?\n\nSQLite is another data storage available in Android where we can store data in the user’s device and can use it any time when required. In this article, we will take a look at creating an SQLite database in the Android app and adding data to that database in the Android app. This is a series of 4 articles in which we are going to perform the basic CRUD (Create, Read, Update, and Delete) operation with SQLite Database in Android. We are going to cover the following 4 articles in this series:\n• None How to Create and Add Data to SQLite Database in Android?\n• None How to Read Data from SQLite Database in Android?\n• None How to Update Data to SQLite Database in Android?\n• None How to Delete Data in SQLite Database in Android?\n\nAndroid SQLite Database is an open-source database provided in Android that is used to store data inside the user’s device in the form of a Text file. We can perform many operations on this data such as adding new data, updating, reading, and deleting this data. SQLite is an offline database that is locally stored in the user’s device and we do not have to create any connection to connect to this database.\n\nHow Data is Being Stored in the SQLite Database?\n\nData is stored in the Android SQLite database in the form of tables. When we store this data in our SQLite database it is arranged in the form of tables that are similar to that of an Excel sheet. Below is the representation of our SQLite database which we are storing in our SQLite database.\n\nBelow are the several important methods that we will be using in this SQLite database integration in Android.\n\nThis method is used to get the Array of column names of our SQLite table. This method will return the number of rows in the cursor. This method returns a Boolean value when our cursor is closed. This method returns the total number of columns present in our table. This method will return the name of the column when we passed the index of our column in it. This method will return the index of our column from the name of the column. This method will return the current position of our cursor in our table.\n\nWhat we are going to build in this article?\n\nWe will be building a simple application in which we will be adding data to the Android SQLite database. We will be creating a database for adding course name, course description, course duration, and course tracks. We will be saving all this data in our Android SQLite database. A sample video is given below to get an idea about what we are going to do in this article. Note that we are going to implement this project using the Java language.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio. Note that select Java as the programming language.\n\nStep 2: Adding permissions to access the storage in the AndroidManifest.xml file\n\nNavigate to the app > AndroidManifest.xml and add the below code to it.\n\nNavigate to the app > res > layout > activity_main.xml and add the below code to that file.\n\nBelow is the code for the activity_main.xml file.\n\nNavigate to the app > java > your app’s package name > Right-click on it > New > Java class and name it as DBHandler and add the below code to it. Comments are added inside the code to understand the code in more detail.\n\n// below variable is for our database name. // below int is our database version // below variable is for our table name. // below variable is for our id column. // below variable is for our course name column // below variable id for our course duration column. // below variable for our course description column. // below variable is for our course tracks column. // below method is for creating a database by running a sqlite query // on below line we are creating // an sqlite query and we are // along with their data types. // at last we are calling a exec sql // this method is use to add new course to our sqlite database. // on below line we are creating a variable for // as we are writing data in our database. // on below line we are creating a // on below line we are passing all values // along with its key and value pair. // after adding all values we are passing // at last we are closing our // this method is called to check if the table exists already.\n\nGo to the MainActivity.java file and refer to the following code. Below is the code for the MainActivity.java file. Comments are added inside the code to understand the code in more detail.\n\nNow run your app and see the output of the app.\n\nAfter successfully executed the code enter the required data inside the EditText. Most importantly if you want to know How to View and Locate SQLite Database in Android Studio then please refer to this article.\n\nAnd you can see below this is how the data stored in the SQLite database.\n\nBelow is the complete project file structure after performing the create and add operation:"
    }
]