[
    {
        "link": "https://luisllamas.es/en/input-simulator",
        "document": "H.InputSimulator is a .NET library that allows you to simulate keyboard or mouse input under the Windows operating system.\n\nIn general, emulating input devices should be the last option for automation. But, in many cases, input automation is a very useful tool for integrating with other programs.\n\nThis library is based on the library https://github.com/TChatzigiannakis/InputSimulatorPlus, which in turn is a fork of the well-known https://github.com/michaelnoonan/inputsimulator. However, InputSimulator is not compatible with .NET Core, and InputSimulatorPlus is currently unmaintained.\n\nInputSimulator provides functionalities for input simulation, such as simulating key presses, modified key presses, or direct text input. Additionally, it can also simulate mouse movement, click simulation, or mouse wheel scrolling.\n\nHow to use InputSimulator\n\nWe can add the library to a .NET project easily, through the corresponding Nuget package.\n\nThe library provides the InputSimulator which has methods to emulate keyboard and mouse input in a “fluent” syntax.\n\nFor example, if we want to simulate the pressing of the Enter key, we can do so with the following code:\n\nThis code will simulate entering the phone number “555-555-5555” in the text field, then press the Tab key to move to the next text field, and finally, write “12345” in the second text field and press the Enter key to submit the form.\n\nHere are a couple of more complex examples, taken from the library’s documentation.\n\nAs we can see, it is a very useful tool for input data automation. Its use is very simple and can save us a lot of time and effort in creating applications that require keyboard and mouse input simulation.\n\nH.InputSimulator is OpenSource and the code is available at https://github.com/HavenDV/H.InputSimulator under the Microsoft Public License (Ms-PL) license."
    },
    {
        "link": "https://stackoverflow.com/questions/18920235/inputsimulator-does-not-simulate-mouse-clicks",
        "document": "I am using InputSimulator to simulate key presses and mouse clicks. Every key I've tested so far works, except the mouse buttons. I send them like this:\n\nBut nothing happens. Do I do anything wrong?"
    },
    {
        "link": "https://stackoverflow.com/questions/57761726/how-to-simulate-physically-moving-the-mouse-c",
        "document": "What I want, is to make the computer think I am physically moving the mouse down toward me. I am making a program that should send input into a game. I have succeded to make it receive keyboard input programmatically, but encounter problems with the mouse.\n\nWhen playing the game normally, it uses a first person perspective with a dot in the middle. When opening menus or maps, it has a cursor, but only then. I have tested several suggestions for mouseinputs, but the game only responds when I am in a mode that uses a cursor that it then moves, like the map or menu, but not in other cases.\n\nWhat I want, is for my avatar to look down when I am in first perspective normal play mode, which it does when I move the mouse down. From this I infer, any method that that tries to move a cursor is ineffective, since the game mode doesn't have a normal cursor. I need to make the computer itself think that the mouse has been physically moved, never mind cursor.\n\n(For reference, one of the things I have tried is https://gist.github.com/Harmek/1263705), and other examples of using imported SendInput."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/input-mouse/how-to-simulate-events?view=netdesktop-9.0",
        "document": "Simulating mouse events in Windows Forms isn't as straight forward as simulating keyboard events. Windows Forms doesn't provide a helper class to move the mouse and invoke mouse-click actions. The only option for controlling the mouse is to use native Windows methods. If you're working with a custom control or a form, you can simulate a mouse event, but you can't directly control the mouse.\n\nMost events have a corresponding method that invokes them, named in the pattern of followed by , such as . This option is only possible within custom controls or forms, because these methods are protected and can't be accessed from outside the context of the control or form. The disadvantage to using a method such as is that it doesn't actually control the mouse or interact with the control, it simply raises the associated event. For example, if you wanted to simulate hovering over an item in a ListBox, and the doesn't visually react with a highlighted item under the cursor.\n\nThese protected methods are available to simulate mouse events.\n\nFor more information about these events, see Using mouse events (Windows Forms .NET)\n\nConsidering most controls do something when clicked, like a button calling user code, or checkbox change its checked state, Windows Forms provides an easy way to trigger the click. Some controls, such as a combobox, don't do anything special when clicked and simulating a click has no effect on the control.\n\nThe System.Windows.Forms.IButtonControl interface provides the PerformClick method which simulates a click on the control. Both the System.Windows.Forms.Button and System.Windows.Forms.LinkLabel controls implement this interface.\n\nWith a form a custom control, use the InvokeOnClick method to simulate a mouse click. This is a protected method that can only be called from within the form or a derived custom control.\n\nFor example, the following code clicks a checkbox from .\n\nWindows provides methods you can call to simulate mouse movements and clicks such as and . The following example moves the mouse cursor to the center of a control:\n• Overview of using the mouse (Windows Forms .NET)\n• How to distinguish between clicks and double-clicks (Windows Forms .NET)"
    },
    {
        "link": "https://github.com/michaelnoonan/inputsimulator",
        "document": "The Windows Input Simulator provides a simple .NET (C#) interface to simulate Keyboard or Mouse input using the Win32 SendInput method. All of the Interop is done for you and there's a simple programming model for sending multiple keystrokes.\n\nWindows Forms provides the SendKeys method which can simulate text entry, but not actual key strokes. Windows Input Simulator can be used in WPF, Windows Forms and Console Applications to synthesize or simulate any Keyboard input including Control, Alt, Shift, Tab, Enter, Space, Backspace, the Windows Key, Caps Lock, Num Lock, Scroll Lock, Volume Up/Down and Mute, Web, Mail, Search, Favorites, Function Keys, Back and Forward navigation keys, Programmable keys and any other key defined in the Virtual Key table. It provides a simple API to simulate text entry, key down, key up, key press and complex modified key strokes and chords.\n\n// You can simulate chords with multiple modifiers // For example CTRL-K-C whic is simulated as // You can simulate complex chords with multiple modifiers and key presses // For example CTRL-ALT-SHIFT-ESC-K which is simulated as\n\n// Determines if the shift key is currently down // Determines if the caps lock key is currently in effect (toggled on)\n\nIt was originally written for use in the WpfKB (WPF Touch Screen Keyboard) project to simulate real keyboard entry to the active window. After looking for a comprehensive wrapper for the Win32 and User32 input simulation methods and coming up dry I decided to write and open-source this project. I hope it helps someone out there!"
    },
    {
        "link": "https://stackoverflow.com/questions/69261221/looking-for-a-way-to-smooth-mouse-movement-in-c-sharp",
        "document": "So, i have every single line of code ready to move and click LMB in c#, but my issue is that the coursor just teleports to desired location and it looks yerk af. Instead of \"teleporation\" happening i would like the mouse to move smoothly to desired position over a set amount of time (desirebly miliseconds).\n\nI'm looking for a method similar to this:\n\nCurrently im using this as my moving method\n\nJust to clarify, im moving the mouse by a certain amount of pixels on X and Y axis, not hard-setting the position on the screen.\n\nI already tried dividing the movement into smaller pieces, but since pixels can't be doubles it means that sometimes, when there is a remainder from the division im loosing on precision.\n\nAny ideas how to implement that? I've read something about vectors, but i did't manage to get them working as intended :("
    },
    {
        "link": "https://stackoverflow.com/questions/7966842/normalize-and-smooth-the-mouse-movements",
        "document": "This is only possible if you can delay the effect of the mouse movement slightly. You record the points of the mouse movement at a certain frequency and then average them out to a line. Then use that line to draw whatever you need. You wont be able to directly set the mouse cursor to the averaged position as that would then feedback into your program as a new mouse movement.\n\nMake sure you build it so you can tweak how long you delay the mouse movement, and how aggressive the averaging is (say by restricting the number of points it includes), and the frequency at which you record mouse movements (this is could affect cpu usage if its too frequent).\n\nYou will of course have to create some sort of abstraction for the mouse in your application and create a way for the application to get hold of it. (I would be trying to keep this as similar as possible to normal winforms/wpf so I could revert the change and just use mouse movement directly if needed)."
    },
    {
        "link": "https://sharpcoderblog.com/blog/how-to-create-a-smooth-mouse-movement-in-unity",
        "document": "Smooth mouse movement is an essential aspect of game development that helps to improve the overall user experience. By implementing smooth mouse movement, you can make your game's camera or player controls feel more fluid and responsive, resulting in a polished and immersive gameplay experience. In this tutorial, we will walk through how to set up smooth mouse movement in Unity, with step-by-step instructions and code examples in C#. We'll also discuss the possible reasons why you would want to implement this feature in your games.\n\nHere are a few reasons why smooth mouse movement is important in games:\n• Improved User Experience: Smooth controls help the player feel more in control of their actions, which is essential for immersion, especially in first-person or third-person games.\n• Enhanced Precision: Fine-tuning mouse movement allows for more precise camera controls, which is crucial in shooter games or any games that involve careful aim.\n• Polished Look and Feel: It makes the game feel more professional and polished, which is essential in retaining players and keeping them engaged.\n• Reduces Motion Sickness: Jittery or overly sensitive camera movement can cause discomfort or motion sickness for players. Smooth mouse movement can help reduce this risk.\n\nLet's go through the steps to create smooth mouse movement in Unity.\n\nFirst, create a new C# script that will control the mouse movement. You can name this script something like .\n• controls how sensitive the mouse input is.\n• represents the player's transform, which rotates along the Y-axis for horizontal mouse movement.\n• The variable stores the current vertical rotation (up and down), and it is clamped between -90 and 90 degrees to prevent over-rotation.\n• We lock the mouse cursor to the center of the screen to avoid the cursor moving out of the game window.\n\nStep 2: Attach the Script to the Camera\n\nNow that the script is ready, go to your Unity scene and attach the script to your camera (e.g., the object).\n\nThen, assign the field by dragging the player object (usually the character controller or an empty game object representing the player) into the script's field in the Inspector.\n\nYou can experiment with the value to achieve the level of control you want. A good starting point is 100, but you can adjust it higher or lower depending on your desired level of precision.\n\nFor even smoother movement, you can apply interpolation to the mouse input values. This ensures that the camera transitions smoothly between each frame, rather than jumping from one position to the next. Here's an example of how to implement that:\n\nThis updated version introduces smoothing using . The variable controls how smooth the transition should be. Lower values make the movement more responsive, while higher values make it slower and more gradual.\n\nOnce you have the script in place, test the game and adjust the sensitivity and smoothing values based on how smooth you want the mouse movement to be. You can also adjust the clamping angle to allow more or less freedom of camera movement.\n\nBy implementing smooth mouse movement in your Unity project, you can significantly enhance the player experience by offering precise and fluid camera control. This tutorial walked you through setting up a basic mouse movement system and enhancing it with smoothing techniques."
    },
    {
        "link": "https://reddit.com/r/pcgaming/comments/52xf4t/how_to_get_smooth_mouse_movement_in_games",
        "document": "Any ideas? I love playing with game pad on my PC, because I can move the camera in a very smooth way. Is it possible to move the camera so smoothly even with a mouse? If so then how? When I want to move the camera slowly with mouse, it's usually kind of tearing movement, but not smooth like with gamepad if you know what I mean. It probably depends on a surface (which one would you recommend me). But is there even another way? Thank you guys"
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/practical-tips-for-boosting-the-performance-of-windows-forms-apps",
        "document": "Practical Tips For Boosting The Performance Of Windows Forms Apps\n\nWindows Forms allow you to build a rich and responsive user interface for your applications. In this article I'll discuss a number of techniques you can use to ensure that Windows® Forms-based apps provide optimal performance as well. I'll discuss common performance-critical scenarios such as startup, control population, and control painting. Plus, I'll discuss how to design and code for performance in your application. Together these techniques should give you a good, basic foundation for getting the most out of your UIs.\n\nStartup time is an important performance metric for most applications. Quick startup leaves the user with a favorable perception of your application's performance and usability. There are two terms that describe how an application starts up: warm startup and cold startup. If you start any managed application immediately after restarting your computer, then close the app and start it again. You will usually notice a pretty significant difference in startup time. The first (cold) startup will have to perform disk I/O operations to bring all of the required pages into memory. The second (warm) startup is significantly faster because it reuses the pages that are already present in memory.\n\nTo get the warm startup effect, you don't necessarily have to have previously run the same application. Just starting any managed application will bring into memory many pages from the Microsoft® .NET Framework binaries, and this will improve startup time for any managed applications that start later.\n\nWhen designing for performance, it is important to distinguish between these two scenarios and to set separate goals for them. While warm startup can be improved by reducing CPU utilization, cold startup is affected mostly by disk I/O. Therefore, some optimizations improve some scenarios and not others.\n\nI will start with some general performance advice applicable to a starting application written in any managed code. Then I'll give you some tips specific to improving the performance of Windows Forms-based apps. For detailed guidelines on improving the startup performance of managed applications, see the CLR Inside Out column by Claudio Caldato in the February 2006 issue of MSDN®Magazine at CLR Inside Out: Improving Application Startup Time.\n\nOne way to improve cold startup is to reduce the number of DLLs that you load into your application. This directly affects the number of pages that have to be touched during application startup. Additionally, reducing the number of modules loaded reduces the CPU overhead associated with loading a module, also improving warm startup times.\n\nYou can diagnose how modules are being loaded into your application using the Load Module event filter within the WinDbg debugger in the Platform SDK. Alternatively you can use the following WinDbg command to see why a specific module was loaded:\n\nReview the call stacks and see if some of the module loads could be avoided. You can also use the \"ca ml\" option of the MDbg managed debugger, available as part of the .NET Framework SDK. In some cases you can avoid loading additional modules by simply refactoring your code. If your application loads lots of DLLs that you own, consider merging them into fewer bigger DLLs where it makes sense to do so.\n\nJust-in-time (JIT) compilation of methods can consume many CPU cycles and easily become a bottleneck during application startup. To avoid this overhead you can precompile assemblies using the Native Image Generator, NGen.exe (see Speed: NGen Revs Up Your Performance with Powerful New Features). NGen performs all of the work of the JIT compiler, but accomplishes this work up front, then persists those changes to disk, saving CPU cycles at run time. Using NGen to precompile your binaries has an additional performance benefit: native code pages can be shared between processes, while JIT-compiled code pages are private to a process and cannot be reused.\n\nDespite the advantages, precompilation is not always a a panacea for startup time. While warm startup will likely benefit from NGen precompilation, cold startup may not improve or might even be a little slower because the pages containing compiled code now need to be loaded from disk. However, if JIT compilation is eliminated completely, you might see a benefit even for cold startup since the pages required for the JIT compiler itself would not need to be loaded. It is good to measure both the cold and warm startup times to assess the impact of NGen.\n\nAnother technique is to install strong-named assemblies in the Global Assembly Cache (GAC) to avoid strong-name signature verification, a costly process that touches every page of the assembly before it is loaded. If you decide to use NGen, it's even more important to have strong-named assemblies in the GAC and avoid DLL rebasing.\n\nEvery binary (DLL or EXE) has a preferred base address—a location in virtual memory where it is to be loaded. This address is specified at build time. If you use the Visual Basic® or C# compiler, then all of your binaries will get the same base address (0x400000) if no explicit build directions to the contrary are given. Thus, at load time, your EXE will be placed at this address and all of your DLLs will be have to be placed elsewhere in virtual memory (rebased), since their preferred base address is occupied.\n\nWhen a DLL is rebased, the loader updates all of the absolute addresses in the DLL to reflect the new load address. This means every page that contains an address that needs to be adjusted will be touched when the DLL gets rebased. Moreover, in order to become writable, a page needs to be copied and backed by a pagefile. At that point the page is private to the process and cannot be shared with other processes.\n\nTo avoid the rebasing performance hit, you can explicitly specify a preferred base address by using the /baseaddress compiler switch for each DLL in your application. Assign base addresses to the DLLs beginning from some predetermined starting point (for example, 0x10000000), and leave gaps between the addresses that are large enough to give some room for growth to the DLL that will lie in that range.\n\nNGen images tend to be significantly bigger than Intermediate Language (IL) images and this increases the impact of rebasing. NGen sets the same base address for the image it creates as the address specified in the IL image. Therefore, if you decide to NGen your assemblies, then when you assign base addresses for your IL images you should leave enough space to fit NGen images. Usually you will need two or three times more space for an NGen image than for the equivalent IL image.\n\nYou can check that your base address assignment worked properly by verifying actual load addresses and comparing them with preferred load addresses. To accomplish this, you can use the task list sample application, TList.exe, and the Microsoft COFF Binary File Dumper, Dumpbin.exe. This command shows the actual load address for each DLL loaded in the context of the application with process ID 1240:\n\nDumpbin allows you to check the preferred base address for your DLL, as shown here:\n\nLooking at the output of this command, you'll see OPTIONAL HEADERS with an image base listed, something like this:\n\nThis means the preferred base address of test.dll is 75F70000 and that the address range of 75F70000 to 75F78FFF should be available in order to load this DLL at its preferred base address.\n\nThe perception of startup performance depends largely on the delay until the first UI is shown. You should minimize the logic required to display the UI. This includes any work performed in the Load event of the form because this is evaluated as the form is in the process of showing itself.\n\nIf you use expensive network or database calls, make them asynchronous on a different thread to avoid blocking the UI. In Windows Forms 2.0, the BackgroundWorker component can be used to push work onto a background thread. In Figure 1, BackgroundWorker is used to recursively find all files matching a given pattern (for example, \"*.txt\") in a given folder and its subfolders. The background thread updates the UI thread on its progress, and the UI thread adds the files or subfolders to a TreeView representation in response to progress updates. The resulting TreeView is filtered so that subfolders that don't contain matching files are not shown.\n\nThe advantage of using a background thread here is that the UI is fully accessible while the search proceeds. Your user can scroll though the list of files found so far and expand subfolder nodes that have been added to the TreeView.\n\nOperations that must be performed, but are not needed for displaying the first UI, can be done while the system is idle or on demand after the first UI is shown. For example, if you have a TabControl, populate only the topmost page on startup and retrieve the information for other pages when required. The code in Figure 2 includes a form with a TabControl containing six TabPages. I put all of the controls required for each TabPage on a UserControl and added this to a control collection of the TabPage when the TabPage is going to be shown. For simplicity I used the same UserControl for each of the TabPages and only slightly changed the context of some child controls, but you can easily have a separate UserControl corresponding to each TabPage.\n\nFor the topmost page I added the UserControl in Form's constructor. For other pages I did it in response to firing of the TabControl.SelectedIndexChanged event when the corresponding page is going to be shown. The user will experience some delay when a TabPage is selected for the first time. Then the next time it is selected, there's no delay since the TabPage has already been initialized.\n\nIn this example, I've intentionally slowed down the creation of the TabPages by showing a ListView with a large number of items. If I initialize all the TabPages up front, the time required to show a form is nine seconds on my system (Pentium III, 800 MHz, 512 MB RAM). By filling the TabPages on demand, showing each TabPage the first time takes about 1.5 seconds. If only the topmost page is populated, the entire form is shown in 1.5 seconds.\n\nI can push this a little further by listening for the Application.Idle event and populating one TabPage at a time when the Idle event occurs. When the form is shown or a new TabPage is shown, it will take a user some time to look at the form and move the mouse to select another page. During this organic delay in the application operation, the Idle event will be processed and additional TabPages will be populated.\n\nIf other techniques fail to improve startup performance sufficiently, you might consider using splash screens and progress bars to keep users informed, like this example at Creating a Splash Screen Form on a Separate Thread. If you write your app in Visual Basic, you can use the My.Application.SplashScreen property of the .NET Framework 2.0 (see My.Application.SplashScreen Property).\n\nMany Windows Forms Controls such as ListView, TreeView, and Combobox display collections of items. Adding too many items to these collections can cause a bottleneck if no optimizations are applied. Fortunately, several control population improvements were incorporated into Windows Forms in the .NET Framework 2.0. These include the use of the BeginUpdate and EndUpdate methods internally within AddRange methods, optimizing TreeView population with AddRange, and optimizing sorted population of all controls.\n\nThe most common reason for slow control population is the repainting of the control after each change. A number of Windows Forms controls implement BeginUpdate and EndUpdate methods, which suppress repainting while the underlying data or control properties are manipulated. Using these methods allows you to make significant changes to your control (like adding items to its collection) while avoiding constant repainting. Here's an example of using these methods:\n\nBulk operations are always more efficient than individual changes. The preferred way to add items to the collections of controls such as ComboBox, ListView, or TreeView is to use the AddRange method, which lets you add an array of pre-created items at one time. Windows Forms does all of the possible optimizations to make this operation efficient. Often this just means that BeginUpdate and EndUpdate will be called for you. In some cases, however, additional optimizations will be done. For the TreeView control, for example, these optimizations are significant.\n\nListView population works considerably faster if it is performed after the ListView's handle is created. If you need to show a form having a ListView with many items, add items to ListView in the Form.Load or Form.Show event handler. At this point the ListView handle is created already. If you add ListView items in the Form's constructor (that is, before the ListView handle is created), the items will be added quickly, but showing the form will take significant time due to slow ListView rendering.\n\nUnlike ListView, TreeView is populated significantly faster if nodes are added before the handle is created. If you use TreeView.AddRange you will not notice the difference; your TreeView will be populated quickly regardless of when you do it. However if you use the Add method and add nodes in the form's constructor before the TreeView's handle is created, your TreeView will be populated and shown as quickly as if you had used the AddRange method.\n\nWhen populating databound controls such as ComboBox or ListBox, it is more efficient to set the DataSource property last, after ValueMember and DisplayMember are set. Otherwise your control will be repopulated as a result of the ValueMember change:\n\nFor this reason, the code just shown is more efficient than this:\n\nBindingSource.SuspendBinding and BindingSource.ResumeBinding are two methods that allow the temporary suspension and resumption of data binding. SuspendBinding prevents changes from being pushed into the data source until ResumeBinding is called.\n\nThese methods are designed to be used with simple bound scenarios such as TextBox or ComboBox data binding. The code in Figure 3 demonstrates that the iteration that suspends and resumes binding works approximately five times faster than the iteration that does not.\n\nControls that implement complex data binding, such as the DataGridView control, update their values based on change events such as ListChanged, so calling SuspendBinding will not prevent them from receiving changes to the data source. You can use these methods in complex binding scenarios if you suppress ListChanged events by setting the RaiseListChangedEvents property to false.\n\nChanges such as resizing or realigning a control can also cause problems. For example, when child controls are added to a form or ToolStrip, a Control.Layout event is fired. A change to the size or location of a child control will cause a Layout event on a parent control. Font size changes will also cause a Layout event. In response to the Layout event, the form scales and arranges controls. Having too many Layout events processed while you create or resize your control may have a significant performance impact.\n\nComponent code generated by the Windows Forms designer starts with SuspendLayout and ends with ResumeLayout. This is done to avoid performing layout on the form while it is being created and populated with controls. The SuspendLayout method allows multiple actions to be performed on a control without generating a Layout event for each change. Use this technique whenever possible to minimize the number of Layout events.\n\nRemember that SuspendLayout only prevents Layout events from being performed for that particular control. If controls are added to a panel, for example, SuspendLayout and ResumeLayout must be called for the panel and not for the parent form.\n\nChanging properties such as Bounds, Size, Location, Visible, and Text for AutoSize controls will fire a Layout event. It will be even more expensive if these properties are changed in Form.Load, since all handles are created by then and thus many messages will be processed. This is another place where you should add SuspendLayout and ResumeLayout to prevent extra Layout events from occurring. If possible, make all of these changes within InitializeComponent—this way only one Layout event is ever needed.\n\nSeveral properties dictate the size or location of a control: Width, Height, Top, Bottom, Left, Right, Size, Location, and Bounds. Setting panel1.Width and then panel1.Height causes twice the work of setting them both together via panel1.Size. Running the code in Figure 4 demonstrates the difference.\n\nIf the handles are created you will notice the difference, even if you use SuspendLayout and ResumeLayout calls. SuspendLayout only prevents Windows Forms OnLayout from being called. It will not prevent messages about size changes from being sent and processed. You should try to set the property that reflects the most information you have. If you're just changing the size, set Size; if you're changing the size and location, change Bounds.\n\nIf your Windows Forms application is drawing-intensive, it could benefit from enhanced painting performance. First, minimize the work that is done on every Paint event. Make your Paint event handler as lightweight as possible by moving any expensive operations out of it. For example, if you need to render text based on your current ClientSize, you can create the appropriately sized Font object in a Resize event handler instead of on every Paint event. If you need to create a Brush for drawing, you could cache it instead of recreating it repeatedly.\n\nWhen you want your control to be redrawn, you can call its Invalidate method. The entire control will be redrawn if you do not pass any arguments to this call. In many cases you can optimize drawing performance by carefully calculating the area that needs to be repainted and passing that area as an argument to Invalidate.\n\nIf this does not work well enough, you might want to use the ClipRectangle structure that is included in the PaintEventArgs parameter of the OnPaint event. For example, you can draw a part of an image that was invalidated by doing the following:\n\nUsing this technique, however, frequently requires careful calculations (such as if scrolling or scaling is involved).\n\nWindows Forms and the underlying Win32® architecture expose two layers of painting for any control: background and foreground. The Control.OnPaintBackground function is responsible for drawing background effects (typically background image and back color) and Control.OnPaint function is responsible for drawing foreground effects (images and text). If your control is not using the background image or background color, but instead custom paints everything in OnPaint, using the Opaque control style may help performance by skipping over painting logic that is not being used. In particular, if ControlStyles.Opaque is set to true on the control, the OnPaintBackground function will be skipped, as it is assumed that the OnPaint function will perform all the painting work (including painting the background). Additionally, this style might be advantageous when your control is completely covered by other controls and its background need not be painted.\n\nYou can measure and draw text on a Windows Forms Control in the .NET Framework 2.0 using the TextRenderer class. TextRenderer has two methods, MeasureText and DrawText, each with several overloads. The efficiency of your rendering operations depends on the overloads you choose and the options that you set in the TextFormatFlags argument.\n\nFor measuring single-line strings, you're better off not using the TextFormatFlag.WordBreak flag. When this flag is set, GDI executes a reliable but costly algorithm to determine the places the text needs to be broken into. Similarly, do not use the TextFormatFlags.PreserveGraphicsClipping and TextFormatFlags.PreserveGraphicsTranslateTransform options if no clipping or transforms have been applied to the Graphics object because these options cause some expensive calculations to occur.\n\nIt's better to use the TextRenderer method overloads that do not get IDeviceContext as an argument. These methods are more efficient because they use a cached screen-compatible memory device context rather than retrieving the native handle for device context from the internal DeviceContext and creating an internal object to wrap it.\n\nIf your application displays image files and contains an alpha component, blending, you can improve performance significantly by prerendering the images into a special premultiplied bitmap format. If an image has an alpha component, its color components should be multiplied by alpha when the image is displayed. Prerendering an image with premultiplied alpha eliminates several (three for RGB images) multiplication operations for each pixel in the image.\n\nTo use this technique, first load the image from a file, then render it to a bitmap with PixelFormat.Format32bppPArgb. Figure 5 uses this technique to set the Background image on a control.\n\nIn Windows Forms 2.0, the BackgroundImage property has a companion property called BackgroundImageLayout. In prior versions of the .NET Framework, the background image was automatically tiled by Windows Forms, letting the image repeat throughout the client area. The new BackgroundImageLayout property allows you to set your background image layout to Tile, Center, Stretch, or Zoom. To preserve application compatibility with previous versions of the .NET Framework, Tile layout is still the default.\n\nIn addition to adding a rich set of background image features to Windows Forms, the nondefault values of BackgroundImageLayout improve performance of your background image painting. The major drawback to the Tile setting is that a TextureBrush is required to repeat the image pattern. The creation of the TextureBrush is expensive as it involves scanning the entire image. Other layouts simply make use of the Graphics.DrawImage method, resulting in much better performance.\n\nFor layouts other than Tile, setting the BackgroundImage and BackgroundImageLayout properties may automatically turn on the DoubleBuffered property. In particular, if the image has some sort of transparency (as detected through ImageFlagsHasAlpha), the control will start using double buffering to increase performance. For Tile layout, the DoubleBuffered property is not turned on automatically, but you can always turn it on manually.\n\nDouble buffering is a technique used to make drawing faster and appear smoother by reducing flicker. The basic idea is to take the drawing operations used to paint your control and apply them to an off-screen buffer. Once all of the drawing operations have finished, this buffer is drawn as a single image onto the control. This usually reduces flicker and makes the application seem faster. This behavior can be achieved in the .NET Framework 2.0 by setting a control style to OptimizedDoubleBuffer, which is equivalent to setting the DoubleBuffer and UserPaint styles in previous versions of the Framework.\n\nTo fully enable double buffering, you must also set AllPaintingInWmPaint to true. When it is set, the window message WM_ERASEBKGRND is ignored, and both OnPaintBackground and OnPaint methods are called directly from the WM_PAINT message. If you set DoubleBuffering and AllPaintingInWmPaint to true, then OnPaintBackground and OnPaint will be called with the same buffered graphics object and everything will paint off-screen together and update all at once.\n\nTo benefit from double buffering you have to set both these styles to true or set the DoubleBuffered property on your control, like this:\n\nIt is important to mention here that setting the DoubleBuffered property is not always the optimal solution to painting problems. This property should be used with care, depending on your application and targeted scenarios. The main drawback of setting DoubleBuffered is that it results in a significant amount of memory being allocated for painting. If you have to use double buffering, consider also invalidating small parts of the control so that only the most important parts need to be repainted.\n\nAnother side effect of setting AllPaintingInWmPaint to true can be a visible white trace over the child controls of your control when a window belonging to another application is moved across your window. This can happen because child control windows get many WM_ERASEBKGND messages and only one WM_PAINT message. Since WM_ERASEBKGND messages are ignored, repainting happens too rarely for them.\n\nThe screen in Figure 6 demonstrates animation of text over a user control for which a background image is set. You can set different painting options to see how they affect painting smoothness and speed (this sample application is available for download from the MSDN Magazine Web site).\n\nThe main form has a user control called DrawingSurface, which has a background image, some text (\"Hello World!\" by default), and two timers. The first timer controls animation speed and is set to 10ms by default. This can be changed through the Interval setting. When the interval elapses, the text is redrawn in a different position on the drawing surface. Depending on the animation effect, the text is either bouncing or spinning.\n\nThe second timer is used to update actual animation speed displayed in the lower-right corner of the drawing surface. By actual animation speed I mean the number of paint events handled during the previous second. Actual animation speed might be lower than the desired animation speed. For example, a 10ms interval means that you would like the text to change its position 100 times per second.\n\nThe Background Image Layout options let you compare drawing performance between Tile and other image layout flags. I chose Center layout just as an example (Zoom or Stretch would have the same effect as Center). In this application I realigned the image to fit the drawing surface size independently of the image layout chosen. However, when the background is painted, Tile layout affects performance. Also when Center layout is chosen, the DoubleBuffered option is set automatically for you. That isn't the case when Tile layout is chosen.\n\nYou can see how different options affect performance by observing flickering effects and by checking the actual animation speed in the lower-right corner of the drawing surface. Animation speed depends on the drawing options, on the update interval you set, and on physical limitations of your machine.\n\nIn my tests, the best results were achieved when Double Buffering and Smart Invalidation techniques were applied, Background Image Layout was set to Center (or, more specifically, any layout other than Tile), and the BackgroundImage was prerendered using PixelFormat.Format32bppPArgb. Painting is smooth and flicker-free when all of these techniques are used. Plus, animation is faster.\n\nThe physical memory used by your application is an important performance metric. You should use the least possible memory and resources so there is as much as possible left over for other processes. This is not just about being a good citizen; your application will benefit from a lower memory footprint, and this benefit can be dramatic if your memory usage is big enough to consume available physical memory and push the machine into paging. But even if you are targeting high-end machines and paging is not your main threat, you should use memory wisely. The cost of memory management in the common language runtime (CLR) can be significant for applications that allocate memory carelessly.\n\nMemory footprint, garbage collection, and managing native resources, such as window handles or GDI handles, are interdependent for Windows Forms applications. Failure to release unmanaged resources increases the pressure on the garbage collector (GC). Windows Forms attempts to track handle usage and may force additional garbage collection cycles by calling GC.Collect if it is in danger of running out of resources. Besides, the managed objects holding these resources will have to be finalized by the GC, which is more expensive than releasing them proactively in your application through the IDisposable interface.\n\nWhen the lifetime of the object is explicitly known, the unmanaged resources associated with it should be released. If a class that you are using implements the Dispose pattern and you explicitly know when you are done with the object, definitely call Dispose. In the Dispose method you will call the same cleanup code that is in the Finalizer and inform the GC that it no longer needs to finalize the object by calling the GC.SuppressFinalization method. This will improve performance since all the unreferenced objects in generation zero will be collected during one GC cycle. If a collectable object needs to be finalized, at least two GC cycles will be required for collecting it.\n\nObjects that implement IDisposable usually do so because they are holding onto resources that should be freed deterministically. Windows Forms controls, for example, hold Windows handles that need to be released. If you add and remove controls from your form dynamically, you should call Dispose on them—otherwise you'll accumulate extra unwanted handles in your process. You only need to dispose the topmost control since its children will be disposed automatically.\n\nIf you show a form modally (using the ShowDialog method) you need to Dispose it after it is closed. It is not disposed automatically in this case, to enable you to inquire on its state after it is closed. Note that other forms are automatically disposed when they are closed.\n\nGraphics objects such as brushes, pens, and fonts implement IDisposable as well, since they hold onto GDI handles. Usually you create these objects in the OnPaint method, which is called each time the control needs to be redrawn. If you don't dispose them immediately, you may accumulate a large number of these objects and hold a lot of GDI handles before these objects are finalized by the GC. If you are writing your code in C# or Visual Basic, the using statement is a handy way to do this:\n\nIf you're using C++, its stack-allocation semantics are also very useful in this regard:\n\nYou should try to avoid invoking GC.Collect if you possibly can. The GC is self-tuning and will adjust itself according to application memory requirements. In most cases, programmatically invoking the GC will hinder that automatic tuning. The only time GC.Collect might be useful is when you know that you have just released a lot of memory and you would like it to be collected immediately. Generally, however, it is more efficient to allow the GC to simply manage itself.\n\nIf your form has more than 200 child controls, you might think of ways to design it more efficiently. Each control consumes native resources, and managing a large number of controls is expensive. Instead, consider using ListView, TreeView, DataGridView, ListBox, ToolStrip, and MenuStrip. The individual items for these controls generally do not require a native handle to back each item.\n\nIf physical memory is in short demand and paging occurs, physical disk usage will be high (since pages are written to disk). Your application will perform unbearably slowly in this case and you will desperately need to reduce memory usage. The profiling tool in Visual Studio Team System will be helpful here. You can also use this tool to look at managed memory allocations, or you can use the CLR's profiling support (CLR Profiler: No Code Can Hide from the Profiling API in the .NET Framework 2.0). Also you might want to use the Virtual Address Dump (VaDump) tool to look at the process working set:\n\nThe sidebar \"Twelve Performance Tips\" provides you with a grab bag of ways to optimize application performance. All of them provide you with definite performance advantages, used both individually or together. Now you should be well-equipped with skills that will allow you to write fast and efficient Windows Forms applications that will impress your users and keep them happy while using your applications.\n\nMilena Salman is a Software Design Engineer on the .NET Client (Windows Forms) team at Microsoft. She focuses on performance tuning of Windows Forms. You can reach Milena at msalman@microsoft.com. Thanks to Shawn Burke and Jessica Fosler from the Windows Forms team for their valuable contribution to this article."
    }
]