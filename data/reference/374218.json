[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api",
        "document": "The Win32 API reference documentation is presented in several different views. You can browse a list of popular technologies on this page, or you can browse the full list of technologies in the table of contents. To browse all of the headers, see the list at the bottom of the table of contents."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=msvc-170",
        "document": "This walkthrough shows how to create a traditional Windows desktop application in Visual Studio. The application you create uses the Windows API to display \"Hello, Windows desktop!\" in a window. You can use the code that you develop in this walkthrough as a pattern to create Windows desktop applications.\n\nThe Windows API (also known as the Win32 API, Windows Desktop API, and Windows Classic API) is a C-language-based framework for creating Windows applications. It has been used to create Windows applications for decades. More advanced and easier-to-program frameworks have been built on top of the Windows API. For example, MFC, ATL, the .NET frameworks. Even the most modern Windows Runtime code for UWP and Store apps written in C++/WinRT uses the Windows API underneath. For more information about the Windows API, see Windows API Index.\n• None A computer that runs Microsoft Windows 7 or later versions. We recommend Windows 11 or later for the best development experience.\n• None A copy of Visual Studio. For information on how to download and install Visual Studio, see Install Visual Studio. When you run the installer, make sure that the Desktop development with C++ workload is checked. Don't worry if you didn't install this workload when you installed Visual Studio. You can run the installer again and install it now.\n• None A basic understanding of using the Visual Studio IDE. If you've used Windows desktop apps before, you can probably keep up. For an introduction, see Visual Studio IDE feature tour.\n• None An understanding of enough of the fundamentals of the C++ language to follow along. Don't worry, we don't do anything too complicated.\n\nFollow these steps to create your first Windows desktop project. Per the note at the beginning of this walkthrough, the completed code is available in the Build the code section at the end of the walkthrough. Go ahead and follow the steps to create the project, but hold off pasting the following sections of code until the end, when the complete application code is presented. Some details are omitted in the code snippets to focus on the most important parts. You can copy the complete code and paste it into your project at the end.\n\nTo simplify the explanation. To see the documentation for your preferred version of Visual Studio, use the Version selector control. It's located at the top of the table of contents on this page.\n\nNext, learn how to create the code for a Windows desktop application in Visual Studio.\n• None Just as every C application and C++ application must have a function as its starting point, every Windows desktop application must have a function. has the following syntax. int WINAPI WinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow ); For information about the parameters and return value of this function, see WinMain entry point. What are all those extra words, such as , or , or , or ? The traditional Windows API uses typedefs and preprocessor macros extensively to abstract away some of the details of types and platform-specific code, such as calling conventions, declarations, and compiler pragmas. In Visual Studio, you can use the IntelliSense Quick Info feature to see what these typedefs and macros define. Hover your mouse over the word of interest, or select it and press Ctrl+K, Ctrl+I for a small pop-up window that contains the definition. For more information, see Using IntelliSense. Parameters and return types often use SAL Annotations to help you catch programming errors. For more information, see Using SAL Annotations to Reduce C/C++ Code Defects.\n• None Windows desktop programs require . You'll also frequently see . That's to make it easier to write an app that can work with either or . The way it works is that you instead use the macro in your code, which resolves ultimately to if the symbol is defined in your project, otherwise it resolves to . If you always build with UNICODE enabled, you don't need and can just use directly. For more information, see Using generic-text mappings. The following code shows theses two statements at the top of the file.\n• None Along with the function, every Windows desktop application must also have a window-procedure function. This function is called a , but you can give it whatever name you like in your code. has the following syntax. LRESULT CALLBACK WndProc( _In_ HWND hWnd, _In_ UINT message, _In_ WPARAM wParam, _In_ LPARAM lParam ); In this function, you write code to handle messages that the application receives from Windows when events occur. For example, if a user chooses an OK button in your application, Windows sends a message to you. You write code inside a function that does whatever work is appropriate. It's called handling an event. You only handle the events that are relevant for your application. For more information, see Window Procedures.\n• None In the function, you need to capture some basic information about your main window. You do that by filling out a structure of type . The structure contains information about the window such as the application icon, the background color of the window, the name to display in the title bar, among other things. Importantly, it contains a function pointer to your window procedure that handles the messages that Windows sends to your app. The following example shows a typical structure: For information about the fields of the structure above, see .\n• None Once you have the structure filled out, you register it with Windows so that it knows about your window and how to send messages to it. Use the function and pass the window class structure as an argument. The macro is used because we use the type per the discussion about Unicode above. The following code shows how to register the window class.\n• None Next you create a window using the function. static TCHAR szWindowClass[] = _T(\"DesktopApp\"); static TCHAR szTitle[] = _T(\"Windows Desktop Guided Tour Application\"); // The parameters to CreateWindowEx explained: // WS_EX_OVERLAPPEDWINDOW : An optional extended window style. // szWindowClass: the name of the application // szTitle: the text that appears in the title bar // WS_OVERLAPPEDWINDOW: the type of window to create // CW_USEDEFAULT, CW_USEDEFAULT: initial position (x, y) // 500, 100: initial size (width, length) // NULL: the parent of this window // NULL: this application does not have a menu bar // hInstance: the first parameter from WinMain // NULL: not used in this application HWND hWnd = CreateWindowEx( WS_EX_OVERLAPPEDWINDOW, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 500, 100, NULL, NULL, hInstance, NULL ); if (!hWnd) { MessageBox(NULL, _T(\"Call to CreateWindowEx failed!\"), _T(\"Windows Desktop Guided Tour\"), NULL); return 1; } This function returns an , which is a handle to a window. A handle is somewhat like a pointer. Windows uses it to keep track of the windows you create. For more information, see Windows Data Types.\n• None At this point, the window has been created, but we still need to tell Windows to make it visible. That's what this code does: // The parameters to ShowWindow explained: // hWnd: the value returned from CreateWindow // nCmdShow: the fourth parameter from WinMain ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); The displayed window is just a blank rectangle because you haven't yet implemented the function. The application isn't yet handling the messages that Windows is now sending to it.\n• None To handle the messages, we first add what's called a message loop to listen for the messages that Windows sends. When the application receives a message, this loop dispatches it to your function to be handled. The message loop resembles the following code: For more information about the structures and functions in the message loop, see , , TranslateMessage, and . A basic function that creates the application's main window, and listens for messages that Windows sends your app, would resemble the following code: int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(wcex.hInstance, IDI_APPLICATION); wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL; wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION); if (!RegisterClassEx(&wcex)) { MessageBox(NULL, _T(\"Call to RegisterClassEx failed!\"), _T(\"Windows Desktop Guided Tour\"), NULL); return 1; } // Store instance handle in our global variable hInst = hInstance; // The parameters to CreateWindowEx explained: // WS_EX_OVERLAPPEDWINDOW : An optional extended window style. // szWindowClass: the name of the application // szTitle: the text that appears in the title bar // WS_OVERLAPPEDWINDOW: the type of window to create // CW_USEDEFAULT, CW_USEDEFAULT: initial position (x, y) // 500, 100: initial size (width, length) // NULL: the parent of this window // NULL: this application dows not have a menu bar // hInstance: the first parameter from WinMain // NULL: not used in this application HWND hWnd = CreateWindowEx( WS_EX_OVERLAPPEDWINDOW, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 500, 100, NULL, NULL, hInstance, NULL ); if (!hWnd) { MessageBox(NULL, _T(\"Call to CreateWindow failed!\"), _T(\"Windows Desktop Guided Tour\"), NULL); return 1; } // The parameters to ShowWindow explained: // hWnd: the value returned from CreateWindow // nCmdShow: the fourth parameter from WinMain ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); // Main message loop: MSG msg; while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } return (int) msg.wParam; }\n• None To handle messages that the application receives, you implement a statement in your function. An important message to handle is . The application receives a message when part of its displayed window must be updated. The event can occur when a user moves a window in front of your window and moves it away again. It receives this message the first time your window is displayed, giving you a chance to display your application UI. Your application finds out about these events when Windows sends them. When the window is first displayed, all of it must be updated. To handle a message, first call , then handle all the logic to lay out the text, buttons, and other controls in the window. Then call . For this application, the code between and displays in the window you created in . In the following code, the function displays the text at the specified location in the window. PAINTSTRUCT ps; HDC hdc; TCHAR greeting[] = _T(\"Hello, Windows desktop!\"); switch (message) { case WM_PAINT: hdc = BeginPaint(hWnd, &ps); // Here your application is laid out. // For this introduction, we just print out \"Hello, Windows desktop!\" // in the top left corner. TextOut(hdc, 5, 5, greeting, _tcslen(greeting)); // End application-specific layout section. EndPaint(hWnd, &ps); break; } In the preceding code, is a handle to a device context which is associated with the window's client area. You use it when drawing in the window to refer to its client area. Use the and functions to prepare for and complete the drawing in the client area. returns a handle to the display device context used for drawing in the client area; ends the paint request and releases the device context.\n• None An application typically handles many other messages. For example, is sent when a window is first created, and when the window is closed. The following code shows a basic but complete function: LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { PAINTSTRUCT ps; HDC hdc; TCHAR greeting[] = _T(\"Hello, Windows desktop!\"); switch (message) { case WM_PAINT: hdc = BeginPaint(hWnd, &ps); // Here your application is laid out. // For this introduction, we just print out \"Hello, Windows desktop!\" // in the top left corner. TextOut(hdc, 5, 5, greeting, _tcslen(greeting)); // End application specific layout section. EndPaint(hWnd, &ps); break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); break; } return 0; }\n\nAs promised, the complete code for the working application follows.\n\nTo build this example\n• None Delete all the code in HelloWindowsDesktop.cpp in the editor. Copy this example code and paste it into HelloWindowsDesktop.cpp: // HelloWindowsDesktop.cpp // compile with: /D_UNICODE /DUNICODE /DWIN32 /D_WINDOWS /c #include <windows.h> #include <stdlib.h> #include <string.h> #include <tchar.h> // Global variables // The main window class name. static TCHAR szWindowClass[] = _T(\"DesktopApp\"); // The string that appears in the application's title bar. static TCHAR szTitle[] = _T(\"Windows Desktop Guided Tour Application\"); // Stored instance handle for use in Win32 API calls such as FindResource HINSTANCE hInst; // Forward declarations of functions included in this code module: LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); int WINAPI WinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow ) { WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(wcex.hInstance, IDI_APPLICATION); wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL; wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION); if (!RegisterClassEx(&wcex)) { MessageBox(NULL, _T(\"Call to RegisterClassEx failed!\"), _T(\"Windows Desktop Guided Tour\"), NULL); return 1; } // Store instance handle in our global variable hInst = hInstance; // The parameters to CreateWindowEx explained: // WS_EX_OVERLAPPEDWINDOW : An optional extended window style. // szWindowClass: the name of the application // szTitle: the text that appears in the title bar // WS_OVERLAPPEDWINDOW: the type of window to create // CW_USEDEFAULT, CW_USEDEFAULT: initial position (x, y) // 500, 100: initial size (width, length) // NULL: the parent of this window // NULL: this application does not have a menu bar // hInstance: the first parameter from WinMain // NULL: not used in this application HWND hWnd = CreateWindowEx( WS_EX_OVERLAPPEDWINDOW, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 500, 100, NULL, NULL, hInstance, NULL ); if (!hWnd) { MessageBox(NULL, _T(\"Call to CreateWindow failed!\"), _T(\"Windows Desktop Guided Tour\"), NULL); return 1; } // The parameters to ShowWindow explained: // hWnd: the value returned from CreateWindow // nCmdShow: the fourth parameter from WinMain ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); // Main message loop: MSG msg; while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } return (int) msg.wParam; } // FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM) // // PURPOSE: Processes messages for the main window. // // WM_PAINT - Paint the main window // WM_DESTROY - post a quit message and return LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { PAINTSTRUCT ps; HDC hdc; TCHAR greeting[] = _T(\"Hello, Windows desktop!\"); switch (message) { case WM_PAINT: hdc = BeginPaint(hWnd, &ps); // Here your application is laid out. // For this introduction, we just print out \"Hello, Windows desktop!\" // in the top left corner. TextOut(hdc, 5, 5, greeting, _tcslen(greeting)); // End application-specific layout section. EndPaint(hWnd, &ps); break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); break; } return 0; }\n• None On the Build menu, choose Build Solution. The results of the compilation appear in the Output window in Visual Studio. The animation shows clicking the save all button, then choosing Build > Build Solution from the main menu.\n• None To run the application, press F5. A window with the text \"Hello, Windows desktop!\" should appear."
    },
    {
        "link": "https://ciprianf.hashnode.dev/win32-api-programming-creating-a-window",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/12a03si/are_there_any_resources_for_using_the_windows_api",
        "document": "I'm a beginner. I'm working on my own console/shell with custom commands. I wanted to add a command that'll get your Windows version and print it (and later on, your specs). All of Microsoft's documents use C++ though. Are there any resources on how to the API in C?"
    },
    {
        "link": "https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/desktop-programming.md",
        "document": "The Win32 API is the name given to the original platform for native C/C++ Windows applications that require direct access to Windows and hardware. It provides a first-class development experience without depending on a managed runtime environment such as .NET. That makes the Win32 API a great choice for applications that need the highest level of performance, and direct access to system hardware. You can use the Win32 API on 32-bit and 64-bit Windows.\n\nFollow these instructions, and start creating desktop apps for Windows that use the Win32 API.\n• Download or update Visual Studio. If you don't already have Visual Studio, then you can install the free Microsoft Visual Studio Community. When you install Visual Studio, make sure to select the Desktop development with C++ workload. For download links, see our Downloads page. [!NOTE] When you install Visual Studio, you can optionally select the .NET desktop development and Universal Windows Platform development workloads for access to other project types and app platforms for building Windows apps.\n• If you want to build your desktop app into an MSIX package, and test or debug the packaged app on your development computer, then you'll need to enable Developer Mode on your computer.\n\nIf you're new to building desktop apps using the Win32 API, the following tutorials and articles will help get you started.\n\nYou can also browse the desktop app samples.\n\nAlternatively, if you have an existing desktop Win32 app, then there are many features in the Universal Windows Platform (UWP) that you can use to deliver your experience on Windows. For example, starting in Windows 10, version 1903, you can host UWP XAML controls in your desktop Win32 app using a feature called XAML Islands.\n\nMost of those UWP features are available as modular components that you can adopt in your desktop app at your own pace without having to rewrite your entire application. You can enhance your existing desktop app by choosing which parts of Windows and UWP to adopt.\n\nYou can configure your development computer to use C++/WinRT. C++/WinRT is an entirely standard modern C++17 language projection that enables you to easily consume Windows Runtime (WinRT) APIs from your C++ Win32 desktop application. C++/WinRT is implemented as a header-file-based library.\n\nTo configure your project for C++/WinRT:\n• For new projects, you can install the C++/WinRT Visual Studio Extension (VSIX) and use one of the C++/WinRT project templates included in that extension.\n• For existing Windows desktop application projects, you can install the Microsoft.Windows.CppWinRT NuGet package in the project.\n\nFor more details about these options, see Visual Studio support for C++/WinRT, XAML, the VSIX extension, and the NuGet package.\n\nTo learn about new Win32 APIs that have been introduced in Windows, see what's new.\n\nWin32 APIs exist for many features and technologies in Windows, including core user interface and windowing APIs, audio and graphics, and networking. For guidance and code samples about using those APIs, see Desktop app technologies."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://stackoverflow.com/questions/67631098/what-is-the-difference-between-ifstream-ofstream-and-fstream",
        "document": "This is how the class hierarchy looks like:\n\nThe three classes that deal with file handling are:\n\n, and are \" \" template specializations which means they are nothing but , and i.e. they deal with reading and writing s from a file.\n• is input file stream which allows you to read the contents of a file.\n• is output file stream which allows you to write contents to a file.\n• allows both reading from and writing to files by default. However, you can have an behave like an or by passing in the flag.\n\nThese flags are additive which means you can combine multiple flags using the bitwise OR operator. If I want to open the file in binary mode and append, I can combine the flags as follows:\n• always has the flag set and it cannot be removed. Similary, always has the flag set and it cannot be removed. Any other flags added will be combined with for and for\n• On the other hand, if you do not pass any flags to , the default is , so you can read from as well as write to the file. But if you specify a flag explicitly for like , it will be opened only for reading, like an .\n\nYou can do so in the constructor or when calling :\n\nIt is basically possible to never use and and always use with the required flags. But it is prone to accidental errors while setting the flags. Hence, using you can be sure that writes will never occur and with only writes will take place.\n\nC++ 23 adds the flag which opens a file exclusively for writing. This flag already existed in some implementations but is now standardized in C++ 23. If the file already exists, it fails to open."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_files.asp",
        "document": "The library allows us to work with files.\n\nTo use the library, include both the standard AND the header file:\n\nThere are three classes included in the library, which are used to create, write or read files:\n\nTo create a file, use either the or class, and specify the name of the file.\n\nTo write to the file, use the insertion operator ( ).\n\n#include <iostream>\n\n#include <fstream>\n\nusing namespace std;\n\n\n\n int main() {\n\n // Create and open a text file\n\n ofstream MyFile(\"filename.txt\");\n\n\n\n // Write to the file\n\n MyFile << \"Files can be tricky, but it is fun enough!\";\n\n\n\n // Close the file\n\n MyFile.close();\n\n}\n\nTo read from a file, use either the or class, and the name of the file.\n\nNote that we also use a loop together with the function (which belongs to the class) to read the file line by line, and to print the content of the file:\n\nFor a complete reference of <fstream> classes and functions, go to our C++ fstream Reference."
    },
    {
        "link": "https://medium.com/@ryan_forrester_/c-file-handling-with-fstream-a-complete-guide-a4ebcc294bd0",
        "document": "#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nint main() {\n\n // Writing to a file\n\n std::ofstream outFile(\"example.txt\");\n\n if (outFile.is_open()) {\n\n outFile << \"Hello, World!\n\n\";\n\n outFile << \"This is a test file.\n\n\";\n\n outFile.close();\n\n } else {\n\n std::cerr << \"Error opening file for writing!\" << std::endl;\n\n return 1;\n\n }\n\n \n\n // Reading from a file\n\n std::ifstream inFile(\"example.txt\");\n\n std::string line;\n\n if (inFile.is_open()) {\n\n while (std::getline(inFile, line)) {\n\n std::cout << line << std::endl;\n\n }\n\n inFile.close();\n\n } else {\n\n std::cerr << \"Error opening file for reading!\" << std::endl;\n\n return 1;\n\n }\n\n \n\n return 0;\n\n}\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nclass FileManager {\n\nprivate:\n\n std::fstream file;\n\n \n\npublic:\n\n FileManager(const std::string& filename) {\n\n file.open(filename, std::ios::in | std::ios::out | std::ios::binary);\n\n }\n\n \n\n ~FileManager() {\n\n if (file.is_open()) {\n\n file.close();\n\n }\n\n }\n\n \n\n void seekAndRead(std::streampos position) {\n\n if (file.is_open()) {\n\n file.seekg(position);\n\n char buffer[100];\n\n file.read(buffer, 99);\n\n buffer[99] = '\\0';\n\n std::cout << \"Read from position \" << position << \": \" \n\n << buffer << std::endl;\n\n }\n\n }\n\n \n\n void seekAndWrite(std::streampos position, const std::string& text) {\n\n if (file.is_open()) {\n\n file.seekp(position);\n\n file << text;\n\n file.flush();\n\n }\n\n }\n\n};\n\n\n\nint main() {\n\n // Create a test file\n\n {\n\n std::ofstream outFile(\"seek_test.txt\");\n\n outFile << \"This is a test file for seeking operations.\n\n\";\n\n }\n\n \n\n FileManager fm(\"seek_test.txt\");\n\n fm.seekAndRead(10); // Read from position 10\n\n fm.seekAndWrite(5, \"was\"); // Replace \"is\" with \"was\"\n\n \n\n return 0;\n\n}\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nclass FileHandler {\n\npublic:\n\n static bool copyFile(const std::string& source, const std::string& dest) {\n\n std::ifstream src(source, std::ios::binary);\n\n if (!src.is_open()) {\n\n std::cerr << \"Error opening source file: \" << source << std::endl;\n\n return false;\n\n }\n\n \n\n std::ofstream dst(dest, std::ios::binary);\n\n if (!dst.is_open()) {\n\n std::cerr << \"Error opening destination file: \" << dest << std::endl;\n\n src.close();\n\n return false;\n\n }\n\n \n\n dst << src.rdbuf();\n\n \n\n if (src.fail() || dst.fail()) {\n\n std::cerr << \"Error during file copy\" << std::endl;\n\n src.close();\n\n dst.close();\n\n return false;\n\n }\n\n \n\n src.close();\n\n dst.close();\n\n return true;\n\n }\n\n \n\n static void checkFileState(std::fstream& file) {\n\n if (file.good()) {\n\n std::cout << \"File stream is good\" << std::endl;\n\n }\n\n if (file.eof()) {\n\n std::cout << \"End of file reached\" << std::endl;\n\n }\n\n if (file.fail()) {\n\n std::cout << \"A recoverable error occurred\" << std::endl;\n\n }\n\n if (file.bad()) {\n\n std::cout << \"A non-recoverable error occurred\" << std::endl;\n\n }\n\n }\n\n};\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n#include <vector>\n\n#include <sstream>\n\n\n\nclass CSVParser {\n\nprivate:\n\n std::string filename;\n\n char delimiter;\n\n \n\npublic:\n\n CSVParser(const std::string& fname, char delim = ',') \n\n : filename(fname), delimiter(delim) {}\n\n \n\n std::vector<std::vector<std::string>> parse() {\n\n std::vector<std::vector<std::string>> data;\n\n std::ifstream file(filename);\n\n \n\n if (!file.is_open()) {\n\n throw std::runtime_error(\"Could not open file: \" + filename);\n\n }\n\n \n\n std::string line;\n\n while (std::getline(file, line)) {\n\n std::vector<std::string> row;\n\n std::stringstream ss(line);\n\n std::string cell;\n\n \n\n while (std::getline(ss, cell, delimiter)) {\n\n // Remove leading and trailing whitespace\n\n cell.erase(0, cell.find_first_not_of(\" \\t\"));\n\n cell.erase(cell.find_last_not_of(\" \\t\") + 1);\n\n row.push_back(cell);\n\n }\n\n \n\n data.push_back(row);\n\n }\n\n \n\n file.close();\n\n return data;\n\n }\n\n};\n\n\n\nint main() {\n\n try {\n\n CSVParser parser(\"data.csv\");\n\n auto data = parser.parse();\n\n \n\n // Print the parsed data\n\n for (const auto& row : data) {\n\n for (const auto& cell : row) {\n\n std::cout << cell << \"\\t\";\n\n }\n\n std::cout << std::endl;\n\n }\n\n } catch (const std::exception& e) {\n\n std::cerr << \"Error: \" << e.what() << std::endl;\n\n return 1;\n\n }\n\n \n\n return 0;\n\n}\n\nfstream in C++ provides robust file handling capabilities. Key points to remember:\n\n1. Always check if files are opened successfully\n\n2. Close files when you’re done with them\n\n3. Use appropriate file modes (binary vs text)\n\n4. Handle errors properly\n\n5. Consider using RAII principles for file management"
    },
    {
        "link": "https://stackoverflow.com/questions/28997295/c-password-handling-security-practices",
        "document": "I am creating a c++ class that handles a username and password.\n\nI was trying to do some research on some rudimentary, but effective practices for me to handle this information, in c++, so it can't be easily found by someone, for example, scanning memory and variables to determine the information.\n\nBy rudimentary, I mean something that would not take a lot of work; I don't want to program an entire cryptography library, random addressing system, or even a hashing function.\n\nAlso, i'm assuming it would be better to not even maintain this information in a variable, and get rid of it as soon as I do not need it?\n\nNo, I would not be saving this information to disk, only keeping it in variables in memory.\n\nThe class is platform independent and uses boost.\n\nhere is the declaration for the function:"
    },
    {
        "link": "https://forums.codeguru.com/showthread.php?513220-Best-practice-to-store-passwords-in-an-application",
        "document": "Click Here to Expand Forum to Full Width \n\n \n\n * The Best Reasons to Target Windows 8\n\n Learn some of the best reasons why you should seriously consider bringing your Android mobile development expertise to bear on the Windows 8 platform.\n• * Porting from Android to Windows 8: The Real Story\n\n Do you have an Android application? How hard would it really be to port to Windows 8?\n• * Guide to Porting Android Applications to Windows 8\n\n If you've already built for Android, learn what do you really need to know to port your application to Windows Phone 8.\n• * HTML5 Development Center\n\n Our portal for articles, videos, and news on HTML5, CSS3, and JavaScript\n• * Windows App Gallery\n\n See the Windows 8.x apps we've spotlighted or submit your own app to the gallery!"
    },
    {
        "link": "https://stackoverflow.com/questions/42600722/checking-if-the-input-password-was-correct",
        "document": "My program was only for me until now. I got asked to make it public for my school, but since now i just compare useriname and password like\n\nbut then i head about hooking and stuff to read out the memory and if i compare it like this it should be really easy to get access.\n\nI have no idea about making it save, I heard about \"hashing\" the pw and then hash the input too with the same algorithm and compare the hashs but cant you read out the algorithm too?\n\nI have no idea, thank you for help!"
    },
    {
        "link": "https://mayhem.security/blog/best-practices-for-secure-programming-in-c",
        "document": "Despite the introduction of multiple programming languages over the past few years, C++ still remains one of the most powerful and widely used programming languages among developers. It’s widely known for its efficiency and performance, which allows developers to create reliable and high-performing applications.\n\nHowever, like any other programming language, C++ faces security vulnerabilities. As a developer, secure programming should be among your top priorities during development. Secure programming ensures that you follow all the best practices available to maintain the integrity of the applications you’re developing. Whether you are developing small utility applications or working on complex systems, ensuring the security of your code is really important, as this will help protect user data while preventing issues like unauthorized access.\n\nAs a C++ developer, being aware of the possible security threats you are bound to encounter will come in handy. With the correct understanding of the potential threats, you can easily address them while cleaning your code and ensuring its efficiency. Some of the most common threats include:\n• Buffer overflow: This is the most common security concern associated with C++ applications. It occurs when a program writes data beyond the set bound of a buffer. This leads to the adjacent memory becoming corrupt. This threat can be exploited, leading to arbitrary code, overwriting critical data, or crashing the application.\n• Integer overflow and underflow: This mostly occurs when the value you’re trying to store in an integer exceeds the maximum value that can be represented. Underflow occurs when the value is less than the minimum value that can be represented. This may lead to unexpected memory behavior, including corruption and potential breach. This includes use-after-free, double-free, and uninitialized memory access, which may lead to the exploitation of the program (by injecting malicious code or gaining unauthorized access).\n• Injection attacks: This involves the insertion of malicious code into a program, which may lead to unintended execution. Some common types of injection associated with C++ include code injection and command injection.\n• Pointer initialization: Using a pointer that is not correctly initialized may lead to the exposure of a lot of sensitive data. Additionally, if the uninitialized pointer is used, it may lead to the program reading or writing to an unexpected memory location.\n• Incorrect type conversion: This is also known as type punning. It occurs when a program treats one data type as if it were a different one. This may cause data to be lost.\n\nBest Practices for Secure Coding in C++\n\nFollowing best practices when developing applications using C++ will help you minimize vulnerabilities and also protect your applications against security threats.\n• Input validation and sanitization: It’s always a good practice to validate and sanitize the user input. This will help prevent attacks such as SQL injection and command injections. Validation techniques such as regular expressions, input length checks, and input format validation can be used to enforce the expected input format. Additionally, make sure that you always validate and sanitize input from external sources.\n• Memory management: Make use of memory management techniques such as dynamic memory allocation to prevent memory leaks and corruption. You should also consider utilizing smart pointers and “Resource Acquisition Is Initialization” (RAII) to automatically manage memory and resources, which will reduce the risks related to memory.\n• Secure coding techniques: Be sure that you always use the secure standard libraries, functions, and containers such as std::vector, std::string, and std::unordered_map when writing code in C++. This helps handle memory management as well as prevent issues like buffer overflows and memory corruption.\n• Error handling and logging: Implement proper error handling mechanisms to prevent information leakage in case of failures. Be sure to follow secure logging practices, which will help you maintain an audit trail and facilitate incident response.\n• Access control and privileges: By enforcing proper access control, you will be able to limit user privileges and prevent unauthorized access to sensitive data by restricting permissions based on user roles and responsibilities. This can be achieved using techniques such as role-based access control (RBAC) or discretionary access control (DAC).\n\nExamples of Secure Coding Techniques in C++\n\nThe techniques below will help you enhance the security of your C++ applications and thereby mitigate some common security threats.\n\nTo protect your application from potential attacks, it’s a good practice to always validate user input. Below is an example of validating and filtering user input in which we validate the username against a set of allowed characters and lengths.\n\nSmart pointers provide automatic memory management and help prevent memory leaks. Meanwhile, the RAII ensures timely resource deallocation. Below, you’ll see an example of acquiring and releasing resources along with automatic deallocation when it goes out of scope to prevent memory leaks.\n\nProper error handling prevents information leakage. In the example below, the function throws an exception when the input value is negative. The exception is then handled in the main function, thus avoiding potential vulnerabilities.\n\nIn addition to best practices and secure coding techniques, there are still several considerations that C++ developers can implement to further enhance their application’s security. These include:\n\nIt’s important to note that secure programming is an ongoing process. Developers should stay up to date with the latest security practices and regularly update their code and libraries to address any known threats. By prioritizing security in the development process, developers can strengthen the security of their applications.\n\nInvesting time and effort in secure programming will not only help protect user data but also help strengthen trust among users and maintain the integrity of the system. Remember that writing secure C++ code should be your responsibility as a developer."
    },
    {
        "link": "https://incredibuild.com/blog/top-10-secure-c-coding-practices",
        "document": ""
    }
]