[
    {
        "link": "https://flask-admin.readthedocs.io/en/latest/api/mod_model",
        "document": "This view does not make any assumptions on how models are stored or managed, but expects the following:\n\nEssentially, if you want to support a new data store, all you have to do is:\n\nDictionary of value type formatters to be used in the list view. By default, three types are formatted:\n• None will be displayed as an empty string\n• None will be displayed as a checkmark if it is\n• None will be joined using ‘, ‘ If you don’t like the default behavior and don’t want any type formatters applied, just override this property with an empty dictionary: If you want to display instead of an empty string, you can do something like this. Also comes with bonus formatter: The callback function has following prototype: # `value` value to format"
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/stable/introduction",
        "document": "The first step is to initialize an empty admin interface for your Flask app: Here, both the name and template_mode parameters are optional. Alternatively, you could use the method. If you start this application and navigate to http://localhost:5000/admin/, you should see an empty page with a navigation bar on top. Customize the look by specifying a Bootswatch theme that suits your needs (see http://bootswatch.com/3/ for available swatches). Model views allow you to add a dedicated set of admin pages for managing any model in your database. Do this by creating instances of the ModelView class, which you can import from one of Flask-Admin’s built-in ORM backends. An example is the SQLAlchemy backend, which you can use as follows: Straight out of the box, this gives you a set of fully featured CRUD views for your model:\n• A view, with support for searching, sorting, filtering, and deleting records. There are many options available for customizing the display and functionality of these built-in views. For more details on that, see Customizing Built-in Views. For more details on the other ORM backends that are available, see Using Different Database Backends. The first thing you’ll notice when you visit http://localhost:5000/admin/ is that it’s just an empty page with a navigation menu. To add some content to this page, save the following text as in your project’s directory: This will override the default index template, but still give you the built-in navigation menu. So, now you can add any content to the index page, while maintaining a consistent user experience.\n\nWhen setting up an admin interface for your application, one of the first problems you’ll want to solve is how to keep unwanted users out. With Flask-Admin there are a few different ways of approaching this. Unfortunately, there is no easy way of applying HTTP Basic Auth just to your admin interface. The simplest form of authentication is HTTP Basic Auth. It doesn’t interfere with your database models, and it doesn’t require you to write any new view logic or template code. So it’s great for when you’re deploying something that’s still under development, before you want the whole world to see it. Have a look at Flask-BasicAuth to see just how easy it is to put your whole application behind HTTP Basic Auth. For a more flexible solution, Flask-Admin lets you define access control rules on each of your admin view classes by simply overriding the method. How you implement the logic is up to you, but if you were to use a low-level library like Flask-Login, then restricting access could be as simple as: # redirect to login page if user doesn't have access In the navigation menu, components that are not accessible to a particular user will not be displayed for that user. For an example of using Flask-Login with Flask-Admin, have a look at https://github.com/flask-admin/Flask-Admin/tree/master/examples/auth-flask-login. The main drawback is that you still need to implement all of the relevant login, registration, and account management views yourself. If you want a more polished solution, you could use Flask-Security, which is a higher-level library. It comes with lots of built-in views for doing common things like user registration, login, email address confirmation, password resets, etc. The only complicated bit is making the built-in Flask-Security views integrate smoothly with the Flask-Admin templates to create a consistent user experience. To do this, you will need to override the built-in Flask-Security templates and have them extend the Flask-Admin base template by adding the following to the top of each file: Now, you’ll need to manually pass in some context variables for the Flask-Admin templates to render correctly when they’re being called from the Flask-Security views. Defining a function will take care of this for you: For a working example of using Flask-Security with Flask-Admin, have a look at https://github.com/flask-admin/Flask-Admin/tree/master/examples/auth. The example only uses the built-in and views, but you could follow the same approach for including the other views, like , , etc.\n\nWhen inheriting from , values can be specified for numerous configuration parameters. Use these to customize the views to suit your particular models: # the number of entries to display on the list view Or, in much the same way, you can specify options for a single model at a time: # the number of entries to display on the list view For a complete list of the attributes that are defined, have a look at the API documentation for . Here are some of the most commonly used attributes: To disable some of the CRUD operations, set any of these boolean parameters: If your model has too much data to display in the list view, you can add a read-only details view by setting: Removing columns from the list view is easy, just pass a list of column names for the column_exclude_list parameter: To make columns searchable, or to use them for filtering, specify a list of column names: For a faster editing experience, enable inline editing in the list view: Or, have the add & edit forms display inside a modal window on the list page, instead of the dedicated create & edit pages: You can restrict the possible values for a text-field by specifying a list of select choices: To remove fields from the create and edit forms: Or, to specify arguments to the WTForms widgets used to render those fields: When your forms contain foreign keys, have those related models loaded via ajax, using: To filter the results that are loaded via ajax, you can use: These inline forms can be customized. Have a look at the API documentation for . To enable csv export of the model view: This will add a button to the model view that exports records, truncating at .\n\nFor situations where your requirements are really specific and you struggle to meet them with the built-in class, Flask-Admin makes it easy for you to take full control and add your own views to the interface. A set of standalone views (not tied to any particular model) can be added by extending the class and defining your own view methods. For example, to add a page that displays some analytics data from a 3rd-party API: This will add a link to the navbar for your view. Notice that it is served at ‘/’, the root URL. This is a restriction on standalone views: at the very minimum, each view class needs at least one method to serve a view at its root. The template for the example above, could look something like: 'm going to display some data.</p> By extending the admin/master.html template, you can maintain a consistent user experience, even while having tight control over your page’s content. There may be some scenarios where you want most of the built-in ModelView functionality, but you want to replace one of the default , , or views. For this you could override only the view in question, and all the links to it will still function as you would expect:\n\nRather than overriding the built-in templates completely, it’s best to extend them. This will make it simpler for you to upgrade to new Flask-Admin versions in future. Internally, the Flask-Admin templates are derived from the template. The three most interesting templates for you to extend are probably: To extend the default edit template with your own functionality, create a template in to look something like: Now, to make your view classes use this template, set the appropriate class property: If you want to use your own base template, then pass the name of the template to the admin constructor during initialization: To take full control over the style and layout of the admin interface, you can override all of the built-in templates. Just keep in mind that the templates will change slightly from one version of Flask-Admin to the next, so once you start overriding them, you need to take care when upgrading your package version. To override any of the built-in templates, simply copy them from the Flask-Admin source into your project’s directory. As long as the filenames stay the same, the templates in your project directory should automatically take precedence over the built-in ones. Flask-Admin defines one base template at that all other admin templates are derived from. This template is a proxy which points to , which defines the following blocks: Various CSS includes in the header Empty block in HTML head, in case you want to put something there Section to the right of the menu (can be used to add login/logout buttons) Content (that’s where your view will be displayed) In addition to all of the blocks that are inherited from , the template also contains the following blocks: Message that will be displayed if there are no models found Have a look at the example at https://github.com/flask-admin/flask-admin/tree/master/examples/custom-layout to see how you can take full stylistic control over the admin interface. While working in any of the templates that extend , you have access to a small number of environment variables: To generate the URL for a specific view, use url_for with a dot prefix: # Get URL for the test view method A specific record can also be referenced with: When referencing ModelView instances, use the lowercase name of the model as the prefix when calling url_for. Other views can be referenced by specifying a unique endpoint for each, and using that as the prefix. So, you could use: If your view endpoint was defined like:"
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/stable/api/mod_model",
        "document": "This view does not make any assumptions on how models are stored or managed, but expects the following:\n\nEssentially, if you want to support a new data store, all you have to do is:\n\nDictionary of value type formatters to be used in the list view. By default, three types are formatted:\n• will be displayed as an empty string\n• will be displayed as a checkmark if it is\n• will be joined using ‘, ‘ If you don’t like the default behavior and don’t want any type formatters applied, just override this property with an empty dictionary: If you want to display instead of an empty string, you can do something like this. Also comes with bonus formatter: The callback function has following prototype: # `value` value to format"
    },
    {
        "link": "https://stackoverflow.com/questions/49824049/flask-admin-setting-up-a-custom-view-thats-configurable-from-config-py",
        "document": "How do I dynamically set the base_path in the Document View to use a variable from my config file? Currently I'm using and I'm getting the\n\nDepending on whether I'm using my test, dev or prod config I'd like to use a different path, which I'd ideally configure in the appropriate class in config.py. Is there a way to do this without pushing the app context from my Document View?\n\nand my class in config.py:\n\nI tried pulling the form_args into a method and setting it which solved my application context issue. However the now I'm getting when I add a file.\n\nand the refactored class in admin.py:"
    },
    {
        "link": "https://stackoverflow.com/questions/14348946/flask-admin-customizing-views",
        "document": "I'm developing a web-app using Flask and pyMongo, and I've recently started to integrate the Flask-Admin module (1.0.4), given the fresh mongodb support.\n\nAll is smooth and fine when using ModelViews, but when it comes to subclassing a BaseView I simply can't get it working.\n\nHere is my setup:\n\nWhen submitting the form, wtforms does not report any error (unless there is any) but the validation does not return to my profile view (the else: branch is always executed)\n\nThere is no way I could find to make this work, inspite having thoroughly scanned flask-admin documentation, source code and examples.\n\nCould anybody suggest how I could fix my code, or work around this problem ?"
    },
    {
        "link": "http://docs.sqlalchemy.org/en/latest/orm/relationship_api.html",
        "document": "\n• None This parameter refers to the class that is to be related. It accepts several forms, including a direct reference to the target class itself, the instance for the target class, a Python callable / lambda that will return a reference to the class or when called, and finally a string name for the class, which will be resolved from the in use in order to locate the class, e.g.: The may also be omitted from the construct entirely, and instead placed inside a annotation on the left side, which should include a Python collection type if the relationship is expected to be a collection, such as: Or for a many-to-one or one-to-one relationship: Defining Mapped Properties with Declarative - further detail on relationship configuration when using Declarative.\n• None A list of columns which are to be used as “foreign key” columns, or columns which refer to the value in a remote column, within the context of this object’s condition. That is, if the condition of this is , and the values in are required to be present in , then the “foreign key” column of this is . In normal cases, the parameter is not required. will automatically determine which columns in the condition are to be considered “foreign key” columns based on those objects that specify , or are otherwise listed as referencing columns in a construct. is only needed when:\n• None There is more than one way to construct a join from the local table to the remote table, as there are multiple foreign key references present. Setting will limit the to consider just those columns specified here as “foreign”.\n• None The being mapped does not actually have or constructs present, often because the table was reflected from a database that does not support foreign key reflection (MySQL MyISAM).\n• None The argument is used to construct a non-standard join condition, which makes use of columns or expressions that do not normally refer to their “parent” column, such as a join condition expressed by a complex comparison using a SQL function. The construct will raise informative error messages that suggest the use of the parameter when presented with an ambiguous condition. In typical cases, if doesn’t raise any exceptions, the parameter is usually not needed. may also be passed as a callable function which is evaluated at mapper initialization time, and may be passed as a Python-evaluable string when using Declarative. When passed as a Python-evaluable string, the argument is interpreted using Python’s function. DO NOT PASS UNTRUSTED INPUT TO THIS STRING. See Evaluation of relationship arguments for details on declarative evaluation of arguments. - allows direct annotation of the “foreign” columns within a condition.\n• None specifies How the related items should be loaded. Default value is . Values include:\n• None - items should be loaded lazily when the property is first accessed, using a separate SELECT statement, or identity map fetch for simple many-to-one references.\n• None - items should be loaded as the parents are loaded, using a separate SELECT statement, or identity map fetch for simple many-to-one references.\n• None - items should be loaded “eagerly” in the same query as that of the parent, using a JOIN or LEFT OUTER JOIN. Whether the join is “outer” or not is determined by the parameter.\n• None - items should be loaded “eagerly” as the parents are loaded, using one additional SQL statement, which issues a JOIN to a subquery of the original statement, for each collection requested.\n• None - items should be loaded “eagerly” as the parents are loaded, using one or more additional SQL statements, which issues a JOIN to the immediate parent object, specifying primary key identifiers using an IN clause.\n• None - no loading should occur at any time. The related collection will remain empty. The strategy is not recommended for general use. For a general use “never load” approach, see Write Only Relationships\n• None - lazy loading is disallowed; accessing the attribute, if its value were not already loaded via eager loading, will raise an . This strategy can be used when objects are to be detached from their attached after they are loaded.\n• None - lazy loading that emits SQL is disallowed; accessing the attribute, if its value were not already loaded via eager loading, will raise an , if the lazy load needs to emit SQL. If the lazy load can pull the related value from the identity map or determine that it should be None, the value is loaded. This strategy can be used when objects will remain associated with the attached , however additional SELECT statements should be blocked.\n• None - the attribute will be configured with a special “virtual collection” that may receive and commands to add or remove individual objects, but will not under any circumstances load or iterate the full set of objects from the database directly. Instead, methods such as , , and are provided which generate SQL constructs that may be used to load and modify rows in bulk. Used for large collections that are never appropriate to load at once into memory. The loader style is configured automatically when the annotation is provided on the left hand side within a Declarative mapping. See the section Write Only Relationships for examples. Write Only Relationships - in the ORM Querying Guide\n• None - the attribute will return a pre-configured object for all read operations, onto which further filtering operations can be applied before iterating the results. The loader style is configured automatically when the annotation is provided on the left hand side within a Declarative mapping. See the section Dynamic Relationship Loaders for examples. The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only” strategy described in the section Write Only Relationships. Write Only Relationships - more generally useful approach for large collections that should not fully load into memory Relationship Loading Techniques - Full documentation on relationship loader configuration in the ORM Querying Guide.\n• A value of True indicates that unloaded child items should not be loaded during a delete operation on the parent. Normally, when a parent item is deleted, all child items are loaded so that they can either be marked as deleted, or have their foreign key to the parent set to NULL. Marking this flag as True usually implies an ON DELETE <CASCADE|SET NULL> rule is in place which will handle updating/deleting child rows on the database side. Additionally, setting the flag to the string value ‘all’ will disable the “nulling out” of the child foreign keys, when the parent object is deleted and there is no delete or delete-orphan cascade enabled. This is typically used when a triggering or error raise scenario is in place on the database side. Note that the foreign key attributes on in-session child objects will not be changed after a flush occurs so this is a very special use-case setting. Additionally, the “nulling out” will still occur if the child object is de-associated with the parent. Using foreign key ON DELETE cascade with ORM relationships - Introductory documentation and examples.\n• None Indicates the persistence behavior to take when a referenced primary key value changes in place, indicating that the referencing foreign key columns will also need their value changed. When True, it is assumed that is configured on the foreign key in the database, and that the database will handle propagation of an UPDATE from a source column to dependent rows. When False, the SQLAlchemy construct will attempt to emit its own UPDATE statements to modify related targets. However note that SQLAlchemy cannot emit an UPDATE for more than one level of cascade. Also, setting this flag to False is not compatible in the case where the database is in fact enforcing referential integrity, unless those constraints are explicitly “deferred”, if the target backend supports it. It is highly advised that an application which is employing mutable primary keys keeps set to True, and instead uses the referential integrity features of the database itself in order to handle the change efficiently and fully."
    },
    {
        "link": "https://docs.sqlalchemy.org/14/orm/basic_relationships.html",
        "document": "The imports used for each of the following sections is as follows: A one to many relationship places a foreign key on the child table referencing the parent. is then specified on the parent, as referencing a collection of items represented by the child: To establish a bidirectional relationship in one-to-many, where the “reverse” side is a many to one, specify an additional and connect the two using the parameter: will get a attribute with many-to-one semantics. Alternatively, the option may be used on a single instead of using : Configuring Delete Behavior for One to Many¶ It is often the case that all objects should be deleted when their owning is deleted. To configure this behavior, the cascade option described at delete is used. An additional option is that a object can itself be deleted when it is deassociated from its parent. This behavior is described at delete-orphan. Using foreign key ON DELETE cascade with ORM relationships Many to one places a foreign key in the parent table referencing the child. is declared on the parent, where a new scalar-holding attribute will be created: Bidirectional behavior is achieved by adding a second and applying the parameter in both directions: Alternatively, the parameter may be applied to a single , such as : One To One is essentially a bidirectional relationship with a scalar attribute on both sides. Within the ORM, “one-to-one” is considered as a convention where the ORM expects that only one related row will exist for any parent row. The “one-to-one” convention is achieved by applying a value of to the parameter of the construct, or in some cases the construct, applying it on the “one-to-many” or “collection” side of a relationship. In the example below we present a bidirectional relationship that includes both one-to-many ( ) and a many-to-one ( ) relationships: Above, is the “one-to-many” side referring to a collection, and is the “many-to-one” side referring to a single object. To convert this to “one-to-one”, the “one-to-many” or “collection” side is converted into a scalar relationship using the flag, renaming to for clarity: Above, when we load a object, the attribute will refer to a single object rather than a collection. If we replace the value of with a new object, the ORM’s unit of work process will replace the previous row with the new one, setting the previous column to NULL by default unless there are specific cascade behaviors set up. As mentioned previously, the ORM considers the “one-to-one” pattern as a convention, where it makes the assumption that when it loads the attribute on a object, it will get only one row back. If more than one row is returned, the ORM will emit a warning. However, the side of the above relationship remains as a “many-to-one” relationship and is unchanged, and there is no intrinsic system within the ORM itself that prevents more than one object to be created against the same during persistence. Instead, techniques such as unique constraints may be used in the actual database schema to enforce this arrangement, where a unique constraint on the column would ensure that only one row may refer to a particular row at a time. In the case where the parameter is used to define the “one-to-many” side, this can be converted to the “one-to-one” convention using the function which allows the relationship generated by the parameter to receive custom parameters, in this case the parameter: Many to Many adds an association table between two classes. The association table is indicated by the argument to . Usually, the uses the object associated with the declarative base class, so that the directives can locate the remote tables with which to link: The “association table” above has foreign key constraints established that refer to the two entity tables on either side of the relationship. The data type of each of and is normally inferred from that of the referenced table and may be omitted. It is also recommended, though not in any way required by SQLAlchemy, that the columns which refer to the two entity tables are established within either a unique constraint or more commonly as the primary key constraint; this ensures that duplicate rows won’t be persisted within the table regardless of issues on the application side: For a bidirectional relationship, both sides of the relationship contain a collection. Specify using , and for each specify the common association table: When using the parameter instead of , the backref will automatically use the same argument for the reverse relationship: The argument of also accepts a callable that returns the ultimate argument, which is evaluated only when mappers are first used. Using this, we can define the at a later point, as long as it’s available to the callable after all module initialization is complete: With the declarative extension in use, the traditional “string name of the table” is accepted as well, matching the name of the table as stored in : When passed as a Python-evaluable string, the argument is interpreted using Python’s function. DO NOT PASS UNTRUSTED INPUT TO THIS STRING. See Evaluation of relationship arguments for details on declarative evaluation of arguments. Deleting Rows from the Many to Many Table¶ A behavior which is unique to the argument to is that the which is specified here is automatically subject to INSERT and DELETE statements, as objects are added or removed from the collection. There is no need to delete from this table manually. The act of removing a record from the collection will have the effect of the row being deleted on flush: # row will be deleted from the \"secondary\" table A question which often arises is how the row in the “secondary” table can be deleted when the child object is handed directly to : There are several possibilities here:\n• None If there is a from to , but there is not a reverse-relationship that links a particular to each , SQLAlchemy will not have any awareness that when deleting this particular object, it needs to maintain the “secondary” table that links it to the . No delete of the “secondary” table will occur.\n• None If there is a relationship that links a particular to each , suppose it’s called , SQLAlchemy by default will load in the collection to locate all objects, and remove each row from the “secondary” table which establishes this link. Note that this relationship does not need to be bidirectional; SQLAlchemy is strictly looking at every associated with the object being deleted.\n• None A higher performing option here is to use ON DELETE CASCADE directives with the foreign keys used by the database. Assuming the database supports this feature, the database itself can be made to automatically delete rows in the “secondary” table as referencing rows in “child” are deleted. SQLAlchemy can be instructed to forego actively loading in the collection in this case using the directive on ; see Using foreign key ON DELETE cascade with ORM relationships for more details on this. Note again, these behaviors are only relevant to the option used with . If dealing with association tables that are mapped explicitly and are not present in the option of a relevant , cascade rules can be used instead to automatically delete entities in reaction to a related entity being deleted - see Cascades for information on this feature. Using foreign key ON DELETE with many-to-many relationships The association object pattern is a variant on many-to-many: it’s used when your association table contains additional columns beyond those which are foreign keys to the left and right tables. Instead of using the argument, you map a new class directly to the association table. The left side of the relationship references the association object via one-to-many, and the association class references the right side via many-to-one. Below we illustrate an association table mapped to the class which includes a column called , which is a string value that is stored along with each association between and : As always, the bidirectional version makes use of or : Working with the association pattern in its direct form requires that child objects are associated with an association instance before being appended to the parent; similarly, access from parent to child goes through the association object: To enhance the association object pattern such that direct access to the object is optional, SQLAlchemy provides the Association Proxy extension. This extension allows the configuration of attributes which will access two “hops” with a single access, one “hop” to the associated object, and a second to a target attribute. The association object pattern does not coordinate changes with a separate relationship that maps the association table as “secondary”. Below, changes made to will not be coordinated with changes made to or in Python; while all of these relationships will continue to function normally by themselves, changes on one will not show up in another until the is expired, which normally occurs automatically after : Additionally, just as changes to one relationship aren’t reflected in the others automatically, writing the same data to both relationships will cause conflicting INSERT or DELETE statements as well, such as below where we establish the same relationship between a and object twice: # redundant, will cause a duplicate INSERT on Association It’s fine to use a mapping like the above if you know what you’re doing, though it may be a good idea to apply the parameter to the “secondary” relationship to avoid the issue of redundant changes being logged. However, to get a foolproof pattern that allows a simple two-object relationship while still using the association object pattern, use the association proxy extension as documented at Association Proxy.\n\nMany of the examples in the preceding sections illustrate mappings where the various constructs refer to their target classes using a string name, rather than the class itself: These string names are resolved into classes in the mapper resolution stage, which is an internal process that occurs typically after all mappings have been defined and is normally triggered by the first usage of the mappings themselves. The object is the container in which these names are stored and resolved to the mapped classes they refer towards. In addition to the main class argument for , other arguments which depend upon the columns present on an as-yet undefined class may also be specified either as Python functions, or more commonly as strings. For most of these arguments except that of the main argument, string inputs are evaluated as Python expressions using Python’s built-in eval() function, as they are intended to receive complete SQL expressions. As the Python function is used to interpret the late-evaluated string arguments passed to mapper configuration construct, these arguments should not be repurposed such that they would receive untrusted user input; is not secure against untrusted user input. The full namespace available within this evaluation includes all classes mapped for this declarative base, as well as the contents of the package, including expression functions like and : For the case where more than one module contains a class of the same name, string class names can also be specified as module-qualified paths within any of these string expressions: The qualified path can be any partial path that removes ambiguity between the names. For example, to disambiguate between and , we can specify or : The construct also accepts Python functions or lambdas as input for these arguments. This has the advantage of providing more compile-time safety and better support for IDEs and PEP 484 scenarios. A Python functional approach might look like the following: The full list of parameters which accept Python functions/lambdas or strings that will be passed to are: Changed in version 1.3.16: Prior to SQLAlchemy 1.3.16, the main to was also evaluated through As of 1.3.16 the string name is resolved from the class resolver directly without supporting custom Python expressions. As stated previously, the above parameters to are evaluated as Python code expressions using eval(). DO NOT PASS UNTRUSTED INPUT TO THESE ARGUMENTS. It should also be noted that in a similar way as described at Appending additional columns to an existing Declarative mapped class, any construct can be added to a declarative base mapping at any time. If we wanted to implement this after the class were available, we could also apply it afterwards: # first, module A, where Child has not been created yet, # we create a Parent class which knows nothing about Child # ... later, in Module B, which is imported after module A: # assign the User.addresses relationship as a class variable. The # declarative base class will intercept this and map the relationship. assignment of mapped properties to a declaratively mapped class will only function correctly if the “declarative base” class is used, which also provides for a metaclass-driven method which will intercept these operations. It will not work if the declarative decorator provided by is used, nor will it work for an imperatively mapped class mapped by . Many-to-many relationships include a reference to an additional, typically non-mapped object that is typically present in the collection referred towards by the . The late-evaluation system also includes support for having this attribute be specified as a string argument which will be resolved from this collection. Below we specify an association table , sharing the collection associated with our declarative base and its . We can then refer to this by name in the parameter: For additional detail on many-to-many relationships see the section Many To Many."
    },
    {
        "link": "https://stackoverflow.com/questions/44477614/sqlalchemy-how-to-create-various-relationship-with-backrefs",
        "document": "I was reading through the SQLAlchemy documentation on basic relationships and I feel like I'm missing some basic understandings as to how to create the relationship declarations. When I run my code, I'm running into errors such as:\n\nI thought that the purpose of the relationship() directive was to minimize the creation of manual keys and ids.\n\nI'm also a little confused on the syntax with regards to one-to-many and many-to-many, and many-to-one and how the syntax would differentiate between the different types of relationships.\n\nHeres my example where I create an Entity and various classes around it to try out the various relationships:\n\nCan someone point me in the right direction to learn more about the proper usage of relationship()? Thank you"
    },
    {
        "link": "http://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html",
        "document": "A quick walkthrough of the basic relational patterns, which in this section are illustrated using Declarative style mappings based on the use of the annotation type.\n\nThe setup for each of the following sections is as follows:\n\nAs SQLAlchemy has evolved, different ORM configurational styles have emerged. For examples in this section and others that use annotated Declarative mappings with , the corresponding non-annotated form should use the desired class, or string class name, as the first argument passed to . The example below illustrates the form used in this document, which is a fully Declarative example using PEP 484 annotations, where the construct is also deriving the target class and collection type from the annotation, which is the most modern form of SQLAlchemy Declarative mapping: In contrast, using a Declarative mapping without annotations is the more “classic” form of mapping, where requires all parameters passed to it directly, as in the example below: Finally, using Imperative Mapping, which is SQLAlchemy’s original mapping form before Declarative was made (which nonetheless remains preferred by a vocal minority of users), the above configuration looks like: Additionally, the default collection style for non-annotated mappings is . To use a or other collection without annotations, indicate it using the parameter: Detail on collection configuration for is at Customizing Collection Access. Additional differences between annotated and non-annotated / imperative styles will be noted as needed.\n\nA one to many relationship places a foreign key on the child table referencing the parent. is then specified on the parent, as referencing a collection of items represented by the child: To establish a bidirectional relationship in one-to-many, where the “reverse” side is a many to one, specify an additional and connect the two using the parameter, using the attribute name of each as the value for on the other: will get a attribute with many-to-one semantics. Using Sets, Lists, or other Collection Types for One To Many¶ Using annotated Declarative mappings, the type of collection used for the is derived from the collection type passed to the container type. The example from the previous section may be written to use a rather than a for the collection using : When using non-annotated forms including imperative mappings, the Python class to use as a collection may be passed using the parameter. Customizing Collection Access - contains further detail on collection configuration including some techniques to map to dictionaries. Configuring Delete Behavior for One to Many¶ It is often the case that all objects should be deleted when their owning is deleted. To configure this behavior, the cascade option described at delete is used. An additional option is that a object can itself be deleted when it is deassociated from its parent. This behavior is described at delete-orphan. Using foreign key ON DELETE cascade with ORM relationships\n\nMany to one places a foreign key in the parent table referencing the child. is declared on the parent, where a new scalar-holding attribute will be created: The above example shows a many-to-one relationship that assumes non-nullable behavior; the next section, Nullable Many-to-One, illustrates a nullable version. Bidirectional behavior is achieved by adding a second and applying the parameter in both directions, using the attribute name of each as the value for on the other: In the preceding example, the relationship is not typed as allowing ; this follows from the column itself not being nullable, as it is typed with . If we wanted to be a nullable many-to-one, we can set both and to be , in which case the configuration would look like: Above, the column for will be created in DDL to allow values. When using with explicit typing declarations, the specification of is equivalent to setting to on the , whereas is equivalent to setting it to . See mapped_column() derives the datatype and nullability from the Mapped annotation for background on this behavior. If using Python 3.10 or greater, PEP 604 syntax is more convenient to indicate optional types using , which when combined with PEP 563 postponed annotation evaluation so that string-quoted types aren’t required, would look like:\n\nOne To One is essentially a One To Many relationship from a foreign key perspective, but indicates that there will only be one row at any time that refers to a particular parent row. When using annotated mappings with , the “one-to-one” convention is achieved by applying a non-collection type to the annotation on both sides of the relationship, which will imply to the ORM that a collection should not be used on either side, as in the example below: Above, when we load a object, the attribute will refer to a single object rather than a collection. If we replace the value of with a new object, the ORM’s unit of work process will replace the previous row with the new one, setting the previous column to NULL by default unless there are specific cascade behaviors set up. As mentioned previously, the ORM considers the “one-to-one” pattern as a convention, where it makes the assumption that when it loads the attribute on a object, it will get only one row back. If more than one row is returned, the ORM will emit a warning. However, the side of the above relationship remains as a “many-to-one” relationship. By itself, it will not detect assignment of more than one , unless the parameter is set, which may be useful: Outside of setting this parameter, the “one-to-many” side (which here is one-to-one by convention) will also not reliably detect if more than one is associated with a single , such as in the case where the multiple objects are pending and not database-persistent. Whether or not is used, it is recommended that the database schema include a unique constraint to indicate that the column should be unique, to ensure at the database level that only one row may refer to a particular row at a time (see Declarative Table Configuration for background on the tuple syntax): New in version 2.0: The construct can derive the effective value of the parameter from a given annotation. When using without the benefit of annotations, the one-to-one pattern can be enabled using the parameter set to on what would normally be the “many” side, illustrated in a non-annotated Declarative configuration below:\n\nThe association object pattern is a variant on many-to-many: it’s used when an association table contains additional columns beyond those which are foreign keys to the parent and child (or left and right) tables, columns which are most ideally mapped to their own ORM mapped class. This mapped class is mapped against the that would otherwise be noted as when using the many-to-many pattern. In the association object pattern, the parameter is not used; instead, a class is mapped directly to the association table. Two individual constructs then link first the parent side to the mapped association class via one to many, and then the mapped association class to the child side via many-to-one, to form a uni-directional association object relationship from parent, to association, to child. For a bi-directional relationship, four constructs are used to link the mapped association class to both parent and child in both directions. The example below illustrates a new class which maps to the named ; this table now includes an additional column called , which is a string value that is stored along with each association between and . By mapping the table to an explicit class, rudimental access from to makes explicit use of : To illustrate the bi-directional version, we add two more constructs, linked to the existing ones using : Working with the association pattern in its direct form requires that child objects are associated with an association instance before being appended to the parent; similarly, access from parent to child goes through the association object: To enhance the association object pattern such that direct access to the object is optional, SQLAlchemy provides the Association Proxy extension. This extension allows the configuration of attributes which will access two “hops” with a single access, one “hop” to the associated object, and a second to a target attribute. Association Proxy - allows direct “many to many” style access between parent and child for a three-class association object mapping. Avoid mixing the association object pattern with the many-to-many pattern directly, as this produces conditions where data may be read and written in an inconsistent fashion without special steps; the association proxy is typically used to provide more succinct access. For more detailed background on the caveats introduced by this combination, see the next section Combining Association Object with Many-to-Many Access Patterns. As mentioned in the previous section, the association object pattern does not automatically integrate with usage of the many-to-many pattern against the same tables/columns at the same time. From this it follows that read operations may return conflicting data and write operations may also attempt to flush conflicting changes, causing either integrity errors or unexpected inserts or deletes. To illustrate, the example below configures a bidirectional many-to-many relationship between and via and . At the same time, an association object relationship is also configured, between and : When using this ORM model to make changes, changes made to will not be coordinated with changes made to or in Python; while all of these relationships will continue to function normally by themselves, changes on one will not show up in another until the is expired, which normally occurs automatically after . Additionally, if conflicting changes are made, such as adding a new object while also appending the same related to , this will raise integrity errors when the unit of work flush process proceeds, as in the example below: # redundant, will cause a duplicate INSERT on Association Appending to directly also implies the creation of rows in the table without indicating any value for the column, which will receive for its value. It’s fine to use a mapping like the above if you know what you’re doing; there may be good reason to use many-to-many relationships in the case where use of the “association object” pattern is infrequent, which is that it’s easier to load relationships along a single many-to-many relationship, which can also optimize slightly better how the “secondary” table is used in SQL statements, compared to how two separate relationships to an explicit association class is used. It’s at least a good idea to apply the parameter to the “secondary” relationship to avoid the issue of conflicting changes occurring, as well as preventing being written to the additional association columns, as below: The above mapping will not write any changes to or to the database, preventing conflicting writes. However, reads of or will not necessarily match the data that’s read from or , if changes are being made to these collections within the same transaction or as where the viewonly collections are being read. If use of the association object relationships is infrequent and is carefully organized against code that accesses the many-to-many collections to avoid stale reads (in extreme cases, making direct use of to cause collections to be refreshed within the current transaction), the pattern may be feasible. A popular alternative to the above pattern is one where the direct many-to-many and relationships are replaced with an extension that will transparently proxy through the class, while keeping everything consistent from the ORM’s point of view. This extension is known as the Association Proxy. Association Proxy - allows direct “many to many” style access between parent and child for a three-class association object mapping.\n\nMost of the examples in the preceding sections illustrate mappings where the various constructs refer to their target classes using a string name, rather than the class itself, such as when using , a forward reference is generated that exists at runtime only as a string: Similarly, when using non-annotated forms such as non-annotated Declarative or Imperative mappings, a string name is also supported directly by the construct: These string names are resolved into classes in the mapper resolution stage, which is an internal process that occurs typically after all mappings have been defined and is normally triggered by the first usage of the mappings themselves. The object is the container where these names are stored and resolved to the mapped classes to which they refer. In addition to the main class argument for , other arguments which depend upon the columns present on an as-yet undefined class may also be specified either as Python functions, or more commonly as strings. For most of these arguments except that of the main argument, string inputs are evaluated as Python expressions using Python’s built-in eval() function, as they are intended to receive complete SQL expressions. As the Python function is used to interpret the late-evaluated string arguments passed to mapper configuration construct, these arguments should not be repurposed such that they would receive untrusted user input; is not secure against untrusted user input. The full namespace available within this evaluation includes all classes mapped for this declarative base, as well as the contents of the package, including expression functions like and : For the case where more than one module contains a class of the same name, string class names can also be specified as module-qualified paths within any of these string expressions: In an example like the above, the string passed to can be disambiguated from a specific class argument by passing the class location string directly to as well. Below illustrates a typing-only import for , combined with a runtime specifier for the target class that will search for the correct name within the : The qualified path can be any partial path that removes ambiguity between the names. For example, to disambiguate between and , we can specify or : The construct also accepts Python functions or lambdas as input for these arguments. A Python functional approach might look like the following: The full list of parameters which accept Python functions/lambdas or strings that will be passed to are: As stated previously, the above parameters to are evaluated as Python code expressions using eval(). DO NOT PASS UNTRUSTED INPUT TO THESE ARGUMENTS. It should also be noted that in a similar way as described at Appending additional columns to an existing Declarative mapped class, any construct can be added to a declarative base mapping at any time (noting that annotated forms are not supported in this context). If we wanted to implement this after the class were available, we could also apply it afterwards: # first, module A, where Child has not been created yet, # we create a Parent class which knows nothing about Child # ... later, in Module B, which is imported after module A: # assign the User.addresses relationship as a class variable. The # declarative base class will intercept this and map the relationship. As is the case for ORM mapped columns, there’s no capability for the annotation type to take part in this operation; therefore, the related class must be specified directly within the construct, either as the class itself, the string name of the class, or a callable function that returns a reference to the target class. As is the case for ORM mapped columns, assignment of mapped properties to an already mapped class will only function correctly if the “declarative base” class is used, meaning the user-defined subclass of or the dynamically generated class returned by or . This “base” class includes a Python metaclass which implements a special method that intercepts these operations. Runtime assignment of class-mapped attributes to a mapped class will not work if the class is mapped using decorators like or imperative functions like . Using a late-evaluated form for the “secondary” argument of many-to-many¶ Many-to-many relationships make use of the parameter, which ordinarily indicates a reference to a typically non-mapped object or other Core selectable object. Late evaluation using a lambda callable is typical. For the example given at Many To Many, if we assumed that the object would be defined at a point later on in the module than the mapped class itself, we may write the using a lambda as: As a shortcut for table names that are also valid Python identifiers, the parameter may also be passed as a string, where resolution works by evaluation of the string as a Python expression, with simple identifier names linked to same-named objects that are present in the same collection referenced by the current . In the example below, the expression is evaluated as a variable named “association_table” that is resolved against the table names within the collection: When passed as a string, the name passed to must be a valid Python identifier starting with a letter and containing only alphanumeric characters or underscores. Other characters such as dashes etc. will be interpreted as Python operators which will not resolve to the name given. Please consider using lambda expressions rather than strings for improved clarity. When passed as a string, argument is interpreted using Python’s function, even though it’s typically the name of a table. DO NOT PASS UNTRUSTED INPUT TO THIS STRING."
    },
    {
        "link": "https://stackoverflow.com/questions/3464443/how-to-create-one-to-one-relationships-with-declarative",
        "document": "I have two tables, and , and I want to link to . The catch is that this is a one-way one-to-one relationship. must not know anything about . For every foo, there will be one and only one .\n\nIdeally, after selecting a foo, I could do something like this:\n\nHow to accomplish this?"
    }
]