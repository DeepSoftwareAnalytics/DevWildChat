[
    {
        "link": "https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/V-SESSION.html",
        "document": "This contains a number that increases every time the session completes a call to the database and there has been an intervening select from a dynamic performance table. This column can be used by performance monitors to monitor statistics in the database. Each time the performance monitor looks at the database, it only needs to look at sessions that are currently active or have a higher value in this column than the highest value that the performance monitor saw the last time. All the other sessions have been idle since the last time the performance monitor looked at the database.\n\nThe final blocking session is the final element in the wait chain constructed by following the sessions that are blocked by one another starting with this session. In the case of a cyclical wait chain, one of the sessions in the wait chain will be chosen as the final blocker. This column provides details on whether there is a final blocking session:\n• - there is a final blocking session and it is identified in the and columns\n• - there is no session blocking this session\n• - this session is not in a wait"
    },
    {
        "link": "https://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_3016.htm",
        "document": "Command in progress (last statement parsed). You can find the command name for any value n returned in this column by running this SQL query: A value of in this column means the command is not recorded in .\n\nStatus of the session:\n• - Session which is inactive and either has no configured limits or has not yet exceeded the configured limits\n• - Session temporarily cached for use by Oracle*XA\n• - An inactive session that has exceeded some configured limits (for example, resource limits specified for the resource manager consumer group or idle_time specified in the user's profile). Such sessions will not be allowed to become active again.\n\nThe final blocking session is the final element in the wait chain constructed by following the sessions that are blocked by one another starting with this session. In the case of a cyclical wait chain, one of the sessions in the wait chain will be chosen as the final blocker. This column provides details on whether there is a final blocking session:\n• - there is a final blocking session and it is identified in the and columns\n• - there is no session blocking this session\n• - this session is not in a wait\n\nIf the session is currently waiting, then the value is . If the session is not in a wait, then the value is as follows:\n• > - Value is the duration of the last wait in hundredths of a second\n• - Duration of the last wait was less than a hundredth of a second This column has been deprecated in favor of the columns and ."
    },
    {
        "link": "https://stackoverflow.com/questions/14109698/how-do-i-use-vsession-vsqlarea-and-vprocess-in-oracle-to-troubleshoot-blocke",
        "document": "As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references, or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question can be improved and possibly reopened, visit the help center for guidance."
    },
    {
        "link": "https://oracle.com/ocom/groups/public/@otn/documents/webcontent/283689.htm",
        "document": ""
    },
    {
        "link": "https://dev.to/arvind_toorpu/identifying-and-resolving-blocking-sessions-in-oracle-database-3odl",
        "document": "Blocking sessions in an Oracle database occur when one session holds a lock on a resource that other sessions need, causing them to wait. This can lead to performance bottlenecks and user complaints. Identifying and resolving these sessions is a critical task for database administrators.\n\nOracle provides several views and tools to help DBAs detect blocking sessions:\n\nThe view helps identify sessions waiting for a resource due to blocking.\n\nThe view provides detailed information about lock types and states.\n• Interpretation of Results:\n• : Type of lock (e.g., TM for DML, TX for transactions).\n• Generate an AWR report during the time of contention:\n• Run the following command in SQL*Plus:\n• Look for \"Blocking Sessions\" in the report.\n• Analyze session statistics and wait events in the report.\n• View the graphical representation of blocking sessions and dependencies.\n\nOnce blocking sessions are identified, you can take steps to resolve them. Ensure you understand the business impact before proceeding.\n\nIf the blocking session is idle or causing severe issues, you can terminate it.\n• Find SID and Serial#: Use the view to identify the SID and SERIAL# of the blocking session:\n\nReplace and with values from the query.\n• Force Kill (if needed): If the session doesn’t terminate, use the option:\n\n2.2 Identify and Resolve the Root Cause\n• \n• Query active transactions to identify long-running or uncommitted ones:\n• Request the application team to commit or rollback the transaction.\n• Resolve Deadlocks:\n• Identify deadlocks using the trace file generated in the directory.\n\nIf the blocked session can wait, adjust the lock timeout to avoid indefinite waits.\n\n\n\nPoorly indexed tables can lead to full-table scans and increased lock contention. Add appropriate indexes to reduce contention.\n• \n• Use row-level locks instead of table locks for DML operations whenever possible.\n• \n• Use application logic to detect and handle deadlocks gracefully.\n• \n• Set up monitoring tools like Oracle Enterprise Manager or scripts to identify blocking sessions early.\n\nBlocking sessions are a routine component of database operations; however, they can lead to serious problems if not addressed swiftly. By actively monitoring and managing these blocking sessions, you can maintain the optimal operation of your Oracle database. Adopting best practices can help avert blocking issues from developing into more substantial performance bottlenecks."
    },
    {
        "link": "https://dev.to/arvind_toorpu/identifying-and-resolving-blocking-sessions-in-oracle-database-3odl",
        "document": "Blocking sessions in an Oracle database occur when one session holds a lock on a resource that other sessions need, causing them to wait. This can lead to performance bottlenecks and user complaints. Identifying and resolving these sessions is a critical task for database administrators.\n\nOracle provides several views and tools to help DBAs detect blocking sessions:\n\nThe view helps identify sessions waiting for a resource due to blocking.\n\nThe view provides detailed information about lock types and states.\n• Interpretation of Results:\n• : Type of lock (e.g., TM for DML, TX for transactions).\n• Generate an AWR report during the time of contention:\n• Run the following command in SQL*Plus:\n• Look for \"Blocking Sessions\" in the report.\n• Analyze session statistics and wait events in the report.\n• View the graphical representation of blocking sessions and dependencies.\n\nOnce blocking sessions are identified, you can take steps to resolve them. Ensure you understand the business impact before proceeding.\n\nIf the blocking session is idle or causing severe issues, you can terminate it.\n• Find SID and Serial#: Use the view to identify the SID and SERIAL# of the blocking session:\n\nReplace and with values from the query.\n• Force Kill (if needed): If the session doesn’t terminate, use the option:\n\n2.2 Identify and Resolve the Root Cause\n• \n• Query active transactions to identify long-running or uncommitted ones:\n• Request the application team to commit or rollback the transaction.\n• Resolve Deadlocks:\n• Identify deadlocks using the trace file generated in the directory.\n\nIf the blocked session can wait, adjust the lock timeout to avoid indefinite waits.\n\n\n\nPoorly indexed tables can lead to full-table scans and increased lock contention. Add appropriate indexes to reduce contention.\n• \n• Use row-level locks instead of table locks for DML operations whenever possible.\n• \n• Use application logic to detect and handle deadlocks gracefully.\n• \n• Set up monitoring tools like Oracle Enterprise Manager or scripts to identify blocking sessions early.\n\nBlocking sessions are a routine component of database operations; however, they can lead to serious problems if not addressed swiftly. By actively monitoring and managing these blocking sessions, you can maintain the optimal operation of your Oracle database. Adopting best practices can help avert blocking issues from developing into more substantial performance bottlenecks."
    },
    {
        "link": "https://medium.com/@amareswer/diagnosing-oracle-blocked-sessions-a-complete-guide-e8e1e133a951",
        "document": "Database performance is critical for business operations, and one of the most common issues Oracle DBAs face is dealing with blocked sessions. In this comprehensive guide, we’ll explore how to identify, analyze, and resolve Oracle blocked sessions with practical examples and ready-to-use scripts.\n\nWhat Are Blocked Sessions in Oracle?\n\nWhen one session in an Oracle database acquires a lock on a resource (such as a table row or object), other sessions requesting access to the same resource may have to wait. These waiting sessions are referred to as “blocked sessions.” The session holding the lock is the “blocking session.”\n\nHow to Identify Blocked Sessions in Oracle\n\nLet’s look at practical methods to detect blocked sessions in your Oracle database.\n\nThis query provides comprehensive information about current blocked sessions:\n\nSELECT \n\n blocking_session.sid blocker_sid,\n\n blocking_session.serial# blocker_serial,\n\n blocking_session.username blocker_username,\n\n blocking_session.machine blocker_machine,\n\n blocking_session.program blocker_program,\n\n blocking_session.logon_time blocker_logon_time,\n\n blocked_session.sid waiting_sid,\n\n blocked_session.serial# waiting_serial,\n\n blocked_session.username waiting_username,\n\n blocked_session.machine waiting_machine,\n\n blocked_session.program waiting_program,\n\n blocked_session.logon_time waiting_logon_time,\n\n w.wait_class waiting_class,\n\n w.event waiting_event,\n\n w.seconds_in_wait wait_seconds,\n\n sql_text.sql_text blocked_sql\n\nFROM \n\n v$session blocked_session\n\n JOIN v$session blocking_session ON (blocked_session.blocking_session = blocking_session.sid)\n\n JOIN v$session_wait w ON (w.sid = blocked_session.sid)\n\n LEFT JOIN v$sql sql_text ON (sql_text.sql_id = blocked_session.sql_id)\n\nWHERE \n\n blocked_session.blocking_session IS NOT NULL\n\nORDER BY \n\n w.seconds_in_wait DESC;\n\nMethod 2: Historical Analysis with Active Session History\n\nTo investigate blocking issues that occurred during a specific time period:\n\nSELECT \n\n ash.sample_time,\n\n ash.session_id blocked_session,\n\n ash.session_serial# blocked_serial#,\n\n ash.user_id blocked_user,\n\n ash.blocking_session blocker_sid,\n\n ash.blocking_session_serial# blocker_serial#,\n\n ash.event blocking_event,\n\n ash.wait_class wait_class,\n\n ash.sql_id sql_id,\n\n ash.sql_plan_hash_value plan_hash,\n\n ash.module blocked_module,\n\n ash.action blocked_action\n\nFROM \n\n dba_hist_active_sess_history ash\n\nWHERE \n\n ash.blocking_session IS NOT NULL\n\n AND ash.sample_time BETWEEN \n\n TIMESTAMP ‘2025–03–08 10:00:00’\n\n AND TIMESTAMP ‘2025–03–08 11:00:00’\n\nORDER BY \n\n ash.sample_time;\n\nMethod 3: Visualizing Blocking Chains\n\nSometimes blocking creates a cascade effect. This query helps visualize the complete blocking tree:\n\nWITH session_tree AS (\n\n SELECT \n\n LEVEL lvl,\n\n sid,\n\n blocking_session,\n\n username,\n\n sql_id,\n\n event,\n\n seconds_in_wait,\n\n LPAD(‘ ‘, (LEVEL-1)*2) || sid session_tree\n\n FROM \n\n v$session\n\n WHERE \n\n sid IN (\n\n SELECT blocking_session FROM v$session\n\n UNION\n\n SELECT sid FROM v$session WHERE blocking_session IS NOT NULL\n\n )\n\n CONNECT BY PRIOR sid = blocking_session\n\n START WITH blocking_session IS NULL\n\n)\n\nSELECT \n\n session_tree,\n\n username,\n\n sql_id,\n\n event,\n\n seconds_in_wait\n\nFROM \n\n session_tree\n\nORDER BY \n\n lvl;\n\nLet’s walk through a real-world example to demonstrate how these techniques can be applied.\n\nProblem: During month-end financial processing, several users reported that their reports were taking unusually long to generate, with some users receiving timeout errors.\n\n- Initial Detection: Using the V$SESSION query, we identified multiple blocked sessions:\n\nBLOCKER_SID BLOCKER_USERNAME WAITING_SID WAITING_USERNAME WAITING_EVENT WAIT_SECONDS\n\n — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — \n\n 123 FINANCE_ADMIN 234 REPORT_USER enq: TX — row lock 302\n\n 123 FINANCE_ADMIN 247 REPORT_USER enq: TX — row lock 287\n\n 123 FINANCE_ADMIN 251 REPORT_USER enq: TX — row lock 265\n\n- Root Cause Analysis: After examining the blocker’s SQL with the following query:\n\nSELECT sql_text \n\nFROM v$sql \n\nWHERE sql_id = (SELECT sql_id FROM v$session WHERE sid = 123);\n\nWe discovered an uncommitted transaction that was updating a large number of rows in the MONTHLY_TOTALS table. The transaction had been running for over 15 minutes without being committed.\n\n- Resolution: We contacted the finance administrator who had left for lunch without completing their transaction. They returned and committed their work, immediately releasing all locks and allowing the blocked sessions to proceed.\n\n- Prevention Measures:\n\n- Implemented a policy to avoid large updates during report generation hours\n\n- Added transaction timeout parameters\n\n- Created a monitoring alert for long-running transactions\n\n- Long-Running Transactions: Transactions that modify data but aren’t committed promptly\n\n- Improper Transaction Management: Applications that don’t handle commits and rollbacks efficiently\n\n- Table/Row Locking Contention: Multiple sessions competing for the same resources\n\n- Missing or Inefficient Indexes: Forcing full table scans that escalate locking\n\n- Application Design Flaws: Poor connection pooling or transaction boundary management\n\n- Optimize Transaction Design:\n\n- Keep transactions short and focused\n\n- Commit frequently, especially after bulk operations\n\n- Avoid user input during open transactions\n\n- Implement Proper Indexing:\n\n- Ensure queries use appropriate indexes\n\n- Regularly review execution plans for full table scans\n\n- Use Appropriate Isolation Levels:\n\n- Consider READ COMMITTED for most operations\n\n- Use SERIALIZABLE only when necessary\n\n- Database Configuration:\n\n- Set appropriate timeouts (DDLTIMEOUT, DISTRIBUTIONTIMEOUT)\n\n- Configure deadlock detection intervals\n\n- Monitoring and Alerting:\n\n- Implement proactive monitoring for blocking sessions\n\n- Set up alerts for long-running transactions\n\nBlocked sessions can significantly impact database performance and user experience. By understanding the causes and implementing proper detection methods, you can quickly identify and resolve these issues. The SQL scripts provided in this post are valuable tools for any Oracle DBA’s toolkit.\n\nRemember that prevention is always better than cure. Implementing the best practices outlined here will help minimize blocking incidents in your Oracle database environment."
    },
    {
        "link": "https://forums.oracle.com/ords/apexds/post/db-locked-sessions-why-0965",
        "document": "From time to time my application slows down and starts timing out due to session being blocked in oracle. I'm trying to investigate this I'd appreciate any more insights to what could be the problem.\n\nIt seems that all the sessions are blocked by session 177, however session 177 is idle and was a select so should not be holding any locks.\n\nSo what I'm asking is how can it be that a select statement blocked all these other statements? What should I be looking for?"
    },
    {
        "link": "https://stackoverflow.com/questions/46886403/finding-query-from-oracle-which-is-blocking-session",
        "document": "First get the SQL_ID of the BLOCKING session from this script:\n\nThen pass this SQL_ID into this script:"
    },
    {
        "link": "https://forums.oracle.com/ords/apexds/post/how-to-find-which-sql-is-holding-a-lock-when-its-not-v-sess-2910",
        "document": "Looking for a nudge in the right direction on a puzzling problem with blocking locks in our EBS database...\n\nWe occasionally will experience blocking locks in our EBS 12.1.3 database (11.2.0.4 RAC on OEL5). I can easily determine the INST_ID and SID holding the lock with this:\n\nselect final_blocking_instance, final_blocking_session from gv$session where lockwait is not null;\n\nand can use these results to find the specific object being blocked by querying gv$locked_object where session_id = xxx and inst_id = xxx. These blocker sessions are typically inactive with an event of \"SQL*Net message from client\" - so they seem to be users connected to the database who simply need to commit or rollback their transactions. Usually when I see this type of behavior, the specific query involved in the unresolved transaction is easily found by taking the SQL_ID (or sometimes the PREV_SQL_ID) value from gv$session and querying gv$sql. I can then use this info to better understand what the users are trying to accomplish and help them understand what they need to change to avoid the blocking problem.\n\nBut recently we have integrated the Oracle Content Management add-on and it appears to have added (I suspect indirectly) triggers to many of the EBS forms our users work in. Now we are experiencing these \"idle form blocking locks\" - and the value of SQL_ID is null and PREV_SQL_ID's related sql_text is\n\nSELECT * FROM AXF_COMMANDS_SYN WHERE FORMID = :b1 AND ( MENUTYPE = 'SPECIAL' OR MENUTYPE = 'ZOOMANDSPECIAL' ) AND AXF_COMMANDS_SYN.SPECIAL IS NOT NULL\n\nthough I can see from both gv$locked_object and the text of the SQL being executed by the blocked sessions that the actual lock being held by the blocker session is on an object (RA_CUSTOMER_TRX_ALL for example) that doesn't appear to be at all related to AXF_COMMANDS_SYN. The AXF schema was added as part of the content management deployment.\n\nSo my thought is that another (previous) open cursor held by the session is the actual unresolved SQL that is holding the lock. Is there a way to determine the SQL_ID of this query \"indirectly\" from gv$locked_object / gv$transaction, gv$open_cursor, etc? I can determine which session is the problem and which user we need to talk to - but I would really like to find the exact SQL that's involved. I'm also concerned with determining whether the new behavior is somehow contributing to the blocking lock problems or just \"a red herring\" - and I believe finding out which SQL statement is holding the lock will help me move forward with that investigation. I'm pretty sure I could find this info by tracing the blocking session - but the problem happens infrequently and I'm not able to determine which session to trace until its too late... :-)\n\nAny recommendations would be appreciated and apologies for the long post..."
    }
]