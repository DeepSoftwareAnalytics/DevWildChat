[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener",
        "document": "Note: This feature is available in Web Workers. The method of the interface sets up a function that will be called whenever the specified event is delivered to the target. Common targets are , or its children, , and , but the target may be any object that supports events (such as ). Note: The method is the recommended way to register an event listener. The benefits are as follows:\n• It allows adding more than one handler for an event. This is particularly useful for libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries or extensions.\n• In contrast to using an property, it gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).\n• It works on any event target, not just HTML or SVG elements. The method works by adding a function, or an object that implements a function, to the list of event listeners for the specified event type on the on which it's called. If the function or object is already in the list of event listeners for this target, the function or object is not added a second time. Note: If a particular anonymous function is in the list of event listeners registered for a certain target, and then later in the code, an identical anonymous function is given in an call, the second function will also be added to the list of event listeners for that target. Indeed, anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, even if in a loop. Repeatedly defining the same unnamed function in such cases can be problematic. (See Memory issues, below.) If an event listener is added to an from inside another listener — that is, during the processing of the event — that event will not trigger the new listener. However, the new listener may be triggered during a later stage of event flow, such as during the bubbling phase.\n\nThe value of \"this\" within the handler It is often desirable to reference the element on which the event handler was fired, such as when using a generic handler for a set of similar elements. When attaching a handler function to an element using , the value of inside the handler will be a reference to the element. It will be the same as the value of the property of the event argument that is passed to the handler. my_element.addEventListener(\"click\", function (e) { console.log(this.className); // logs the className of my_element console.log(e.currentTarget === this); // logs `true` }); As a reminder, arrow functions do not have their own context. my_element.addEventListener(\"click\", (e) => { console.log(this.className); // WARNING: `this` is not `my_element` console.log(e.currentTarget === this); // logs `false` }); If an event handler (for example, ) is specified on an element in the HTML source, the JavaScript code in the attribute value is effectively wrapped in a handler function that binds the value of in a manner consistent with the ; an occurrence of within the code represents a reference to the element. <table id=\"my_table\" onclick=\"console.log(this.id);\"> <!-- `this` refers to the table; logs 'my_table' --> … </table> Note that the value of inside a function, called by the code in the attribute value, behaves as per standard rules. This is shown in the following example: <script> function logID() { console.log(this.id); } </script> <table id=\"my_table\" onclick=\"logID();\"> <!-- when called, `this` will refer to the global object --> … </table> The value of within is a reference to the global object (or in the case of strict mode. Specifying \"this\" using bind() The method lets you establish a fixed context for all subsequent calls — bypassing problems where it's unclear what will be, depending on the context from which your function was called. Note, however, that you'll need to keep a reference to the listener around so you can remove it later. This is an example with and without : class Something { name = \"Something Good\"; constructor(element) { // bind causes a fixed `this` context to be assigned to `onclick2` this.onclick2 = this.onclick2.bind(this); element.addEventListener(\"click\", this.onclick1, false); element.addEventListener(\"click\", this.onclick2, false); // Trick } onclick1(event) { console.log(this.name); // undefined, as `this` is the element } onclick2(event) { console.log(this.name); // 'Something Good', as `this` is bound to the Something instance } } const s = new Something(document.body); Another solution is using a special function called to catch any events: class Something { name = \"Something Good\"; constructor(element) { // Note that the listeners in this case are `this`, not this.handleEvent element.addEventListener(\"click\", this, false); element.addEventListener(\"dblclick\", this, false); } handleEvent(event) { console.log(this.name); // 'Something Good', as this is bound to newly created object switch (event.type) { case \"click\": // some code here… break; case \"dblclick\": // some code here… break; } } } const s = new Something(document.body); Another way of handling the reference to is to use an arrow function, which doesn't create a separate context. class SomeClass { name = \"Something Good\"; register() { window.addEventListener(\"keydown\", (e) => { this.someMethod(e); }); } someMethod(e) { console.log(this.name); switch (e.code) { case \"ArrowUp\": // some code here… break; case \"ArrowDown\": // some code here… break; } } } const myObject = new SomeClass(); myObject.register();\n\nconst elts = document.getElementsByTagName(\"*\"); // Case 1 for (const elt of elts) { elt.addEventListener( \"click\", (e) => { // Do something }, false, ); } // Case 2 function processEvent(e) { // Do something } for (const elt of elts) { elt.addEventListener(\"click\", processEvent, false); } In the first case above, a new (anonymous) handler function is created with each iteration of the loop. In the second case, the same previously declared function is used as an event handler, which results in smaller memory consumption because there is only one handler function created. Moreover, in the first case, it is not possible to call because no reference to the anonymous function is kept (or here, not kept to any of the multiple anonymous functions the loop might create.) In the second case, it's possible to do because is the function reference. Actually, regarding memory consumption, the lack of keeping a function reference is not the real issue; rather it is the lack of keeping a static function reference.\n\nIf an event has a default action — for example, a event that scrolls the container by default — the browser is in general unable to start the default action until the event listener has finished, because it doesn't know in advance whether the event listener might cancel the default action by calling . If the event listener takes too long to execute, this can cause a noticeable delay, also known as jank, before the default action can be executed. By setting the option to , an event listener declares that it will not cancel the default action, so the browser can start the default action immediately, without waiting for the listener to finish. If the listener does then call , this will have no effect. The specification for defines the default value for the option as always being . However, to realize the scroll performance benefits of passive listeners in legacy code, modern browsers have changed the default value of the option to for the , , and events on the document-level nodes , , and . That prevents the event listener from canceling the event, so it can't block page rendering while the user is scrolling. Because of that, when you want to override that behavior and ensure the option is , you must explicitly set the option to (rather than relying on the default). You don't need to worry about the value of for the basic event. Since it can't be canceled, event listeners can't block page rendering anyway. See Improving scroll performance using passive listeners for an example showing the effect of passive listeners.\n\nThe following example shows the effect of setting . It includes a that contains some text, and a check box. <div id=\"container\"> <p> But down there it would be dark now, and not the lovely lighted aquarium she imagined it to be during the daylight hours, eddying with schools of tiny, delicate animals floating and dancing slowly to their own serene currents and creating the look of a living painting. That was wrong, in any case. The ocean was different from an aquarium, which was an artificial environment. The ocean was a world. And a world is not art. Dorothy thought about the living things that moved in that world: large, ruthless and hungry. Like us up here. </p> </div> <div> <input type=\"checkbox\" id=\"passive\" name=\"passive\" checked /> <label for=\"passive\">passive</label> </div> The code adds a listener to the container's event, which by default scrolls the container. The listener runs a long-running operation. Initially the listener is added with the option, and whenever the checkbox is toggled, the code toggles the option. const passive = document.querySelector(\"#passive\"); passive.addEventListener(\"change\", (event) => { container.removeEventListener(\"wheel\", wheelHandler); container.addEventListener(\"wheel\", wheelHandler, { passive: passive.checked, once: true, }); }); const container = document.querySelector(\"#container\"); container.addEventListener(\"wheel\", wheelHandler, { passive: true, once: true, }); function wheelHandler() { function isPrime(n) { for (let c = 2; c <= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const quota = 1000000; const primes = []; const maximum = 1000000; while (primes.length < quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } console.log(primes); }\n• Initially, the listener is passive, so trying to scroll the container with the wheel is immediate.\n• If you uncheck \"passive\" and try to scroll the container using the wheel, then there is a noticeable delay before the container scrolls, because the browser has to wait for the long-running listener to finish."
    },
    {
        "link": "https://w3schools.com/js/js_htmldom_eventlistener.asp",
        "document": "The method attaches an event handler to the specified element.\n\nThe method attaches an event handler to an element without overwriting existing event handlers.\n\nYou can add many event handlers to one element.\n\nYou can add many event handlers of the same type to one element, i.e two \"click\" events.\n\nYou can add event listeners to any DOM object not only HTML elements. i.e the window object.\n\nThe method makes it easier to control how the event reacts to bubbling.\n\nWhen using the method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup.\n\nYou can easily remove an event listener by using the method.\n\n\n\nThe first parameter is the type of the event (like \" \" or \" \" or any other HTML DOM Event.)\n\nThe second parameter is the function we want to call when the event occurs.\n\nThe third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.\n\nAdd an Event Handler to an Element\n\nYou can also refer to an external \"named\" function:\n\nAdd Many Event Handlers to the Same Element\n\nThe method allows you to add many events to the same element, without overwriting existing events:\n\nYou can add events of different types to the same element:\n\nAdd an Event Handler to the window Object\n\nThe method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support events, like the object.\n\nWhen passing parameter values, use an \"anonymous function\" that calls the specified function with the parameters:\n\nThere are two ways of event propagation in the HTML DOM, bubbling and capturing.\n\nEvent propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first?\n\nIn bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.\n\nIn capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.\n\nWith the addEventListener() method you can specify the propagation type by using the \"useCapture\" parameter:\n\nThe default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n\nThe method removes event handlers that have been attached with the addEventListener() method:\n\nFor a list of all HTML DOM events, look at our complete HTML DOM Event Object Reference."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/input_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020 .\n\nThe event fires when the of an , , or element has been changed as a direct result of a user action (such as typing in a textbox or checking a checkbox).\n\nThe event also applies to elements with enabled, and to any element when is turned on. In the case of and , the event target is the editing host. If these properties apply to multiple elements, the editing host is the nearest ancestor element whose parent isn't editable.\n\nFor elements with or , the event should fire whenever a user toggles the control, per the HTML Living Standard specification. However, historically this has not always been the case. Check compatibility, or use the event instead for elements of these types.\n\nFor and elements that accept text input ( , , etc.), the interface is ; for others, the interface is .\n\nThe event is fired every time the of the element changes. This is unlike the event, which only fires when the value is committed, such as by pressing the enter key or selecting a value from a list of options. Note that the event is not fired when JavaScript changes an element's programmatically."
    },
    {
        "link": "https://w3schools.com/jsref/dom_obj_event.asp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/47944253/addeventlistener-to-all-input-elements-when-dom-changes",
        "document": "At the moment I'm doing the following when the document is complete.\n\nWhich works as expected. However if the page has some additional script which modifies the DOM and adds more elements then they are not hooked.\n\nHow can add event handlers for ALL elements, even those added to the DOM thru script/ajax?\n\nNot a duplicate I don't consider this a duplicate as this question Detect Changes in the DOM which focuses on detecting changes in the DOM. My questions focus is on adding an to all elements even when the DOM changes. I have since added my own answer to this now."
    },
    {
        "link": "http://w3schools.com/TAgs/att_textarea_maxlength.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/maxlength",
        "document": "The attribute defines the maximum string length that the user can enter into an or . The attribute must have an integer value of 0 or higher.\n\nThe length is measured in UTF-16 code units, which (for most scripts) is equivalent to the number of characters. If no is specified, or an invalid value is specified, the input has no maximum length.\n\nAny value must be greater than or equal to the value of , if present and valid. The input will fail constraint validation if the length of the text value of the field is greater than maxlength UTF-16 code units long. Constraint validation is only applied when the value is changed by the user."
    },
    {
        "link": "https://stackoverflow.com/questions/3578678/how-can-i-block-further-input-in-textarea-using-maxlength",
        "document": "I have a textarea that I want to block input on if the entered characters reaches a max-length.\n\nI currently have a Jquery script for the textbox that calculates the characters entered and want to add something that will block input in the textarea once 150 characters are entered.\n\nI have tried using max-length plugins in conjunction with my script but they don't seem to work. Help is appreciated."
    },
    {
        "link": "https://ux.stackexchange.com/questions/13055/character-limits-on-textarea-fields-pros-and-cons-and-best-practices",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/1125482/how-to-impose-maxlength-on-textarea-in-html-using-javascript",
        "document": "I would like to have some functionality by which if I write\n\nit will automatically impose the maxlength on the textArea. If possible please do not provide the solution in jQuery.\n\nNote: This can be done if I do something like this:\n\nCopied from What is the best way to emulate an HTML input “maxlength” attribute on an HTML textarea?\n\nBut the point is I don't want to write onKeyPress and onKeyUp every time I declare a textArea."
    }
]