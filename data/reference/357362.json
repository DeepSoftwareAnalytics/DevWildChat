[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-9.0",
        "document": "Initializes a new instance of the Timer class with an infinite period and an infinite due time, using the newly created Timer object as the state object. Public Sub New (callback As TimerCallback) The following code example creates a new timer, using the timer itself as the state object. The Change method is used to start the timer. When the timer callback occurs, the state object is used to turn the timer off. using System; using System.Threading; public class Example { public static void Main() { // Create an instance of the Example class, and start two // timers. Example ex = new Example(); ex.StartTimer(2000); ex.StartTimer(1000); Console.WriteLine(\"Press Enter to end the program.\"); Console.ReadLine(); } public void StartTimer(int dueTime) { Timer t = new Timer(new TimerCallback(TimerProc)); t.Change(dueTime, 0); } private void TimerProc(object state) { // The state object is the Timer object. Timer t = (Timer) state; t.Dispose(); Console.WriteLine(\"The timer callback executes.\"); } } Imports System.Threading Public Class Example Public Shared Sub Main() ' Create an instance of the Example class, and start two ' timers. Dim ex As New Example() ex.StartTimer(2000) ex.StartTimer(1000) Console.WriteLine(\"Press Enter to end the program.\") Console.ReadLine() End Sub Public Sub StartTimer(ByVal dueTime As Integer) Dim t As New Timer(AddressOf TimerProc) t.Change(dueTime, 0) End Sub Private Sub TimerProc(ByVal state As Object) ' The state object is the Timer object. Dim t As Timer = CType(state, Timer) t.Dispose() Console.WriteLine(\"The timer callback executes.\") End Sub End Class Call this constructor when you want to use the Timer object itself as the state object. After creating the timer, use the Change method to set the interval and due time. This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the Timer object is assigned to the state object. The method specified for should be reentrant, because it is called on ThreadPool threads. The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.\n\nInitializes a new instance of the class, using a 32-bit signed integer to specify the time interval. Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer) An object containing information to be used by the callback method, or . The amount of time to delay before is invoked, in milliseconds. Specify Infinite to prevent the timer from starting. Specify zero (0) to start the timer immediately. The time interval between invocations of , in milliseconds. Specify Infinite to disable periodic signaling. The or parameter is negative and is not equal to Infinite. The following code example shows how to create a delegate and initialize a new instance of the class. using namespace System; using namespace System::Threading; ref class StatusChecker { private: int invokeCount, maxCount; public: StatusChecker(int count) { invokeCount = 0; maxCount = count; } // This method is called by the timer delegate. void CheckStatus(Object^ stateInfo) { AutoResetEvent^ autoEvent = dynamic_cast<AutoResetEvent^>(stateInfo); Console::WriteLine(\"{0:h:mm:ss.fff} Checking status {1,2}.\", DateTime::Now, ++invokeCount); if (invokeCount == maxCount) { // Reset the counter and signal the waiting thread. invokeCount = 0; autoEvent->Set(); } } }; ref class TimerExample { public: static void Main() { // Create an AutoResetEvent to signal the timeout threshold in the // timer callback has been reached. AutoResetEvent^ autoEvent = gcnew AutoResetEvent(false); StatusChecker^ statusChecker = gcnew StatusChecker(10); // Create a delegate that invokes methods for the timer. TimerCallback^ tcb = gcnew TimerCallback(statusChecker, &StatusChecker::CheckStatus); // Create a timer that invokes CheckStatus after one second, // and every 1/4 second thereafter. Console::WriteLine(\"{0:h:mm:ss.fff} Creating timer.\n\n\", DateTime::Now); Timer^ stateTimer = gcnew Timer(tcb, autoEvent, 1000, 250); // When autoEvent signals, change the period to every half second. autoEvent->WaitOne(5000, false); stateTimer->Change(0, 500); Console::WriteLine(\"\n\nChanging period to .5 seconds.\n\n\"); // When autoEvent signals the second time, dispose of the timer. autoEvent->WaitOne(5000, false); stateTimer->~Timer(); Console::WriteLine(\"\n\nDestroying timer.\"); } }; int main() { TimerExample::Main(); } // The example displays output like the following: // 11:59:54.202 Creating timer. // // 11:59:55.217 Checking status 1. // 11:59:55.466 Checking status 2. // 11:59:55.716 Checking status 3. // 11:59:55.968 Checking status 4. // 11:59:56.218 Checking status 5. // 11:59:56.470 Checking status 6. // 11:59:56.722 Checking status 7. // 11:59:56.972 Checking status 8. // 11:59:57.223 Checking status 9. // 11:59:57.473 Checking status 10. // // Changing period to .5 seconds. // // 11:59:57.474 Checking status 1. // 11:59:57.976 Checking status 2. // 11:59:58.476 Checking status 3. // 11:59:58.977 Checking status 4. // 11:59:59.477 Checking status 5. // 11:59:59.977 Checking status 6. // 12:00:00.478 Checking status 7. // 12:00:00.980 Checking status 8. // 12:00:01.481 Checking status 9. // 12:00:01.981 Checking status 10. // // Destroying timer. using System; using System.Threading; class TimerExample { static void Main() { // Create an AutoResetEvent to signal the timeout threshold in the // timer callback has been reached. var autoEvent = new AutoResetEvent(false); var statusChecker = new StatusChecker(10); // Create a timer that invokes CheckStatus after one second, // and every 1/4 second thereafter. Console.WriteLine(\"{0:h:mm:ss.fff} Creating timer.\n\n\", DateTime.Now); var stateTimer = new Timer(statusChecker.CheckStatus, autoEvent, 1000, 250); // When autoEvent signals, change the period to every half second. autoEvent.WaitOne(); stateTimer.Change(0, 500); Console.WriteLine(\"\n\nChanging period to .5 seconds.\n\n\"); // When autoEvent signals the second time, dispose of the timer. autoEvent.WaitOne(); stateTimer.Dispose(); Console.WriteLine(\"\n\nDestroying timer.\"); } } class StatusChecker { private int invokeCount; private int maxCount; public StatusChecker(int count) { invokeCount = 0; maxCount = count; } // This method is called by the timer delegate. public void CheckStatus(Object stateInfo) { AutoResetEvent autoEvent = (AutoResetEvent)stateInfo; Console.WriteLine(\"{0} Checking status {1,2}.\", DateTime.Now.ToString(\"h:mm:ss.fff\"), (++invokeCount).ToString()); if(invokeCount == maxCount) { // Reset the counter and signal the waiting thread. invokeCount = 0; autoEvent.Set(); } } } // The example displays output like the following: // 11:59:54.202 Creating timer. // // 11:59:55.217 Checking status 1. // 11:59:55.466 Checking status 2. // 11:59:55.716 Checking status 3. // 11:59:55.968 Checking status 4. // 11:59:56.218 Checking status 5. // 11:59:56.470 Checking status 6. // 11:59:56.722 Checking status 7. // 11:59:56.972 Checking status 8. // 11:59:57.223 Checking status 9. // 11:59:57.473 Checking status 10. // // Changing period to .5 seconds. // // 11:59:57.474 Checking status 1. // 11:59:57.976 Checking status 2. // 11:59:58.476 Checking status 3. // 11:59:58.977 Checking status 4. // 11:59:59.477 Checking status 5. // 11:59:59.977 Checking status 6. // 12:00:00.478 Checking status 7. // 12:00:00.980 Checking status 8. // 12:00:01.481 Checking status 9. // 12:00:01.981 Checking status 10. // // Destroying timer. Imports System.Threading Public Module Example Public Sub Main() ' Use an AutoResetEvent to signal the timeout threshold in the ' timer callback has been reached. Dim autoEvent As New AutoResetEvent(False) Dim statusChecker As New StatusChecker(10) ' Create a timer that invokes CheckStatus after one second, ' and every 1/4 second thereafter. Console.WriteLine(\"{0:h:mm:ss.fff} Creating timer.\" & vbCrLf, DateTime.Now) Dim stateTimer As New Timer(AddressOf statusChecker.CheckStatus, autoEvent, 1000, 250) ' When autoEvent signals, change the period to every half second. autoEvent.WaitOne() stateTimer.Change(0, 500) Console.WriteLine(vbCrLf & \"Changing period to .5 seconds.\" & vbCrLf) ' When autoEvent signals the second time, dispose of the timer. autoEvent.WaitOne() stateTimer.Dispose() Console.WriteLine(vbCrLf & \"Destroying timer.\") End Sub End Module Public Class StatusChecker Dim invokeCount, maxCount As Integer Sub New(count As Integer) invokeCount = 0 maxCount = count End Sub ' The timer callback method. Sub CheckStatus(stateInfo As Object) Dim autoEvent As AutoResetEvent = DirectCast(stateInfo, AutoResetEvent) invokeCount += 1 Console.WriteLine(\"{0:h:mm:ss.fff} Checking status {1,2}.\", DateTime.Now, invokeCount) If invokeCount = maxCount Then ' Reset the counter and signal the waiting thread. invokeCount = 0 autoEvent.Set() End If End Sub End Class ' The example displays output like the following: ' 11:59:54.202 Creating timer. ' ' 11:59:55.217 Checking status 1. ' 11:59:55.466 Checking status 2. ' 11:59:55.716 Checking status 3. ' 11:59:55.968 Checking status 4. ' 11:59:56.218 Checking status 5. ' 11:59:56.470 Checking status 6. ' 11:59:56.722 Checking status 7. ' 11:59:56.972 Checking status 8. ' 11:59:57.223 Checking status 9. ' 11:59:57.473 Checking status 10. ' ' Changing period to .5 seconds. ' ' 11:59:57.474 Checking status 1. ' 11:59:57.976 Checking status 2. ' 11:59:58.476 Checking status 3. ' 11:59:58.977 Checking status 4. ' 11:59:59.477 Checking status 5. ' 11:59:59.977 Checking status 6. ' 12:00:00.478 Checking status 7. ' 12:00:00.980 Checking status 8. ' 12:00:01.481 Checking status 9. ' 12:00:01.981 Checking status 10. ' ' Destroying timer. The delegate specified by the parameter is invoked once after elapses, and thereafter each time the time interval elapses. If is zero (0), is invoked immediately. If is Timeout.Infinite, is not invoked; the timer is disabled, but can be re-enabled by calling the Change method. Because the Timer class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the delegate executes at intervals defined by the resolution of the system clock if is less than the resolution of the system clock. If is zero (0) or Timeout.Infinite and is not Timeout.Infinite, is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the Change method. The system clock that is used is the same clock used by GetTickCount, which is not affected by changes made with timeBeginPeriod and timeEndPeriod. The method specified for should be reentrant, because it is called on ThreadPool threads. The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.\n\nInitializes a new instance of the class, using 64-bit signed integers to measure time intervals. Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long) An object containing information to be used by the callback method, or . The amount of time to delay before is invoked, in milliseconds. Specify Infinite to prevent the timer from starting. Specify zero (0) to start the timer immediately. The time interval between invocations of , in milliseconds. Specify Infinite to disable periodic signaling. The or parameter is negative and is not equal to Infinite. The or parameter is greater than 4294967294. The delegate specified by the parameter is invoked once after elapses, and thereafter each time the time interval elapses. If is zero (0), is invoked immediately. If is Timeout.Infinite, is not invoked; the timer is disabled, but can be re-enabled by calling the Change method. Because the Timer class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the delegate executes at intervals defined by the resolution of the system clock if is less than the resolution of the system clock. If is zero (0) or Timeout.Infinite and is not Timeout.Infinite, is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the Change method. The system clock that is used is the same clock used by GetTickCount, which is not affected by changes made with timeBeginPeriod and timeEndPeriod. The method specified for should be reentrant, because it is called on ThreadPool threads. The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.\n\nInitializes a new instance of the class, using TimeSpan values to measure time intervals. Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan) An object containing information to be used by the callback method, or . The amount of time to delay before the is invoked. Specify InfiniteTimeSpan to prevent the timer from starting. Specify Zero to start the timer immediately. The time interval between invocations of . Specify InfiniteTimeSpan to disable periodic signaling. The number of milliseconds in the value of or is negative and not equal to Infinite, or is greater than Int32.MaxValue. The following code example shows how to create a delegate and initialize a new instance of the class. using namespace System; using namespace System::Threading; ref class StatusChecker { private: int invokeCount; int maxCount; public: StatusChecker( int count ) : invokeCount( 0 ), maxCount( count ) {} // This method is called by the timer delegate. void CheckStatus( Object^ stateInfo ) { AutoResetEvent^ autoEvent = dynamic_cast<AutoResetEvent^>(stateInfo); Console::WriteLine( \"{0} Checking status {1,2}.\", DateTime::Now.ToString( \"h:mm:ss.fff\" ), (++invokeCount).ToString() ); if ( invokeCount == maxCount ) { // Reset the counter and signal main. invokeCount = 0; autoEvent->Set(); } } }; int main() { AutoResetEvent^ autoEvent = gcnew AutoResetEvent( false ); StatusChecker^ statusChecker = gcnew StatusChecker( 10 ); // Create the delegate that invokes methods for the timer. TimerCallback^ timerDelegate = gcnew TimerCallback( statusChecker, &StatusChecker::CheckStatus ); TimeSpan delayTime = TimeSpan(0,0,1); TimeSpan intervalTime = TimeSpan(0,0,0,0,250); // Create a timer that signals the delegate to invoke CheckStatus // after one second, and every 1/4 second thereafter. Console::WriteLine( \"{0} Creating timer.\n\n\", DateTime::Now.ToString( \"h:mm:ss.fff\" ) ); Timer^ stateTimer = gcnew Timer( timerDelegate,autoEvent,delayTime,intervalTime ); // When autoEvent signals, change the period to every 1/2 second. autoEvent->WaitOne( 5000, false ); stateTimer->Change( TimeSpan(0), intervalTime + intervalTime ); Console::WriteLine( \"\n\nChanging period.\n\n\" ); // When autoEvent signals the second time, dispose of the timer. autoEvent->WaitOne( 5000, false ); stateTimer->~Timer(); Console::WriteLine( \"\n\nDestroying timer.\" ); } using System; using System.Threading; class TimerExample { static void Main() { AutoResetEvent autoEvent = new AutoResetEvent(false); StatusChecker statusChecker = new StatusChecker(10); // Create the delegate that invokes methods for the timer. TimerCallback timerDelegate = new TimerCallback(statusChecker.CheckStatus); TimeSpan delayTime = new TimeSpan(0, 0, 1); TimeSpan intervalTime = new TimeSpan(0, 0, 0, 0, 250); // Create a timer that signals the delegate to invoke // CheckStatus after one second, and every 1/4 second // thereafter. Console.WriteLine(\"{0} Creating timer.\n\n\", DateTime.Now.ToString(\"h:mm:ss.fff\")); Timer stateTimer = new Timer( timerDelegate, autoEvent, delayTime, intervalTime); // When autoEvent signals, change the period to every // 1/2 second. autoEvent.WaitOne(5000, false); stateTimer.Change(new TimeSpan(0), intervalTime + intervalTime); Console.WriteLine(\"\n\nChanging period.\n\n\"); // When autoEvent signals the second time, dispose of // the timer. autoEvent.WaitOne(5000, false); stateTimer.Dispose(); Console.WriteLine(\"\n\nDestroying timer.\"); } } class StatusChecker { int invokeCount, maxCount; public StatusChecker(int count) { invokeCount = 0; maxCount = count; } // This method is called by the timer delegate. public void CheckStatus(Object stateInfo) { AutoResetEvent autoEvent = (AutoResetEvent)stateInfo; Console.WriteLine(\"{0} Checking status {1,2}.\", DateTime.Now.ToString(\"h:mm:ss.fff\"), (++invokeCount).ToString()); if(invokeCount == maxCount) { // Reset the counter and signal Main. invokeCount = 0; autoEvent.Set(); } } } Imports System.Threading Public Class TimerExample <MTAThread> _ Shared Sub Main() Dim autoEvent As New AutoResetEvent(False) Dim statusChecker As New StatusChecker(10) ' Create the delegate that invokes methods for the timer. Dim timerDelegate As TimerCallback = _ AddressOf statusChecker.CheckStatus Dim delayTime As New TimeSpan(0, 0, 1) Dim intervalTime As New TimeSpan(0, 0, 0, 0, 250) ' Create a timer that signals the delegate to invoke ' CheckStatus after one second, and every 1/4 second ' thereafter. Console.WriteLine(\"{0} Creating timer.\" & vbCrLf, _ DateTime.Now.ToString(\"h:mm:ss.fff\")) Dim stateTimer As Timer = New Timer( _ timerDelegate, autoEvent, delayTime, intervalTime) ' When autoEvent signals, change the period to every ' 1/2 second. autoEvent.WaitOne(5000, False) stateTimer.Change( _ new TimeSpan(0), intervalTime.Add(intervalTime)) Console.WriteLine(vbCrLf & \"Changing period.\" & vbCrLf) ' When autoEvent signals the second time, dispose of ' the timer. autoEvent.WaitOne(5000, False) stateTimer.Dispose() Console.WriteLine(vbCrLf & \"Destroying timer.\") End Sub End Class Public Class StatusChecker Dim invokeCount, maxCount As Integer Sub New(count As Integer) invokeCount = 0 maxCount = count End Sub ' This method is called by the timer delegate. Sub CheckStatus(stateInfo As Object) Dim autoEvent As AutoResetEvent = _ DirectCast(stateInfo, AutoResetEvent) invokeCount += 1 Console.WriteLine(\"{0} Checking status {1,2}.\", _ DateTime.Now.ToString(\"h:mm:ss.fff\"), _ invokeCount.ToString()) If invokeCount = maxCount Then ' Reset the counter and signal to stop the timer. invokeCount = 0 autoEvent.Set() End If End Sub End Class The delegate specified by the parameter is invoked once after elapses, and thereafter each time the time interval elapses. If is zero (0), is invoked immediately. If is negative one (-1) milliseconds, is not invoked; the timer is disabled, but can be re-enabled by calling the Change method. Because the Timer class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the delegate executes at intervals defined by the resolution of the system clock if is less than the resolution of the system clock. If is zero (0) or negative one (-1) milliseconds and is positive, is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the Change method. The system clock that is used is the same clock used by GetTickCount, which is not affected by changes made with timeBeginPeriod and timeEndPeriod. The method specified for should be reentrant, because it is called on ThreadPool threads. The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.\n\nThis API is not CLS-compliant. Initializes a new instance of the class, using 32-bit unsigned integers to measure time intervals. Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger) An object containing information to be used by the callback method, or . The amount of time to delay before is invoked, in milliseconds. Specify Infinite to prevent the timer from starting. Specify zero (0) to start the timer immediately. The time interval between invocations of , in milliseconds. Specify Infinite to disable periodic signaling. The or parameter is negative and is not equal to Infinite. The delegate specified by the parameter is invoked once after elapses, and thereafter each time the time interval elapses. If is zero (0), is invoked immediately. If is Timeout.Infinite, is not invoked; the timer is disabled, but can be re-enabled by calling the Change method. Because the Timer class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the delegate executes at intervals defined by the resolution of the system clock if is less than the resolution of the system clock. If is zero (0) or Timeout.Infinite and is not Timeout.Infinite, is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the Change method. The system clock that is used is the same clock used by GetTickCount, which is not affected by changes made with timeBeginPeriod and timeEndPeriod. The method specified for should be reentrant, because it is called on ThreadPool threads. The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times."
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2004/february/comparing-the-timer-classes-in-the-net-framework-class-library",
        "document": "Comparing the Timer Classes in the .NET Framework Class Library\n\nThis article assumes you're familiar with C#\n\nTimers often play an important role in both client applications and server-based components (including Windows services). Writing effective timer-driven managed code requires a clear understanding of program flow and the subtleties of the .NET threading model. The .NET Framework Class Library provides three different timer classes: System.Windows.Forms.Timer, System.Timers.Timer, and System.Threading.Timer. Each of these classes has been designed and optimized for use in different situations. This article examines the three timer classes and helps you gain an understanding of how and when each class should be used.\n\nTimer objects in Microsoft® Windows® allow you to control when actions take place. Some of the most common uses of timers are to start a process at a regularly scheduled time, to set intervals between events, and to maintain consistent animation speeds (regardless of processor speed) when working with graphics. In the past, timers have even allowed developers who use Visual Basic® to simulate multitasking.\n\nAs you would expect, the Microsoft .NET Framework arms you with the tools you need to tackle each of these scenarios. There are three different timer classes in the .NET Framework Class Library: System.Windows.Forms.Timer, System.Timers.Timer, and System.Threading.Timer. The first two classes appear in the Visual Studio® .NET toolbox window, allowing you to drag and drop both of these timer controls directly onto a Windows Forms designer or a component class designer. If you're not careful, this is where trouble can begin.\n\nThe Visual Studio .NET toolbox has a timer control on both the Windows Forms tab and the Components tab (see Figure 1). It is very easy to use the wrong one, or worse yet, to not even realize that they are different. Use the timer control that is located under the Windows Forms tab only if the target is a Windows Forms designer. This control will place an instance of the System.Windows.Forms.Timer class on your form. Like all other controls in the toolbox, you can either let Visual Studio .NET handle the plumbing or you can manually instantiate and initialize the class yourself.\n\nThe timer control that is located on the Components tab can be safely used in any class. This control creates an instance of the System.Timers.Timer class. If you're using the Visual Studio .NET toolbox, you can safely use this timer with either the Windows Forms designer or the component class designer. The component class designer is used by Visual Studio .NET when you're working on a class that derives from System.ComponentModel.Component (as is the case when you're working with Windows services). The System.Threading.Timer class does not appear on the Visual Studio .NET toolbox window. It is somewhat more complicated but provides a higher level of control, as you will see later in this article.\n\nLet's first examine the System.Windows.Forms.Timer and System.Timers.Timer classes. These two classes have a very similar object model. Later I'll explore the more advanced System.Threading.Timer class. Figure 2 shows a screenshot of the sample application that I will be referring to throughout this article. This application will help you gain a clear understanding of each of the timer classes. You can download the complete code from the link at the top of this article and experiment with it.\n\nIf you're looking for a metronome, you've come to the wrong place. The timer events raised by this timer class are synchronous with respect to the rest of the code in your Windows Forms app. This means that application code that is executing will never be preempted by an instance of this timer class (assuming you don't call Application.DoEvents). Just like the rest of the code in a typical Windows Forms application, any code that resides inside a timer event handler (for this type of timer class) is executed using the application's UI thread. During idle time, the UI thread is also responsible for processing all messages in the application's Windows message queue. This includes Windows API messages as well as the Tick events raised by this timer class. The UI thread processes these messages whenever your application isn't busy doing something else.\n\nIf you wrote Visual Basic code prior to Visual Studio .NET, you probably know that in a Windows-based application the only way to allow the UI thread to respond to Windows messages while executing in an event handler is to call the Application.DoEvents method. Just like with Visual Basic, calling Application.DoEvents from the .NET Framework can cause many problems. Application.DoEvents yields control to the UI message pump, allowing all pending events to be processed. This can alter the expected path of execution that I just mentioned. If Application.DoEvents is called from your code, your program flow may be interrupted in order to process the timer events generated by an instance of this class. This can cause unexpected behaviors and make debugging difficult.\n\nHow this timer class behaves becomes evident when running the sample application. Clicking the application's Start button, then its Sleep button, and finally the Stop button, will yield the following output:\n\nThe sample application sets the Interval property of the System.Windows.Forms.Timer class to 1000 milliseconds. As you can see, if the timer event handler had continued to capture timer events while the main UI thread was sleeping (for five seconds), there would have been five timer events displayed as soon as the UI thread woke up again—one for each second the UI thread was sleeping. Instead, the timer remained in a suspended state while the UI thread was sleeping.\n\nProgramming the System.Windows.Forms.Timer class couldn't be easier—it has a very simple and intuitive programmatic interface. The Start and Stop methods essentially provide an alternate way of setting the Enabled property (which itself is a thin wrapper around Win32® SetTimer/ KillTimer functions). The Interval property, which I just mentioned, is self-explanatory. Even though you can technically set the Interval property as low as one millisecond, you should be aware that the .NET Framework documentation states that this property is only accurate to approximately 55 milliseconds (provided that the UI thread is available for processing).\n\nCapturing the events raised by an instance of the System.Windows.Forms.Timer class is handled by wiring the Tick event to a standard EventHandler delegate, as shown by the code snippet in the following example:\n\nThe .NET Framework documentation refers to the System.Timers.Timer class as a server-based timer that was designed and optimized for use in multithreaded environments. Instances of this timer class can be safely accessed from multiple threads. Unlike the System.Windows.Forms.Timer, the System.Timers.Timer class will, by default, call your timer event handler on a worker thread obtained from the common language runtime (CLR) thread pool. This means that the code inside your Elapsed event handler must conform to a golden rule of Win32 programming: an instance of a control should never be accessed from any thread other than the thread that was used to instantiate it.\n\nThe System.Timers.Timer class provides an easy way to deal with this dilemma—it exposes a public SynchronizingObject property. Setting this property to an instance of a Windows Form (or a control on a Windows Form) will ensure that the code in your Elapsed event handler runs on the same thread on which the SynchronizingObject was instantiated.\n\nIf you use the Visual Studio .NET toolbox, Visual Studio .NET will automatically set the SynchronizingObject property to the current form instance. At first it may seem as though using this timer class with the SynchronizingObject property makes it functionally equivalent to using the System.Windows.Forms.Timer. For the most part, it is. When the operating system notifies the System.Timers.Timer class that the enabled timer has elapsed, the timer uses the SynchronizingObject.Begin.Invoke method to execute the Elapsed event delegate on the thread on which the SynchronizingObject's underlying handle was created. The event handler will be blocked until the UI thread is able to process it. However, unlike with System.Windows.Forms.Timer, the event will still eventually be raised. As you saw in Figure 2, System.Windows.Forms.Timer will not raise events that occur while the UI thread is unable to process them, whereas System.Timers.Timer will queue them to be processes when the UI thread is available.\n\nFigure 3 shows an example of how to use the SynchronizingObject property. You can use the sample application to analyze this class by selecting the System.Timers.Timer radio button and running through the same sequence of events as you did with the System.Windows.Forms.Timer. Doing so will produce the output shown in Figure 4.\n\nAs you can see, it didn't skip a beat—even when the UI thread was sleeping. An Elapsed event handler was queued to be executed at each event interval. Because the UI thread was sleeping, however, the sample application displays the five timer events (4 through 8) all at once when the UI thread wakes up again and is able to process the handlers.\n\nAs I mentioned earlier, the System.Timers.Timer class members are very similar to those of the System.Windows.Forms.Timer class. The biggest difference is that System.Timers.Timer is a wrapper around Win32 waitable timer objects and raises an Elapsed event on a worker thread rather than a Tick event on the UI thread. The Elapsed event must be connected to an event handler that matches the ElapsedEventHandler delegate. The event handler receives an argument of type ElapsedEventArgs.\n\nAbove and beyond the standard EventArgs members, the ElapsedEventArgs class exposes a public SignalTime property, which contains the exact time the timer elapsed. Because this class supports access from different threads, it is conceivable that the Stop method may be called on a thread other than the thread that is used for the Elapsed event. This could potentially result in the Elapsed event firing even after the Stop method has been called. You can deal with this by comparing the SignalTime property to the time the Stop method was called.\n\nThe System.Timers.Timer class also provides an AutoReset property that determines if the Elapsed event should fire continuously or just once. Keep in mind that resetting the Interval property after the timer has started will reset the current count back to zero. For example, if the interval is set to 5 seconds and 3 seconds have already elapsed before the interval is changed to 10 seconds, the next timer event will be 13 seconds from the last timer event.\n\nThe third timer class comes from the System.Threading namespace. I'd like to say that this is the best of all timer classes, but that would be misleading. For one thing, I was surprised to find that instances of this class are not inherently thread safe, given that it resides in the System.Threading namespace. (Obviously, this doesn't mean it can't be used in a thread-safe manner.) The programmatic interface of this class is not consistent with the other two timer classes and it's also a bit more cumbersome.\n\nUnlike the previous two timer classes that I have just covered, System.Threading.Timer has four overloaded constructors. The following shows what they look like:\n\nThe first parameter (callback) requires a TimerCallback delegate that points to a method with the following signature:\n\nThe second parameter (state) can either be null or an object containing application-specific information. This state object is passed to your timer callback function during each timer event invocation. Keep in mind that the timer callback function is executed on a worker thread, so you'll want to ensure that you have thread-safe access to the state object.\n\nThe third parameter (dueTime) allows you to specify when the initial timer event should be fired. You can specify 0 to start the timer immediately or to prevent the timer from automatically starting, you can use the System.Threading.Timeout.Infinite constant.\n\nThe fourth parameter (period) allows you to specify the interval (in milliseconds) at which the callback function should be called. Specifying either 0 or Timeout.Infinite for this parameter will disable subsequent timer event invocations.\n\nOnce the constructor has been called, you can still alter the dueTime and period settings by using the Change method. This method has the following four overloads:\n\nHere's the code I used in the sample application to start and stop this timer:\n\nAs you might expect, running the sample application with the System.Threading.Timer class selected results in the same output you just saw with the System.Timers.Timer class. Because the TimerCallback function gets called on a worker thread, there are no skipped beats (assuming the availability of worker threads). Figure 5 shows the output from the sample application.\n\nUnlike the System.Timers.Timer class, there is no counterpart to the SynchronizingObject property that was offered by the System.Timers.Timer class. Any operations that require access to UI controls should be marshaled using the Control's Invoke or BeginInvoke methods.\n\nTo maximize code reuse, the sample application calls the same ShowTimerEventFired method from all three different types of timer events. Here are the three timer event handlers:\n\nAs you can see, the ShowTimerEventFired method takes the current time and current thread name as arguments. In order to distinguish worker threads from the UI thread, the main entry point for the sample application sets the Name property of the CurrentThread object to \"UIThread.\" The GetThreadName helper method returns either the value of Thread.CurrentThread.Name or \"WorkerThread\" if the Thread.CurrentThread.IsThreadPoolThread property is true.\n\nBecause the timer events for System.Timers.Timer and System.Threading.Timer execute on worker threads, it is imperative that any user interface code within these event handlers be marshaled back onto the UI thread for processing. To do this, I created a delegate called ShowTimerEventFiredDelegate:\n\nShowTimerEventFiredDelegate allows the ShowTimerEventFired method to call itself back on the UI thread. Figure 6 shows the code that makes all this happen.\n\nIt's very easy to determine whether you can safely access a Windows Forms control from the current thread by querying its InvokeRequired property. In this example, if the ListBox's InvokeRequired property is true, the form's BeginInvoke method can be used to call the ShowTimerEventFired method again via ShowTimerEventFiredDelegate. This will ensure that the ListBox Add method executes on the UI thread.\n\nAs you can see, there are many issues you need to be aware of when programming with asynchronous timer events. I recommend that you read Ian Griffith's article \"Windows Forms: Give Your .NET-based Application a Fast and Responsive UI with Multiple Threads,\" from the February 2003 issue of MSDN Magazine before using either System.Timers.Timer or System.Threading.Timer.\n\nThere's another subtle issue you'll need to consider when working with asynchronous timer events, such as the events generated by System.Timers.Timer and System.Threading.Timer. The problem has to do with code reentrance. If the code in your timer event handler takes longer to execute than the interval at which the timer is raising events, and you haven't taken the necessary precautions to guard against multithreaded access to your objects and variables, then you could be in for some difficult debugging sessions. Take a look at the following code snippet:\n\nAssuming your timer Interval property is set to 1000 milliseconds, you may be surprised to find out that the first message box that pops up will show a value of 5. This is because during the five seconds that the first timer event was sleeping, the timer kept on generating Elapsed events on different worker threads. Hence, the value of the tickCounter variable was incremented five times before the processing of the first timer event was completed. Notice how I used the Interlocked.Increment method to increment the tickCounter variable in a thread-safe manner. There are other ways to do this, but the Interlocked.Increment method was specifically designed for this kind of operation.\n\nOne easy way to solve this type of reentrance problem is to sandwich your timer event handler in a block of code that temporarily disables and then reenables the timer, as shown in the following example:\n\nWith this code in place, message boxes will show up every five seconds and, as you would expect, the value of tickCounter will be incremented by one each time. Another option would be to use a synchronization primitive such as Monitor or a mutex to ensure that all future events are queued until the current handler has finished executing.\n\nFor a quick recap of my look at the three timer classes available in the .NET Framework, see the table in Figure 7 which compares these three classes. A point you may want to consider when working with timers is whether your problem can be solved more simply by using the Windows Scheduler (or the AT command for that matter) to run a standard executable periodically.\n\nFor related articles see:\n\n Windows Forms: Give Your .NET-Based Application a Fast and Responsive UI with Multiple Threads\n\nFor background information see:\n\n Programming the Thread Pool in the .NET Framework: Using Timers\n\n .NET Framework Class Library\n\nAlex Calvo is a Microsoft Certified Solutions Developer for .NET. When he's not reading, coding, or meditating, he's playing guitar. You can reach Alex at acalvo@hotmail.com."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer?view=net-9.0",
        "document": "The following example instantiates a object that fires its Timer.Elapsed event every two seconds (2,000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the ElapsedEventArgs.SignalTime property each time it is raised.\n\nThe Timer component is a server-based timer that raises an Elapsed event in your application after the number of milliseconds in the Interval property has elapsed. You can configure the Timer object to raise the event just once or repeatedly using the AutoReset property. Typically, a Timer object is declared at the class level so that it stays in scope as long as it is needed. You can then handle its Elapsed event to provide regular processing. For example, suppose you have a critical server that must be kept running 24 hours a day, 7 days a week. You could create a service that uses a Timer object to periodically check the server and ensure that the system is up and running. If the system is not responding, the service could attempt to restart the server or notify an administrator.\n\nThis type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a / block. To dispose of it indirectly, use a language construct such as (in C#) or (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the IDisposable interface topic.\n\nThe server-based System.Timers.Timer class is designed for use with worker threads in a multithreaded environment. Server timers can move among threads to handle the raised Elapsed event, resulting in more accuracy than Windows timers in raising the event on time.\n\nThe System.Timers.Timer component raises the Elapsed event, based on the value (in milliseconds) of the Interval property. You can handle this event to perform the processing you need. For example, suppose that you have an online sales application that continuously posts sales orders to a database. The service that compiles the instructions for shipping operates on a batch of orders rather than processing each order individually. You could use a Timer to start the batch processing every 30 minutes.\n\nWhen AutoReset is set to , a System.Timers.Timer object raises the Elapsed event only once, after the first Interval has elapsed. To keep raising the Elapsed event regularly at the interval defined by the Interval, set AutoReset to , which is the default value.\n\nThe Timer component catches and suppresses all exceptions thrown by event handlers for the Elapsed event. This behavior is subject to change in future releases of the .NET Framework. Note, however, that this is not true of event handlers that execute asynchronously and include the operator (in C#) or the operator (in Visual Basic). Exceptions thrown in these event handlers are propagated back to the calling thread, as the following example illustrates. For more information on exceptions thrown in asynchronous methods, see Exception Handling.\n\nIf the SynchronizingObject property is , the Elapsed event is raised on a ThreadPool thread. If processing of the Elapsed event lasts longer than Interval, the event might be raised again on another ThreadPool thread. In this situation, the event handler should be reentrant.\n\nEven if SynchronizingObject is not , Elapsed events can occur after the Dispose or Stop method has been called or after the Enabled property has been set to , because the signal to raise the Elapsed event is always queued for execution on a thread pool thread. One way to resolve this race condition is to set a flag that tells the event handler for the Elapsed event to ignore subsequent events.\n\nIf you use the System.Timers.Timer class with a user interface element, such as a form or control, without placing the timer on that user interface element, assign the form or control that contains the Timer to the SynchronizingObject property, so that the event is marshaled to the user interface thread.\n\nFor a list of default property values for an instance of Timer, see the Timer constructor.\n\nInitializes a new instance of the Timer class, and sets all the properties to their initial values. Initializes a new instance of the Timer class, and sets the Interval property to the specified number of milliseconds. Initializes a new instance of the Timer class, setting the Interval property to the specified period. Gets or sets a Boolean indicating whether the Timer should raise the Elapsed event only once ( ) or repeatedly ( ). Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets the IContainer that contains the Component. (Inherited from Component) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets or sets a value indicating whether the Timer should raise the Elapsed event. Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets the interval, expressed in milliseconds, at which to raise the Elapsed event. Gets or sets the site that binds the Timer to its container in design mode. Gets or sets the object used to marshal event-handler calls that are issued when an interval has elapsed. Begins the run-time initialization of a Timer that is used on a form or by another component. Releases the resources used by the Timer. Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases all resources used by the current Timer. Ends the run-time initialization of a Timer that is used on a form or by another component. Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Starts raising the Elapsed event by setting Enabled to . Stops raising the Elapsed event by setting Enabled to . Returns a String containing the name of the Component, if any. This method should not be overridden. (Inherited from Component) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component)\n\nAny public members of this type are thread safe. Any instance members are not guaranteed to be thread safe."
    },
    {
        "link": "https://stackoverflow.com/questions/3520927/system-threading-timer-maximum-duetime-value-problem",
        "document": "This looks like a race in the CLR's implementation of the timer. I need to wave my hands at the exact cause, I don't really understand how it can go wrong. At least from looking at the SSCLI20 source code (clr\\src\\vm\\win32threadpool.cpp), there's a good chance that this is no longer accurate with the currently shipping code.\n\nI can repro the problem easily by setting a breakpoint at the Change() call but not when I let the code run without a break. It behaves like it calculates the due time from the last observed value returned by GetTickCount() instead of the current value. Adding 0xfffffffe to that stale value then calculates a time that already expired. The tick count only has 32-bits of resolution. I think the real race is in the calculation of how long to SleepEx() to wait for the next time due event, but that's a guess.\n\nIt is possible that this race can occur also if you don't use the debugger to pause the timer thread. Although it would probably be rare. I'd have to recommend you stay away from any value close to 0xfffffffe to be sure this won't happen. No hardship there, sleeping for 24 days is not less efficient than sleeping for 49 days :) Implement longer intervals by counting sleep periods yourself."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.threading.timer?view=net-9.0",
        "document": "The following example defines a class that includes a method whose signature is the same as the TimerCallback delegate. The argument of the method is an AutoResetEvent object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate. The class also includes two state variables:\n\nIndicates the number of times the callback method has been invoked.\n\nDetermines the maximum number of times the callback method should be invoked.\n\nThe application thread creates the timer, which waits one second and then executes the callback method every 250 milliseconds. The application thread then blocks until the AutoResetEvent object is signaled. When the callback method executes times, it calls the method to set the state of the AutoResetEvent object to signaled. The first time this happens, the application thread calls the Change(Int32, Int32) method so that the callback method now executes every half second. It once again blocks until the AutoResetEvent object is signaled. When this happens, the timer is destroyed by calling its Dispose method, and the application terminates.\n\nUse a TimerCallback delegate to specify the method you want the Timer to execute. The signature of the TimerCallback delegate is:\n\nThe timer delegate is specified when the timer is constructed, and cannot be changed. The method does not execute on the thread that created the timer; it executes on a ThreadPool thread supplied by the system.\n\nWhen you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period). The Timer class has the same resolution as the system clock. This means that if the period is less than the resolution of the system clock, the TimerCallback delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems. You can change the due time and period, or disable the timer, by using the Change method.\n\nWhen a timer is no longer needed, use the Dispose method to free the resources held by the timer. Note that callbacks can occur after the Dispose() method overload has been called, because the timer queues callbacks for execution by thread pool threads. You can use the Dispose(WaitHandle) method overload to wait until all callbacks have completed.\n\nThe callback method executed by the timer should be reentrant, because it is called on ThreadPool threads. The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/background-tasks-with-ihostedservice",
        "document": "Implement background tasks in microservices with IHostedService and the BackgroundService class\n\nBackground tasks and scheduled jobs are something you might need to use in any application, whether or not it follows the microservices architecture pattern. The difference when using a microservices architecture is that you can implement the background task in a separate process/container for hosting so you can scale it down/up based on your need.\n\nFrom a generic point of view, in .NET we called these type of tasks Hosted Services, because they are services/logic that you host within your host/application/microservice. Note that in this case, the hosted service simply means a class with the background task logic.\n\nSince .NET Core 2.0, the framework provides a new interface named IHostedService helping you to easily implement hosted services. The basic idea is that you can register multiple background tasks (hosted services) that run in the background while your web host or host is running, as shown in the image 6-26.\n\nFigure 6-26. Using IHostedService in a WebHost vs. a Host\n\nASP.NET Core 1.x and 2.x support for background processes in web apps. .NET Core 2.1 and later versions support for background processes with plain console apps. Note the difference made between and .\n\nA (base class implementing ) in ASP.NET Core 2.0 is the infrastructure artifact you use to provide HTTP server features to your process, such as when you're implementing an MVC web app or Web API service. It provides all the new infrastructure goodness in ASP.NET Core, enabling you to use dependency injection, insert middlewares in the request pipeline, and similar. The uses these very same for background tasks.\n\nA (base class implementing ) was introduced in .NET Core 2.1. Basically, a allows you to have a similar infrastructure than what you have with (dependency injection, hosted services, etc.), but in this case, you just want to have a simple and lighter process as the host, with nothing related to MVC, Web API or HTTP server features.\n\nTherefore, you can choose and either create a specialized host-process with to handle the hosted services and nothing else, such a microservice made just for hosting the , or you can alternatively extend an existing ASP.NET Core , such as an existing ASP.NET Core Web API or MVC app.\n\nEach approach has pros and cons depending on your business and scalability needs. The bottom line is basically that if your background tasks have nothing to do with HTTP ( ) you should use .\n\nRegistering hosted services in your WebHost or Host\n\nLet's drill down further on the interface since its usage is pretty similar in a or in a .\n\nSignalR is one example of an artifact using hosted services, but you can also use it for much simpler things like:\n• A background task polling a database looking for changes.\n• An implementation of QueueBackgroundWorkItem that allows a task to be executed on a background thread.\n• Processing messages from a message queue in the background of a web app while sharing common services such as .\n\nYou can basically offload any of those actions to a background task that implements .\n\nThe way you add one or multiple into your or is by registering them up through the AddHostedService extension method in an ASP.NET Core (or in a in .NET Core 2.1 and above). Basically, you have to register the hosted services within application startup in Program.cs.\n\nIn that code, the hosted service is real code from the Ordering business microservice in eShopOnContainers, while the other two are just two additional samples.\n\nThe background task execution is coordinated with the lifetime of the application (host or microservice, for that matter). You register tasks when the application starts and you have the opportunity to do some graceful action or clean-up when the application is shutting down.\n\nWithout using , you could always start a background thread to run any task. The difference is precisely at the app's shutdown time when that thread would simply be killed without having the opportunity to run graceful clean-up actions.\n\nWhen you register an , .NET calls the and methods of your type during application start and stop respectively. For more details, see IHostedService interface.\n\nAs you can imagine, you can create multiple implementations of IHostedService and register each of them in Program.cs, as shown previously. All those hosted services will be started and stopped along with the application/microservice.\n\nAs a developer, you are responsible for handling the stopping action of your services when method is triggered by the host.\n\nImplementing IHostedService with a custom hosted service class deriving from the BackgroundService base class\n\nYou could go ahead and create your custom hosted service class from scratch and implement the , as you need to do when using .NET Core 2.0 and later.\n\nHowever, since most background tasks will have similar needs in regard to the cancellation tokens management and other typical operations, there is a convenient abstract base class you can derive from, named (available since .NET Core 2.1).\n\nThat class provides the main work needed to set up the background task.\n\nThe next code is the abstract BackgroundService base class as implemented in .NET.\n\nWhen deriving from the previous abstract base class, thanks to that inherited implementation, you just need to implement the method in your own custom hosted service class, as in the following simplified code from eShopOnContainers which is polling a database and publishing integration events into the Event Bus when needed.\n\nIn this specific case for eShopOnContainers, it's executing an application method that's querying a database table looking for orders with a specific state and when applying changes, it is publishing integration events through the event bus (underneath it can be using RabbitMQ or Azure Service Bus).\n\nOf course, you could run any other business background task, instead.\n\nBy default, the cancellation token is set with a 5 seconds timeout, although you can change that value when building your using the extension of the . This means that our service is expected to cancel within 5 seconds otherwise it will be more abruptly killed.\n\nThe following code would be changing that time to 10 seconds.\n\nThe following image shows a visual summary of the classes and interfaces involved when implementing IHostedServices.\n\nFigure 6-27. Class diagram showing the multiple classes and interfaces related to IHostedService\n\nClass diagram: IWebHost and IHost can host many services, which inherit from BackgroundService, which implements IHostedService.\n\nIt is important to note that the way you deploy your ASP.NET Core or .NET might impact the final solution. For instance, if you deploy your on IIS or a regular Azure App Service, your host can be shut down because of app pool recycles. But if you are deploying your host as a container into an orchestrator like Kubernetes, you can control the assured number of live instances of your host. In addition, you could consider other approaches in the cloud especially made for these scenarios, like Azure Functions. Finally, if you need the service to be running all the time and are deploying on a Windows Server you could use a Windows Service.\n\nBut even for a deployed into an app pool, there are scenarios like repopulating or flushing application's in-memory cache that would be still applicable.\n\nThe interface provides a convenient way to start background tasks in an ASP.NET Core web application (in .NET Core 2.0 and later versions) or in any process/host (starting in .NET Core 2.1 with ). Its main benefit is the opportunity you get with the graceful cancellation to clean-up the code of your background tasks when the host itself is shutting down."
    },
    {
        "link": "https://stackoverflow.com/questions/60304112/asp-net-scheduled-task-using-ihostedservice",
        "document": "It's not safe. Take a look at the guide here: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio\n\nIf the app shuts down unexpectedly (for example, the app's process fails), StopAsync might not be called. Therefore, any methods called or operations conducted in StopAsync might not occur.\n\nIt's not the case exactly, but it assumes that the application can be restarted. Same thing goes with application pool which restarts occasionally.\n\nOverall, this will not assure that it will run daily. If the application restarts frequently for whatever reason, it could be that it never runs.\n\nThe same is true with libraries like hangfire.\n\nOther solutions could be web jobs, or you could check if it has executed today by using some kind of persistence like a database that stores the last execution time and the will check every some time and on startup whether or not it should execute the background job and act accordingly."
    },
    {
        "link": "https://medium.com/@iamprovidence/the-good-the-bad-and-the-ugly-ihostedservice-8be82d063584",
        "document": "In today’s fast-paced digital landscape, applications often need to perform tasks in the background without interrupting the main user experience. Whether it’s processing data, performing scheduled jobs, or handling system events, developers require a reliable and efficient mechanism to manage these background tasks seamlessly. This is where the enters the stage.\n\nIn this article, we will dive into the world of background jobs. Explore how simplifies their implementation and execution. You will see why your application may not start because of a long-running task. How to inject a service in your background job. And what is the correct timer to be used within . By the end of this article, you will have a comprehensive guide to building a robust implementation.\n\nIf you are ready, let’s begin.\n\nGive me a reason I wish you would\n\nIt is common for your application to perform processes in the background. While in more advanced cases, to do a time-consuming job, you would go with Hangfire, Quartz, Azure functions, and so on, there is still a place, especially in simple scenarios, where can be applied.\n\nis usually used to solve the next problems:\n• a need to perform periodical background jobs like cache invalidation, email notification, system health monitoring, data synchronization\n• a need to perform one-time action on application startup like data migration, cache warm-up\n• a need to perform ongoing processes like reading messages from a queue\n\nHow to implement it?\n\nIf you found your issue suits any of the cases above, you are good to start implementing it.\n\nWe will start with something simple. Imagine, we want to increase a release number, every time we deploy our application. To do so, we need to implement the interface:\n\nThe implementation itself is quite straightforward:\n\nThe last missing piece is to register our service in the DI container:\n\nIt may seem like is doing some shenanigans under the hood and there is a new lifecycle in the DI container, but in practice, it just registers it as by calling this one:\n\nOf course, you can also manually register your hosted service as and it will work, but has next advantages:\n• it makes sure your service implement interface\n• it makes sure the hosted service will be registered as , so it can not be injected as in other services by mistake\n• it makes sure hosted service implementation will be registered once and only once, even if was called multiple times\n• it is an abstraction level, allowing ASP’s developers to modify the way they manage hosted services, without introducing breaking changes. For example, making it and not as it used to be\n\nI hope it was clear with a simple example. Let’s make it more complicated this time. Imagine, we want to implement a background job, something like reading a message from a queue every 5 seconds.\n\nThe naive implementation will have the next look:\n\nAs soon as you run your application, you will find yourself wondering why nothing happens 🤔 This is a mistake I'm constantly making 😅\n\n⚠️ Notice, your host will discover all implementations of and run one by one. It means, if you have a inside that is running forever, it will block the launch for the rest of the application.\n\nHere is a rewritten code from above, with our new knowledge:\n\nThere are a lot of infrastructure details that distract us from our main logic. With one simple background job, it might not be a problem, but as soon as you have a couple of them, it becomes annoying to copy-paste the same code over and over.\n\nThe solution would be to introduce an abstract class, that will do it. Turned out that such class already exists. It is called :\n\nI have avoided details on how it is implemented, but there are still a few things worth mentioning:\n• it implements and works the same way\n• you only need to implement , but it is still possible to override and\n• is an async method without (fire and forget), because of the same reason described above\n• even though it is running in a fire-and-forget manner, it is still being tracked by the host, meaning exceptions won’t be swallowed and will be bubbled up\n\nLet’s rewrite our service once again, this time inheriting from . Finally, we can use and infinitive loop without worrying it will break our application 😌\n\nHaving such a universal mechanism as , makes forgotten almost in all scenarios. The only reason why you would use , is if you desperately need access to a host’s lifetime.\n\nAnother caveat about you need to know is that there is no simple way to inject a service into it. I mean, there is, but let’s go in the order.\n\nIn our background service, we have method. Let’s say it performs, some business logic. The only reason why we have it there, is only because we were in a rush. However now it is finally time to refactor it and move it to a separate service called :\n\nRemember, is registered as . The code above, will only work if is registered as or .\n\nBut let’s say it is not the case 😊. Most of the services are registered as to maintain their state during request, to build the dependency graph properly or to keep a consistent codebase. Regardless of the reasons, let’s say our is scoped too.\n\nSo, how do you inject service into the ? Correct! There is no way 😁 Surely, I am joking. There is a way. But it is full of pain and regrets. You would have to use :\n\nNow you can inject a service into your background job without changing its lifecycle.\n\nThere are other ways with factories, lazy delegates, and so on. But all those have a common issue. They all prevent the dependency graph from being validated.\n\nDo you remember when I said starts in a fire-and-forget manner, but not exactly? It used to be the case, that exceptions would be forgotten, but not anymore.\n\nNow, if an exception occurs inside your it will stop an application.\n\nTo avoid that, you can override the default configuration in :\n\nNow, it will only stop while the rest of the application will continue running.\n\nHowever, we would not like to stop our job from running because of some stupid exception 😒. That is why it is common to have global there:\n\nNow, if your background task is executed periodically, you don’t have to worry that exceptions can break it or the whole application will go down.\n\nSo far, we have been using as a timer to schedule a job execution. However, I am going to tell you a secret. is not a timer 😁. Surely it isn’t. But on a surface level, it works in most cases.\n\nFor most of us, it does not matter when exactly the job is executed, as long as there is some delay between its execution. While that may be the case for you, it is not necessarily the case for others.\n\nHaving a scheduled job every 5 seconds, I would expect it to be executed at every 5th second, like this 00:00, 00:05, 00:10, 00:15 and so on. That is not the case with . Let’s say it takes approximately from 3 to 6 seconds for our job to finish, so with a 5 seconds delay it will be executed like this 00:00, 00:08, 00:16. I think, you see a problem. It is not deterministic at all! 😒\n\nThe only solution would be to use a :\n\nThere are several problems with timers:\n• there are too many different timers ( , , , , …)\n• the implementation will always vary\n• you have to deal with callbacks\n• you have to deal with\n• you have to deal with\n• you have to deal with potential concurrency issues since Timers don’t wait for the previous job to finish\n• you have to write additional infrastructure code\n\nIf only there were a solution providing the simplicity of and functionality of timers. Turned out, there is! It is called 😃\n\nNow, it will be executed as expected at every 5th second (00:00, 00:05, 00:10, 00:15) regardless of how much time it takes for a job to finish.\n\nThe section with the asterisk. It is not by accident. I don’t think you need to know the information described in this section. Believe me, it won’t ever be useful, and you can skip it 😊 This section is only for those who want to know a bit more than needed.\n\nBy default, ASP starts executing before middlewares are configured. This means that if you have an http call from your background service to your API, it won’t work, since routing is not fully configured yet.\n\nTo change that behavior and start after the application is configured and started, you need to register your service not in but in :\n\nPersonally, I don’t like this approach. You have half of the services registered in and half in the . It is not obvious why it is done this way, so a comment is a must. It can easily be broken. Stinky, so to say 🤢\n\nThe second solution would be to inject and wait until :\n\nHowever, if you are following new trends, you are likely to hear about Minimal API. You don’t have there. Starting from .Net6 by default are executed after middlewares are configured, so this is completely irrelevant.\n\nI told you, this section is useless 😅 But who knows, maybe you have not migrated to the latest version yet 🙃\n\nIf you want more, here are some useful links:\n• Waiting for your ASP.NET Core app to be ready from an IHostedService in .NET 6\n\nBackground tasks and scheduled jobs are something you might need to use in any application. Even though .NET provides an interface named helping you to easily implement background jobs, it is suitable only for one-time actions and requires lots of additional infrastructure code to work. The only reason why it should be used is when you want to have direct access to the Host’s lifecycle.\n\nFor other scenarios, since most background tasks will have similar needs in regard to the cancellation tokens management and other typical operations, there is a convenient abstract base class you can derive from, named . Regardless, being designed as a class with shared logic for background jobs, it still lacks some basic capabilities like services injection, exception handling and recurring execution. As a result, there are still lots of infrastructure code to write before you can begin working with it.\n\nIt works fine for simple scenarios, but for more advanced consider using other robust tools and libraries such as Hangfire, Quartz, Azure function and so on.\n\nI hope you find this article useful. If so, don’t forget to give it a rating in the form of claps 👏 Add a comment when you know some other fancy behavior of 💬 Support me using the link below ☕️ Share it with friends 🗣 Check out my other articles ⬇️ And don’t forget to follow ✅ See you 😉"
    },
    {
        "link": "https://stackoverflow.com/questions/63795334/in-asp-net-core-3-1-how-can-i-schedule-a-background-task-cron-jobs-with-hoste",
        "document": "I am working on a project based on ASP.NET Core 3.1 and I want to add a specific functionality to it to schedule publishing a post in the future in a date and time specified by post author (something like what Wordpress does for scheduled posts through its cron jobs). For example, if we receive this date and time from user :\n\nThen, how can I schedule a background task for it by using hosted services to run only for one time and to change a flag in database and save changes after that?\n\nI've read some articles about it but they didn't specify date and time and just mentioned repeated tasks for every 5 second and stuff like that with cron expressions, but, the thing I need to know is how can I schedule a background task for a specific date and time?\n\nThank you in advance."
    }
]