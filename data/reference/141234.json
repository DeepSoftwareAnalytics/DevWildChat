[
    {
        "link": "https://docs.docker.com/reference/cli/docker/compose/build",
        "document": "Services are built once and then tagged, by default as .\n\nIf the Compose file specifies an image name, the image is tagged with that name, substituting any variables beforehand. See variable interpolation .\n\nIf you change a service's or the contents of its build directory, run to rebuild it."
    },
    {
        "link": "https://docs.docker.com/reference/compose-file/build",
        "document": "Build is an optional part of the Compose Specification. It tells Compose how to (re)build an application from source and lets you define the build process within a Compose file in a portable way. can be either specified as a single string defining a context path, or as a detailed build definition.\n\nIn the former case, the whole path is used as a Docker context to execute a Docker build, looking for a canonical at the root of the directory. The path can be absolute or relative. If it is relative, it is resolved from the directory containing your Compose file. If it is absolute, the path prevents the Compose file from being portable so Compose displays a warning.\n\nIn the latter case, build arguments can be specified, including an alternate location. The path can be absolute or relative. If it is relative, it is resolved from the directory containing your Compose file. If it is absolute, the path prevents the Compose file from being portable so Compose displays a warning.\n\nWhen Compose is confronted with both a subsection for a service and an attribute, it follows the rules defined by the attribute.\n\nIf is missing from the service definition, Compose attempts to pull the image first and then builds from source if the image isn't found in the registry or platform cache.\n\nCompose with support offers an option to push built images to a registry. When doing so, it doesn't try to push service images without an attribute. Compose warns you about the missing attribute which prevents images being pushed.\n\nThe following example illustrates Compose Build Specification concepts with a concrete sample application. The sample is non-normative.\n\nWhen used to build service images from source, the Compose file creates three Docker images:\n• : A Docker image is built using sub-directory, within the Compose file's parent folder, as the Docker build context. Lack of a within this folder throws an error.\n• : A Docker image is built using sub-directory within the Compose file parent folder. file is used to define build steps, this file is searched relative to the context path, which means resolves to the Compose file's parent folder, so is a sibling file.\n• A Docker image is built using the directory with the user's as the Docker context. Compose displays a warning about the non-portable path used to build image.\n\nOn push, both and Docker images are pushed to the default registry. The service image is skipped as no attribute is set and Compose displays a warning about this missing attribute.\n\nThe subsection defines configuration options that are applied by Compose to build Docker images from source. can be specified either as a string containing a path to the build context or as a detailed structure:\n\nUsing the string syntax, only the build context can be configured as either:\n• None A relative path to the Compose file's parent folder. This path must be a directory and must contain a\n• None A Git repository URL. Git URLs accept context configuration in their fragment section, separated by a colon ( ). The first part represents the reference that Git checks out, and can be either a branch, a tag, or a remote reference. The second part represents a subdirectory inside the repository that is used as a build context.\n\nAlternatively can be an object with fields defined as follows:\n\ndefines a list of named contexts the image builder should use during image build.\n\ncan be a mapping or a list:\n\nWhen used as a list, the syntax follows the format, where is a string. Validation beyond that is the responsibility of the image builder (and is builder specific). Compose supports at least absolute and relative paths to a directory and Git repository URLs, like context does. Other context flavours must be prefixed to avoid ambiguity with a prefix.\n\nCompose warns you if the image builder does not support additional contexts and may list the unused contexts.\n\nIllustrative examples of how this is used in Buildx can be found here .\n\ncan also refer to an image built by another service. This allows a service image to be built using another service image as a base image, and to share layers between service images.\n\nUsing the following Dockerfile as an example:\n\ncan be set in the Compose file under the key to define . can be set as a mapping or a list:\n\nValues can be omitted when specifying a build argument, in which case its value at build time must be obtained by user interaction, otherwise the build argument won't be set when building the Docker image.\n\ndefines either a path to a directory containing a Dockerfile, or a URL to a Git repository.\n\nWhen the value supplied is a relative path, it is interpreted as relative to the project directory. Compose warns you about the absolute path used to define the build context as those prevent the Compose file from being portable.\n\nIf not set explicitly, defaults to project directory ( ).\n\ndefines a list of sources the image builder should use for cache resolution.\n\nCache location syntax follows the global format . Simple is actually a shortcut notation for .\n\nCompose Build implementations may support custom types, the Compose Specification defines canonical types which must be supported:\n• to retrieve build cache from an OCI image set by key\n\nUnsupported caches are ignored and don't prevent you from building images.\n\ndefines a list of export locations to be used to share build cache with future builds.\n\nCache target is defined using the same syntax defined by .\n\nUnsupported caches are ignored and don't prevent you from building images.\n\nsets an alternate Dockerfile. A relative path is resolved from the build context. Compose warns you about the absolute path used to define the Dockerfile as it prevents Compose files from being portable.\n\nWhen set, attribute is not allowed and Compose rejects any Compose file having both set.\n\ndefines the Dockerfile content as an inlined string in a Compose file. When set, the attribute is not allowed and Compose rejects any Compose file having both set.\n\nUse of YAML multi-line string syntax is recommended to define the Dockerfile content:\n\ndefines extra privileged entitlements to be allowed during the build.\n\nadds hostname mappings at build-time. Use the same syntax as .\n\nIPv6 addresses can be enclosed in square brackets, for example:\n\nThe separator is preferred, but can also be used. Introduced in Docker Compose version 2.24.1. For example:\n\nCompose creates matching entry with the IP address and hostname in the container's network configuration, which means for Linux will get extra lines:\n\nadd metadata to the resulting image. can be set either as an array or a map.\n\nIt's recommended that you use reverse-DNS notation to prevent your labels from conflicting with other software.\n\nSet the network containers connect to for the instructions during build.\n\nUse to disable networking during build:\n\ndisables image builder cache and enforces a full rebuild from source for all image layers. This only applies to layers declared in the Dockerfile, referenced images can be retrieved from local image store whenever tag has been updated on registry (see pull).\n\nWhen the attribute is omitted, Compose includes the service's platform in the list of the default build target platforms.\n\nWhen the attribute is defined, Compose includes the service's platform, otherwise users won't be able to run images they built.\n\nComposes reports an error in the following cases:\n• None When the list contains multiple platforms but the implementation is incapable of storing multi-platform images.\n• None When the list contains an unsupported platform.\n• None When the list is non-empty and does not contain the service's platform.\n\nconfigures the service image to build with elevated privileges. Support and actual impacts are platform specific.\n\nrequires the image builder to pull referenced images ( Dockerfile directive), even if those are already available in the local image store.\n\ngrants access to sensitive data defined by secrets on a per-service build basis. Two different syntax variants are supported: the short syntax and the long syntax.\n\nCompose reports an error if the secret isn't defined in the section of this Compose file.\n\nThe short syntax variant only specifies the secret name. This grants the container access to the secret and mounts it as read-only to within the container. The source name and destination mountpoint are both set to the secret name.\n\nThe following example uses the short syntax to grant the build of the service access to the secret. The value of is set to the contents of the file .\n\nThe long syntax provides more granularity in how the secret is created within the service's containers.\n• : The name of the secret as it exists on the platform.\n• : The name of the file to be mounted in in the service's task containers. Defaults to if not specified.\n• and : The numeric uid or gid that owns the file within in the service's task containers. Default value is .\n• : The permissions for the file to be mounted in in the service's task containers, in octal notation. Default value is world-readable permissions (mode ). The writable bit must be ignored if set. The executable bit may be set.\n\nThe following example sets the name of the secret file to within the container, sets the mode to (group-readable) and sets the user and group to . The value of secret is provided by the platform through a lookup and the secret lifecycle not directly managed by Compose.\n\nService builds may be granted access to multiple secrets. Long and short syntax for secrets may be used in the same Compose file. Defining a secret in the top-level must not imply granting any service build access to it. Such grant must be explicit within service specification as secrets service element.\n\ndefines SSH authentications that the image builder should use during image build (e.g., cloning private repository).\n\nproperty syntax can be either:\n• : Let the builder connect to the SSH-agent.\n• : A key/value definition of an ID and the associated path. It can be either a PEM file, or path to ssh-agent socket.\n\nUsing a custom id with path to a local SSH key:\n\nThe image builder can then rely on this to mount the SSH key during build.\n\nFor illustration, SSH mounts can be used to mount the SSH key set by ID and access a secured resource:\n\nsets the size of the shared memory ( partition on Linux) allocated for building Docker images. Specify as an integer value representing the number of bytes or as a string expressing a byte value.\n\ndefines a list of tag mappings that must be associated to the build image. This list comes in addition to the property defined in the service section\n\ndefines the stage to build as defined inside a multi-stage .\n\noverrides the default for a container. It's specified either as an integer for a single limit or as mapping for soft/hard limits."
    },
    {
        "link": "https://docs.docker.com/compose",
        "document": "Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience.\n\nCompose simplifies the control of your entire application stack, making it easy to manage services, networks, and volumes in a single, comprehensible YAML configuration file. Then, with a single command, you create and start all the services from your configuration file.\n\nCompose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:"
    },
    {
        "link": "https://docs.docker.com/reference/cli/docker/compose",
        "document": "Use to specify the name and path of one or more Compose files\n\nUse the flag to specify the location of a Compose configuration file.\n\nYou can supply multiple configuration files. When you supply multiple files, Compose combines them into a single configuration. Compose builds the configuration in the order you supply the files. Subsequent files override and add to their predecessors.\n\nFor example, consider this command line:\n\nThe file might specify a service.\n\nIf the also specifies this same service, any matching fields override the previous file. New values, add to the service configuration.\n\nWhen you use multiple Compose files, all paths in the files are relative to the first configuration file specified with . You can use the option to override this base path.\n\nUse a with (dash) as the filename to read the configuration from stdin. When stdin is used all paths in the configuration are relative to the current working directory.\n\nThe flag is optional. If you don’t provide this flag on the command line, Compose traverses the working directory and its parent directories looking for a or file.\n\nYou can use the flag to specify a path to a Compose file that is not located in the current directory, either from the command line or by setting up a environment variable in your shell or in an environment file.\n\nFor an example of using the option at the command line, suppose you are running the Compose Rails sample, and have a file in a directory called . You can use a command like to get the postgres image for the db service from anywhere by using the flag as follows:\n\nUse to specify a project name\n\nEach configuration has a project name. Compose sets the project name using the following mechanisms, in order of precedence:\n• The top level variable from the config file (or the last from a series of config files specified using )\n• The of the project directory containing the config file (or containing the first config file specified using )\n• The of the current directory if no config file is specified Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit. If the of the project directory or current directory violates this constraint, you must use one of the other mechanisms.\n\nUse to specify one or more active profiles Calling starts the services with the profile and services without any specified profiles. You can also enable multiple profiles, e.g. with the profiles and is enabled.\n\nProfiles can also be set by environment variable.\n\nUse to specify the maximum level of parallelism for concurrent engine calls. Calling pulls the pullable images defined in the Compose file one at a time. This can also be used to control build concurrency.\n\nParallelism can also be set by the environment variable.\n\nYou can set environment variables for various docker compose options, including the , and flags.\n\nSetting the environment variable is equivalent to passing the flag, environment variable does the same as the flag, environment variable is equivalent to the flag and does the same as the flag.\n\nIf flags are explicitly set on the command line, the associated environment variable is ignored.\n\nSetting the environment variable to stops docker compose from detecting orphaned containers for the project.\n\nSetting the environment variable to disables the helper menu when running in attached mode. Alternatively, you can also run to disable the helper menu.\n\nUse Dry Run mode to test your command\n\nUse flag to test a command without changing your application stack state. Dry Run mode shows you all the steps Compose applies when executing a command, for example:\n\nFrom the example above, you can see that the first step is to pull the image defined by service, then build the service. Next, the containers are created. The service is started, and the and wait until the service is healthy before starting.\n\nDry Run mode works with almost all commands. You cannot use Dry Run mode with a command that doesn't change the state of a Compose stack such as , , for example."
    },
    {
        "link": "https://docs.docker.com/reference/compose-file",
        "document": "The Compose Specification is the latest and recommended version of the Compose file format. It helps you define a Compose file which is used to configure your Docker application’s services, networks, volumes, and more.\n\nLegacy versions 2.x and 3.x of the Compose file format were merged into the Compose Specification. It is implemented in versions 1.27.0 and above (also known as Compose V2) of the Docker Compose CLI.\n\nThe Compose Specification on Docker Docs is the Docker Compose implementation. If you wish to implement your own version of the Compose Specification, see the Compose Specification repository .\n\nUse the following links to navigate key sections of the Compose Specification."
    },
    {
        "link": "https://stackoverflow.com/questions/22049212/copying-files-from-docker-container-to-host",
        "document": "To achieve this I would need to copy the build artifacts that are built inside the container back into the host. Is that possible?\n\nI'm thinking of using Docker to build my dependencies on a Continuous Integration (CI) server, so that I don't have to install all the runtimes and libraries on the agents themselves.\n\nThe community is reviewing whether to reopen this question as of 6 days ago.\n\nThis question does not appear to be about a specific programming problem, a software algorithm, or software tools primarily used by programmers . If you believe the question would be on-topic on another Stack Exchange site , you can leave a comment to explain where the question may be able to be answered.\n\nThis question is not about programming or software development . It is not currently accepting answers.\n\nIn order to copy a file from a container to the host, you can use the command Here goofy_roentgen is the container name I got from the following command: You can also use (part of) the Container ID. The following command is equivalent to the first\n\nMount a \"volume\" and copy the artifacts into there: mkdir artifacts docker run -i -v ${PWD}/artifacts:/artifacts ubuntu:14.04 sh << COMMANDS # ... build software here ... cp <artifact> /artifacts # ... copy more artifacts into `/artifacts` ... COMMANDS Then when the build finishes and the container is no longer running, it has already copied the artifacts from the build into the directory on the host. Caveat: When you do this, you may run into problems with the user id of the docker user matching the user id of the current running user. That is, the files in will be shown as owned by the user with the UID of the user used inside the docker container. A way around this may be to use the calling user's UID: docker run -i -v ${PWD}:/working_dir -w /working_dir -u $(id -u) \\ ubuntu:14.04 sh << COMMANDS # Since $(id -u) owns /working_dir, you should be okay running commands here # and having them work. Then copy stuff into /working_dir/artifacts . COMMANDS\n\nWith the release of Docker 19.03, you can skip creating the container and even building an image. There's an option with BuildKit based builds to change the output destination. You can use this to write the results of the build to your local directory rather than into an image. E.g. here's a build of a go binary: $ ls Dockerfile go.mod main.go $ cat Dockerfile FROM golang:1.12-alpine as dev RUN apk add --no-cache git ca-certificates RUN adduser -D appuser WORKDIR /src COPY . /src/ CMD CGO_ENABLED=0 go build -o app . && ./app FROM dev as build RUN CGO_ENABLED=0 go build -o app . USER appuser CMD [ \"./app\" ] FROM scratch as release COPY --from=build /etc/passwd /etc/group /etc/ COPY --from=build /src/app /app USER appuser CMD [ \"/app\" ] FROM scratch as artifact COPY --from=build /src/app /app FROM release From the above Dockerfile, I'm building the stage that only includes the files I want to export. And the newly introduced flag lets me write those to a local directory instead of an image. This needs to be performed with the BuildKit engine that ships with 19.03: $ DOCKER_BUILDKIT=1 docker build --target artifact --output type=local,dest=. . [+] Building 43.5s (12/12) FINISHED => [internal] load build definition from Dockerfile 0.7s => => transferring dockerfile: 572B 0.0s => [internal] load .dockerignore 0.5s => => transferring context: 2B 0.0s => [internal] load metadata for docker.io/library/golang:1.12-alpine 0.9s => [dev 1/5] FROM docker.io/library/golang:1.12-alpine@sha256:50deab916cce57a792cd88af3479d127a9ec571692a1a9c22109532c0d0499a0 22.5s => => resolve docker.io/library/golang:1.12-alpine@sha256:50deab916cce57a792cd88af3479d127a9ec571692a1a9c22109532c0d0499a0 0.0s => => sha256:1ec62c064901392a6722bb47a377c01a381f4482b1ce094b6d28682b6b6279fd 155B / 155B 0.3s => => sha256:50deab916cce57a792cd88af3479d127a9ec571692a1a9c22109532c0d0499a0 1.65kB / 1.65kB 0.0s => => sha256:2ecd820bec717ec5a8cdc2a1ae04887ed9b46c996f515abc481cac43a12628da 1.36kB / 1.36kB 0.0s => => sha256:6a17089e5a3afc489e5b6c118cd46eda66b2d5361f309d8d4b0dcac268a47b13 3.81kB / 3.81kB 0.0s => => sha256:89d9c30c1d48bac627e5c6cb0d1ed1eec28e7dbdfbcc04712e4c79c0f83faf17 2.79MB / 2.79MB 0.6s => => sha256:8ef94372a977c02d425f12c8cbda5416e372b7a869a6c2b20342c589dba3eae5 301.72kB / 301.72kB 0.4s => => sha256:025f14a3d97f92c07a07446e7ea8933b86068d00da9e252cf3277e9347b6fe69 125.33MB / 125.33MB 13.7s => => sha256:7047deb9704134ff71c99791be3f6474bb45bc3971dde9257ef9186d7cb156db 125B / 125B 0.8s => => extracting sha256:89d9c30c1d48bac627e5c6cb0d1ed1eec28e7dbdfbcc04712e4c79c0f83faf17 0.2s => => extracting sha256:8ef94372a977c02d425f12c8cbda5416e372b7a869a6c2b20342c589dba3eae5 0.1s => => extracting sha256:1ec62c064901392a6722bb47a377c01a381f4482b1ce094b6d28682b6b6279fd 0.0s => => extracting sha256:025f14a3d97f92c07a07446e7ea8933b86068d00da9e252cf3277e9347b6fe69 5.2s => => extracting sha256:7047deb9704134ff71c99791be3f6474bb45bc3971dde9257ef9186d7cb156db 0.0s => [internal] load build context 0.3s => => transferring context: 2.11kB 0.0s => [dev 2/5] RUN apk add --no-cache git ca-certificates 3.8s => [dev 3/5] RUN adduser -D appuser 1.7s => [dev 4/5] WORKDIR /src 0.5s => [dev 5/5] COPY . /src/ 0.4s => [build 1/1] RUN CGO_ENABLED=0 go build -o app . 11.6s => [artifact 1/1] COPY --from=build /src/app /app 0.5s => exporting to client 0.1s => => copying files 10.00MB 0.1s After the build was complete the binary was exported: Docker has other options to the flag documented in their upstream BuildKit repo: https://github.com/moby/buildkit#output\n\nThis can also be done in the SDK for example python. If you already have a container built you can lookup the name via console ( ) name seems to be some concatenation of a scientist and an adjective (i.e. \"relaxed_pasteur\"). Help on method get_archive in module docker.models.containers: get_archive(path, chunk_size=2097152) method of docker.models.containers.Container instance Retrieve a file or folder from the container in the form of a tar archive. Args: path (str): Path to the file or folder to retrieve chunk_size (int): The number of bytes returned by each iteration of the generator. If ``None``, data will be streamed as it is received. Default: 2 MB Returns: (tuple): First element is a raw tar data stream. Second element is a dict containing ``stat`` information on the specified ``path``. Raises: :py:class:`docker.errors.APIError` If the server returns an error. Example: >>> f = open('./sh_bin.tar', 'wb') >>> bits, stat = container.get_archive('/bin/sh') >>> print(stat) {'name': 'sh', 'size': 1075464, 'mode': 493, 'mtime': '2018-10-01T15:37:48-07:00', 'linkTarget': ''} >>> for chunk in bits: ... f.write(chunk) >>> f.close() So then something like this will pull out from the specified path ( /output) in the container to your host machine and unpack the tar. import docker import os import tarfile # Docker client client = docker.from_env() #container object container = client.containers.get(\"relaxed_pasteur\") #setup tar to write bits to f = open(os.path.join(os.getcwd(),\"output.tar\"),\"wb\") #get the bits bits, stat = container.get_archive('/output') #write the bits for chunk in bits: f.write(chunk) f.close() #unpack tar = tarfile.open(\"output.tar\") tar.extractall() tar.close()"
    },
    {
        "link": "https://docs.docker.com/reference/cli/docker/container/cp",
        "document": "The utility copies the contents of to the . You can copy from the container's file system to the local machine or the reverse, from the local filesystem to the container. If is specified for either the or , you can also stream a tar archive from or to . The can be a running or stopped container. The or can be a file or directory.\n\nThe command assumes container paths are relative to the container's (root) directory. This means supplying the initial forward slash is optional; The command sees and as identical. Local machine paths can be an absolute or relative value. The command interprets a local machine's relative paths as relative to the current working directory where is run.\n\nThe command behaves like the Unix command in that directories are copied recursively with permissions preserved if possible. Ownership is set to the user and primary group at the destination. For example, files copied to a container are created with of the root user. Files copied to the local machine are created with the of the user which invoked the command. However, if you specify the option, sets the ownership to the user and primary group at the source. If you specify the option, follows any symbolic link in the . doesn't create parent directories for if they don't exist.\n\nAssuming a path separator of , a first argument of and second argument of , the behavior is as follows:\n• specifies a file\n• does not exist\n• the file is saved to a file created at\n• does not exist and ends with\n• exists and is a file\n• the destination is overwritten with the source file's contents\n• exists and is a directory\n• the file is copied into this directory using the basename from\n• specifies a directory\n• does not exist\n• is created as a directory and the contents of the source directory are copied into this directory\n• exists and is a directory\n• does not end with (that is: slash followed by dot)\n• the source directory is copied into this directory\n• does end with (that is: slash followed by dot)\n• the content of the source directory is copied into this directory\n\nThe command requires and to exist according to the above rules. If is local and is a symbolic link, the symbolic link, not the target, is copied by default. To copy the link target and not the link, specify the option.\n\nA colon ( ) is used as a delimiter between and its path. You can also use when specifying paths to a or on a local machine, for example . If you use a in a local machine path, you must be explicit with a relative or absolute path, for example:\n\nIt isn't possible to copy certain system files such as resources under , , , tmpfs, and mounts created by the user in the container. However, you can still copy such files by manually running in . Both of the following examples do the same thing in different ways (consider and are directories):\n\nUsing as the streams the contents of as a tar archive. The command extracts the content of the tar to the in container's filesystem. In this case, must specify a directory. Using as the streams the contents of the resource as a tar archive to ."
    },
    {
        "link": "https://stackoverflow.com/questions/39176561/copying-files-to-a-container-with-docker-compose",
        "document": "Preface: I realize this question is quite old and that the OP may have found a workaround but because I do not see an accurate answer, I felt it appropriate to address the questions posed by the OP as well as any related issues.\n\nFirst, clarifying the distinction between named volumes and bind mounts. The former will allow you to see, from outside the container, files that already exist in the container location whereas the latter will not. In essence, bind mounts operate very much like when mounting a volume in xNIX meaning that any files already in the mount location will be masked after a device is mounted - think of it as an overlay.\n\nNext, when you specify , you are specifying a bind mount which is why when you look in on the host-side, all of the files you expect to see are gone. If I understand your end-goal correctly, you want to have the files in within the container be accessible via the exact same location outside of the container. If so, then you probably want to use a named volume along with a user-specified mount point as follows:\n\nBe aware that without the listed above, the named volume will still exist but the host-side location will be in the Docker area. This is typically something like or similar. The exact location can be found in the section of the command.\n\nHere is a similar setup on my PiHole lab host."
    },
    {
        "link": "https://forums.docker.com/t/copying-files-to-host-from-docker-script-during-build/136007",
        "document": ""
    },
    {
        "link": "https://warp.dev/terminus/docker-copy-file-from-container-to-host",
        "document": "Using docker cp to copy files to the local host\n\nTo copy a file from a container to your local host, you can specify the destination directory using either its relative or absolute path:\n\nAlternatively, you can copy and rename at the same time, by providing the full destination path:\n\nNote that it is not possible to copy multiple files at once using the docker cp command, unless you copy the entire directory that contains them (if located in the same directory).\n\nWhen copying a directory, the docker cp command will behave like the Unix cp -a command, which means that the directory will be copied recursively with permission preserved if possible.\n\nCopying absolute and relative paths, such as a parent directory\n\nThe docker cp assumes container paths are relative to the container's root directory (i.e. /). A source path can therefore be written with or without the initial forward slash, as docker cp will see these two commands as identical:\n\nDestination paths on the other hand, can be written either in their relative form:\n\nOr in their absolute form:\n\nYou can learn more about the docker cp command in the official Docker documentation and in our article on how to copy files and directories to a running Docker container."
    }
]