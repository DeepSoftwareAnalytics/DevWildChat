[
    {
        "link": "https://dev.mysql.com/doc/en/select.html",
        "document": "is used to retrieve rows selected from one or more tables, and can include operations and subqueries. and operations are also supported. The , , and operators are described in more detail later in this section. See also Section 15.2.15, “Subqueries”.\n\nA statement can start with a clause to define common table expressions accessible within the . See Section 15.2.20, “WITH (Common Table Expressions)”.\n\nThe most commonly used clauses of statements are these:\n\ncan also be used to retrieve rows computed without reference to any table.\n\nYou are permitted to specify as a dummy table name in situations where no tables are referenced:\n\nis purely for the convenience of people who require that all statements should have and possibly other clauses. MySQL may ignore the clauses. MySQL does not require if no tables are referenced.\n\nIn general, clauses used must be given in exactly the order shown in the syntax description. For example, a clause must come after any clause and before any clause. The clause, if present, can appear in any position indicated by the syntax description, but within a given statement can appear only once, not in multiple positions. For more information about , see Section 15.2.13.1, “SELECT ... INTO Statement”.\n\nThe list of terms comprises the select list that indicates which columns to retrieve. Terms specify a column or expression or can use -shorthand:\n\nThe following list provides additional information about other clauses:\n• None A can be given an alias using . The alias is used as the expression's column name and can be used in , , or clauses. For example: SELECT CONCAT(last_name,', ',first_name) AS full_name FROM mytable ORDER BY full_name; The keyword is optional when aliasing a with an identifier. The preceding example could have been written like this: However, because the is optional, a subtle problem can occur if you forget the comma between two expressions: MySQL interprets the second as an alias name. For example, in the following statement, is treated as an alias name: For this reason, it is good practice to be in the habit of using explicitly when specifying column aliases. It is not permissible to refer to a column alias in a clause, because the column value might not yet be determined when the clause is executed. See Section B.3.4.4, “Problems with Column Aliases”.\n• None The clause indicates the table or tables from which to retrieve rows. If you name more than one table, you are performing a join. For information on join syntax, see Section 15.2.13.2, “JOIN Clause”. For each table specified, you can optionally specify an alias. The use of index hints provides the optimizer with information about how to choose indexes during query processing. For a description of the syntax for specifying these hints, see Section 10.9.4, “Index Hints”. You can use as an alternative way to force MySQL to prefer key scans instead of table scans. See Section 7.1.8, “Server System Variables”.\n• None You can refer to a table within the default database as , or as . to specify a database explicitly. You can refer to a column as , . , or . . . You need not specify a or . prefix for a column reference unless the reference would be ambiguous. See Section 11.2.2, “Identifier Qualifiers”, for examples of ambiguity that require the more explicit column reference forms.\n• None A table reference can be aliased using or . These statements are equivalent: SELECT t1.name, t2.salary FROM employee AS t1, info AS t2 WHERE t1.name = t2.name; SELECT t1.name, t2.salary FROM employee t1, info t2 WHERE t1.name = t2.name;\n• None Columns selected for output can be referred to in and clauses using column names, column aliases, or column positions. Column positions are integers and begin with 1: SELECT college, region, seed FROM tournament ORDER BY region, seed; SELECT college, region AS r, seed AS s FROM tournament ORDER BY r, s; SELECT college, region, seed FROM tournament ORDER BY 2, 3; To sort in reverse order, add the (descending) keyword to the name of the column in the clause that you are sorting by. The default is ascending order; this can be specified explicitly using the keyword. If occurs within a parenthesized query expression and also is applied in the outer query, the results are undefined and may change in a future version of MySQL. Use of column positions is deprecated because the syntax has been removed from the SQL standard.\n• None When you use or to sort a column in a , the server sorts values using only the initial number of bytes indicated by the system variable.\n• None MySQL extends the use of to permit selecting fields that are not mentioned in the clause. If you are not getting the results that you expect from your query, please read the description of found in Section 14.19, “Aggregate Functions”.\n• None The clause, like the clause, specifies selection conditions. The clause specifies conditions on columns in the select list, but cannot refer to aggregate functions. The clause specifies conditions on groups, typically formed by the clause. The query result includes only groups satisfying the conditions. (If no is present, all rows implicitly form a single aggregate group.) The clause is applied nearly last, just before items are sent to the client, with no optimization. ( is applied after .) The SQL standard requires that must reference only columns in the clause or columns used in aggregate functions. However, MySQL supports an extension to this behavior, and permits to refer to columns in the list and columns in outer subqueries as well. If the clause refers to a column that is ambiguous, a warning occurs. In the following statement, is ambiguous because it is used as both an alias and a column name: SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2; Preference is given to standard SQL behavior, so if a column name is used both in and as an aliased column in the select column list, preference is given to the column in the column.\n• None Do not use for items that should be in the clause. For example, do not write the following:\n• None The clause can refer to aggregate functions, which the clause cannot: SELECT user, MAX(salary) FROM users GROUP BY user HAVING MAX(salary) > 10;\n• None MySQL permits duplicate column names. That is, there can be more than one with the same name. This is an extension to standard SQL. Because MySQL also permits and to refer to values, this can result in an ambiguity: SELECT 12 AS a, a FROM t GROUP BY a; In that statement, both columns have the name . To ensure that the correct column is used for grouping, use different names for each .\n• None The clause, if present, defines named windows that can be referred to by window functions. For details, see Section 14.20.4, “Named Windows”.\n• None MySQL resolves unqualified column or alias references in clauses by searching in the values, then in the columns of the tables in the clause. For or clauses, it searches the clause before searching in the values. (For and , this differs from the pre-MySQL 5.0 behavior that used the same rules as for .)\n• None The clause can be used to constrain the number of rows returned by the statement. takes one or two numeric arguments, which must both be nonnegative integer constants, with these exceptions:\n• None Within prepared statements, parameters can be specified using placeholder markers.\n• None Within stored programs, parameters can be specified using integer-valued routine parameters or local variables. With two arguments, the first argument specifies the offset of the first row to return, and the second specifies the maximum number of rows to return. The offset of the initial row is 0 (not 1): To retrieve all rows from a certain offset up to the end of the result set, you can use some large number for the second parameter. This statement retrieves all rows from the 96th row to the last: With one argument, the value specifies the number of rows to return from the beginning of the result set: In other words, is equivalent to . For prepared statements, you can use placeholders. The following statements return one row from the table: SET @a=1; PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?'; EXECUTE STMT USING @a; The following statements return the second to sixth rows from the table: SET @skip=1; SET @numrows=5; PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?'; EXECUTE STMT USING @skip, @numrows; For compatibility with PostgreSQL, MySQL also supports the syntax. If occurs within a parenthesized query expression and also is applied in the outer query, the results are undefined and may change in a future version of MySQL.\n• None The form of enables the query result to be written to a file or stored in variables. For more information, see Section 15.2.13.1, “SELECT ... INTO Statement”.\n• None If you use with a storage engine that uses page or row locks, rows examined by the query are write-locked until the end of the current transaction. You cannot use as part of the in a statement such as . (If you attempt to do so, the statement is rejected with the error Can't update table ' ' while ' ' is being created.) and set shared locks that permit other transactions to read the examined rows but not to update or delete them. and are equivalent. However, , like , supports , , and options. is a replacement for , but remains available for backward compatibility. causes a or query to execute immediately, returning an error if a row lock cannot be obtained due to a lock held by another transaction. causes a or query to execute immediately, excluding rows from the result set that are locked by another transaction. and options are unsafe for statement-based replication. Queries that skip locked rows return an inconsistent view of the data. is therefore not suitable for general transactional work. However, it may be used to avoid lock contention when multiple sessions access the same queue-like table. applies and queries to named tables. For example: SELECT * FROM t1, t2 FOR SHARE OF t1 FOR UPDATE OF t2; All tables referenced by the query block are locked when is omitted. Consequently, using a locking clause without in combination with another locking clause returns an error. Specifying the same table in multiple locking clauses returns an error. If an alias is specified as the table name in the statement, a locking clause may only use the alias. If the statement does not specify an alias explicitly, the locking clause may only specify the actual table name. For more information about and , see Section 17.7.2.4, “Locking Reads”. For additional information about and options, see Locking Read Concurrency with NOWAIT and SKIP LOCKED.\n\nFollowing the keyword, you can use a number of modifiers that affect the operation of the statement. , , and modifiers beginning with are MySQL extensions to standard SQL.\n• None The and modifiers specify whether duplicate rows should be returned. (the default) specifies that all matching rows should be returned, including duplicates. specifies removal of duplicate rows from the result set. It is an error to specify both modifiers. is a synonym for . can be used with a query that also uses .\n• None gives the higher priority than a statement that updates a table. You should use this only for queries that are very fast and must be done at once. A query that is issued while the table is locked for reading runs even if there is an update statement waiting for the table to be free. This affects only storage engines that use only table-level locking (such as , , and ). cannot be used with statements that are part of a .\n• None forces the optimizer to join the tables in the order in which they are listed in the clause. You can use this to speed up a query if the optimizer joins the tables in nonoptimal order. also can be used in the list. See Section 15.2.13.2, “JOIN Clause”. does not apply to any table that the optimizer treats as a or table. Such a table produces a single row, is read during the optimization phase of query execution, and references to its columns are replaced with the appropriate column values before query execution proceeds. These tables appear first in the query plan displayed by . See Section 10.8.1, “Optimizing Queries with EXPLAIN”. This exception may not apply to or tables that are used on the -complemented side of an outer join (that is, the right-side table of a or the left-side table of a .\n• None or can be used with or to tell the optimizer that the result set has many rows or is small, respectively. For , MySQL directly uses disk-based temporary tables if they are created, and prefers sorting to using a temporary table with a key on the elements. For , MySQL uses in-memory temporary tables to store the resulting table instead of using sorting. This should not normally be needed.\n• None forces the result to be put into a temporary table. This helps MySQL free the table locks early and helps in cases where it takes a long time to send the result set to the client. This modifier can be used only for top-level statements, not for subqueries or following .\n• None tells MySQL to calculate how many rows there would be in the result set, disregarding any clause. The number of rows can then be retrieved with . See Section 14.15, “Information Functions”. The query modifier and accompanying function are deprecated; expect them to be removed in a future version of MySQL. See the description of for information about an alternative strategy.\n• None The and modifiers were used with the query cache prior to MySQL 8.4. The query cache was removed in MySQL 8.4. The modifier was removed as well. is deprecated, and has no effect; expect it to be removed in a future MySQL release."
    },
    {
        "link": "https://dev.mysql.com/doc/en/functions.html",
        "document": "Expressions can be used at several points in SQL statements, such as in the or clauses of statements, in the clause of a , , or statement, or in statements. Expressions can be written using values from several sources, such as literal values, column values, , variables, built-in functions and operators, loadable functions, and stored functions (a type of stored object).\n\nThis chapter describes the built-in functions and operators that are permitted for writing expressions in MySQL. For information about loadable functions and stored functions, see Section 7.7, “MySQL Server Loadable Functions”, and Section 27.2, “Using Stored Routines”. For the rules describing how the server interprets references to different kinds of functions, see Section 11.2.5, “Function Name Parsing and Resolution”.\n\nAn expression that contains always produces a value unless otherwise indicated in the documentation for a particular function or operator.\n\nBy default, there must be no whitespace between a function name and the parenthesis following it. This helps the MySQL parser distinguish between function calls and references to tables or columns that happen to have the same name as a function. However, spaces around function arguments are permitted. To tell the MySQL server to accept spaces after function names by starting it with the option. (See Section 7.1.11, “Server SQL Modes”.) Individual client programs can request this behavior by using the option for . In either case, all function names become reserved words.\n\nFor the sake of brevity, some examples in this chapter display the output from the mysql program in abbreviated form. Rather than showing examples in this format:\n\nThis format is used instead:"
    },
    {
        "link": "https://dev.mysql.com/doc",
        "document": "X DevAPI\n\n API for MySQL Shell and Connectors supporting the X Protocol"
    },
    {
        "link": "https://downloads.mysql.com/docs/refman-8.0-en.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/1135245/how-can-i-get-a-list-of-user-accounts-using-the-command-line-in-mysql",
        "document": "Peter and Jesse are correct, but just make sure you first select the \"mysql\" database.\n\nThat should do your trick."
    },
    {
        "link": "https://prisma.io/dataguide/mysql/authentication-and-authorization/intro-to-authn-and-authz",
        "document": "Authentication and authorization are essential considerations for managing and securing your MySQL servers. Authentication (sometimes abbreviated as \"authn\") refers to the class of policies and mechanisms that verify that clients are allowed to connect as a certain user. Authorization (sometimes abbreviated as \"authz\") is a process that occurs after authentication to determine what actions an account is permitted to perform. In this guide, we'll take a look at the concepts and components that MySQL provides to manage this access control system. We'll talk about the interplay between users, roles, authentication methods, and privileges that, together, solve the problem of how to control who can do what on MySQL database servers.\n\nHow does MySQL configure authentication and authorization? MySQL manages its authentication and authorization requirements through quite a few different related systems. Broadly speaking, its component parts are:\n• Users: Users are individual accounts configured on a MySQL server that function as an identity. These identities can be coupled with authentication methods to allow clients to connect with the user and can be given privileges to allow them to access and control different database objects at various levels of granularity. Users in MySQL consist of a name and a that the user is connecting from. The same name connecting from a different is considered a different user.\n• Authentication methods: Authentication methods are ways of determining whether a connecting client should be allowed to use a specific user account. The methods often involve accepting and validating a password from the client, but other methods of authentication are also available.\n• Privileges: A user's capabilities and level of access are defined by the privileges granted to them directly, through role membership, or through object ownership. These are defined at a variety of scopes and are checked against each action the user attempts.\n• Roles: Practically speaking, roles are sets of privileges that can be applied to users. Adding related groups of privileges to roles and then assigning those privileges via role membership can simplify privilege management. The actual access control process is divided into two distinct parts. First, the client authenticates to the server as a specific user. Afterwards, every action is checked against the user's authorized privileges to determine whether to allow or deny each request.\n\nThe first stage in MySQL's access control system is to authenticate the connection. MySQL decides whether to accept a connection request based on the following factors:\n• Whether you can correctly authenticate as the user account you are requesting\n• Whether that user account is locked within the system If the user you are connecting with is unlocked, and if you're able to correctly authenticate, MySQL accepts the connection and allows you to proceed to part 2 of the access control system. If the user is marked as locked, if your authentication attempt fails, or if the user you provided is not valid, MySQL will reject the connection request. Columns related to authentication in the table To perform these functions, MySQL consults the following columns within the table within its internal database: The username that the client is connecting as helps MySQL to determine how to authenticate the user. When combined with the field below, it forms a complete, unique identity within MySQL. In the table, a blank value will match any user provided by the client. However, when this occurs, the client is considered an anonymous user for the duration of the session. This has implications in the second stage of access control, where the server will check actions against an anonymous user instead of the user that the client provided. The host that the client is connecting from is considered a key part of the user's identity. In MySQL, unique identities are formed from the combination of a user's name and the host they connect from. So from is considered distinct from from . The field and the field together tell MySQL which account to try to authenticate to. Once MySQL uses the and to determine the right record to retrieve for the connection request, it uses the field to decide how to authenticate the client. The field for a user defines the authentication method that should be used to validate the user's credentials. The default plugin, , will check the user's password against a hashed version of the password stored within the table. For \"native\" authentication plugins (those that authenticate users using only information within the table) the column contains the string to check the user's password against. Most of the time, this is a hashed version of the password. If the for a native plugin is blank in the table, the client must not specify a password in order to successfully authenticate. For plugins that use external systems for authentication, the is often used to specify additional information needed by the external system to correctly authenticate the user (like a service name, additional identifying information, etc.). This column determines if this specific user account is locked within the system. Accounts can be locked manually by database administrators. The account must be unlocked to proceed. Determining the priority of rows in the table MySQL uses the five fields above to determine whether to accept the connection. However, there are some cases where multiple entries would match a client's connection. For instance, it's possible for a client to not provide a host or for the table to contain a row without a user. MySQL needs a way to establish the priority of these rows to determine how to authenticate the client. To do this, MySQL reads the rows from the table into its memory when the server starts up or when it's given the signal to reload its information from disk. While it reads the rows, it also sorts them by specificity so that the rows in the table are ordered from most specific to least specific. First, MySQL sorts the rows based on the specificity of the column. Rows with a consisting of a full domain name or IP address are sorted to the top of the pile, followed by those using wildcards in the field (putting rows that contain only , the match-all wildcard, at the end as the least specific entries), and finally followed by rows with a blank . MySQL uses the column as a secondary sort field. This means that if two rows have the same specificity, the one with a more specific entry will be prioritized. Wildcards are not permitted in the field. The field consists of either:\n• a string that must exactly match the provided username, or\n• a blank field, which will match any username provided by the client, but will proceed with the session as an anonymous user MySQL will only authenticate a client connection using a maximum of one row from the table. This means that if authentication fails or if the wrong row matches, it will not check for alternatives that might authenticate correctly. To determine the row to use to authenticate a client connection request, MySQL starts at the top of the sorted list. It checks each row sequentially and uses the first row it finds that matches the client connection. This can have some surprising implications if you don't pay attention to the sort order described above. For instance, a row that contains a value but no will always be selected in preference to a row with a value and no . Understanding this sorting system will help you avoid an entire class of authentication problems. If you have trouble authenticating with a certain user, check to see that there's not a more specific entry that matches. If you can connect, but you can't perform the actions you think you should be able to, verify that MySQL is allowing you access as your requested username instead of as an anonymous user, which can happen as described above. This command will print out the user you are currently authenticated as::\n\nOnce a client's credentials are authenticated, MySQL establishes a connection and then enters the second part of the access control system to determine authorization. MySQL authorization is an ongoing process that checks each command against the user account's specific privileges. If the commands fall within the scope of the user's privileges, the action is allowed. If not, the server denies the request. In order to explain why certain privileges are stored where, it's necessary to talk about different types of privileges within MySQL. Privileges can be assigned at different scopes which determines the area of effect of the granted privilege. Some privileges are only valid at specific scopes while others can be assigned at different scopes depending on the granularity you wish to enable. Global privileges are privileges that are not tied to a specific database. They are valid throughout the entire MySQL server. Many global privileges are related to the system administration and are associated with system management responsibilities rather than directly with data management. Database privileges are tied to a specific database within a MySQL server. Privileges granted at the database scope affect what a user can do to the database as well as any database object (like tables) contained within. Database privileges can be granted to a specific database or can be granted for databases in general. Object privileges give you control over tables, indexes, etc. within a database. These privileges can be granted for a specific object, all objects of a certain type within a specific database, or can be granted to all objects of a certain type within the entire server. Internally, privileges can be classified as either static or dynamic. Static privileges are built into the server and cannot be unregistered (disabled). These privileges are always available regardless of what components are enabled on the server. In general, static privileges are usually fundamental privileges (like the ability to read or write data, for example) that are applicable in all or most systems. Dynamic privileges, on the other hand, are contingent on the availability of the plugin or component that defines them. These privileges can be registered or unregistered at runtime to affect their availability. Unregistered privileges cannot be granted but privileges that have already been granted are automatically registered at startup. Dynamic privileges are always global in scope (apply to the entire MySQL server). MySQL's privileges are defined in many different tables in the internal system database. The combination of the privileges defined within will determine user's specific privileges in relationship to an action or a database object. The following tables in the database are involved in defining privileges:\n• : In addition to defining user accounts for authentication, the table also defines each user's static global privileges. These privileges apply to the whole MySQL server and are not affected by the availability of any plugins or components.\n• : The table defines each user's dynamic global privileges. Any privileges defined by a plugin or component are registered in this table.\n• : The table defines database-level privileges. The table matches the user's and values just like the table but also has a column called that defines the database scope for the row.\n• : The table defines table-level privileges in a similar way that the table does for databases. To enable table-level scope, a column called is available in addition to the , , and .\n• : A step further than the table, the table determines access at the column level. To add this additional granularity, a column called is included in addition to the columns available within the table.\n• : The table defines privileges for executing procedures and functions. It uses the , , , , and columns to scope the user's privileges for different types of processes.\n• : The table defines a user's proxying privileges. Proxying allows one user to act as another user, inheriting their privileges. The table uses the and columns to match a user and then uses separate columns called and to define who the matched user can act as. The user account matching for these tables functions similarly to how we described the way the table is read into memory and sorted earlier. To show the grants currently associated with a user, you can type: You can also see non-privilege account properties with: Roles are a related component that also fit into the authorization process. Roles are named bundles of privileges that can be created by administrators to make managing privileges easier. Once a group of privileges is granted to a role, you can grant those privileges to a user by adding them as a member of the role. So if you want give multiple users the ability to insert and update values within a specific table, you can create a role with those privileges. Then, you can control who can insert and update on that table by adding or removing users from that role. This creates specific defined levels of access for different types of users and helps to ensure that access levels are consistently applied across accounts. The impact of roles on the complexity of the authentication processes they're involved with is minimal. However, we mention them here because of their usefulness as a way of managing privileges.\n\nAuthentication and authorization are important requirements of MySQL's security approach. Together, they function as the system's access control controllers by regulating who can connect to the server, what structures they can see and interact with, and what data they have access to. Understanding how these systems interact can help you configure secure policies that safeguard your data while leaving all legitimate actions unimpeded."
    },
    {
        "link": "https://dev.mysql.com/doc/mysql-security-excerpt/5.7/en/access-control.html",
        "document": "MySQL enables the creation of accounts that permit client users to connect to the server and access data managed by the server. The primary function of the MySQL privilege system is to authenticate a user who connects from a given host and to associate that user with privileges on a database such as , , , and . Additional functionality includes the ability to grant privileges for administrative operations.\n\nTo control which users can connect, each account can be assigned authentication credentials such as a password. The user interface to MySQL accounts consists of SQL statements such as , , and . See Account Management Statements.\n\nThe MySQL privilege system ensures that all users may perform only the operations permitted to them. As a user, when you connect to a MySQL server, your identity is determined by the host from which you connect and the user name you specify. When you issue requests after connecting, the system grants privileges according to your identity and what you want to do.\n\nMySQL considers both your host name and user name in identifying you because there is no reason to assume that a given user name belongs to the same person on all hosts. For example, the user who connects from need not be the same person as the user who connects from . MySQL handles this by enabling you to distinguish users on different hosts that happen to have the same name: You can grant one set of privileges for connections by from , and a different set of privileges for connections by from . To see what privileges a given account has, use the statement. For example:\n\nInternally, the server stores privilege information in the grant tables of the system database. The MySQL server reads the contents of these tables into memory when it starts and bases access-control decisions on the in-memory copies of the grant tables.\n\nMySQL access control involves two stages when you run a client program that connects to the server:\n\nStage 1: The server accepts or rejects the connection based on your identity and whether you can verify your identity by supplying the correct password.\n\nStage 2: Assuming that you can connect, the server checks each statement you issue to determine whether you have sufficient privileges to perform it. For example, if you try to select rows from a table in a database or drop a table from the database, the server verifies that you have the privilege for the table or the privilege for the database.\n\nFor a more detailed description of what happens during each stage, see Section 4.5, “Access Control, Stage 1: Connection Verification”, and Section 4.6, “Access Control, Stage 2: Request Verification”. For help in diagnosing privilege-related problems, see Section 4.17, “Troubleshooting Problems Connecting to MySQL”.\n\nIf your privileges are changed (either by yourself or someone else) while you are connected, those changes do not necessarily take effect immediately for the next statement that you issue. For details about the conditions under which the server reloads the grant tables, see Section 4.9, “When Privilege Changes Take Effect”.\n\nThere are some things that you cannot do with the MySQL privilege system:"
    },
    {
        "link": "https://prisma.io/dataguide/mysql/authentication-and-authorization/user-management-and-authentication",
        "document": "User management is of the most important responsibilities of anyone hoping to manage a MySQL database system. Creating, altering, and deleting user accounts to best represent the users and services in your environment helps lay the groundwork for locking down access, limiting scope for changes, and implementing auditing and accountability for modifications. In this guide, we will talk about how to manage user accounts within MySQL. First, we will discuss what a valid user is in MySQL and show you how to add additional users to the system. This leads into a discussion about how to configure authentication for each user and how the system chooses an authentication option from a list of possibilities. We'll continue on to talk about making changes to existing users, how to log in with the accounts you've created, and how to delete users you no longer need.\n\nBefore we start creating new accounts, it's helpful to take some time to get familiar with the various that MySQL uses for creating and referring to users. You also need to be familiar with MySQL's authentication algorithm to understand what user account it will use to authenticate connections. What is MySQL's syntax for user accounts? In MySQL, user accounts are composed of two separate pieces of information, joined by an at sign (@):\n• The host that the user is connecting from In general, user accounts on the system will look like the following: Single quotes can be used, as above, to individually wrap the user and host components of the user account. They are sometimes necessary if either of the components contain characters that would otherwise be misinterpreted. In general, adding them is always a good idea to be explicit. So rather than just having an account called , in MySQL, the full account name would require some kind of host, such as . This means that there may be multiple accounts on the system and MySQL will view each of them as a unique account as long as they are coming from a different domain. With all this being said, it's possible to define user accounts that do not have a user or host component, but there are important implications that you must be aware of. You can define a user account without a user value by using an empty string: For instance, you could create a user as . This user would match any username connecting from the local computer. Likewise, you could have a user account that matches from any host. Rather than using an empty string, for host values, you would use the wildcard, like this: For example, if you create , that account would match a user connecting from any host. Understanding how MySQL actually processes each authentication request is very important to avoid a common class of authentication problems that result from reasonable, but incorrect assumptions. This was discussed in some depth in our introduction to authentication and authorization in MySQL article. When authenticating a connection request, MySQL uses a number of fields within the table of its internal database to decide whether to allow the connection. MySQL will use at most one user account record to try to authenticate a connection. This means that MySQL needs a way to decide on which user account to use if there are more than one accounts that could match a connection. MySQL's algorithm for authenticating users begins when the server starts up. On start up, MySQL loads the entire table into memory. It also does this whenever user accounts are created using the regular MySQL commands. As it loads the table, it sorts the entries from highest priority to lowest. MySQL uses the column as the primary sort field and prioritizes results with more specific values. So literal values are sorted to the top as the highest priority and those that use wildcards, like , are sorted to the bottom. The final entries are those that only contain with no other characters, followed by entries that have a completely blank host. The column is used as a secondary sort field for any entries that have the same value. Once again, the more exact matches are prioritized. Since the column cannot use wildcards, all entries are at equal footing except for those with a blank value. Those are sorted to the bottom. If any entry with a blank value is selected, the user will be authenticated as an \"anonymous user\", which usually equates to having no privileges. Now, whenever a connection request is made, MySQL goes through its sorted table in memory from the top to the bottom. It uses the first entry it finds to authenticate the user, regardless if there are other entries that would also match. If the client fails to authenticate using the method defined by that entry, the connection will fail and no other entries will be checked. What are the implications of not including a user or host in a MySQL user account definition? Because of MySQL's authentication algorithm, problems can emerge if you're not careful when creating user accounts without a user or host component. This is because the way that MySQL decides which record to use to authenticate you can be unintuitive and surprising. For instance, if a user authenticates to MySQL with the user portion as a blank string, MySQL will consider them an \"anonymous user\" for the remainder of the session. As a rule, anonymous users have almost no power and can do very little once connected. It's possible to even accidentally authenticate as an anonymous user when trying to authenticate using a different user account. The challenge with using wildcard hosts for user accounts is that other user accounts that include a host value can easily mask, or make unavailable, the user account that uses the wildcard. For instance, if you have a user account defined as , you might expect to be able to authenticate to from any host. However, if you have a user account with a blank user but a host value that matches the host is connecting from, MySQL will authenticate using that account instead (leading to an anonymous user login as described above). So as an example, MySQL will sort the following accounts into the following order: These are of equal priority, which is okay because it's only possible for one of them to match a connection. These two entries are, again of the same priority. Since they don't have a user component, but they do have a literal host component, they are placed at the bottom of the entries that have exact host values. This entry has a wildcard in the host component, so it's given lower priority than entries with exact host values. This entry is grouped with the entries that have a wildcard within their host value. Since it has no user component, it is at the bottom of this group. This entry has a host value consisting only of a wildcard. Since it matches any host, it has a very low priority. This entry can be used authenticate any user from any host as an anonymous user. It's of extremely low priority since it matches any connection. This entry has an entirely blank host value, which is of even lower priority than a host that only contains a wildcard host. This is the lowest possible priority user. It contains no host information so it is place at the end during the host sorting. Since it also contains a blank user, it is placed below other entries in this group. Like all entries without a user, connections authenticated with this entry will be signed in as an anonymous user.\n\nHow do you create users? Now that you have a feel for the way that MySQL handles user accounts, we can begin creating some new users. Remember to login with a user with the privileges described in the prerequisites. The basic syntax for creating a new user is relatively simple. You use the command and then specify the user and host for the new account: This will create a basic account without configuring any details beyond its user and host at creation. How do you create a user with a password? Often, you want to configure authentication while you're creating the user. You can do this by adding the optional clause onto statement: This creates a new user account, as before, and assigns a password for the account at the same time. We will cover how to assign a password after the fact or how to change a user's password later on. How do you create a user with Unix socket authentication? While password authentication is the most common authentication method for most users, it's not the only option. MySQL provides many different internal and external authentication mechanisms that you can configure to your user accounts to use. As an example, we'll configure a new account using Unix socket authentication. Unix socket authentication can be used in Linux or Unix-like environments so that an account on the operating system is given access to the same account name within MySQL without further authentication. In this configuration, the MySQL administrator knows that user accounts on the operating system are tightly controlled. So if there is a user on the operating system, they will be able to login to the account within MySQL if Unix socket authentication is the defined authentication mechanism. Let's configure this now. Socket authentication requires the plugin, so first load the plugin by typing: Next, create a user account that matches a user account you have on your operating system. For this example, we'll use the account we discussed above. If you don't use a name that matches one of your operating system names, you won't be able to authenticate using this user. To create the user with socket authentication, we need to use the clause (different than the clause used earlier) to specify the authentication plugin to use: Now, you should be able to authenticate to the MySQL user from the user on your operating system. When logged in as , connect to the database without providing any username or password: You should be signed in automatically through the Unix socket authentication you configured.\n\nHow do you show existing users? Next, let's take a look at how to find information about the existing users. To show all of the existing MySQL users, consisting of their user and host component, as well as the authentication plugin they're currently using, you can those fields from the database: Here, we can see that there are six users defined on the system, all of which can only login locally. Five of the accounts are configured to use password authentication. The account is configured to use Unix socket authentication. We can find additional information about user properties by using the command. In spite of its name, it shows all of the current properties of a user account, not necessarily the ones that were used during the initial account creation. The command takes an account name as an argument: It's usually best to end the command with the statement terminator instead of the usual colon ( ) so that you can view the results a bit more clearly. To display the properties for the account, you would type: CREATE USER for useradmin@localhost: CREATE USER 'useradmin'@'localhost' IDENTIFIED WITH 'caching_sha2_password' AS '$A$005$O\n\nHow do you change existing MySQL users? You can change existing users within MySQL using the command. This can be used to change most of the user-related properties of an account, with the exception of account privileges, which are controlled by the and commands. The basic syntax for looks like this: How do you change the password for a MySQL user? For most people, the most common use of is to modify passwords. For example, you can modify the password for by typing: If you want to set a temporary password for a user that they'll have to replace immediately, you can set and expire a password at the same time: You can always change your own password, even without the privilege. It's easiest to use the function to automatically fill in your own username: How do you change authentication plugins for a MySQL user? You can also change the mechanism or plugin used to authenticate an account. In an earlier example, we configured an account called to use Unix socket authentication. If we later want to change that account to use conventional password authentication, we can use the command again. First, identify the default authentication plugin for your server. If it's a password-based authentication method, it's probably best to reuse the default selection: In this case, the default authentication plugin is , so we'll use that when we switch to password authentication. Now, change to use the plugin with a new password: The user will no longer be able to login using Unix socket authentication, but they can log in using the provided password.\n\nHow do you login to MySQL? We've discussed how to create and modify MySQL user accounts, including authentication. However, we haven't talked about how to actually login using these authentication methods. The client is a powerful command line client that can be used to connect to local and remote databases. We'll use it to talk about how to authenticate using the methods we configured above. How do you login to a local database with a password? To login to a locally hosted MySQL database using a user account with a password, the basic syntax looks like this: So, if the user wants to login to MySQL and connect to the database from the computer where the system is hosted, they can type: The client will prompt for the password for . If you provide the correct credentials, you'll be connected to the database. Specifying a database on the command line is optional. If none is specified, you'll connect to the server but not to a specific database. How do you login to a local database with Unix socket authentication? To login to a local MySQL server using Unix socket authentication, you need to be logged into your operating system as the account name that matches. So, if we want to authenticate to using Unix socket authentication, we first have to login to our computer with a username called . Once you are using the correct operating system account, you can connect directly to the local database by executing the client, with no options. As before, you can optionally append a database name to connect to a specific database you'd like. How do you login to a remote database with a password? If your MySQL server isn't running on your local server, you'll have to specify the host that the client should try to connect to. You can do that by adding the option. Most of the time, you'll be authenticating with a password to remote MySQL servers, so the command would look something like this: So could connect to a MySQL server located on by typing:"
    },
    {
        "link": "https://support.cs.wwu.edu/home/survival_guide/curricular/cs330/MySQL_Account_Information.html",
        "document": "This is a short explanation of how accounts/authentication work when working with a MySQL database. This will not cover some of the more granular/complex things you can do permission wise. I am going to assume that you all know what MySQL is and how to connect to the MySQL server (mysqld). Basic sql knowledge is also assumed. The first thing you need to understand when working with MySQL is what their concept of an ‘account’ is; it’s probably somewhat different than your normal concept of a user account. In MySQL an account is comprised of two pieces of information: a user name and a ‘connecting domain.’ MySQL stores administrative information (user information as well as other things) in the database named mysql. Within the mysql db, there is a table called user whose schema includes but is not limited to:\n\nThere are many other fields in this table corresponding to various permission sets, but for now its really only necessary to understand that this table contains a field for the user name, a field for the host (the connecting domain) and a field for the password (actually the password hash). Consider:\n\nFrom the previous select statement you can see that for my user name there are 2 MySQL accounts. One for the localhost domain, and one for the ‘%’ domain. The ‘%’ character is the wildcard character in MySQL, and so this domain would actually represent “any domain other than localhost.” As a quick example you could use ‘%.example.com’ to represent foo.example.com, bar.example.com, and so on. Depending on where I connect to the database from, the hash of the password I supply will be checked against one of these two hashes. If I log into sw, or am running a webapp that is stored on sw, the password I supply will get checked against the localhost hash, similarly if I connect to the MySQL server from home (or any machine other than sw) my password will get checked against the entry in the record where Host=’%’.\n\nOne reason MySQL ties an account to a particular domain is that its conceivable you would want different permissions for the same “user name” depending on how the entity (actual person, webapp, db application, and so on) is connecting to the database. Consider a MySQL user name called “accounting.” You (as astute administrators) might want the accounting staff to be able to connect locally (on a terminal on the actual server) to have full access to the accounting database, but webapps connecting from a webserver to ONLY have select privileges on the tables in the database. Strictly speaking within MySQL these would be two separate accounts, each with their own entry in the mysql.user table.\n\nMuch of the confusion over why people are typically denied access to their database stems from not understanding what is currently in the mysql.user table. MySQL provides a set of directives to change the password hash for a user. The format of this command is:\n\nIf [FOR user] is not present, MySQL will attempt to set the password for the currently logged in user. You can choose to either specify the plain text password, or the actual hash as returned by MySQL’s PASSWORD( ) function. Normally I advise to change the password hash for each of the MySQL accounts at the same time unless you have specific reasons to want the password to be different among the various accounts.\n\nIt is perfectly legal to do the following:\n\nThis updates the hash of the currently logged in user, sometimes it’s not always obvious which account that is. For reference you may execute the following command to see who you are currently logged in as:\n\nthe following two commands will change both the local host and the everything else password. The first logs in to mysql as username@localhost, while the second logs on as username@%"
    },
    {
        "link": "https://stackoverflow.com/questions/685855/how-do-i-authenticate-a-user-in-php-mysql",
        "document": "So recently I learned how to properly add a username and password to a database. My database is usersys, and the table storing user information is called userdb. The table has two columns - username (primary), password.\n\nThe registration form works great, enters the users input into the database correctly and also checks to see whether the user's username is already in the database or not.\n\nWith that said, I am asking if anyone could help me create a login script. So far, this is what I have:\n\nThe POST data is from the previous log in page. I want this script to check the table (userdb) and find the row for the username that the user entered from the previous form and verify that the password entered matches the username's password set in that row, in userdb table.\n\nI also want some type of way to check whether or not if the username entered exists, to tell the user that the username entered does not exists if it can not be found in the table."
    }
]