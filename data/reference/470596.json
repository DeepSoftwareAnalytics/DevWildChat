[
    {
        "link": "https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html",
        "document": "Cython source file names consist of the name of the module followed by a extension, for example a module called primes would have a source file named .\n\nCython code, unlike Python, must be compiled. This happens in two stages:\n\nOnce you have written your / file, there are a couple of ways how to turn it into an extension module.\n\nThe following sub-sections describe several ways to build your extension modules, and how to pass directives to the Cython compiler.\n\nThere are also a number of tools that process files apart from Cython, e.g.\n\nThere are two ways of compiling from the command line.\n• None The cython command takes a or file and compiles it into a C/C++ file.\n• None The cythonize command takes a or file and compiles it into a C/C++ file. It then compiles the C/C++ file into an extension module which is directly importable from Python. One way is to compile it manually with the Cython compiler, e.g.: This will produce a file called , which then needs to be compiled with the C compiler using whatever options are appropriate on your platform for generating an extension module. For these options look at the official Python documentation. The other, and probably better, way is to use the extension provided with Cython. The benefit of this method is that it will give the platform specific compilation options, acting like a stripped down autotools. Run the cythonize compiler command with your options and list of files to generate an extension module. For example: This creates a file (or in C++ mode), compiles it, and puts the resulting extension module ( or , depending on your platform) next to the source file for direct import ( builds “in place”). The switch additionally produces an annotated html file of the source code. The cythonize command accepts multiple source files and glob patterns like as argument and also understands the common option for running multiple parallel build jobs. When called without further options, it will only translate the source files to or files. Pass the flag for a complete list of supported options. There simpler command line tool cython only invokes the source code translator. In the case of manual compilation, how to compile your files will vary depending on your operating system and compiler. The Python documentation for writing extension modules should have some details for your system. On a Linux system, for example, it might look similar to this: After compilation, a ( for Windows) file is written into the target directory and your module, , is available for you to import as with any other Python module. Note that if you are not relying on cythonize or , you will not automatically benefit from the platform specific file extension that CPython generates for disambiguation, such as on a regular 64bit Linux installation of CPython 3.5.\n\nThe setuptools extension provided with Cython allows you to pass files directly to the constructor in your setup file. If you have a single Cython file that you want to turn into a compiled extension, say with filename the associated would be: If your build depends directly on Cython in this way, then you may also want to inform pip that is required for to execute, following PEP 518, creating a file containing, at least: To understand the more fully look at the official setuptools documentation. To compile the extension for use in the current directory use: setuptools 74.1.0 adds experimental support for extensions in (instead of ): In this case, you can use any build frontend - e.g. build More details on building Cython modules that use cimport numpy can be found in the Numpy section of the user guide. If you have Cython include files or Cython definition files in non-standard places you can pass an parameter to : If you need to specify compiler options, libraries to link with or other linker options you will need to create instances manually (note that glob syntax can still be used to specify multiple extensions in one line): # Everything but primes.pyx is included here. Some useful options to know about are\n• None - list of directories to search for C/C++ header files (in Unix form for portability),\n• None - list of library names (not filenames or paths) to link against,\n• None - list of directories to search for C/C++ libraries at link time. Note that when using setuptools, you should import it before Cython, otherwise, both might disagree about the class to use here. Often, Python packages that offer a C-level API provide a way to find the necessary C header files: If your options are static (for example you do not need to call a tool like to determine them) you can also provide them directly in your or source file using a special comment block at the start of the file: If you cimport multiple .pxd files defining libraries, then Cython merges the list of libraries, so this works as expected (similarly with other options, like above). If you have some C files that have been wrapped with Cython and you want to compile them into your extension, you can define the setuptools parameter: Note that these sources are added to the list of sources of the current extension module. Spelling this out in the file looks as follows: The class takes many options, and a fuller explanation can be found in the setuptools documentation. Sometimes this is not enough and you need finer customization of the setuptools . To do this, you can provide a custom function to create the final object after Cython has processed the sources, dependencies and directives but before the file is actually Cythonized. This function takes 2 arguments and , where is the object given as input to Cython and is a with all keywords which should be used to create the . The function must return a 2-tuple , where is the created and is metadata which will be written as JSON at the top of the generated C files. This metadata is only used for debugging purposes, so you can put whatever you want in there (as long as it can be converted to JSON). The default function (defined in ) is: In case that you pass a string instead of an to , the will be an without sources. For example, if you do , the will be . Just as an example, this adds as library to every extension: If you Cythonize in parallel (using the argument), then the argument to must be pickleable. In particular, it cannot be a lambda function. The function can take extra arguments which will allow you to customize your build. Compile a set of source modules into C/C++ files and return a list of distutils Extension objects for them.\n• None module_list – As module list, pass either a glob pattern, a list of glob patterns or a list of Extension objects. The latter allows you to configure the extensions separately through the normal distutils options. You can also pass Extension objects that have glob patterns as their sources. Then, cythonize will resolve the pattern and create a copy of the Extension for every matching file.\n• None exclude – When passing glob patterns as , you can exclude certain module names explicitly by passing them into the option.\n• None nthreads – The number of concurrent builds for parallel compilation (requires the module).\n• None aliases – If you want to use compiler directives like but can only know at compile time (when running the ) which values to use, you can use aliases and pass a dictionary mapping those aliases to Python strings when calling . As an example, say you want to use the compiler directive but this path isn’t always fixed and you want to find it when running the . You can then do , find the value of in the , put it in a python variable called as a string, and then call .\n• None quiet – If True, Cython won’t print error, warning, or status messages during the compilation.\n• None force – Forces the recompilation of the Cython modules, even if the timestamps don’t indicate that a recompilation is necessary.\n• None language – To globally enable C++ mode, you can pass . Otherwise, this will be determined at a per-file level based on compiler directives. This affects only modules found based on file names. Extension instances passed into will not be changed. It is recommended to rather use the compiler directive than this option.\n• None exclude_failures – For a broad ‘try to compile’ mode that ignores compilation failures and simply excludes the failed extensions, pass . Note that this only really makes sense for compiling files which can also be used without compilation.\n• None show_all_warnings – By default, not all Cython warnings are printed. Set to true to show all warnings.\n• None annotate – If , will produce a HTML file for each of the or files compiled. The HTML file gives an indication of how much Python interaction there is in each of the source code lines, compared to plain C code. It also allows you to see the C/C++ code generated for each line of Cython code. This report is invaluable when optimizing a function for speed, and for determining when to release the GIL: in general, a block may contain only “white” code. See examples in Determining where to add types or Primes.\n• None annotate-fullc – If will produce a colorized HTML version of the source which includes entire generated C/C++-code.\n• None compiler_directives – Allow to set compiler directives in the like this: . See Compiler directives.\n• None depfile – produce depfiles for the sources if True.\n• None cache – If the cache enabled with default path. If the value is a path to a directory, then the directory is used to cache generated / files. By default cache is disabled. See Cython cache.\n\nIn some scenarios, it can be useful to link multiple Cython modules (or other extension modules) into a single binary, e.g. when embedding Python in another application. This can be done through the inittab import mechanism of CPython. Create a new C file to integrate the extension modules and add this macro to it: If you are only targeting Python 3.x, just use as prefix. Then, for each of the modules, declare its module init function as follows, replacing with the name of the module: In C++, declare them as . If you are not sure of the name of the module init function, refer to your generated module source file and look for a function name starting with . Next, before you start the Python runtime from your application code with , you need to initialise the modules at runtime using the C-API function, again inserting the name of each of the modules: This enables normal imports for the embedded extension modules. In order to prevent the joined binary from exporting all of the module init functions as public symbols, Cython 0.28 and later can hide these symbols if the macro is defined while C-compiling the module C files. Also take a look at the cython_freeze tool. It can generate the necessary boilerplate code for linking one or more modules into a single Python executable.\n\nFor building Cython modules during development without explicitly running after each change, you can use : This allows you to automatically run Cython on every that Python is trying to import. You should use this for simple Cython builds only where no extra C libraries and no special building setup is needed. It is also possible to compile new modules that are being imported (including the standard library and installed packages). For using this feature, just tell that to : In the case that Cython fails to compile a Python module, will fall back to loading the source modules instead. Note that it is not recommended to let build code on end user side as it hooks into their import system. The best way to cater for end users is to provide pre-built binary packages in the wheel packaging format. The function can take several arguments to influence the compilation of Cython or Python files. Call this to install the import hook in your meta-path for a single Python process. If you want it to be installed whenever you use Python, add it to your (as described above).\n• None pyximport – If set to False, does not try to import files.\n• None pyimport – You can pass to also install the import hook in your meta-path. Note, however, that it is rather experimental, will not work at all for some files and packages, and will heavily slow down your imports due to search and compilation. Use at your own risk.\n• None build_dir – By default, compiled modules will end up in a directory in the user’s home directory. Passing a different path as will override this.\n• None build_in_temp – If , will produce the C files locally. Working with complex dependencies and debugging becomes more easy. This can principally interfere with existing files of the same name.\n• None setup_args – Dict of arguments for Distribution. See .\n• None reload_support – Enables support for dynamic , e.g. after a change in the Cython code. Additional files may arise on that account, when the previously loaded module file cannot be overwritten.\n• None load_py_module_on_import_failure – If the compilation of a file succeeds, but the subsequent import fails for some reason, retry the import with the normal module instead of the compiled module. Note that this may lead to unpredictable results for modules that change the system state during their import, as the second import will rerun these modifications in whatever state the system was left after the import of the compiled module failed.\n• None inplace – Install the compiled module ( for Linux and Mac / for Windows) next to the source file.\n• None language_level – The source language level to use: 2 or 3. The default is to use the language level of the current Python runtime for .py files and Py2 for files. Since does not use internally, it currently requires a different setup for dependencies. It is possible to declare that your module depends on multiple files, (likely and files). If your Cython module is named and thus has the filename then you should create another file in the same directory called . The file can be a list of filenames or “globs” (like or ). Each filename or glob must be on a separate line. Pyximport will check the file date for each of those files before deciding whether to rebuild the module. In order to keep track of the fact that the dependency has been handled, Pyximport updates the modification time of your “.pyx” source file. Future versions may do something more sophisticated like informing setuptools of the dependencies directly. does not use . Thus it is not possible to do things like using compiler directives at the top of Cython files or compiling Cython code to C++. Pyximport does not give you any control over how your Cython file is compiled. Usually the defaults are fine. You might run into problems if you wanted to write your program in half-C, half-Cython and build them into a single library. Pyximport does not hide the setuptools/GCC warnings and errors generated by the import process. Arguably this will give you better feedback if something went wrong and why. And if nothing went wrong it will give you the warm fuzzy feeling that pyximport really did rebuild your module as it was supposed to. Basic module reloading support is available with the option . Note that this will generate a new module filename for each build and thus end up loading multiple shared libraries into memory over time. CPython has limited support for reloading shared libraries as such, see PEP 489. Pyximport puts both your file and the platform-specific binary into a separate build directory, usually . To copy it back into the package hierarchy (usually next to the source file) for manual reuse, you can pass the option .\n\nIt’s possible to compile code in a notebook cell with Cython. For this you need to load the Cython magic: Then you can define a Cython cell by writing on top of it. Like this: Note that each cell will be compiled into a separate extension module. So if you use a package in a Cython cell, you will have to import this package in the same cell. It’s not enough to have imported the package in a previous cell. Cython will tell you that there are “undefined global names” at compilation time if you don’t comply. The global names (top level functions, classes, variables and modules) of the cell are then loaded into the global namespace of the notebook. So in the end, it behaves as if you executed a Python cell. Additional allowable arguments to the Cython magic are listed below. You can see them also by typing in IPython or a Jupyter notebook. Produce a colorized HTML version of the source which includes entire generated C/C++-code. Output a C++ rather than C file. Force the compilation of a new module, even if the source has been previously compiled. Extra flags to pass to compiler via the extra_compile_args. Extra flags to pass to linker via the extra_link_args. Add a library to link the extension against (can be specified multiple times). Add a path to the list of library directories (can be specified multiple times). Add a path to the list of include directories (can be specified multiple times). Add a path to the list of src files (can be specified multiple times). Specify a name for the Cython module. Enable profile guided optimisation in the C compiler. Compiles the cell twice and executes it in between to generate a runtime profile.\n\nCompiler options can be set in the , before calling , like this: Here are the options that are available: Whether or not to include docstring in the Python extension. If False, the binary size will be smaller, but the attribute of any class or function will be an empty string. Embed the source code position in the docstrings of functions and classes. Decref global variables in each module on exit for garbage collection. 0: None, 1+: interned objects, 2+: cdef globals, 3+: types objects Mostly for reducing noise in Valgrind as it typically executes at process exit (when all memory will be reclaimed anyways). Note that directly or indirectly executed cleanup code that makes use of global variables or types may no longer be safe when enabling the respective level since there is no guaranteed order in which the (reference counted) objects will be cleaned up. The order can change due to live references and reference cycles. Should tp_clear() set object fields to None instead of clearing them to NULL? Generate an annotated HTML version of the input source files for debugging and optimisation purposes. This has the same effect as the argument in . This will abort the compilation on the first error occurred rather than trying to keep going and printing further error messages. Make unknown names an error. Python raises a NameError when encountering unknown names at runtime, whereas this option makes them a compile time error. If you want full Python compatibility, you should disable this option and also ‘cache_builtins’. Make uninitialized local variable reference a compile time error. Python raises UnboundLocalError at runtime, whereas this option makes them a compile time error. Note that this option affects only variables of “python object” type. This will convert statements of the form to when is a C integer type, and the direction (i.e. sign of step) can be determined. WARNING: This may change the semantics if the range causes assignment to i to overflow. Specifically, if this option is set, an error will be raised before the loop is entered, whereas without this option the loop will execute until an overflowing value is encountered. Perform lookups on builtin names only once, at module initialisation time. This will prevent the module from getting imported if a builtin name that it uses cannot be found during initialisation. Default is True. Note that some legacy builtins are automatically remapped from their Python 2 names to their Python 3 names by Cython when building in Python 3.x, so that they do not get in the way even if this option is enabled. Generate branch prediction hints to speed up error handling etc. Enable this to allow one to write to overwrite the definition if the cpdef function foo, at the cost of an extra dictionary lookup on every call. If this is false it generates only the Python wrapper and no override check. Whether or not to embed the Python interpreter, for use in making a standalone executable or calling from external libraries. This will provide a C function which initialises the interpreter and executes the body of this module. See this demo for a concrete example. If true, the initialisation function is the C main() function, but this option can also be set to a non-empty string to provide a function name explicitly. Default is False. Allows cimporting from a pyx file without a pxd file. Maximum number of dimensions for buffers – set lower than number of dimensions in numpy, as slices are passed by value and involve a lot of copying. Number of function closure instances to keep in a freelist (0: no freelists)\n\nCompiler directives are instructions which affect the behavior of Cython code. Here is the list of currently supported directives: Controls whether free functions behave more like Python’s CFunctions (e.g. ) or, when set to True, more like Python’s functions. When enabled, functions will bind to an instance when looked up as a class attribute (hence the name) and will emulate the attributes of Python functions, including introspections like argument names and annotations. Changed in version 3.0.0: Default changed from False to True If set to False, Cython is free to assume that indexing operations ([]-operator) in the code will not cause any IndexErrors to be raised. Lists, tuples, and strings are affected only if the index can be determined to be non-negative (or if is False). Conditions which would normally trigger an IndexError may instead cause segfaults or data corruption if this is set to False. In Python, arrays and sequences can be indexed relative to the end. For example, A[-1] indexes the last value of a list. In C, negative indexing is not supported. If set to False, Cython is allowed to neither check for nor correctly handle negative indices, possibly causing segfaults or data corruption. If bounds checks are enabled (the default, see above), negative indexing will usually raise an for indices that Cython evaluates itself. However, these cases can be difficult to recognise in user code to distinguish them from indexing or slicing that is evaluated by the underlying Python array or sequence object and thus continues to support wrap-around indices. It is therefore safest to apply this option only to code that does not process negative indices at all. If set to True, Cython checks that\n• None a memoryview is initialized whenever its elements are accessed or assigned to.\n• None a C++ class is initialized when it is accessed (only when is on) Setting this to False disables these checks. If set to False, Cython is free to assume that native field accesses on variables typed as an extension type, or buffer accesses on a buffer variable, never occurs when the variable is set to . Otherwise a check is inserted and the appropriate exception is raised. This is off by default for performance reasons. If set to True, Cython sets the slot to to signal that the module is safe to run without an active GIL and prevent the GIL from being enabled when the module is imported. Otherwise the slot is set to which will cause the GIL to be automatically enabled. Setting this to True does not itself make the module safe to run without the GIL; it merely confirms that you have checked the logic and consider it safe to run. Since free-threading support is still experimental itself, this is also an experimental directive that might be changed or removed in future releases. If set to True, raise errors on overflowing C integer arithmetic operations. Incurs a modest runtime penalty, but is much faster than using Python ints. If set to True, and overflowcheck is True, check the overflow bit for nested, side-effect-free arithmetic expressions once rather than at every step. Depending on the compiler, architecture, and optimization settings, this may help or hurt performance. A simple suite of benchmarks can be found in . If set to True, Cython will embed a textual copy of the call signature in the docstring of all Python visible functions and classes. Tools like IPython and epydoc can thus display the signature, which cannot otherwise be retrieved after compilation. If set to , Cython will generate signatures preserving C type declarations and Python type annotations. If set to , Cython will do a best attempt to use pure-Python type annotations in embedded signatures. For arguments without Python type annotations, the C type is mapped to the closest Python type equivalent (e.g., C is mapped to Python type and C is mapped to Python type). The specific output and type mapping are experimental and may change over time. The format generates signatures that are compatible with those understood by CPython’s Argument Clinic tool. The CPython runtime strips these signatures from docstrings and translates them into a attribute. This is mainly useful when using , since the Cython functions generated with do not have (nor need) a attribute. If set to False, Cython will adjust the remainder and quotient operators C types to match those of Python ints (which differ when the operands have opposite signs) and raise a when the right operand is 0. This has up to a 35% speed penalty. If set to True, no checks are performed. See CEP 516. If set to True, Cython will emit a runtime warning whenever division is performed with negative operands. See CEP 516. modifies the return type of , as shown in the table below: C integer (known to be >= 0 at compile time) C integer (may be negative) Return type is C double (note that Python would dynamically pick or here, while Cython doesn’t) C floating point (or C integer) Return type is floating point, result is NaN if the result would be complex Either a C real or complex number at cost of some speed The behaviour largely keeps the result type the same as the operand types, while the behaviour follows Python and returns a flexible type depending on the inputs. Introduced in Cython 3.0 with a default of False; before that, the behaviour matched the version. When disabled, uses the and signatures when constructing functions/methods which take zero or one arguments. Has no effect on special methods and functions with more than one argument. The and signatures provide slightly faster calling conventions but disallow the use of keywords. When enabled, makes the special binary operator methods ( , etc.) behave according to the low-level C-API slot semantics, i.e. only a single method implements both the normal and reversed operator. This used to be the default in Cython 0.x and was now replaced by Python semantics, i.e. the default in Cython 3.x and later is . Write hooks for Python profilers into the compiled C code. Write line tracing hooks for Python profilers or coverage reporting into the compiled C code. This also enables profiling. Note that the generated module will not actually use line tracing, unless you additionally pass the C macro definition to the C compiler (e.g. using the setuptools option ). Define to also include functions and sections. Infer types of untyped variables in function bodies. Default is None, indicating that only safe (semantically-unchanging) inferences are allowed. In particular, inferring integral types for variables used in arithmetic expressions is considered unsafe (due to possible overflow) and must be explicitly requested. Globally set the Python language level to be used for module compilation. Default is None, indicating compatibility with Python 3 in Cython 3.x and with Python 2 in Cython 0.x. To enable Python 3 source code semantics, set this to 3 (or 3str) at the start of a module or pass the “-3” or “–3str” command line options to the compiler. For Python 2 semantics, use 2 and “-2” accordingly. Before Cython 3.1, the option enabled Python 3 semantics but did not change the type and unprefixed string literals to when the compiled code runs in Python 2.x. In Cython 3.1, is an alias for . Language level 2 ignores type annotations due to the int/long ambiguity. Note that cimported files inherit this setting from the module being compiled, unless they explicitly set their own language level. Included source files always inherit this setting. Globally set the type of an implicit coercion from char* or std::string. Globally set the encoding to use when implicitly coercing char* or std:string to a unicode object. Coercion from a unicode object to C type is only allowed when set to or , the latter being utf-8 in Python 3 and nearly-always ascii in Python 2. Enables the attribute cache for extension types in CPython by setting the type flag . Default is True, meaning that the cache is enabled for Cython implemented types. To disable it explicitly in the rare cases where a type needs to juggle with its internally without paying attention to cache consistency, this option can be set to False. Whether to print tracebacks when suppressing unraisable exceptions. PEP 492 specifies that async-def coroutines must not be iterable, in order to prevent accidental misuse in non-async contexts. However, this makes it difficult and inefficient to write backwards compatible code that uses async-def coroutines in Cython but needs to interact with async Python code that uses the older yield-from syntax, such as asyncio before Python 3.5. This directive can be applied in modules or selectively as decorator on an async-def coroutine to make the affected coroutine(s) iterable and thus directly interoperable with yield-from. Uses function argument annotations to determine the type of variables. Since Python does not enforce types given in annotations, setting to False gives greater compatibility with Python code. From Cython 3.0, can be set on a per-function or per-class basis. Copy the original source code line by line into C code comments in the generated code file to help with understanding the output. This is also required for coverage analysis. Make C++ variables behave more like Python variables by allowing them to be “unbound” instead of always default-constructing them at the start of a function. See cpp_locals directive for more detail. When enabled, functions will not propagate raised exceptions by default. Hence, the function will behave in the same way as if declared with keyword. See Error return values for details. Setting this directive to will cause Cython 3.0 to have the same semantics as Cython 0.x. This directive was solely added to help migrate legacy code written before Cython 3. It will be removed in a future release. Whether to expand chained if-else statements (including statements like ) into C switch statements. This can have performance benefits if there are lots of values but cause compiler errors if there are any duplicate values (which may not be detectable at Cython compile time for all C constants). Cython can generate code that optimistically checks for Python method objects at call time and unpacks the underlying function to call it directly. This can substantially speed up method calls, especially for builtins, but may also have a slight negative performance impact in some cases where the guess goes completely wrong. Disabling this option can also reduce the code size. All warning directives take True / False as options to turn the warning on / off. Warns about any variables that are implicitly declared without a declaration Warns about code paths that are statically determined to be unreachable, e.g. returning twice unconditionally. Warns about use of variables that are conditionally uninitialized. Warns about unused assignment to the same name, such as Warns about multiple variables declared on the same line with at least one pointer type. For example - which, as in C, declares as a pointer, as a value type, but could be mininterpreted as declaring two pointers. Warns about use of the deprecated statement in Cython code, see Conditional Compilation and Deprecation of DEF / IF. Warns about use of the deprecated statement in Cython code, see Conditional Compilation and Deprecation of DEF / IF. Show performance hints during compilation pointing to places in the code which can yield performance degradation. Note that performance hints are not warnings and hence the directives starting with above do not affect them and they will not trigger a failure when “error on warnings” is enabled. One can set compiler directives through a special header comment near the top of the file, like this: The comment must appear before any code (but can appear after other comments or whitespace). One can also pass a directive on the command line by using the -X switch: Directives passed on the command line will override directives set in header comments. For local blocks, you need to cimport the special builtin module: Then you can use the directives either as decorators or in a with statement, like this: # turn off boundscheck for this function # turn it temporarily on again for this block These two methods of setting directives are not affected by overriding the directive on the command-line using the -X option. Compiler directives can also be set in the file by passing a keyword argument to : This will override the default directives as specified in the dictionary. Note that explicit per-file or local directives as explained above take precedence over the values passed to .\n\nCython has a number of C macros that can be used to control compilation. Typically, these would be set using in (for example ), however they can also be set in other ways like using the environmental variable. These macros are set automatically by Cython to sensible default values unless you chose to explicitly override them, so they are a tool that most users can happily ignore. Not all combinations of macros are compatible or tested, and some change the default value of other macros. They are listed below in rough order from most important to least important: Turns on Cython’s experimental Limited API support, meaning that one compiled module can be used by many Python interpreter versions (at the cost of some performance). At this stage many features do not work in the Limited API. You should set this macro to be the version hex for the minimum Python version you want to support (>=3.7). will support Python 3.7 upwards. Note that this is a :external+python:c:macro:`Python macro <Py_LIMITED_API>`_, rather than just a Cython macro, and so it changes what parts of the Python headers are visible too. See The Limited API and Stable ABI for more details about this feature. Uses multi-phase module initialization as described in PEP 489. This improves Python compatibility, especially when running the initial import of the code when it makes attributes such as available. It is therefore on by default where supported. Stores module data on a struct associated with the module object rather than as C global variables. The advantage is that it should be possible to import the same module more than once (e.g. in different sub-interpreters). At the moment this is experimental and not all data has been moved. Specifically, globals have not been moved. Defines es as Heap Types rather than “static types”. Practically this does not change a lot from a user point of view, but it is needed to implement Limited API support. These control the inclusion of profiling and line tracing calls in the module. See the and Compiler directives. Slightly different to the other macros, this controls how functions appear to C++ code. See C++ public declarations for full details. Controls whether C lines numbers appear in tracebacks. See C line numbers in tracebacks for a complete description. Passes complex numbers using the C or C++ language standard library types instead of an internal type defined by Cython. Turning it on maximizes compatibility with external libraries. However, MSVC has poor standards support (especially in C mode) and so struggles to use the standard library types. It is on by default on platforms where we think it’s likely to work. There is a further list of macros which turn off various optimizations or language features. Under normal circumstance Cython enables these automatically based on the version of Python you are compiling for so there is no need to use them to try to enable extra optimizations - all supported optimizations are enabled by default. These are mostly relevant if you’re tying to get Cython working in a new and unsupported Python interpreter where you will typically want to set them to 0 to disable optimizations. They are listed below for completeness but hidden by default since most users will be uninterested in changing them. If enabled, Cython will directly access members of the struct. Use the internal function for more efficient access to properties of C classes. Enable optimizations based on direct access into the internals of Python / / objects respectively. Use a faster (but internal) mechanism for building unicode strings, for example in f-strings. Avoid using “borrowed references” and ensure that Cython always holds a reference to objects it manipulates. Most useful for non-reference-counted implementations of Python, like PyPy (where it is enabled by default). Avoid using APIs that return unsafe “borrowed references” and instead use the equivalent APIs that return “strong references”. Most useful for the free-threaded build of CPython, where incrementing the reference count of borrowed references to items in mutable containers might introduce thread safety issues. Borrowed references to items in immutable containers are still allowed with this setting. Use some C-API macros that increase performance by skipping error checking, which may not be safe on all Python implementations (e.g. PyPy). Prefer the C-API macros / inline-functions for builtin types over their counterparts if errors are not expected. On some Python versions this speeds up getting/releasing the GIL. Try to speed up method calls at the cost of code-size. Linked to the compiler directive - this macro is used to selectively enable the compiler directive only on versions of Python that support it. These are used internally to incrementally enable the vectorcall calling mechanism on older Python versions (<3.8). Use the type-slot instead of , as described in PEP 442. Try to optimize attribute lookup by using versioned dictionaries where supported. Use an internal structure to track exception state, used in CPython 3.7 and later. Attempt to provide docstrings also for special (double underscore) methods. Enable the use of freelists on extension types with the @cython.freelist decorator. Enable the use of atomic reference counting (as opposed to locking then reference counting) in Cython typed memoryviews. Debug option for including constant (string/integer/code/…) objects in . By default, Cython avoids GC traversing these objects because they can never participate in reference cycles, and thus would uselessly waste time during garbage collection runs. Makes module state lookup thread-safe (when and are both enabled). This is on by default where it would be helpful, however it can be disabled if you are sure that one interpreter will not be importing your module at the same time as another is using it. Values greater than 1 can be used to select a specific implementation for debugging purposes."
    },
    {
        "link": "https://cython.readthedocs.io/en/latest/src/userguide/faq.html",
        "document": "Do I need to rename my file to ?¶ Answer: No. Cython can compile both .py and .pyx files. The difference is that the extended Cython syntax ( ) is only available in Cython .pyx files and not in Python .py files. But you can use Cython’s pure Python mode to provide type declarations for the compilation, including Python’s PEP-484 syntax for type hints. For cases where no interaction with external C libraries is required, this is also the recommended way to type your code, since sticking to .py files with regular Python syntax keeps the whole range of debugging, linting, formatting, profiling etc. tools for Python code available for your software development needs, which usually cannot handle the syntax of .pyx files. Can Cython generate C code for classes?¶ Answer: A plain class becomes a fully-fledged Python class. Cython can also generate C classes, where the class data is stored in an efficient C structure at the cost of some additional limitations. Can I call my Python code from C?¶ Answer: Yes, easily. Follow the example in Demos/callback/ in the Cython source distribution. How do I interface numpy arrays using Cython?¶ How do I compile Cython with subpackages?¶ Answer: It’s highly recommended to arrange Cython modules in exactly the same Python package structure as the Python parts of the code base. As long as you don’t keep your Cython code in unusual places, everything should just work. This is in part due to the fact that fully qualified names are resolved at compile time, and moving files around or adding files between the Cython compile and the Python runtime invocation means that cimports and imports may resolve differently. Failure to do this may result in errors like .pxd files not found or . How do I speed up the C compilation?¶ Answer: Especially with large modules, the code that Cython generates can take the C compiler quite some time to optimise. This is usually ok for production builds, but during development, this can get in the way. It can substantially speed up the C compiler runs to disable the code optimisation, e.g. by setting the environment variable on Linux or MacOS, which also enables full debugging symbols for better crash reports and debugger usage. For MSVC on Windows, you can pass the option to disable all optimisations. How do I reduce the size of the binary modules?¶ Answer: The Python distutils build often includes debugging symbols in the extension modules. The default for gcc is , for example. Disabling them ( for gcc), or setting them to the bare minimum that is required to produce stack traces on crashes ( for gcc), can visibly reduce the size of the binaries. Here are some more things to try:\n• None If you don’t need pickle support for your cdef classes, memoryviews or functions, consider disabling auto-pickle support with a directive: # you can still enable or disable it locally for single class:\n• None If you do not need C line information in exception stack traces (i.e. Python/Cython lines are enough, as for normal Python code), you can disable this feature with the C macro : In Cython versions before 3.1, you also had to pass the option or set the option to get the reduction in size.\n• None If you do not need Cython implemented functions to look and behave like Python functions when it comes to introspection (argument names, annotations, etc.), you can turn off the directive, either globally, or locally for classes or specific functions. This will make Cython use the normal CPython implementation for natively implemented functions, which does not expose such functionality.\n• None If you do not need to expose the docstrings of Python functions and classes, you can exclude them from the extension module with the option . How well is Unicode supported?¶ Answer: The support for Unicode is as good as CPython’s, but additionally distinguishes between the Python ( in Python 2.7) and (always Unicode text) string type. Note that there is no equivalent C type available for Unicode strings, but Cython can automatically convert (encode/decode) from and to encoded C/C++ strings ( / ).\n\nHow do I help Cython find numpy header files?¶ Answer: If you are seeing errors like these: You should modify your setup.py file to grab the numpy include directory as follows: How do I declare numeric or integer C types?¶ Answer: In most cases, you don’t need to. For types declared in , just them from which comes with Cython, e.g. For non-standard types, it’s enough to provide Cython with a declaration that maps them to a closely related standard C type, e.g. Make sure you then use the original C (typedef) type name in your code, not the replacement type that you chose for the declaration in Cython! The exact size of the type at C compile time is not that important because Cython generates automatic size detection code (evaluated at C compile time). However, when your code mixes different types in arithmetic code, Cython must know about the correct signedness and the approximate longness in order to infer the appropriate result type of an expression. Therefore, when using a as above, try to come up with a good approximation of the expected C type. Since the largest type wins in mixed arithmetic expressions, it’s usually not a problem if the type turns out to be somewhat larger than what the C compiler eventually determines for a given platform. In the worst case, if your replacement type is substantially larger than the real C type (say, ‘long long’ instead of ‘int’), you may end up with slightly slower conversion code. However, if the type is declared too small and Cython considers it smaller than other types it is used together with, Cython may infer the wrong type for an expression and may end up generating incorrect coercion code. You may or may not get a warning by the C compiler in this case. Also note that Cython will consider large integer literals (>32 bit signed) unsafe to use in C code and may therefore use Python objects to represent them. You can make sure a large literal is considered a safe C literal by appending a C suffix, such as ‘LL’ or ‘UL’. Note that a single ‘L’ is not considered a C suffix in Python 2 code. How do I declare an object of type bool?¶ Answer: Well, that depends on whether you want the C99/C++ or the Python . Previously, Cython always defaulted to the Python type, which led to hard-to-debug issues when users unsuspectingly used in wrapping C++ code. We decided to make the choice explicit – you can import whichever you’d like:\n• None For the Python type, do .\n• None For the C++ type, do . Note that there is also a type called , which is essentially a C but automatically coerces from and to a Python bool value, i.e. gives either or . How do I use ?¶ Answer: You can just use it in your code and in your declarations. How do I use builtins like with the C type ?¶ Answer: Cython maps directly to , which means that it will count the number of characters up to the first 0 byte. Similarly, is optimised into a C-API call, and applying it to sliced values will skip the length counting step. For other Python operations on , the generated code may be inefficient, as a temporary object may have to get created. If you notice this for your code and think that Cython can do better, please speak up on the mailing list. How do I make a cdef’d class that derives from a builtin Python type such as list?¶ Answer: You can just use the type as a base class in your cdef class declaration. The only exception are the types bytes (‘str’ in Python 2) and tuple, which can only be subtyped by Python classes (not cdef classes). This is considered a bug. However, you can safely subtype ‘unicode’ and ‘list’ instead. How do I raise an exception in Cython code that will be visible to ancestor (in the callstack) CPython code?¶ If your cdef or cpdef function or method does not declare a return type (as is normal in CPython code), then you get exceptions without any extra effort. If your cdef or cpdef function or method declares a C-style return type, see Error return values. How do I assign to a global variable?¶ Answer: You need to declare the variable to be global (see above) before trying to assign to it. Often this occurs when one has code like This will result in an error “Cannot convert to Python object.” This is because, as in Python, assignment declares a local variable. Instead, you must write See http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces for more details. How do I create objects or apply operators to locally created objects as pure C code?¶ Answer: For methods like and the Python calling convention is mandatory and identical for all objects, so Cython cannot provide a major speed-up for them. To instantiate an extension type, however, the fastest way is to actually use the normal Python idiom of calling the method of a type: # calling \"__new__()\" will not call \"__init__()\" ! \"This class cannot be instantiated from Python\" Note that this has similar restrictions as the normal Python code: it will not call the method (which makes it quite a bit faster). Also, while all Python class members will be initialised to None, you have to take care to initialise the C members. Either the method or a factory function like the one above are good places to do so. How do I implement a single class method in a Cython module?¶ Answer: As of Cython 3.0, Cython-defined methods bind by default. That means that the following should work: How do I pass string buffers that may contain 0 bytes to Cython?¶ You need to use either a Python byte string object or a char*/length pair of variables. The normal way to convert a char* to a Python byte string is as follows: However, this will not work for C strings that contain 0 bytes, as a 0 byte is the normal C way of terminating a string. So the above method will cut the string at the first 0 byte. To handle this case correctly, you have to specify the total length of the string that you want to convert: # take the first 21 bytes of the string, including the \\0 byte Note that this will not handle the case that the specified slice length is longer than the actual C string. This code will crash if the allocated memory area of the is shorter. There is also support for decoding a C string slice efficiently into a Python unicode string like this: How do I pass a Python string parameter on to a C library?¶ Answer: It depends on the semantics of the string. Imagine you have this C function: For binary data, you can simply require byte strings at the API level, so that this will work: It will raise an error (with a message that may or may not be appropriate for your use case) if users pass other things than a byte string. For textual data, however, you must handle Unicode data input. What you do with it depends on what your C function accepts. For example, if it requires UTF-8 encoded byte sequences, this might work: Note that this also accepts subtypes of the Python unicode type. Typing the “text” parameter as “unicode” will not cover this case. How do I use variable args?¶ Answer: For a regular function, just use as in Python. For a C-function it can’t be done cleanly yet, but you can use the C mechanism: How do I make a standalone binary from a Python program using cython?¶ Answer: You probably want a recipe something like this: The magic is the option, which embeds a copy of the Python interpreter main in the generated C. You’ll want to change to reflect the name of your script, of course, and as appropriate. More details can be found in the embedding documentation. How do I have to wrap C code that uses the restrict qualifier?¶ Answer: There currently is no way of doing this directly into C code. Cython does not understand the restrict qualifier. However you can wrap your way around it. See the following example code: This is a simple, but optimized PEG (Parser Expression Group) parser. It will parse through anything you hand it provided what you hand it This avoids the problems using the restrict qualifiers (Such as are needed with the functions declared in regex.h on FreeBSD [at least 7.X]) by allowing the C compiler to handle things going from C to C, Cython’s support for this even using the “const trick” doesn’t seem to behave properly (at least as of 0.12). the following commands will generate your compiled module from the above source: It is also possible to use distutils by adding the file cslurp.c (or your files name) to the list of files to be compiled for the extension. How do I automatically generate Cython definition files from C (.h) or C++ (.hpp) header files ?¶ Answer: Several people have created scripts to parse header files and automatically produce Cython bindings. autowrap automatically generates python extension modules for wrapping C++ libraries based on annotated (commented) cython pxd files. Current features include wrapping of template classes, enums, free functions and static methods as well as converters from Python data types to (many) STL containers and back. Finally, also manually written Cython code can be incorporated for wrapping code. Automatically generate pxd from C headers. It uses [pycparser](https://github.com/eliben/pycparser) to parse the definitions, so the only requirement beyond python dependencies is a C preprocessor on PATH. How do I run doctests in Cython code (pyx files)?¶ Cython generates a dictionary in the module that contains all docstrings of Python visible functions and classes that look like doctests (i.e. that contain ). The doctest module will properly pick this up and run the doctests. This is run from the command line, passing a command to Python: (This still won't let a Cython module run its own doctests when called with \"python mymod.py\", but it's pretty close. Further options can be passed to testmod() as desired, e.g. Return true if the given object is defined in the given module. # [XX] no way not be sure. \"object must be a class or function\" Extract docstrings from cython functions, that would be skipped by doctest All other arguments are passed directly to doctest.testmod(). How do I work around the when installing on OS X?¶ This is a known issue in OS X with some Python installs. It has nothing to do with Cython, and you will run on the same trouble every time you want to build an C extension module. This is the most sane (if not the only) way to fix it: That should output the full path of a ‘Makefile’… Open that file with any text editor and remove all occurrences of ‘-Wno-long-double’ flag. How do I work around the “unable to find vcvarsall.bat” error when using MinGW as the compiler (on Windows)?¶ Answer: This error means that Python cannot find the C++ compiler on your system. Normally, this is managed by distutils, but it may happen that it’s not yet up-to-date. For example, you may be using this in setup.py: Instead, you can try to load setuptools, which will monkey-patch distutils to find vcvarsall.bat: In IPython, you can just import setuptools, like this: If this is unsuccessful, try the following workarounds. If no python libraries are imported, define the compiler by adding the following statement: Therefore, the line should read: This, however, does not solve the issue when using the pyximport method (see the tutorial). Alternatively, the following patch can be applied. Open the file pyximport/pyxbuild.py and add the four lines marked with “+” at the appropriate place. Finally, if this does not work, create a file called “pydistutils.cfg” in notepad and give it the contents: Save this to the home directory, which can be found by typing at the command prompt:\n\nWhat is the difference between a and file? When should either be used?¶ SHORT Answer: You should always use .pxd files for declarations and .pxi files only for code that you want to include. MEDIUM Answer: A .pxd files are lists of declarations, .pxi files are textually included, and their use for declarations is a historical artifact of the way common declarations were shared before .pxd files existed. LONG Answer: A .pxd file is a declaration file, and is used to declare classes, methods, etc. in a C extension module, (typically as implemented in a .pyx file of the same name). It can contain declarations only, i.e. no executable statements. One can things from .pxd files just as one would import things in Python. Two separate modules cimporting from the same .pxd file will receive identical objects. A .pxi file is an include file and is textually included (similar to the C directive) and may contain any valid Cython code at the given point in the program. It may contain implementations (e.g. common cdef inline functions) which will be copied into both files. For example, this means that if I have a class A declared in a.pxi, and both b.pyx and c.pyx do then I will have two distinct classes b.A and c.A. Interfaces to C libraries (including the Python/C API) have usually been declared in .pxi files (as they are not associated to a specific module). It is also re-parsed at every invocation. Now that can be used, there is no reason to use .pxi files for external declarations. What is better, a single big module or multiple separate modules?¶ Answer: In short, one big module is clumsy to handle but allows broader optimisations by the C compiler. The compile time might actually decrease for multiple modules since the build can be parallelised. The “build_ext” command in distutils has a “-j” option since Py3.5. Also, smaller modules are usually faster to compile by the C compiler, because some optimisations may involve non-linear overhead. The distribution size, and the size per module, will probably increase when splitting a module because there are some things that Cython has to copy into each module. There is a feature request that would mitigate this. C calls between modules are slightly slower than C calls inside of a module, simply because the C compiler cannot optimise and/or inline them. You will have to use shared .pxd declarations for them, which will then call through a function pointer. If modules use a functional split, however, this should not hurt too much. It might still be a good idea to create a shared .pxd file (or .pxi) with inline functions for performance critical code that is used in multiple modules. When splitting an existing module, you will also have to deal with the API changes. Leaving some legacy imports here and there, or turning a module into a package that merges the module namespaces back together via imports, might prevent code breakage for users of your original module when you move names around and redistribute them across multiple modules. What is the difference between and ?¶ Answer: A variable of type is a simple C pointer, just like . It is not reference counted, which is sometimes referred to as a borrowed reference. An variable is an owned reference to a Python object. You can convert one into the other by casting: * # this increases the reference count to the list Note that the lifetime of the object is only bound to its owned references, not to any C pointers that happen to point to it. This means that in the example above becomes invalid as soon as the last reference to the object dies: * # last reference to list dies here Pointers are commonly used when passing objects through C callbacks, e.g. Once again, care must be taken to keep the objects alive as long as any pointers to them are still in use. Why does Cython not always give errors for uninitialized variables?¶ Answer: Cython does some static checks for variable initialization before use during compile time, but these are very basic, as Cython has no definite knowledge what paths of code will be taken at runtime: With CPython, both functions lead to the following exception: With Cython, the first variant prints “None”, the second variant leads to a compile time error. Both behaviours differ from CPython’s. This is considered a BUG and will change in the future. Why does a function with cdef’d parameters accept None?¶ Answer: It is a fairly common idiom in Python to use as a way to mean “no value” or “invalid”. This doesn’t play well with C, as is not compatible with any C type. To accommodate for this, the default behavior is for functions with cdefed parameters to also accept None. This behavior was inherited from Pyrex, and while it has been proposed that it be changed, it will likely stay (at least for a while) for backwards capability. You have four choices for how to handle in your code:\n• None In Cython 3.x, use Python type annotations instead of Cython syntax. Python type annotations distinguish between and , where the first disallows and the second explicitly allows it. allows it as well because it is explicitly required by the provided default value.\n• None If you want to consider invalid input, then you need to write code that checks for it, and raised an appropriate exception.\n• None If you want Cython to raise an exception if is passed in for an extension type parameter, you can use the declaration: which is a short-hand for\n• None You can also put at the top of your file and all access will be checked for None, but it will slow things down, as it is adding a check on every access, rather that once on function call.\n\nAnswer: Not officially, no. However, it compiles almost all existing Python code, which gets it pretty close to a real Python implementation. The result depends on the CPython runtime, though, which we consider a major compatibility advantage. In any case, it is an official goal for Cython to compile regular Python code and run (most of) the normal Python test suite - obviously faster than CPython. ;-) Answer: For most things, yes. For example, a Cython compiled pybench runs more than 30% faster in total, while being 60-90% faster on control structures like and -loops. We regularly run the tests from the CPython benchmark suite (which includes Django templates, 2to3, computational benchmarks and other applications) and most of them work out-of-the-box without modifications or static typing, with a performance increase of 20-60%. However the main advantage of Cython is that it scales very well to even greater performance requirements. For code that operates heavily on common builtin types (lists, dicts, strings), Cython can often speed up processing loops by factors. For numerical code, speed-ups of 100-1000 times compared to CPython are not unusual, and are achieved by simply adding static type declarations to performance critical parts of the code, thus trading Python’s dynamic typing for speed. As this can be done at any granularity in the code, Cython makes it easy to write simple Python code that is fast enough, and just tune the critical 5% of your code into maximum performance by using static C types in just the right places. Answer: From Cython 0.21 on, the supported versions are 2.6, 2.7 and 3.4+, with Python 2.6 being phased out implicitly due to lack of testing capabilities. Cython 3.0 removes support for Python 2.6 completely and requires either Python 2.7 or Python 3.4+. Python 2.x support is scheduled for removal in Cython 3.1, which will probably require Python 3.6 or later at the time of its release. The C code generated by Cython is portable and builds in all supported Python versions. All supported CPython release series are tested regularly. New CPython versions are usually supported before they are released. The source code that Cython compiles can use both Python 2 and Python 3 syntax, defaulting to Python 2 syntax in Cython 0.x and Python 3 syntax in Cython 3.x and later. When compiling Cython modules (.pyx files) in Python 2 mode, most Python 3 syntax features are available by default if they do not interfere with Python 2 syntax (as in Python 2.7), but the general language semantics are defined as in Python 2. When compiling Python modules (.py files), the special Cython syntax (such as the keyword) is not available. For both input types, the language level can be set to Python 3 by either passing the “-3” option to the compiler, or by putting at the top of the module file (within the first comment and before any code or empty lines). With Cython 3.x, compiling Python 2 code requires the option “-2” or the directive . By default, with the Python 3 semantics in Cython 3.0, is a function, loop variables in list comprehensions do not leak into the outer scope, etc. This is equivalent to or the option . If you instead select , then, additionally, unprefixed strings are always unicode strings. Answer: You can use the output of Pyrex/Cython however you like (and license it how you like - be it BSD, public domain, GPL, all rights reserved, whatever). More details: The Python License is different from the GPL used for GCC, for example. GCC requires a special exception clause for its output as it is linked against the library part of GCC, i.e. against GPL software, which triggers the GPL restrictions. Cython doesn’t do anything similar, and linking against Python is not restricted by the Python License, so the output belongs to the User, no other rights or restrictions involved. Also, all of the copyright holders of Pyrex/Cython stated in mailing list that people are allowed to use the output of Pyrex/Cython however they would like. How do I cite Cython in an academic paper?¶ Answer: If you mention Cython, the simplest way to reference us is to add the URL to our website in a footnote. You may also choose to reference our software project in a more formal way, such as For a yet more formal citation, there is a journal paper on Cython. If you wish to cite it, here’s the Bibtex: What is the relation between Cython and Pyrex?¶ Years later, Pyrex development has effectively stopped, whereas Cython has kept adding new features and support for new Python versions. As of 2023, Pyrex is only of historical interest."
    },
    {
        "link": "https://stackoverflow.com/questions/21831045/cythonize-a-pyc-no-pyx-available",
        "document": "Cython is a superset of Python, and hence you can cythonize a file. I say this because files can be decompiled to file. There are several libraries that can do this, however, I would suggest that you have a look at this question asked previously.\n\nAlthough this can be done, there are no real benefits, your python code can at most gain a 20% speed boost."
    },
    {
        "link": "https://stackoverflow.com/questions/22507592/making-an-executable-in-cython",
        "document": "What you want is the flag for the Cython compiler. There isn't a ton of documentation on it, but this is what I was able to find. It does link to a simple working example.\n\nTo compile the Cython source code to a C file that can then be compiled to an executable you use a command like and then compile with whichever C compiler you are using.\n\nWhen you compile the C source code, you will still need to include the directory with the Python headers and link to the corresponding Python shared library on your system (a file named something like or if you are using Python 2.7).\n\nEdit: Here are some more instructions on how to get the commands for including the proper headers and linking against the proper libraries.\n\nAs I said earlier, you need to run the Cython compiler like this:\n\nTo compile using gcc, you will need to find where the python headers are on your system (you can get this location by running (you'll have to import it first). It is probably just the subdirectory in your Python installation directory.\n\nYou will also have to find the python shared library. For Python 2.7 it would be on Windows or on Linux.\n\nYour gcc command will then be\n\nIt may be wise to include the flag. On Windows 64 bit machines you will also have to include the flags that tells mingw to compile for 64 bit windows.\n\nIf you are compiling something that depends on NumPy, you will also need to include the directory containing the NumPy headers. You can find this folder by running (again, after importing numpy). Your gcc command then becomes\n\nThis gcc command option guide may be helpful.\n\nAlso, I would recommend you use Cython memory views if possible. That will make it so that you won't have to include the NumPy headers and include the NumPy pxd file in your Cython file. It also makes slicing operations easier for the C compiler to optimize."
    },
    {
        "link": "https://groups.google.com/g/cython-users/c/V-i0a8r-x00",
        "document": "> Jon Olav Vik, 21.07.2011 23:15: \n\n> \n\n> > This differs in some respects from the \"python -m pyxtest\" \n\n> > functionality that I would like: \n\n> > * It recompiles the module every time, rather than using whatever \n\n> > pyxtest.so or pyxtest.pyd already exists. \n\n> > * It requires me to know the exact path (and extension) of the module, \n\n> > rather than looking it up on the PYTHONPATH. \n\n> > * Installing Cython doesn't copy \"cythonrun\" to a bin directory on the \n\n> > PATH. Of course, I could do that manually; I'm merely suggesting that \n\n> > cythonrun be treated like e.g. pydoc, which can be invoked by either \n\n> > \"pydoc ...\" (on Linux) or \"python -m pydoc ...\". \n\n> \n\n> Sure. We take patches. \n\n \n\n On Jul 21, 11:28 pm, Stefan Behnel < stefan...@behnel.de > wrote:> Jon Olav Vik, 21.07.2011 23:15:> > This differs in some respects from the \"python -m pyxtest\"> > functionality that I would like:> > * It recompiles the module every time, rather than using whatever> > pyxtest.so or pyxtest.pyd already exists.> > * It requires me to know the exact path (and extension) of the module,> > rather than looking it up on the PYTHONPATH.> > * Installing Cython doesn't copy \"cythonrun\" to a bin directory on the> > PATH. Of course, I could do that manually; I'm merely suggesting that> > cythonrun be treated like e.g. pydoc, which can be invoked by either> > \"pydoc ...\" (on Linux) or \"python -m pydoc ...\".> Sure. We take patches.\n\n\n\n> > * It seems to ignore the setup.py file (?); \n\n> \n\n> Using a \"setup.py\" doesn't make sense for a module on the PYTHONPATH, so \n\n> that's a contradicting goal. \n\n \n\n\n\n\n\n> > then how would I specify \n\n> > e.g. include_dirs and library_dirs? \n\n> \n\n> According to the source code (hint, hint), \n\n \n\n\n\n\n\n> you can at least pass CFLAGS. \n\n> Don't think there's currently a way to pass external libraries. \n\n \n\n\n\nI'm aware of that. However, makefiles and distutils, compiler issuesand the internal workings of Cython are all somewhat beyond me, so allI can offer for now is to articulate my suggestions as an appreciativeend-user.Sorry if I was being unclear, but what I've always done is \"compileonce, then place on pythonpath\". Doesn't Cython itself use a setup.pyto install itself on the pythonpath? (If I were more familiar withdistutils, I guess I could make an \"install\" option in addition to\"build_ext\".) Currently, the actual way I compile my modules and placethem on the pythonpath is as follows.1. Write my .pyx file.2. Hack together a setup.py file by modifying an existing one.3. python setup.py build_ext --inplace.4. Somehow place the compiled module on the PYTHONPATH:4a. Manually copy the .so or .pyd file to somewhere on the pythonpath,or4b. Have the .pyx and something_setup.py file already on thepythonpath, so the .so or .pyd file also ends up there (this requiresgiving each something_setup.py a unique name, and removing the \"build\"subdirectory between compilations).4c. Make subdirectories, within the pythonpath, with something.pyx andsetup.py, so I can \"import something.something\" (this is what I do forcythonization of autogenerated code).I may be missing the nuances between using a setup.py (usingdistutils, if I understand correctly) and using Cython.Build. Also,there is pyximport, which I've only got to work when I didn't need tospecify include_dirs or library_dirs. Is there some documentation Iought to read about this?Please understand that I do put in quite a lot of googling, readingdocstrings, and also looking at source code before bothering the listwith questions. (Digression: My only experience with CFLAGS comes fromfollowing other people's installation instructions, and both CFLAGS,include_dirs and library_dirs look like voodoo from my point ofvantage.) I represent the user who is quite skilled in pure Python andhigh-level scientific computing, and is using Cython to minimize mydealings with the intricacies of C. I think this is an importantmarket segment for Cython, but users are likely to be alienated byadmonishments for not knowing how to debug C compilation.Okay, thank you. In either case, it seems cythonrun is solving adifferent issue than mine.Jon Olav"
    },
    {
        "link": "https://stackoverflow.com/questions/39657830/cythonize-dynamic-pyx-function",
        "document": "I've created a file dynamically, but struggle to cythonize and use the function encoded in it.\n\nbut this doesn't seem to work. Any idea how can I do this?"
    },
    {
        "link": "https://stackoverflow.com/questions/7508803/how-do-i-import-function-from-pyx-file-in-python",
        "document": "I'm trying to run Hadoopy, which has a file _main.pyx, and is failing with module not found in __init__.py.\n\nI'm trying to run this on OS X w/ standard python 2.7."
    },
    {
        "link": "https://github.com/cython/cython/issues/2113",
        "document": "I have build a compiler that generates some pyx code. Can you tell me how to properly load (reload) a module using pyximport? Note that this code is run several times, and each module must remain usable. The code that doesnt work:"
    },
    {
        "link": "https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html",
        "document": "Cython source file names consist of the name of the module followed by a extension, for example a module called primes would have a source file named .\n\nCython code, unlike Python, must be compiled. This happens in two stages:\n\nOnce you have written your / file, there are a couple of ways how to turn it into an extension module.\n\nThe following sub-sections describe several ways to build your extension modules, and how to pass directives to the Cython compiler.\n\nThere are also a number of tools that process files apart from Cython, e.g.\n\nThere are two ways of compiling from the command line.\n• None The cython command takes a or file and compiles it into a C/C++ file.\n• None The cythonize command takes a or file and compiles it into a C/C++ file. It then compiles the C/C++ file into an extension module which is directly importable from Python. One way is to compile it manually with the Cython compiler, e.g.: This will produce a file called , which then needs to be compiled with the C compiler using whatever options are appropriate on your platform for generating an extension module. For these options look at the official Python documentation. The other, and probably better, way is to use the extension provided with Cython. The benefit of this method is that it will give the platform specific compilation options, acting like a stripped down autotools. Run the cythonize compiler command with your options and list of files to generate an extension module. For example: This creates a file (or in C++ mode), compiles it, and puts the resulting extension module ( or , depending on your platform) next to the source file for direct import ( builds “in place”). The switch additionally produces an annotated html file of the source code. The cythonize command accepts multiple source files and glob patterns like as argument and also understands the common option for running multiple parallel build jobs. When called without further options, it will only translate the source files to or files. Pass the flag for a complete list of supported options. There simpler command line tool cython only invokes the source code translator. In the case of manual compilation, how to compile your files will vary depending on your operating system and compiler. The Python documentation for writing extension modules should have some details for your system. On a Linux system, for example, it might look similar to this: After compilation, a ( for Windows) file is written into the target directory and your module, , is available for you to import as with any other Python module. Note that if you are not relying on cythonize or , you will not automatically benefit from the platform specific file extension that CPython generates for disambiguation, such as on a regular 64bit Linux installation of CPython 3.5.\n\nThe setuptools extension provided with Cython allows you to pass files directly to the constructor in your setup file. If you have a single Cython file that you want to turn into a compiled extension, say with filename the associated would be: If your build depends directly on Cython in this way, then you may also want to inform pip that is required for to execute, following PEP 518, creating a file containing, at least: To understand the more fully look at the official setuptools documentation. To compile the extension for use in the current directory use: setuptools 74.1.0 adds experimental support for extensions in (instead of ): In this case, you can use any build frontend - e.g. build More details on building Cython modules that use cimport numpy can be found in the Numpy section of the user guide. If you have Cython include files or Cython definition files in non-standard places you can pass an parameter to : If you need to specify compiler options, libraries to link with or other linker options you will need to create instances manually (note that glob syntax can still be used to specify multiple extensions in one line): # Everything but primes.pyx is included here. Some useful options to know about are\n• None - list of directories to search for C/C++ header files (in Unix form for portability),\n• None - list of library names (not filenames or paths) to link against,\n• None - list of directories to search for C/C++ libraries at link time. Note that when using setuptools, you should import it before Cython, otherwise, both might disagree about the class to use here. Often, Python packages that offer a C-level API provide a way to find the necessary C header files: If your options are static (for example you do not need to call a tool like to determine them) you can also provide them directly in your or source file using a special comment block at the start of the file: If you cimport multiple .pxd files defining libraries, then Cython merges the list of libraries, so this works as expected (similarly with other options, like above). If you have some C files that have been wrapped with Cython and you want to compile them into your extension, you can define the setuptools parameter: Note that these sources are added to the list of sources of the current extension module. Spelling this out in the file looks as follows: The class takes many options, and a fuller explanation can be found in the setuptools documentation. Sometimes this is not enough and you need finer customization of the setuptools . To do this, you can provide a custom function to create the final object after Cython has processed the sources, dependencies and directives but before the file is actually Cythonized. This function takes 2 arguments and , where is the object given as input to Cython and is a with all keywords which should be used to create the . The function must return a 2-tuple , where is the created and is metadata which will be written as JSON at the top of the generated C files. This metadata is only used for debugging purposes, so you can put whatever you want in there (as long as it can be converted to JSON). The default function (defined in ) is: In case that you pass a string instead of an to , the will be an without sources. For example, if you do , the will be . Just as an example, this adds as library to every extension: If you Cythonize in parallel (using the argument), then the argument to must be pickleable. In particular, it cannot be a lambda function. The function can take extra arguments which will allow you to customize your build. Compile a set of source modules into C/C++ files and return a list of distutils Extension objects for them.\n• None module_list – As module list, pass either a glob pattern, a list of glob patterns or a list of Extension objects. The latter allows you to configure the extensions separately through the normal distutils options. You can also pass Extension objects that have glob patterns as their sources. Then, cythonize will resolve the pattern and create a copy of the Extension for every matching file.\n• None exclude – When passing glob patterns as , you can exclude certain module names explicitly by passing them into the option.\n• None nthreads – The number of concurrent builds for parallel compilation (requires the module).\n• None aliases – If you want to use compiler directives like but can only know at compile time (when running the ) which values to use, you can use aliases and pass a dictionary mapping those aliases to Python strings when calling . As an example, say you want to use the compiler directive but this path isn’t always fixed and you want to find it when running the . You can then do , find the value of in the , put it in a python variable called as a string, and then call .\n• None quiet – If True, Cython won’t print error, warning, or status messages during the compilation.\n• None force – Forces the recompilation of the Cython modules, even if the timestamps don’t indicate that a recompilation is necessary.\n• None language – To globally enable C++ mode, you can pass . Otherwise, this will be determined at a per-file level based on compiler directives. This affects only modules found based on file names. Extension instances passed into will not be changed. It is recommended to rather use the compiler directive than this option.\n• None exclude_failures – For a broad ‘try to compile’ mode that ignores compilation failures and simply excludes the failed extensions, pass . Note that this only really makes sense for compiling files which can also be used without compilation.\n• None show_all_warnings – By default, not all Cython warnings are printed. Set to true to show all warnings.\n• None annotate – If , will produce a HTML file for each of the or files compiled. The HTML file gives an indication of how much Python interaction there is in each of the source code lines, compared to plain C code. It also allows you to see the C/C++ code generated for each line of Cython code. This report is invaluable when optimizing a function for speed, and for determining when to release the GIL: in general, a block may contain only “white” code. See examples in Determining where to add types or Primes.\n• None annotate-fullc – If will produce a colorized HTML version of the source which includes entire generated C/C++-code.\n• None compiler_directives – Allow to set compiler directives in the like this: . See Compiler directives.\n• None depfile – produce depfiles for the sources if True.\n• None cache – If the cache enabled with default path. If the value is a path to a directory, then the directory is used to cache generated / files. By default cache is disabled. See Cython cache.\n\nIn some scenarios, it can be useful to link multiple Cython modules (or other extension modules) into a single binary, e.g. when embedding Python in another application. This can be done through the inittab import mechanism of CPython. Create a new C file to integrate the extension modules and add this macro to it: If you are only targeting Python 3.x, just use as prefix. Then, for each of the modules, declare its module init function as follows, replacing with the name of the module: In C++, declare them as . If you are not sure of the name of the module init function, refer to your generated module source file and look for a function name starting with . Next, before you start the Python runtime from your application code with , you need to initialise the modules at runtime using the C-API function, again inserting the name of each of the modules: This enables normal imports for the embedded extension modules. In order to prevent the joined binary from exporting all of the module init functions as public symbols, Cython 0.28 and later can hide these symbols if the macro is defined while C-compiling the module C files. Also take a look at the cython_freeze tool. It can generate the necessary boilerplate code for linking one or more modules into a single Python executable.\n\nFor building Cython modules during development without explicitly running after each change, you can use : This allows you to automatically run Cython on every that Python is trying to import. You should use this for simple Cython builds only where no extra C libraries and no special building setup is needed. It is also possible to compile new modules that are being imported (including the standard library and installed packages). For using this feature, just tell that to : In the case that Cython fails to compile a Python module, will fall back to loading the source modules instead. Note that it is not recommended to let build code on end user side as it hooks into their import system. The best way to cater for end users is to provide pre-built binary packages in the wheel packaging format. The function can take several arguments to influence the compilation of Cython or Python files. Call this to install the import hook in your meta-path for a single Python process. If you want it to be installed whenever you use Python, add it to your (as described above).\n• None pyximport – If set to False, does not try to import files.\n• None pyimport – You can pass to also install the import hook in your meta-path. Note, however, that it is rather experimental, will not work at all for some files and packages, and will heavily slow down your imports due to search and compilation. Use at your own risk.\n• None build_dir – By default, compiled modules will end up in a directory in the user’s home directory. Passing a different path as will override this.\n• None build_in_temp – If , will produce the C files locally. Working with complex dependencies and debugging becomes more easy. This can principally interfere with existing files of the same name.\n• None setup_args – Dict of arguments for Distribution. See .\n• None reload_support – Enables support for dynamic , e.g. after a change in the Cython code. Additional files may arise on that account, when the previously loaded module file cannot be overwritten.\n• None load_py_module_on_import_failure – If the compilation of a file succeeds, but the subsequent import fails for some reason, retry the import with the normal module instead of the compiled module. Note that this may lead to unpredictable results for modules that change the system state during their import, as the second import will rerun these modifications in whatever state the system was left after the import of the compiled module failed.\n• None inplace – Install the compiled module ( for Linux and Mac / for Windows) next to the source file.\n• None language_level – The source language level to use: 2 or 3. The default is to use the language level of the current Python runtime for .py files and Py2 for files. Since does not use internally, it currently requires a different setup for dependencies. It is possible to declare that your module depends on multiple files, (likely and files). If your Cython module is named and thus has the filename then you should create another file in the same directory called . The file can be a list of filenames or “globs” (like or ). Each filename or glob must be on a separate line. Pyximport will check the file date for each of those files before deciding whether to rebuild the module. In order to keep track of the fact that the dependency has been handled, Pyximport updates the modification time of your “.pyx” source file. Future versions may do something more sophisticated like informing setuptools of the dependencies directly. does not use . Thus it is not possible to do things like using compiler directives at the top of Cython files or compiling Cython code to C++. Pyximport does not give you any control over how your Cython file is compiled. Usually the defaults are fine. You might run into problems if you wanted to write your program in half-C, half-Cython and build them into a single library. Pyximport does not hide the setuptools/GCC warnings and errors generated by the import process. Arguably this will give you better feedback if something went wrong and why. And if nothing went wrong it will give you the warm fuzzy feeling that pyximport really did rebuild your module as it was supposed to. Basic module reloading support is available with the option . Note that this will generate a new module filename for each build and thus end up loading multiple shared libraries into memory over time. CPython has limited support for reloading shared libraries as such, see PEP 489. Pyximport puts both your file and the platform-specific binary into a separate build directory, usually . To copy it back into the package hierarchy (usually next to the source file) for manual reuse, you can pass the option .\n\nIt’s possible to compile code in a notebook cell with Cython. For this you need to load the Cython magic: Then you can define a Cython cell by writing on top of it. Like this: Note that each cell will be compiled into a separate extension module. So if you use a package in a Cython cell, you will have to import this package in the same cell. It’s not enough to have imported the package in a previous cell. Cython will tell you that there are “undefined global names” at compilation time if you don’t comply. The global names (top level functions, classes, variables and modules) of the cell are then loaded into the global namespace of the notebook. So in the end, it behaves as if you executed a Python cell. Additional allowable arguments to the Cython magic are listed below. You can see them also by typing in IPython or a Jupyter notebook. Produce a colorized HTML version of the source which includes entire generated C/C++-code. Output a C++ rather than C file. Force the compilation of a new module, even if the source has been previously compiled. Extra flags to pass to compiler via the extra_compile_args. Extra flags to pass to linker via the extra_link_args. Add a library to link the extension against (can be specified multiple times). Add a path to the list of library directories (can be specified multiple times). Add a path to the list of include directories (can be specified multiple times). Add a path to the list of src files (can be specified multiple times). Specify a name for the Cython module. Enable profile guided optimisation in the C compiler. Compiles the cell twice and executes it in between to generate a runtime profile.\n\nCompiler options can be set in the , before calling , like this: Here are the options that are available: Whether or not to include docstring in the Python extension. If False, the binary size will be smaller, but the attribute of any class or function will be an empty string. Embed the source code position in the docstrings of functions and classes. Decref global variables in each module on exit for garbage collection. 0: None, 1+: interned objects, 2+: cdef globals, 3+: types objects Mostly for reducing noise in Valgrind as it typically executes at process exit (when all memory will be reclaimed anyways). Note that directly or indirectly executed cleanup code that makes use of global variables or types may no longer be safe when enabling the respective level since there is no guaranteed order in which the (reference counted) objects will be cleaned up. The order can change due to live references and reference cycles. Should tp_clear() set object fields to None instead of clearing them to NULL? Generate an annotated HTML version of the input source files for debugging and optimisation purposes. This has the same effect as the argument in . This will abort the compilation on the first error occurred rather than trying to keep going and printing further error messages. Make unknown names an error. Python raises a NameError when encountering unknown names at runtime, whereas this option makes them a compile time error. If you want full Python compatibility, you should disable this option and also ‘cache_builtins’. Make uninitialized local variable reference a compile time error. Python raises UnboundLocalError at runtime, whereas this option makes them a compile time error. Note that this option affects only variables of “python object” type. This will convert statements of the form to when is a C integer type, and the direction (i.e. sign of step) can be determined. WARNING: This may change the semantics if the range causes assignment to i to overflow. Specifically, if this option is set, an error will be raised before the loop is entered, whereas without this option the loop will execute until an overflowing value is encountered. Perform lookups on builtin names only once, at module initialisation time. This will prevent the module from getting imported if a builtin name that it uses cannot be found during initialisation. Default is True. Note that some legacy builtins are automatically remapped from their Python 2 names to their Python 3 names by Cython when building in Python 3.x, so that they do not get in the way even if this option is enabled. Generate branch prediction hints to speed up error handling etc. Enable this to allow one to write to overwrite the definition if the cpdef function foo, at the cost of an extra dictionary lookup on every call. If this is false it generates only the Python wrapper and no override check. Whether or not to embed the Python interpreter, for use in making a standalone executable or calling from external libraries. This will provide a C function which initialises the interpreter and executes the body of this module. See this demo for a concrete example. If true, the initialisation function is the C main() function, but this option can also be set to a non-empty string to provide a function name explicitly. Default is False. Allows cimporting from a pyx file without a pxd file. Maximum number of dimensions for buffers – set lower than number of dimensions in numpy, as slices are passed by value and involve a lot of copying. Number of function closure instances to keep in a freelist (0: no freelists)\n\nCompiler directives are instructions which affect the behavior of Cython code. Here is the list of currently supported directives: Controls whether free functions behave more like Python’s CFunctions (e.g. ) or, when set to True, more like Python’s functions. When enabled, functions will bind to an instance when looked up as a class attribute (hence the name) and will emulate the attributes of Python functions, including introspections like argument names and annotations. Changed in version 3.0.0: Default changed from False to True If set to False, Cython is free to assume that indexing operations ([]-operator) in the code will not cause any IndexErrors to be raised. Lists, tuples, and strings are affected only if the index can be determined to be non-negative (or if is False). Conditions which would normally trigger an IndexError may instead cause segfaults or data corruption if this is set to False. In Python, arrays and sequences can be indexed relative to the end. For example, A[-1] indexes the last value of a list. In C, negative indexing is not supported. If set to False, Cython is allowed to neither check for nor correctly handle negative indices, possibly causing segfaults or data corruption. If bounds checks are enabled (the default, see above), negative indexing will usually raise an for indices that Cython evaluates itself. However, these cases can be difficult to recognise in user code to distinguish them from indexing or slicing that is evaluated by the underlying Python array or sequence object and thus continues to support wrap-around indices. It is therefore safest to apply this option only to code that does not process negative indices at all. If set to True, Cython checks that\n• None a memoryview is initialized whenever its elements are accessed or assigned to.\n• None a C++ class is initialized when it is accessed (only when is on) Setting this to False disables these checks. If set to False, Cython is free to assume that native field accesses on variables typed as an extension type, or buffer accesses on a buffer variable, never occurs when the variable is set to . Otherwise a check is inserted and the appropriate exception is raised. This is off by default for performance reasons. If set to True, Cython sets the slot to to signal that the module is safe to run without an active GIL and prevent the GIL from being enabled when the module is imported. Otherwise the slot is set to which will cause the GIL to be automatically enabled. Setting this to True does not itself make the module safe to run without the GIL; it merely confirms that you have checked the logic and consider it safe to run. Since free-threading support is still experimental itself, this is also an experimental directive that might be changed or removed in future releases. If set to True, raise errors on overflowing C integer arithmetic operations. Incurs a modest runtime penalty, but is much faster than using Python ints. If set to True, and overflowcheck is True, check the overflow bit for nested, side-effect-free arithmetic expressions once rather than at every step. Depending on the compiler, architecture, and optimization settings, this may help or hurt performance. A simple suite of benchmarks can be found in . If set to True, Cython will embed a textual copy of the call signature in the docstring of all Python visible functions and classes. Tools like IPython and epydoc can thus display the signature, which cannot otherwise be retrieved after compilation. If set to , Cython will generate signatures preserving C type declarations and Python type annotations. If set to , Cython will do a best attempt to use pure-Python type annotations in embedded signatures. For arguments without Python type annotations, the C type is mapped to the closest Python type equivalent (e.g., C is mapped to Python type and C is mapped to Python type). The specific output and type mapping are experimental and may change over time. The format generates signatures that are compatible with those understood by CPython’s Argument Clinic tool. The CPython runtime strips these signatures from docstrings and translates them into a attribute. This is mainly useful when using , since the Cython functions generated with do not have (nor need) a attribute. If set to False, Cython will adjust the remainder and quotient operators C types to match those of Python ints (which differ when the operands have opposite signs) and raise a when the right operand is 0. This has up to a 35% speed penalty. If set to True, no checks are performed. See CEP 516. If set to True, Cython will emit a runtime warning whenever division is performed with negative operands. See CEP 516. modifies the return type of , as shown in the table below: C integer (known to be >= 0 at compile time) C integer (may be negative) Return type is C double (note that Python would dynamically pick or here, while Cython doesn’t) C floating point (or C integer) Return type is floating point, result is NaN if the result would be complex Either a C real or complex number at cost of some speed The behaviour largely keeps the result type the same as the operand types, while the behaviour follows Python and returns a flexible type depending on the inputs. Introduced in Cython 3.0 with a default of False; before that, the behaviour matched the version. When disabled, uses the and signatures when constructing functions/methods which take zero or one arguments. Has no effect on special methods and functions with more than one argument. The and signatures provide slightly faster calling conventions but disallow the use of keywords. When enabled, makes the special binary operator methods ( , etc.) behave according to the low-level C-API slot semantics, i.e. only a single method implements both the normal and reversed operator. This used to be the default in Cython 0.x and was now replaced by Python semantics, i.e. the default in Cython 3.x and later is . Write hooks for Python profilers into the compiled C code. Write line tracing hooks for Python profilers or coverage reporting into the compiled C code. This also enables profiling. Note that the generated module will not actually use line tracing, unless you additionally pass the C macro definition to the C compiler (e.g. using the setuptools option ). Define to also include functions and sections. Infer types of untyped variables in function bodies. Default is None, indicating that only safe (semantically-unchanging) inferences are allowed. In particular, inferring integral types for variables used in arithmetic expressions is considered unsafe (due to possible overflow) and must be explicitly requested. Globally set the Python language level to be used for module compilation. Default is None, indicating compatibility with Python 3 in Cython 3.x and with Python 2 in Cython 0.x. To enable Python 3 source code semantics, set this to 3 (or 3str) at the start of a module or pass the “-3” or “–3str” command line options to the compiler. For Python 2 semantics, use 2 and “-2” accordingly. Before Cython 3.1, the option enabled Python 3 semantics but did not change the type and unprefixed string literals to when the compiled code runs in Python 2.x. In Cython 3.1, is an alias for . Language level 2 ignores type annotations due to the int/long ambiguity. Note that cimported files inherit this setting from the module being compiled, unless they explicitly set their own language level. Included source files always inherit this setting. Globally set the type of an implicit coercion from char* or std::string. Globally set the encoding to use when implicitly coercing char* or std:string to a unicode object. Coercion from a unicode object to C type is only allowed when set to or , the latter being utf-8 in Python 3 and nearly-always ascii in Python 2. Enables the attribute cache for extension types in CPython by setting the type flag . Default is True, meaning that the cache is enabled for Cython implemented types. To disable it explicitly in the rare cases where a type needs to juggle with its internally without paying attention to cache consistency, this option can be set to False. Whether to print tracebacks when suppressing unraisable exceptions. PEP 492 specifies that async-def coroutines must not be iterable, in order to prevent accidental misuse in non-async contexts. However, this makes it difficult and inefficient to write backwards compatible code that uses async-def coroutines in Cython but needs to interact with async Python code that uses the older yield-from syntax, such as asyncio before Python 3.5. This directive can be applied in modules or selectively as decorator on an async-def coroutine to make the affected coroutine(s) iterable and thus directly interoperable with yield-from. Uses function argument annotations to determine the type of variables. Since Python does not enforce types given in annotations, setting to False gives greater compatibility with Python code. From Cython 3.0, can be set on a per-function or per-class basis. Copy the original source code line by line into C code comments in the generated code file to help with understanding the output. This is also required for coverage analysis. Make C++ variables behave more like Python variables by allowing them to be “unbound” instead of always default-constructing them at the start of a function. See cpp_locals directive for more detail. When enabled, functions will not propagate raised exceptions by default. Hence, the function will behave in the same way as if declared with keyword. See Error return values for details. Setting this directive to will cause Cython 3.0 to have the same semantics as Cython 0.x. This directive was solely added to help migrate legacy code written before Cython 3. It will be removed in a future release. Whether to expand chained if-else statements (including statements like ) into C switch statements. This can have performance benefits if there are lots of values but cause compiler errors if there are any duplicate values (which may not be detectable at Cython compile time for all C constants). Cython can generate code that optimistically checks for Python method objects at call time and unpacks the underlying function to call it directly. This can substantially speed up method calls, especially for builtins, but may also have a slight negative performance impact in some cases where the guess goes completely wrong. Disabling this option can also reduce the code size. All warning directives take True / False as options to turn the warning on / off. Warns about any variables that are implicitly declared without a declaration Warns about code paths that are statically determined to be unreachable, e.g. returning twice unconditionally. Warns about use of variables that are conditionally uninitialized. Warns about unused assignment to the same name, such as Warns about multiple variables declared on the same line with at least one pointer type. For example - which, as in C, declares as a pointer, as a value type, but could be mininterpreted as declaring two pointers. Warns about use of the deprecated statement in Cython code, see Conditional Compilation and Deprecation of DEF / IF. Warns about use of the deprecated statement in Cython code, see Conditional Compilation and Deprecation of DEF / IF. Show performance hints during compilation pointing to places in the code which can yield performance degradation. Note that performance hints are not warnings and hence the directives starting with above do not affect them and they will not trigger a failure when “error on warnings” is enabled. One can set compiler directives through a special header comment near the top of the file, like this: The comment must appear before any code (but can appear after other comments or whitespace). One can also pass a directive on the command line by using the -X switch: Directives passed on the command line will override directives set in header comments. For local blocks, you need to cimport the special builtin module: Then you can use the directives either as decorators or in a with statement, like this: # turn off boundscheck for this function # turn it temporarily on again for this block These two methods of setting directives are not affected by overriding the directive on the command-line using the -X option. Compiler directives can also be set in the file by passing a keyword argument to : This will override the default directives as specified in the dictionary. Note that explicit per-file or local directives as explained above take precedence over the values passed to .\n\nCython has a number of C macros that can be used to control compilation. Typically, these would be set using in (for example ), however they can also be set in other ways like using the environmental variable. These macros are set automatically by Cython to sensible default values unless you chose to explicitly override them, so they are a tool that most users can happily ignore. Not all combinations of macros are compatible or tested, and some change the default value of other macros. They are listed below in rough order from most important to least important: Turns on Cython’s experimental Limited API support, meaning that one compiled module can be used by many Python interpreter versions (at the cost of some performance). At this stage many features do not work in the Limited API. You should set this macro to be the version hex for the minimum Python version you want to support (>=3.7). will support Python 3.7 upwards. Note that this is a :external+python:c:macro:`Python macro <Py_LIMITED_API>`_, rather than just a Cython macro, and so it changes what parts of the Python headers are visible too. See The Limited API and Stable ABI for more details about this feature. Uses multi-phase module initialization as described in PEP 489. This improves Python compatibility, especially when running the initial import of the code when it makes attributes such as available. It is therefore on by default where supported. Stores module data on a struct associated with the module object rather than as C global variables. The advantage is that it should be possible to import the same module more than once (e.g. in different sub-interpreters). At the moment this is experimental and not all data has been moved. Specifically, globals have not been moved. Defines es as Heap Types rather than “static types”. Practically this does not change a lot from a user point of view, but it is needed to implement Limited API support. These control the inclusion of profiling and line tracing calls in the module. See the and Compiler directives. Slightly different to the other macros, this controls how functions appear to C++ code. See C++ public declarations for full details. Controls whether C lines numbers appear in tracebacks. See C line numbers in tracebacks for a complete description. Passes complex numbers using the C or C++ language standard library types instead of an internal type defined by Cython. Turning it on maximizes compatibility with external libraries. However, MSVC has poor standards support (especially in C mode) and so struggles to use the standard library types. It is on by default on platforms where we think it’s likely to work. There is a further list of macros which turn off various optimizations or language features. Under normal circumstance Cython enables these automatically based on the version of Python you are compiling for so there is no need to use them to try to enable extra optimizations - all supported optimizations are enabled by default. These are mostly relevant if you’re tying to get Cython working in a new and unsupported Python interpreter where you will typically want to set them to 0 to disable optimizations. They are listed below for completeness but hidden by default since most users will be uninterested in changing them. If enabled, Cython will directly access members of the struct. Use the internal function for more efficient access to properties of C classes. Enable optimizations based on direct access into the internals of Python / / objects respectively. Use a faster (but internal) mechanism for building unicode strings, for example in f-strings. Avoid using “borrowed references” and ensure that Cython always holds a reference to objects it manipulates. Most useful for non-reference-counted implementations of Python, like PyPy (where it is enabled by default). Avoid using APIs that return unsafe “borrowed references” and instead use the equivalent APIs that return “strong references”. Most useful for the free-threaded build of CPython, where incrementing the reference count of borrowed references to items in mutable containers might introduce thread safety issues. Borrowed references to items in immutable containers are still allowed with this setting. Use some C-API macros that increase performance by skipping error checking, which may not be safe on all Python implementations (e.g. PyPy). Prefer the C-API macros / inline-functions for builtin types over their counterparts if errors are not expected. On some Python versions this speeds up getting/releasing the GIL. Try to speed up method calls at the cost of code-size. Linked to the compiler directive - this macro is used to selectively enable the compiler directive only on versions of Python that support it. These are used internally to incrementally enable the vectorcall calling mechanism on older Python versions (<3.8). Use the type-slot instead of , as described in PEP 442. Try to optimize attribute lookup by using versioned dictionaries where supported. Use an internal structure to track exception state, used in CPython 3.7 and later. Attempt to provide docstrings also for special (double underscore) methods. Enable the use of freelists on extension types with the @cython.freelist decorator. Enable the use of atomic reference counting (as opposed to locking then reference counting) in Cython typed memoryviews. Debug option for including constant (string/integer/code/…) objects in . By default, Cython avoids GC traversing these objects because they can never participate in reference cycles, and thus would uselessly waste time during garbage collection runs. Makes module state lookup thread-safe (when and are both enabled). This is on by default where it would be helpful, however it can be disabled if you are sure that one interpreter will not be importing your module at the same time as another is using it. Values greater than 1 can be used to select a specific implementation for debugging purposes."
    },
    {
        "link": "https://neurohackademy.github.io/high-performance-python/03-compiling",
        "document": "Typical usage of Cython will include the writing of Python and Cython code side by side in the same library. Consider our Fibonacci series code.\n\nTo mark it as a Cython (rather than Python) file, we place it in a file.\n\nWe create two files. The first is a Cython file that contains the code we’ve already written for the Fibonacci series. We’ll save it as :\n\nIn another file, we’ll set up the compilation. The Python library has functionality to deal with extension code, and Cython knows how to take advantage of that to orchestrate the compilation of files:\n\nTo compile the fib.pyx file, we run the file:\n\nThis creates a compiled object and a bundled Python extension, such that in a Python/IPython session, you can now do:\n\nThe function that we created here is statically typed. That means that, in contrast to a Python function it will only accept the types of objects for which it has been compiled.\n\nFor example, if you run the function with an input for which would fail, it will not . For example, we can try running:\n\nThe dynamically typed Python could not identify that this is not the right type for the operations in this function, but the C code, that is statically typed recognizes this upfront, and fails immediately upon calling the function.\n\nAn even easier way to use cython is through the mechanism. For example, we can create a Python file called that has the following content:\n\nLooking around in this folder, we see that this time, there is no , or files around. This looks like magic, but we can resolve the mystery by asking Python where it loaded this module from:\n\nTypically, we will write an entire Cython module with functions, classes, and so forth. Some of these objects need to have a public interface, so that they can be used by our Python code, but some of these are local to the Cython module, and don’t need to be available to use in python code. We can gain additional performance boosts by defining them in such a way that the compiler knows they don’t need to have a Python interface.\n\nWe can use the keyword to define local functions and even types. For example, in a Cython file called , we define the following function and class:\n\nThese defined objects would be unavailable from the Python side, but will be available to other functions within that file/module. They have the advantage that they have no Python overhead when called, so their performance is very good.\n\nAlternatively, defining these objects with will create both the Cython-available and the Python-available versions of a function or class. Not as simple, because the inputs now need to be something that python knows how to produce (array pointers are not one of those…). Instead, here we use typed memory views. This is a ‘view’ onto the memory occupied by a numpy array from within the C side of things. This makes things go really fast, because instead of passing in the array, you are passing in a view into the memory (see also this blog post for much more details on this).\n\nFinally, make sure that you are not writing Cython code that you could easily get from somewhere else. If it’s a basic operation that many people might use, it’s probably already been implemented (and it’s probably better implemented than you would implement it, see )."
    }
]