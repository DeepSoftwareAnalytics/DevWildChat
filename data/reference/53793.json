[
    {
        "link": "https://askubuntu.com/questions/866161/setting-path-variable-in-etc-environment-vs-profile",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/12351702/how-to-write-a-bash-script-to-set-global-environment-variable",
        "document": "Each and every shell has its own environment. There's no Universal environment that will magically appear in all console windows. An environment variable created in one shell cannot be accessed in another shell.\n\nIt's even more restrictive. If one shell spawns a subshell, that subshell has access to the parent's environment variables, but if that subshell creates an environment variable, it's not accessible in the parent shell.\n\nIf all of your shells need access to the same set of variables, you can create a startup file that will set them for you. This is done in BASH via the file (or through if doesn't exist) or through . Other shells have their own set of startup files. One is used for logins, and one is used for shells spawned without logins (and, as with bash, a third for non-interactive shells). See the manpage to learn exactly what startup scripts are used and what order they're executed).\n\nYou can try using shared memory, but I believe that only works while processes are running, so even if you figured out a way to set a piece of shared memory, it would go away as soon as that command is finished. (I've rarely used shared memory except for named pipes). Otherwise, there's really no way to set an environment variable in one shell and have another shell automatically pick it up. You can try using named pipes or writing that environment variable to a file for other shells to pick it up.\n\nImagine the problems that could happen if someone could change the environment of one shell without my knowledge."
    },
    {
        "link": "https://unix.stackexchange.com/questions/495929/adding-path-to-profile-safely-using-a-script",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://superuser.com/questions/488173/how-can-i-edit-the-path-on-linux",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://baeldung.com/linux/path-variable",
        "document": "In this quick tutorial, we’ll focus on how to add a path to the Linux PATH variable in Bash and Zsh.\n\nSince the methods we use for Bash work for Zsh as well, we’ll first address how to add a new path to the PATH variable in Bash.\n\nThen we’ll explore some Zsh specific ways to do the job.\n\nThe PATH variable is an environment variable containing an ordered list of paths that Linux will search for executables when running a command. Using these paths means that we don’t have to specify an absolute path when running a command.\n\nFor example, if we want to print Hello, world! in Bash, the command echo can be used rather than /bin/echo, so long as /bin is in PATH:\n\nLinux traverses the colon-separated paths in order until finding an executable. Thus, Linux uses the first path if two paths contain the desired executable.\n\nWe can print the current value of the PATH variable by echoing the PATH environment variable:\n\nWe should see a list of colon-separated paths (exact paths may differ):\n\nWe can add a new path to the PATH variable using the export command.\n\nTo prepend a new path, such as /some/new/path, we reassign the PATH variable with our new path at the beginning of the existing PATH variable (represented by $PATH):\n\nTo append a new path, we reassign PATH with the new path at the end:\n\nWhen we use the export command and open a new shell, the added path is lost.\n\nTo persist our changes for the current user, we add our export command to the end of ~/.profile. If the ~/.profile file doesn’t exist, we should create it using the touch command:\n\nThen we can add our export command to ~/.profile.\n\nAdditionally, we need to open a new shell, or source our ~/.profile file to reflect the change. We’d execute:\n\nOr if we’re using Bash, we could use the source command:\n\nWe could also append our export command to ~/.bash_profile if we’re using Bash, but our changes won’t be reflected in other shells, such as Zsh.\n\nWe shouldn’t add our export command to ~/.bashrc because only interactive Bash shells read this configuration file. If we open a non-interactive shell or a shell other than Bash, our PATH change won’t be reflected.\n\nWe can add a new path for all users on a Unix-like system by creating a file ending in .sh in /etc/profile.d/ and adding our export command to this file.\n\nFor example, we can create a new script file, /etc/profile.d/example.sh, and add the following line to append /some/new/path to the global PATH:\n\nAll of the scripts in /etc/profile.d/ will be executed when a new shell initializes. Therefore, we need to open a new shell for our global changes to take effect.\n\nWe can also add our new path directly to the existing PATH in the /etc/environment file:\n\nThe /etc/environment file isn’t a script file, it only contains simple variable assignments, and it’s less flexible than a script. Because of this, making PATH changes in /etc/environment is discouraged. We recommend adding a new script to /etc/profile.d instead.\n\nZsh is getting popular, since it provides a rich set of excellent features. Now let’s see how to add a new path in Zsh.\n\nSo far, we’ve learned methods for adding a new path in Bash. First of all, these methods work for Zsh too.\n\nIf our shell is Zsh, we can append a new path to the $PATH variable in the array way:\n\nAs the example above shows, we used path+=/a/new/path to append a new path to $PATH. Please note that we used the lower case path+=….\n\nThis is because path is an array. It also affects its upper-case partner equivalent $PATH. Zsh has bound these two with typeset builtin by default.\n\nSimilarly, we can prepend a new path in the array way too:\n\nHowever, after adding the new entry to the path array, we shouldn’t forget “export $PATH,” as we did in Bash.\n\nFor compatibility, Zsh first sources .profile, then sources zshenv and zshrc. That is to say, the settings in zshenv and zshrc may override configurations in .profile. Therefore, for Zsh, it would be good if we put settings in Zsh specific configuration files.\n\nSimilar to the bashrc file, /etc/zshrc or ~/.zshrc is only for the interactive shell. So it’s not an ideal place to store $PATH.\n\nThus, if we want all Zsh users to have the $PATH setting, effectively setting $PATH globally, we can put it in /etc/zshenv. It’s worth mentioning that this file may not exist, and we can create it if we want to set something globally.\n\nOn the other hand, if we would like to set $PATH for our user only, we can put $PATH in ~/.zshenv.\n\nIn this article, we learned how Linux uses the PATH variable to find executables when running a command.\n\nWe can prepend or append to PATH, but to persist these changes, we need to put the PATH configuration in the right configuration file.\n\nThis table can summarize it clearly:"
    },
    {
        "link": "https://stackoverflow.com/questions/17189237/how-can-i-write-and-append-using-echo-command-to-a-file",
        "document": "If you want to have quotes, then you must escape them using the backslash character.\n\nThe same holds true if you i.e. also want to write the itself, as it may cause side effects. So you have to use\n\nAnother option would be to use The `'' instead of quotes.\n\nHowever in this case variable substition doesn't work, so if you want to use variables you have to put them outside."
    },
    {
        "link": "https://geeksforgeeks.org/echo-command-in-linux-with-examples",
        "document": "The echo command in Linux is a built-in command that allows users to display lines of text or strings that are passed as arguments. It is commonly used in shell scripts and batch files to output status text to the screen or a file.\n\n[options] = The various options available for modifying the behavior of the `echo` command\n\n[string] = It is the string that we want to display.\n\nThe most straightforward usage of the echo command is to display a text or string on the terminal. To do this, you simply provide the desired text or string as an argument to the echo command.\n\nIf we want to display “Geeks for Geeks”. We use the following command.\n\nOptions Available in `echo` command in Linux\n\nNOTE :- -e here enables the interpretation of backslash escapes\n\n1. \\b : it removes all the spaces in between the text\n\n2. \\c : suppress trailing new line with backspace interpreter ‘-e‘ to continue without emitting new line.\n\nIn the above example, text after \\c is not printed and omitted trailing new line.\n\n3. \n\n : this option creates a new line from where it is used.\n\n4. \\t : this option is used to create horizontal tab spaces.\n\n5. \\r : carriage return with backspace interpreter ‘-e‘ to have specified carriage return in output.\n\nIn the above example, text before \\r is not printed.\n\n6. \\v : this option is used to create vertical tab spaces.\n\n7. \\a : alert return with backspace interpreter ‘-e‘ to have sound alert.\n\nThis command when executed, it will produce an alert sound or Bell.\n\n8. echo *: this command will print all files/folders, similar to ls command.\n\n9. -n: this option is used to omit echoing trailing newline.\n\nThe output of the `echo` can be redirected to a file instead of displaying it on the terminal. We can achive this by using the `>` or `>>` operators for output redirection.\n\nThis will write the output of the echo command to the file name `output.txt`. File will be overwritten if it already exists.\n\nIf we want to append the output in an existing file, we use `>>` instead of `>`.\n\nIn this article we have discussed `echo` command in Linux which is a powerful and versatile tool and allows users to display lines of the text or strings on the terminal. Overall, we can say that by understanding the `echo` command experimenting with its features, we can effectively display message, variables, or any desired text in our Linux."
    },
    {
        "link": "https://earthly.dev/blog/practical-guide-to-linux-echo-cmd",
        "document": "This article explains the Linux command in detail. Earthly improves continuous integration (CI) workflows by isolating shell scripts. Learn how.\n\nLinux is one of the most popular operating systems. It has a powerful command-line interface that allows various commands to be passed as instructions to be executed by the computer. The command is one of the most commonly used Linux commands.\n\nThis tutorial will introduce you to the Linux command, go over its options and their usage, and show you how you can use it.\n\nWhat Is the Command?\n\nis a built-in Linux command that is used to display the text passed in as an argument. It is one of the basic Linux commands used in shell scripting and Bash files to display output status text at the command line.\n\nJust like the Python function that is used to display texts on the screen, is used in Linux, Bash, and C shells for the same purpose. It has a simple syntax with various options:\n\nThe argument is the text or the message you want to display on the terminal, while the option is used to modify the behavior of the text passed.\n\nFor example, to suppress the newline character and display the message “Hello, world!” on a single line, you’ll run the following command:\n\nUnderstanding the Command Options and Their Uses\n\nThe command has a few options that are used to format the string output to the screen. This section will go over some of these options.\n\nprints your output on a new line by default. You can omit trailing newlines by using the option.\n\nYou can also print multiple lines of text without adding new lines after each line; use the option with the echo command.\n\nUse to Add Various Escape Characters\n\ncharacter allows you to use the various escape characters to format the output of your argument in different ways. The option allows to interpret these characters.\n\nThe following escape characters are used with :\n\ncharacter allows you to sound an alert like a beep with an when the output is displayed.\n\nThe character is a backspace character. It is used to erase the previous character in the output string. When the character is encountered in the output string, the terminal emulator will erase the previous character and move the cursor one position to the left.\n\nConsider the following examples:\n\nIn the example above, is erased, and the remaining text is in the output. 2. Print a string with a backspace character at the end\n\nIn the example above, the last letter is erased. 3. Print a string with multiple backspace characters.\n\nThe ‘c’ character in the echo command suppresses the trailing newline that is automatically added to the end of the output. This is useful when printing a string of text that another command or string of text must immediately follow without a line break in between.\n\nHere, “good” is truncated, and everything before the is printed out.\n\nYou can also print a string with and a custom delimiter:\n\n: This means the form feed character, and it lets the printer advance to the next page.\n\nYou can use the form feed character with the command to insert a page break in a text file. For example, the following command will insert a page break in a text file named “newfile.txt”:\n\nThe second example of using the form feed character in an command is to print multiple pages of text on a single line. Here’s an example:\n\nThis will print the text on separate pages.\n\nThe character allows you to add a new line to your output. Here’s an example:\n\nThe character can also be used in combination with other escape characters, such as for a tab, to create more formatted output.\n\nThe character gives you the behavior of horizontal tab spaces.\n\nHere, the character adds horizontal tab spaces between the texts.\n\nThe character gives you the behavior of vertical tab spaces, as shown:\n\nHere, the character adds vertical tab spaces between the texts.\n\nThe character allows you to display the backslash character.\n\nUnlike the option which lets you interpret escape characters, the option ignores all the escape characters in an argument.\n\nHere, the texts are printed as they are passed in, and the escape characters are ignored.\n\nThe command can be used to add new text to a file or overwrite the previous texts in a file. This operation is carried out using the or operators. The operator is used for overwriting the file content, while the operator is used for adding new texts to the file.\n\nThis creates a new file named ‘test.txt’ and adds the text if the file doesn’t exist, or simply adds the new text to the file if it already exists.\n\nTo check the content of the file:\n\nYou can overwrite the text in the file above.\n\nThe file text changes to the following:\n\nUsing the command, you can display the different variables you declared as well as environment variables on your terminal. Here’s an example:\n\nHere, you declared a new variable called and assigned to it. Its value is printed out by adding the sign in front of the variable, which tells that it is a variable and not a text.\n\nYou can also use the echo command to display the value of multiple variables at once by separating them with a space. For example, if you have a second variable that contains the value “hello”, you can display both and by running the following command:\n\nYou may sometimes want to look for a specific file type in a specific directory. In this case, the command will come in handy, as it can be used to display files of a specific type that exist in a directory.\n\nConsider the following example where you display all the files in your Desktop directory:\n\nThis displays all of the files with the extension in your current directory. When searching for documents in your folders, this can be helpful because you can easily filter out if that document type exists. You can also display all files in your directory.\n\nYou can also search for a specific file type in your directory by piping the command to the command.\n\nHere is an example of how you can do this:\n\nIn this example, the command is used to specify the text “myfile.txt”, which is then piped to the command using the pipe operator . The command is used with the option, which tells it to search recursively through all directories and subdirectories for the specified text.\n\nThis command will search for the file named “myfile.txt” within the current directory and all of its subdirectories, and output the results of the search to the terminal.\n\nUsing as an Alternative to the Command\n\nThe command can also be used in place of the ls command to list all the contents of a directory.\n\nHere, you listed all the contents in the desktop directory.\n\nYou can also list only the directories and exclude files:\n\nThis list only contains folders and does not include files in the desktop directory, which is useful when searching for folders in your directory.\n\nTo print the names of only the files in the current directory, you can use the following:\n\nThis will only print the names of files that do not end in a forward slash (/), indicating that they are files and not directories.\n\nThe echo command can be piped with other commands to perform various actions using the pipe operator . Some examples of piping the echo command with other commands are:\n\nUsing With the Command\n\nTo output the result of a command and save it to a file, the echo command can be piped with the tee command:\n\nTo append the output of a command to an existing file, the command can be piped with the command and the -a flag:\n\nUsing With the Command\n\nTo pass the output of a command as input to another command, the command can be piped with the desired command:\n\nUsing With the Command\n\nTo search for a specific string in the output of a command, the command can be piped with the command:\n\nThis would search for the text “world” within the output of the echo command, which in this case is the string “Hello World”. The command will return the string “World” since it matches the search pattern.\n\nYou can use the option with to include the line number in the output:\n\nThis would return “1:world”, indicating that the string “world” was found on line 1 of the output.\n\nBy default, the color of the output of the command matches the terminal theme. You might be in a situation where you need to change the colors, such as when writing a script and you need to show whether a step was successful, which is usually displayed in green, or warn them about a step in which red is used.\n\nThe color output is changed by formatting them using the ANSI escape codes for each color.\n\nHere, you used which represents , followed by the ANSI escape color code for Red , and then an to change the color of the output.\n\nYou can also write a Bash script to perform an action and change color. Here’s an example:\n\nIn this script, we first set a variable called to the value we want to find the square root of. Then, we use the command to pass the function and the value of to the command, which calculates the square root and stores the result in a variable called . Finally, we use the echo command to display the result in the terminal and change its color to green.\n\nSave this script to a file , say, myscript.sh, make it executable with the command: , and then run it with the : to see the green message in the terminal.\n\nHere are the ANSI escape color codes for some colors:\n\nThis tutorial equipped you with the know-how of using the command and its various options like , , and . We explored its uses in different scenarios including text manipulation, outputting variables, and filtering files. Also, we saw how it can be integrated with other commands using the pipe operator for customized output colors.\n\nAs you continue to explore and enhance your command line skills, you might be interested in powering up your Linux build automation. If so, give Earthly a shot. It’s a tool that can significantly simplify and optimize your build processes."
    },
    {
        "link": "https://stackoverflow.com/questions/66704205/append-a-text-to-a-file-in-linux",
        "document": "I am trying to append a text to the existing file in Linux. Currently, instead of appending it to the existing line, it appends content to the next line. How can I append to the same line /or a specific line?\n\nthe output of the file comes in two-line like the one below\n\nhow can I bring output like the below one\n\nHow to bring the appending text to the same /specific line?"
    },
    {
        "link": "https://phoenixnap.com/kb/bash-append-to-file",
        "document": "Bash is one of the most versatile shell scripting languages that provides users with many data manipulation features. It is versatile and offers a convenient way to append content to files without overwriting old data.\n\nAppending to files is especially useful when working with log or configuration files, where you want to preserve the file history and add new information.\n\nIn this tutorial, you will learn various techniques for appending content to files using Bash.\n\nAppend to File in Bash With >> Redirection Operator\n\nOne of the ways to append text to a file in Bash is to use the redirection operator.\n\nThe redirection operator is used in command-line interfaces and shell scripting to control the input and output of commands. Use the operator to redirect a command's output to the end of the specified file. If the file doesn't exist, the system creates it.\n\nThe difference between the and operators is that the operator overwrites any existing contents of the specified file with the command's output. The operator only appends the output without overwriting anything.\n\nWe will test the redirection using the echo command that prints text to standard output. We can redirect that output to append it to a file.\n\nReplace with the file you want to append to. For example:\n\nCheck if the content is in the file using the cat command:\n\nThe output shows that the specified content has been appended to the file.\n\nAnother command that prints text to standard output is printf. The command allows you to format and print text or variables with more control over the output and formatting. That way, you can produce complex outputs and specify the formatting.\n\nThe command utilizes the output of the command and appends it to the specified file, as in the command output.\n\nIf you want to append multiple lines of output to a file, use a Here document (HereDoc). HereDocs are useful when redirecting multiple commands at once.\n\nFor example, pass the contents using the command and append it to a file:\n\nThe command reads the HereDoc and writes the contents to standard output, which is then redirected to the specified file.\n\nAppend to File in Bash With tee Command\n\nThe Linux tee command is a command-line utility that reads from the standard input and writes to both standard output and one or more files at the same time. Use the command with the ( ) option to append the output to a file instead of overwriting it by default.\n\nFor example, use the command to print something to standard output and pipe the output to the command:\n\nThe advantage of using the command instead of the redirection operator is that allows you to simultaneously append text to multiple files and write to files owned by other users if used with .\n\nTo append text to multiple files, specify the files as arguments:\n\nThe command appends the content to all the specified files.\n\nThis tutorial showed how to append text to a file or multiple files in Bash using several methods. Appending to a file in Bash is a straightforward process that can be accomplished using the redirect operator ( ) or the command without overwriting previous content.\n\nNext, learn about Bash math operations, or take a look at our Bash HereDoc tutorial with useful examples."
    }
]