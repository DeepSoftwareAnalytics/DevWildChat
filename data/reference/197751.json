[
    {
        "link": "http://htmlpurifier.org/docs",
        "document": "HTML Purifier has documentation for all types of people. Here is an index of all of them.\n\nEnd-user documentation that contains articles, tutorials and useful information for casual developers using HTML Purifier.\n\nProposed features, as well as the associated rambling to get a clear objective in place before attempted implementation.\n\nMiscellaneous essays, research pieces and other reference type material that may not directly discuss HTML Purifier.\n\nPlaintext documents that are more for use by active developers of the code. They may be upgraded to HTML files or stay as TXT scratchpads."
    },
    {
        "link": "http://htmlpurifier.org/live/configdoc/plain.html",
        "document": "List of allowed class values in the class attribute. By default, this is null, which means all classes are allowed. Lookup table of all allowed link frame targets. Some commonly used link targets include _blank, _self, _parent and _top. Values should be lowercase, as validation will be done in a case-sensitive manner despite W3C's recommendation. XHTML 1.0 Strict does not permit the target attribute so this directive will have no effect in that doctype. XHTML 1.1 does not enable the Target module by default, you will have to manually enable it (see the module documentation for more details.) List of allowed forward document relationships in the rel attribute. Common values may be nofollow or print. By default, this is empty, meaning that no document relationships are allowed. List of allowed reverse document relationships in the rev attribute. This attribute is a bit of an edge-case; if you don't know what it is for, stay away. If null, class will auto-detect the doctype and, if matching XHTML 1.1 or XHTML 2.0, will use the restrictive NMTOKENS specification of class. Otherwise, it will use a relaxed CDATA definition. If true, the relaxed CDATA definition is forced; if false, the NMTOKENS definition is forced. To get behavior of HTML Purifier prior to 4.0.0, set this directive to false. Some rational behind the auto-detection: in previous versions of HTML Purifier, it was assumed that the form of class was NMTOKENS, as specified by the XHTML Modularization (representing XHTML 1.1 and XHTML 2.0). The DTDs for HTML 4.01 and XHTML 1.0, however specify class as CDATA. HTML 5 effectively defines it as CDATA, but with the additional constraint that each name should be unique (this is not explicitly outlined in previous specifications). This is the content of the alt tag of an image if the user had not previously specified an alt attribute. This applies to all images without a valid alt attribute, as opposed to %Attr.DefaultInvalidImageAlt , which only applies to invalid images, and overrides in the case of an invalid image. Default behavior with null is to use the basename of the src tag for the alt. This is the default image an img tag will be pointed to if it does not have a valid src attribute. In future versions, we may allow the image tag to be removed completely, but due to design issues, this is not possible right now. This is the content of the alt tag of an invalid image if the user had not previously specified an alt attribute. It has no effect when the image is valid but there was no alt attribute present. Defines the default text direction (ltr or rtl) of the document being parsed. This generally is the same as the value of the dir attribute in HTML, or ltr if that is not specified. Allows the ID attribute in HTML. This is disabled by default due to the fact that without proper configuration user input can easily break the validation of a webpage by specifying an ID that is already on the surrounding HTML. If you don't mind throwing caution to the wind, enable this directive, but I strongly recommend you also consider blacklisting IDs you use ( %Attr.IDBlacklist ) or prefixing all user supplied IDs ( %Attr.IDPrefix ). When set to true HTML Purifier reverts to the behavior of pre-1.2.0 versions. List of forbidden class values in the class attribute. By default, this is empty, which means that no classes are forbidden. See also %Attr.AllowedClasses In HTML5, restrictions on the format of the id attribute have been significantly relaxed, such that any string is valid so long as it contains no spaces and is at least one character. In lieu of a general HTML5 compatibility flag, set this configuration directive to true to use the relaxed rules. Array of IDs not allowed in the document. PCRE regular expression to be matched against all IDs. If the expression is matches, the ID is rejected. Use this with care: may cause significant degradation. ID matching is done after all other validation. String to prefix to IDs. If you have no idea what IDs your pages may use, you may opt to simply add a prefix to all user-submitted ID attributes so that they are still usable, but will not conflict with core page IDs. Example: setting the directive to 'user_' will result in a user submitted 'foo' to become 'user_foo' Be sure to set %HTML.EnableAttrID to true before using this. Temporary prefix for IDs used in conjunction with %Attr.IDPrefix . If you need to allow multiple sets of user content on web page, you may need to have a seperate prefix that changes with each iteration. This way, seperately submitted user content displayed on the same page doesn't clobber each other. Ideal values are unique identifiers for the content it represents (i.e. the id of the row in the database). Be sure to add a seperator (like an underscore) at the end. Warning: this directive will not work unless %Attr.IDPrefix is set to a non-empty value!\n\nThis directive turns on auto-paragraphing, where double newlines are converted in to paragraphs whenever possible. Auto-paragraphing:\n• Always applies to inline elements or text in the root node,\n• Applies to inline elements or text with double newlines in nodes that allow paragraph tags, tags must be allowed for this directive to take effect. We do not use tags for paragraphing, as that is semantically incorrect. To prevent auto-paragraphing as a content-producer, refrain from using double-newlines except to specify a new paragraph or in contexts where it has special meaning (whitespace usually has no meaning except in tags like , so this should not be difficult.) To prevent the paragraphing of inline text adjacent to block elements, wrap them in tags (the behavior is slightly different outside of the root node.) This directive can be used to add custom auto-format injectors. Specify an array of injector names (class name minus the prefix) or concrete implementations. Injector class must exist. This directive turns on the in-text display of URIs in <a> tags, and disables those links. For example, example becomes example (http://example.com). This directive turns on linkification, auto-linking http, ftp and https URLs. tags with the attribute must be allowed. Location of configuration documentation to link to, let %s substitute into the configuration's namespace and directive names sans the percent sign. Internal auto-formatter that converts configuration directives in syntax %Namespace.Directive to links. tags with the attribute must be allowed. Given that an element has no contents, it will be removed by default, unless this predicate dictates otherwise. The predicate can either be an associative map from tag name to list of attributes that must be present for the element to be considered preserved: thus, the default always preserves , and , and also if it has a . When %AutoFormat.RemoveEmpty and %AutoFormat.RemoveEmpty.RemoveNbsp are enabled, this directive defines what HTML elements should not be removede if they have only a non-breaking space in them. When enabled, HTML Purifier will treat any elements that contain only non-breaking spaces as well as regular whitespace as empty, and remove them when %AutoForamt.RemoveEmpty is enabled. See %AutoFormat.RemoveEmpty.RemoveNbsp.Exceptions for a list of elements that don't have this behavior applied to them. When enabled, HTML Purifier will attempt to remove empty elements that contribute no semantic information to the document. The following types of nodes will be removed:\n• Tags with no attributes and no content, and that are not empty elements (remove but not ), and\n• Tags with no content, except for:\n• Elements with the or attribute, when those attributes are permitted on those elements. Please be very careful when using this functionality; while it may not seem that empty elements contain useful information, they can alter the layout of a document given appropriate styling. This directive is most useful when you are processing machine-generated HTML, please avoid using it on regular user HTML. Elements that contain only whitespace will be treated as empty. Non-breaking spaces, however, do not count as whitespace. See %AutoFormat.RemoveEmpty.RemoveNbsp for alternate behavior. This algorithm is not perfect; you may still notice some empty tags, particularly if a node had elements, but those elements were later removed because they were not permitted in that context, or tags that, after being auto-closed by another tag, where empty. This is for safety reasons to prevent clever code from breaking validation. The general rule of thumb: if a tag looked empty on the way in, it will get removed; if HTML Purifier made it empty, it will stay. This directive causes tags without any attributes to be removed. It will also remove spans that had all attributes removed during processing.\n\nThis directive enables aggressive pre-filter fixes HTML Purifier can perform in order to ensure that open angled-brackets do not get killed during parsing stage. Enabling this will result in two preg_replace_callback calls and at least two preg_replace calls for every HTML document parsed; if your users make very well-formed HTML, you can set this directive false. This has no effect when DirectLex is used. Notice: This directive's default turned from false to true in HTML Purifier 3.2.0. This directive enables aggressive pre-filter removal of script tags. This is not necessary for security, but it can help work around a bug in libxml where embedded HTML elements inside script sections cause the parser to choke. To revert to pre-4.9.0 behavior, set this to false. This directive has no effect if %Core.Trusted is true, %Core.RemoveScriptContents is false, or %Core.HiddenElements does not contain script. By RFC 1123, underscores are not permitted in host names. (This is in contrast to the specification for DNS, RFC 2181, which allows underscores.) However, most browsers do the right thing when faced with an underscore in the host name, and so some poorly written websites are written with the expectation this should work. Setting this parameter to true relaxes our allowed character check so that underscores are permitted. Whether or not to collect errors found while filtering the document. This is a useful way to give feedback to your users. Warning: Currently this feature is very patchy and experimental, with lots of possible error messages not yet implemented. It will not cause any problems, but it may not help your users either. Lookup array of color names to six digit hexadecimal number corresponding to color, with preceding hash mark. Used when parsing colors. The lookup is done in a case-insensitive manner. This parameter determines whether or not the filter should convert input that is a full document with html and body tags to a fragment of just the contents of a body tag. This parameter is simply something HTML Purifier can do during an edge-case: for most inputs, this processing is not necessary. Specifies the number of tokens the DirectLex line number tracking implementations should process before attempting to resyncronize the current line count by manually counting all previous new-lines. When at 0, this functionality is disabled. Lower values will decrease performance, and this is only strictly necessary if the counting algorithm is buggy (in which case you should report it as a bug). This has no effect when %Core.MaintainLineNumbers is disabled or DirectLex is not being used. This directive disables SGML-style exclusions, e.g. the exclusion of in any descendant of a tag. Disabling excludes will allow some invalid documents to pass through HTML Purifier, but HTML Purifier will also be less likely to accidentally remove large documents during processing. Allows international domain names in URLs. This configuration option requires the PEAR Net_IDNA2 module to be installed. It operates by punycoding any internationalized host names for maximum portability. If for some reason you are unable to convert all webpages to UTF-8, you can use this directive as a stop-gap compatibility change to let HTML Purifier deal with non UTF-8 input. This technique has notable deficiencies: absolutely no characters outside of the selected character encoding will be preserved, not even the ones that have been ampersand escaped (this is due to a UTF-8 specific feature that automatically resolves all entities), making it pretty useless for anything except the most I18N-blind applications, although %Core.EscapeNonASCIICharacters offers fixes this trouble with another tradeoff. This directive only accepts ISO-8859-1 if iconv is not enabled. Warning: this configuration option is no longer does anything as of 4.6.0. When true, a child is found that is not allowed in the context of the parent element will be transformed into text as if it were ASCII. When false, that element and all internal tags will be dropped, though text will be preserved. There is no option for dropping the element but preserving child nodes. When true, invalid tags will be written back to the document as plain text. Otherwise, they are silently dropped. This directive overcomes a deficiency in %Core.Encoding by blindly converting all non-ASCII characters into decimal numeric entities before converting it to its native encoding. This means that even characters that can be expressed in the non-UTF-8 encoding will be entity-ized, which can be a real downer for encodings like Big5. It also assumes that the ASCII repetoire is available, although this is the case for almost all encodings. Anyway, use UTF-8! This directive is a lookup array of elements which should have their contents removed when they are not allowed by the HTML definition. For example, the contents of a tag are not normally shown in a document, so if script tags are to be removed, their contents should be removed to. This is opposed to a tag, which defines some presentational changes but does not hide its contents. ISO 639 language code for localizable things in HTML Purifier to use, which is mainly error reporting. There is currently only an English (en) translation, so this directive is currently useless. Prior to HTML Purifier 4.9.0, entities were decoded by performing a global search replace for all entities whose decoded versions did not have special meanings under HTML, and replaced them with their decoded versions. We would match all entities, even if they did not have a trailing semicolon, but only if there weren't any trailing alphanumeric characters. In HTML Purifier 4.9.0, we changed the behavior of entity parsing to match entities that had missing trailing semicolons in less cases, to more closely match HTML5 parsing behavior: This parameter determines what lexer implementation can be used. The valid values are: Recommended, the lexer implementation will be auto-detected based on your PHP-version and configuration. This is a slim way of manually overridding the implementation. Currently recognized values are: DOMLex (the default PHP5 implementation) and DirectLex (the default PHP4 implementation). Only use this if you know what you are doing: usually, the auto-detection will manage things for cases you aren't even aware of. Super-advanced: you can specify your own, custom, implementation that implements the interface defined by . I may remove this option simply because I don't expect anyone to use it. If true, HTML Purifier will add line number information to all tokens. This is useful when error reporting is turned on, but can result in significant performance degradation and should not be used when unnecessary. This directive must be used with the DirectLex lexer, as the DOMLex lexer does not (yet) support this functionality. If the value is null, an appropriate value will be selected based on other configuration. Whether or not to normalize newlines to the operating system default. When , HTML Purifier will attempt to preserve mixed newline files. This directive enables pre-emptive URI checking in tags, as the attribute validation strategy is not authorized to remove elements from the document. Revert to pre-1.3.0 behavior by setting to false. Instead of escaping processing instructions in the form , remove it out-right. This may be useful if the HTML you are validating contains XML processing instruction gunk, however, it can also be user-unfriendly for people attempting to post PHP snippets. Warning: This directive was deprecated in version 2.1.0. This directive was deprecated in version 2.1.0. %Core.HiddenElements should be used instead. This directive enables HTML Purifier to remove not only script tags but all of their contents.\n\nThis directive can be used to add custom filters; it is nearly the equivalent of the now deprecated method. Specify an array of concrete implementations. Whether or not to escape the dangerous characters <, > and & as \\3C, \\3E and \\26, respectively. This is can be safely set to false if the contents of StyleBlocks will be placed in an external stylesheet, where there is no risk of it being interpreted as HTML. If you would like users to be able to define external stylesheets, but only allow them to specify CSS declarations for a specific node and prevent them from fiddling with other elements, use this directive. It accepts any valid CSS selector, and will prepend this to any CSS declaration extracted from the document. For example, if this directive is set to and a user uses the selector , the final selector will be . The comma shorthand may be used; consider the above example, with , the final selector will be . Warning: It is possible for users to bypass this measure using a naughty + selector. This is a bug in CSS Tidy 1.3, not HTML Purifier, and I am working to get it fixed. Until then, HTML Purifier performs a basic check to prevent this. If left NULL, HTML Purifier will attempt to instantiate a class to use for internal cleaning. This will usually be good enough. However, for trusted user input, you can set this to to disable cleaning. In addition, you can supply your own concrete implementation of Tidy's interface to use, although I don't know why you'd want to do that. This directive turns on the style block extraction filter, which removes blocks from input HTML, cleans them up with CSSTidy, and places them in the context variable, for further use by you, usually to be placed in an external stylesheet, or a block in the of your document. <?php header('Content-type: text/html; charset=utf-8'); echo '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'; ?> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\"> <head> <title>Filter.ExtractStyleBlocks</title> <?php require_once '/path/to/library/HTMLPurifier.auto.php'; require_once '/path/to/csstidy.class.php'; $dirty = '<style>body {color:#F00;}</style> Some text'; $config = HTMLPurifier_Config::createDefault(); $config->set('Filter', 'ExtractStyleBlocks', true); $purifier = new HTMLPurifier($config); $html = $purifier->purify($dirty); // This implementation writes the stylesheets to the styles/ directory. // You can also echo the styles inside the document, but it's a bit // more difficult to make sure they get interpreted properly by // browsers; try the usual CSS armoring techniques. $styles = $purifier->context->get('StyleBlocks'); $dir = 'styles/'; if (!is_dir($dir)) mkdir($dir); $hash = sha1($_GET['html']); foreach ($styles as $i => $style) { file_put_contents($name = $dir . $hash . \"_$i\"); echo '<link rel=\"stylesheet\" type=\"text/css\" href=\"'.$name.'\" />'; } ?> </head> <body> <div> <?php echo $html; ?> </div> </body> </html> Warning: It is possible for a user to mount an imagecrash attack using this CSS. Counter-measures are difficult; it is not simply enough to limit the range of CSS lengths (using relative lengths with many nesting levels allows for large values to be attained without actually specifying them in the stylesheet), and the flexible nature of selectors makes it difficult to selectively disable lengths on image tags (HTML Purifier, however, does disable CSS width and height in inline styling). There are probably two effective counter measures: an explicit width and height set to auto in all images in your document (unlikely) or the disabling of width and height (somewhat reasonable). Whether or not these measures should be used is left to the reader. Warning: Deprecated in favor of %HTML.SafeObject and %Output.FlashCompat (turn both on to allow YouTube videos and other Flash content). This directive enables YouTube video embedding in HTML Purifier. Check this document on embedding videos for more information on what this filter does.\n\nWhitelist that defines the schemes that a URI is allowed to have. This prevents XSS attacks from using pseudo-schemes like javascript or mocha. There is also support for the and URI schemes, but they are not enabled by default. The base URI is the URI of the document this purified HTML will be inserted into. This information is important if HTML Purifier needs to calculate absolute URIs from relative URIs, such as when %URI.MakeAbsolute is on. You may use a non-absolute URI for this value, but behavior may vary (%URI.MakeAbsolute deals nicely with both absolute and relative paths, but forwards-compatibility is not guaranteed). Warning: If set, the scheme on this URI overrides the one specified by %URI.DefaultScheme. Defines through what scheme the output will be served, in order to select the proper object validator when no scheme information is present. Starting with HTML Purifier 4.9.0, the default scheme can be null, in which case we reject all URIs which do not have explicit schemes. Unique identifier for a custom-built URI definition. If you want to add custom URIFilters, you must specify this value. Revision identifier for your custom definition. See %HTML.DefinitionRev for details. Disables all URIs in all forms. Not sure why you'd want to do that (after all, the Internet's founded on the notion of a hyperlink). Disables links to external websites. This is a highly effective anti-spam and anti-pagerank-leech measure, but comes at a hefty price: nolinks or images outside of your domain will be allowed. Non-linkified URIs will still be preserved. If you want to be able to link to subdomains or use absolute URIs, specify %URI.Host for your website. Disables the embedding of external resources, preventing users from embedding things like images from other hosts. This prevents access tracking (good for email viewers), bandwidth leeching, cross-site request forging, goatse.cx posting, and other nasties, but also results in a loss of end-user functionality (they can't directly post a pic they posted from Flickr anymore). Use it if you don't have a robust user-content moderation team. Disables embedding resources, essentially meaning no pictures. You can still link to them though. See %URI.DisableExternalResources for why this might be a good idea. Note: While this directive has been available since 1.3.0, it didn't actually start doing anything until 4.2.0. Defines the domain name of the server, so we can determine whether or an absolute URI is from your website or not. Not strictly necessary, as users should be using relative URIs to reference resources on your website. It will, however, let you use absolute URIs to link to subdomains of the domain you post here: i.e. example.com will allow sub.example.com. However, higher up domains will still be excluded: if you set %URI.Host to sub.example.com, example.com will be blocked. Note: This directive overrides %URI.Base because a given page may be on a sub-domain, but you wish HTML Purifier to be more relaxed and allow some of the parent domains too. List of strings that are forbidden in the host of any URI. Use it to kill domain names of spam, etc. Note that it will catch anything in the domain, so will catch . Converts all URIs into absolute forms. This is useful when the HTML being filtered assumes a specific base path, but will actually be viewed in a different context (and setting an alternate base URI is not possible). %URI.Base must be set for this directive to work. Munges all browsable (usually http, https and ftp) absolute URIs into another URI, usually a URI redirection service. This directive accepts a URI, formatted with a where the url-encoded original URI should be inserted (sample: ).\n• Prevent PageRank leaks, while being fairly transparent to users (you may also want to add some client side JavaScript to override the text in the statusbar). Notice: Many security experts believe that this form of protection does not deter spam-bots.\n• Redirect users to a splash page telling them they are leaving your website. While this is poor usability practice, it is often mandated in corporate environments. Prior to HTML Purifier 3.1.1, this directive also enabled the munging of browsable external resources, which could break things if your redirection script was a splash page or used tags. To revert to previous behavior, please use %URI.MungeResources. You may want to also use %URI.MungeSecretKey along with this directive in order to enforce what URIs your redirector script allows. Open redirector scripts can be a security risk and negatively affect the reputation of your domain name. Starting with HTML Purifier 3.1.1, there is also these substitutions: 1 - The URI embeds a resource\n\n(blank) - The URI is merely a link The name of the tag this URI came from The name of the attribute this URI came from The name of the CSS property this URI came from, or blank if irrelevant Admittedly, these letters are somewhat arbitrary; the only stipulation was that they couldn't be a through f. r is for resource (I would have preferred e, but you take what you can get), n is for name, m was picked because it came after n (and I couldn't use a), p is for property. If true, any URI munging directives like %URI.Munge will also apply to embedded resources, such as . Be careful enabling this directive if you have a redirector script that does not use the HTTP header; all of your images and other embedded resources will break. Warning: It is strongly advised you use this in conjunction %URI.MungeSecretKey to mitigate the security risk of an open redirector. This directive enables secure checksum generation along with %URI.Munge. It should be set to a secure key that is not shared with anyone else. The checksum can be placed in the URI using %t. Use of this checksum affords an additional level of protection by allowing a redirector to check if a URI has passed through HTML Purifier with this line: If the output is TRUE, the redirector script should accept the URI. Please note that it would still be possible for an attacker to procure secure hashes en-mass by abusing your website's Preview feature or the like, but this service affords an additional level of protection that should be combined with website blacklisting. Remember this has no effect if %URI.Munge is not on. If this is set to true (which it is by default), you can override %URI.AllowedSchemes by simply registering a HTMLPurifier_URIScheme to the registry. If false, you will also have to update that directive in order to add more schemes. A PCRE regular expression that will be matched against an iframe URI. This is a relatively inflexible scheme, but works well enough for the most common use-case of iframes: embedded video. This directive only has an effect if %HTML.SafeIframe is enabled. Here are some example values: Note that this directive does not give you enough granularity to, say, disable all videos. Pipe up on the HTML Purifier forums if this is a capability you want."
    },
    {
        "link": "https://stackoverflow.com/questions/41495819/how-to-use-htmlpurifier-to-allow-entire-document-to-be-passed-including-html-hea",
        "document": "HTML Purifier by default only knows tags that are valid within a context, because that's its intended use-case. Basically, it doesn't actually know what a , , or tag is - and that's a big deal, because most of its security relies on understanding the semantic underpinnings of the HTML!\n\nThere are some older stackoverflow questions on this topic:\n• Allowing full html to be parsed in HTMLPurifier\n\n...but they don't currently have very useful answers, so after some contemplation, I think your question still has merit and am going to answer here.\n\nGenerally, this has been discussed a few times on the HTML Purifier forums (e.g. in Allow HTML, HEAD, STYLE and BODY tags) - but the nutshell is that you can't do this without a significant amount of work, and unfortunately I'm not currently familiar with any snippet of code that solves this problem with a simple copy and paste.\n\nSo you're going to have to dig into the guts of HTML Purifier.\n\nYou can teach HTML Purifier most tags and associated behaviour using the instructions on the Customize! documentation page. The part most interesting for you would be near the bottom, an example where is taught to HTML Purifier. Quoting from there for some posterity:\n\nEach of the parameters corresponds to one of the questions we asked. Notice that we added an asterisk to the end of the action attribute to indicate that it is required. If someone specifies a form without that attribute, the tag will be axed. Also, the extra line at the end is a special extra declaration that prevents forms from being nested within each other.\n\nYou would have to do similar things with all tags outside of the tag that you want to support (all the way up to ).\n\nNote: Even if you add all these tags to HTML Purifier, the setting that you discovered needs to be set to (as you have done).\n\nIf this looks like too much work, and you have other ways to sanitise the header section and body attributes of your document, you can also cut your document into pieces, sanitise the pieces separately, then carefully stick them back together."
    },
    {
        "link": "https://stackoverflow.com/questions/9486222/htmlpurifier-addelement-syntax",
        "document": "I want to let users to use tag , so I've added \"vid\" to HTML.AllowedElements in config of purifier, so it throws me an error telling that its dont know such tag and pointing me to http://htmlpurifier.org/docs/enduser-customize.html So I've tried to use the following code:\n\nBut tag is stripping. What I'm doing wrong?"
    },
    {
        "link": "http://htmlpurifier.org/doxygen/html/classHTMLPurifier__HTMLModule.html",
        "document": "Represents an XHTML 1.1 module, with information on elements, tags and attributes. More...\n\nMore rarely used for adding attributes to the global collections. Example is the StyleAttribute module adding the style attribute to the Core. Corresponds to HTMLDefinition's attr_collections->info, since the object's data is only info, with extra behavior associated with it.\n\nBoolean flag that indicates whether or not getChildDef is implemented. For optimization reasons: may save a call to a function. Be sure to set it if you do implement getChildDef(), otherwise it will have no effect!\n\nList of HTMLPurifier_Injector to be performed during well-formedness fixing. An injector will only be invoked if all of it's pre-requisites are met; if an injector fails setup, there will be no error; it will simply be silently disabled.\n\nBoolean flag whether or not this module is safe. If it is not safe, all of its members are unsafe. Modules are safe by default (this might be slightly dangerous, but it doesn't make much sense to force HTML Purifier, which is based off of safe HTML, to explicitly say, \"This is safe,\" even though there are modules which are \"unsafe\") Previously, safety could be applied at an element level granularity. We've removed this ability, so in order to add \"unsafe\" elements or attributes, a dedicated module with this property set to false must be used.\n\nThe documentation for this class was generated from the following files:"
    },
    {
        "link": "http://htmlpurifier.org/docs/enduser-customize.html",
        "document": "HTML Purifier has this quirk where if you try to allow certain elements or attributes, HTML Purifier will tell you that it's not supported, and that you should go to the forums to find out how to implement it. Well, this document is how to implement elements and attributes which HTML Purifier doesn't support out of the box.\n\nIs it necessary?\n\nBefore we even write any code, it is paramount to consider whether or not the code we're writing is necessary or not. HTML Purifier, by default, contains a large set of elements and attributes: large enough so that any element or attribute in XHTML 1.0 or 1.1 (and its HTML variants) that can be safely used by the general public is implemented.\n\nSo what needs to be implemented? (Feel free to skip this section if you know what you want).\n\nAll of the modules listed below are based off of the modularization of XHTML, which, while technically for XHTML 1.1, is quite a useful resource.\n\nIf you don't recognize it, you probably don't need it. But the curious can look all of these modules up in the above-mentioned document. Note that inline scripting comes packaged with HTML Purifier (more on this later).\n\nAs of HTMLPurifier 2.1.0, we have implemented the Ruby module, which defines a set of tags for publishing short annotations for text, used mostly in Japanese and Chinese school texts, but applicable for positioning any text (not limited to translations) above or below other corresponding text.\n\nHTML 5 is a fork of HTML 4.01 by WHATWG, who believed that XHTML 2.0 was headed in the wrong direction. It too is a working draft, and may change drastically before publication, but it should be noted that the tag has been implemented by many browser vendors.\n\nThere are a number of proprietary tags still in the wild. Many of them have been documented in ref-proprietary-tags.txt, but there is currently no implementation for any of them.\n\nThere are also a number of other XML languages out there that can be embedded in HTML documents: two of the most popular are MathML and SVG, and I frequently get requests to implement these. But they are expansive, comprehensive specifications, and it would take far too long to implement them correctly (most systems I've seen go as far as whitelisting tags and no further; come on, what about nesting!)\n\nWord of warning: HTML Purifier is currently not namespace aware.\n\nAs you may imagine from the details above (don't be abashed if you didn't read it all: a glance over would have done), there's quite a bit that HTML Purifier doesn't implement. Recent architectural changes have allowed HTML Purifier to implement elements and attributes that are not safe! Don't worry, they won't be activated unless you set %HTML.Trusted to true, but they certainly help out users who need to put, say, forms on their page and don't want to go through the trouble of reading this and implementing it themself.\n\nSo any of the above that you implement for your own application could help out some other poor sap on the other side of the globe. Help us out, and send back code so that it can be hammered into a module and released with the core. Any code would be greatly appreciated!\n\nEnough philosophical talk, time for some code:\n\nAssuming that HTML Purifier has already been properly loaded (hint: include ), this code will set up the environment that you need to start customizing the HTML definition. What's going on?\n• The first three lines are regular configuration code:\n• %HTML.DefinitionID is set to a unique identifier for your custom HTML definition. This prevents it from clobbering other custom definitions on the same installation.\n• %HTML.DefinitionRev is a revision integer of your HTML definition. Because HTML definitions are cached, you'll need to increment this whenever you make a change in order to flush the cache.\n• The fourth line retrieves a raw object that we will be tweaking. Interestingly enough, we have placed it in an if block: this is because , as its name suggests, may return a NULL, in which case we should skip doing any initialization. This, in fact, will correspond to when our fully customized object is already in the cache.\n\nTo make development easier, we're going to temporarily turn off definition caching:\n\nA few things should be mentioned about the caching mechanism before we move on. For performance reasons, HTML Purifier caches generated objects in serialized files stored (by default) in . A lot of processing is done in order to create these objects, so it makes little sense to repeat the same processing over and over again whenever HTML Purifier is called.\n\nIn order to identify a cache entry, HTML Purifier uses three variables: the library's version number, the value of %HTML.DefinitionRev and a serial of relevant configuration. Whenever any of these changes, a new HTML definition is generated. Notice that there is no way for the definition object to track changes to customizations: here, it is up to you to supply appropriate information to DefinitionID and DefinitionRev.\n\nFor this example, we're going to implement the attribute found on elements. To implement an attribute, we have to ask a few questions:\n• What element is it found on?\n• What is its name?\n• Is it required or optional?\n• What are valid values for it?\n\nThe first three are easy: the element is , the attribute is , and it is not a required attribute. (If it was required, we'd need to append an asterisk to the attribute name, you'll see an example of this in the addElement() example).\n\nThe last question is a little trickier. Lets allow the special values: _blank, _self, _target and _top. The form of this is called an enumeration, a list of valid values, although only one can be used at a time. To translate this into code form, we write:\n\nThe does all the magic. The string is split into two parts, separated by a hash mark (#):\n• The first part is the name of what we call an\n• The second part is the parameter of the above-mentioned\n\nIf that sounds vague and generic, it's because it is! HTML Purifier defines an assortment of different attribute types one can use, and each of these has their own specialized parameter format. Here are some of the more useful ones:\n\nFor a complete list, consult ; more information on attributes that accept parameters can be found on their respective includes in .\n\nSometimes, the restrictive list in AttrTypes just doesn't cut it. Don't sweat: you can also use a fully instantiated object as the value. The equivalent, verbose form of the above example is:\n\nTrust me, you'll learn to love the shorthand.\n\nAdding attributes is really small-fry stuff, though, and it was possible to add them (albeit a bit more wordy) prior to 2.0. The real gem of the Advanced API is adding elements. There are five questions to ask when adding a new element:\n• What is the element's name?\n• What content set does this element belong to?\n• What are the allowed children of this element?\n• What attributes does the element allow that are general?\n• What attributes does the element allow that are specific to this element?\n\nIt's a mouthful, and you'll be slightly lost if your not familiar with the HTML specification, so let's explain them step by step.\n\nThe HTML specification defines two major content sets: Inline and Block. Each of these content sets contain a list of elements: Inline contains things like and while Block contains things like and .\n\nThese content sets amount to a macro mechanism for HTML definition. Most elements in HTML are organized into one of these two sets, and most elements in HTML allow elements from one of these sets. If we had to write each element verbatim into each other element's allowed children, we would have ridiculously large lists; instead we use content sets to compactify the declaration.\n\nPractically speaking, there are several useful values you can use here:\n\nBy specifying a valid value here, all other elements that use that content set will also allow your element, without you having to do anything. If you specify false, you'll have to register your element manually.\n\nAllowed children defines the elements that this element can contain. The allowed values may range from none to a complex regexp depending on your element.\n\nIf you've ever taken a look at the HTML DTD's before, you may have noticed declarations like this:\n\nThe indicates the allowed children of the tag: allows any number of flow elements as its children. (The allows the closing tag to be omitted, though in XML this is not allowed.) In HTML Purifier, we'd write it like (here's where the content sets we were discussing earlier come into play). There are three shorthand content models you can specify:\n\nThis covers 90% of all the cases out there, but what about elements that break the mold like ? This guy requires at least one child, and the only valid children for it are . The content model is: . There are two parts: the first type determines what will be used to validate content models. The most common values are:\n\nYou can also implement your own : this was done for a few special cases in HTML Purifier such as (for and ), and .\n\nThe second part specifies either valid elements or a regular expression. Valid elements are separated with horizontal bars (|), i.e. \" \". Use #PCDATA to represent plain text. Regular expressions are based off of DTD's style:\n• Parentheses () are used for grouping\n• Commas (,) separate elements that should come one after another\n• Horizontal bars (|) indicate one or the other elements should be used\n• Plus signs (+) are used for a one or more match\n• Asterisks (*) are used for a zero or more match\n• Question marks (?) are used for a zero or one match\n\nFor example, \" \" means \"In this order, one element, at most one element, one or element (but not both), one or more elements, and any number of elements.\" Regex veterans should be able to jump right in, and those not so savvy can always copy-paste W3C's content model definitions into HTML Purifier and hope for the best.\n\nA word of warning: while the regex format is extremely flexible on the developer's side, it is quite unforgiving on the user's side. If the user input does not exactly match the specification, the entire contents of the element will be nuked. This is why there is are specific content model types like Optional and Required: while they could be implemented as , the custom classes contain special recovery measures that make sure as much of the user's original content gets through. HTML Purifier's core, as a rule, does not use Custom.\n\nOne final note: you can also use Content Sets inside your valid elements lists or regular expressions. In fact, the three shorthand content models mentioned above are just that: abbreviations:\n\nWhen the definition is compiled, Inline will be replaced with a horizontal-bar separated list of inline elements. Also, notice that it does not contain text: you have to specify that yourself.\n\nCongratulations: you have just gotten over the proverbial hump (Allowed children). Common attributes is much simpler, and boils down to one question: does your element have the , , , and attributes? If so, you'll want to specify the attribute collection, which contains these five attributes that are found on almost every HTML element in the specification.\n\nThere are a few more collections, but they're really edge cases:\n\nCommon is a combination of the above-mentioned collections.\n\nReaders familiar with the modularization may have noticed that the Core attribute collection differs from that specified by the abstract modules of the XHTML Modularization 1.1. We believe this section to be in error, as permits the use of the attribute even though it uses the collection, and the DTD and XML Schemas supplied by W3C support our interpretation.\n\nIf you didn't read the earlier section on adding attributes, read it now. The last parameter is simply an array of attribute names to attribute implementations, in the exact same format as .\n\nPutting it all together\n\nWe're going to implement . Before we embark, lets grab a reference implementation from over at the transitional DTD:\n\nJuicy! With just this, we can answer four of our five questions:\n• What is the element's name? form\n• What content set does this element belong to? Block (this needs a little sleuthing, I find the easiest way is to search the DTD for and determine which set it is in.)\n• What are the allowed children of this element? One or more flow elements, but no nested s\n• What attributes does the element allow that are general? Common\n• What attributes does the element allow that are specific to this element? A whole bunch, see ATTLIST; we're going to do the vital ones: , and\n\nEach of the parameters corresponds to one of the questions we asked. Notice that we added an asterisk to the end of the attribute to indicate that it is required. If someone specifies a without that attribute, the tag will be axed. Also, the extra line at the end is a special extra declaration that prevents forms from being nested within each other.\n\nAnd that's all there is to it! Implementing the rest of the form module is left as an exercise to the user; to see more examples check the directory in your local HTML Purifier installation.\n\nPerceptive users may have realized that, to a certain extent, we have simply re-implemented the facilities of XML Schema or the Document Type Definition. What you are seeing here, however, is not just an XML Schema or Document Type Definition: it is a fully expressive method of specifying the definition of HTML that is a portable superset of the capabilities of the two above-mentioned schema languages. What makes HTMLDefinition so powerful is the fact that if we don't have an implementation for a content model or an attribute definition, you can supply it yourself by writing a PHP class.\n\nThere are many facets of HTMLDefinition beyond the Advanced API I have walked you through today. To find out more about these, you can check out these source files:\n\nPreviously, this tutorial gave some incorrect template code for editing raw definitions, and that template code will now produce the error Due to a documentation error in previous version of HTML Purifier... Here is how to mechanically transform old-style code into new-style code.\n\nFirst, identify all code that edits the raw definition object, and put it together. Ensure none of this code must be run on every request; if some sub-part needs to always be run, move it outside this block. Here is an example below, with the raw definition object code bolded.\n\nNext, replace the raw definition retrieval with a maybeGetRawHTMLDefinition method call inside an if conditional, and place the editing code inside that if block.\n\nAnd you're done! Alternatively, if you're OK with not ever caching your code, the following will still work and not emit warnings.\n\nA slightly less efficient version of this was what was going on with old versions of HTML Purifier.\n\nTechnical notes: ajh pointed out on in a forum topic that HTML Purifier appeared to be repeatedly writing to the cache even when a cache entry already existed. Investigation lead to the discovery of the following infelicity: caching of customized definitions didn't actually work! The problem was that even though a cache file would be written out at the end of the process, there was no way for HTML Purifier to say, Actually, I've already got a copy of your work, no need to reconfigure your customizations . This required the API to change: placing all of the customizations to the raw definition object in a conditional which could be skipped."
    },
    {
        "link": "https://stackoverflow.com/questions/28087395/allowing-custom-attribute-to-element-with-htmlpurifier",
        "document": "Got stuck half-way through my little process, need help with this last step.\n\nNeeded to add a custom element to accept a custom element that would be passed through a textarea form.\n\nReturns: you should check this out: <book>my book title</book>!\n\nBut it is stripping out the\n\nIf I add in the standard htmlpurifier attr allowance, such as:\n\nI need it so that the can be included or not included.\n\nCan somebody please share the code change/addition I need to get the to be allowed - thanks!"
    },
    {
        "link": "https://stackoverflow.com/questions/60008039/how-to-allow-elements-at-the-same-allow-custom-attribute-in-htmlpurifier",
        "document": "I am going to add a custom attribute 'custom-type' with \"a\" element, at the same time only allow \"h1\" and \"a\" element.\n\nIt generates errors like below:\n\n\"Cannot set directive after finalization invoked on line 69 in file \"\n\nI am wondering what is wrong with above codes. Any suggestions would be appreciated."
    },
    {
        "link": "https://cdc.gy/sahana/3rd/htmlpurifier/docs/enduser-customize.html",
        "document": "You may have heard of the Advanced API. If you're interested in reading dry prose and boring functional specifications, feel free to click that link to get a no-nonsense overview on the Advanced API. For the rest of us, there's this tutorial. By the time you're finished reading this, you should have a pretty good idea on how to implement custom tags and attributes that HTML Purifier may not have.\n\nIs it necessary?\n\nBefore we even write any code, it is paramount to consider whether or not the code we're writing is necessary or not. HTML Purifier, by default, contains a large set of elements and attributes: large enough so that any element or attribute in XHTML 1.0 (and its HTML variant) that can be safely used by the general public is implemented.\n\nSo what needs to be implemented? (Feel free to skip this section if you know what you want).\n\nAll of the modules listed below are based off of the modularization of XHTML, which, while technically for XHTML 1.1, is quite a useful resource.\n\nIf you don't recognize it, you probably don't need it. But the curious can look all of these modules up in the above-mentioned document. Note that inline scripting comes packaged with HTML Purifier (more on this later).\n\nWe have not implemented the Ruby module, which defines a set of tags for publishing short annotations for text, used mostly in Japanese and Chinese school texts.\n\nXHTML 2.0 is still a working draft, so any elements introduced in the specification have not been implemented and will not be implemented until we get a recommendation or proposal. Because XHTML 2.0 is an entirely new markup language, implementing rules for it will be no easy task.\n\nHTML 5 is a fork of HTML 4.01 by WHATWG, who believed that XHTML 2.0 was headed in the wrong direction. It too is a working draft, and may change drastically before publication, but it should be noted that the tag has been implemented by many browser vendors.\n\nThere are a number of proprietary tags still in the wild. Many of them have been documented in ref-proprietary-tags.txt, but there is currently no implementation for any of them.\n\nThere are also a number of other XML languages out there that can be embedded in HTML documents: two of the most popular are MathML and SVG, and I frequently get requests to implement these. But they are expansive, comprehensive specifications, and it would take far too long to implement them correctly (most systems I've seen go as far as whitelisting tags and no further; come on, what about nesting!)\n\nWord of warning: HTML Purifier is currently not namespace aware.\n\nAs you may imagine from the details above (don't be abashed if you didn't read it all: a glance over would have done), there's quite a bit that HTML Purifier doesn't implement. Recent architectural changes have allowed HTML Purifier to implement elements and attributes that are not safe! Don't worry, they won't be activated unless you set %HTML.Trusted to true, but they certainly help out users who need to put, say, forms on their page and don't want to go through the trouble of reading this and implementing it themself.\n\nSo any of the above that you implement for your own application could help out some other poor sap on the other side of the globe. Help us out, and send back code so that it can be hammered into a module and released with the core. Any code would be greatly appreciated!\n\nEnough philosophical talk, time for some code:\n\nAssuming that HTML Purifier has already been properly loaded (hint: include ), this code will set up the environment that you need to start customizing the HTML definition. What's going on?\n• The first three lines are regular configuration code:\n• %HTML.DefinitionID is set to a unique identifier for your custom HTML definition. This prevents it from clobbering other custom definitions on the same installation.\n• %HTML.DefinitionRev is a revision integer of your HTML definition. Because HTML definitions are cached, you'll need to increment this whenever you make a change in order to flush the cache.\n• The fourth line retrieves a raw object that we will be tweaking. If the parameter was removed, we would be retrieving a fully formed definition object, which is somewhat useless for customization purposes.\n\nThose of you who have already been twiddling around with the raw HTML definition object, you'll be noticing that you're getting an error when you attempt to retrieve the raw definition object without specifying a DefinitionID. It is vital to caching (see below) that you make a unique name for your customized definition, so make up something right now and things will operate again.\n\nTo make development easier, we're going to temporarily turn off definition caching:\n\nA few things should be mentioned about the caching mechanism before we move on. For performance reasons, HTML Purifier caches generated objects in serialized files stored (by default) in . A lot of processing is done in order to create these objects, so it makes little sense to repeat the same processing over and over again whenever HTML Purifier is called.\n\nIn order to identify a cache entry, HTML Purifier uses three variables: the library's version number, the value of %HTML.DefinitionRev and a serial of relevant configuration. Whenever any of these changes, a new HTML definition is generated. Notice that there is no way for the definition object to track changes to customizations: here, it is up to you to supply appropriate information to DefinitionID and DefinitionRev.\n\nFor this example, we're going to implement the attribute found on elements. To implement an attribute, we have to ask a few questions:\n• What element is it found on?\n• What is its name?\n• Is it required or optional?\n• What are valid values for it?\n\nThe first three are easy: the element is , the attribute is , and it is not a required attribute. (If it was required, we'd need to append an asterisk to the attribute name, you'll see an example of this in the addElement() example).\n\nThe last question is a little trickier. Lets allow the special values: _blank, _self, _target and _top. The form of this is called an enumeration, a list of valid values, although only one can be used at a time. To translate this into code form, we write:\n\nThe does all the magic. The string is split into two parts, separated by a hash mark (#):\n• The first part is the name of what we call an\n• The second part is the parameter of the above-mentioned\n\nIf that sounds vague and generic, it's because it is! HTML Purifier defines an assortment of different attribute types one can use, and each of these has their own specialized parameter format. Here are some of the more useful ones:\n\nFor a complete list, consult ; more information on attributes that accept parameters can be found on their respective includes in .\n\nSometimes, the restrictive list in AttrTypes just doesn't cut it. Don't sweat: you can also use a fully instantiated object as the value. The equivalent, verbose form of the above example is:\n\nTrust me, you'll learn to love the shorthand.\n\nAdding attributes is really small-fry stuff, though, and it was possible to add them (albeit a bit more wordy) prior to 2.0. The real gem of the Advanced API is adding elements. There are five questions to ask when adding a new element:\n• What is the element's name?\n• What content set does this element belong to?\n• What are the allowed children of this element?\n• What attributes does the element allow that are general?\n• What attributes does the element allow that are specific to this element?\n\nIt's a mouthful, and you'll be slightly lost if your not familiar with the HTML specification, so let's explain them step by step.\n\nThe HTML specification defines two major content sets: Inline and Block. Each of these content sets contain a list of elements: Inline contains things like and while Block contains things like and .\n\nThese content sets amount to a macro mechanism for HTML definition. Most elements in HTML are organized into one of these two sets, and most elements in HTML allow elements from one of these sets. If we had to write each element verbatim into each other element's allowed children, we would have ridiculously large lists; instead we use content sets to compactify the declaration.\n\nPractically speaking, there are several useful values you can use here:\n\nBy specifying a valid value here, all other elements that use that content set will also allow your element, without you having to do anything. If you specify false, you'll have to register your element manually.\n\nAllowed children defines the elements that this element can contain. The allowed values may range from none to a complex regexp depending on your element.\n\nIf you've ever taken a look at the HTML DTD's before, you may have noticed declarations like this:\n\nThe indicates the allowed children of the tag: allows any number of flow elements as its children. In HTML Purifier, we'd write it like (here's where the content sets we were discussing earlier come into play). There are three shorthand content models you can specify:\n\nThis covers 90% of all the cases out there, but what about elements that break the mold like ? This guy requires at least one child, and the only valid children for it are . The content model is: . There are two parts: the first type determines what will be used to validate content models. The most common values are:\n\nYou can also implement your own : this was done for a few special cases in HTML Purifier such as (for and ), and .\n\nThe second part specifies either valid elements or a regular expression. Valid elements are separated with horizontal bars (|), i.e. \" \". Use #PCDATA to represent plain text. Regular expressions are based off of DTD's style:\n• Parentheses () are used for grouping\n• Commas (,) separate elements that should come one after another\n• Horizontal bars (|) indicate one or the other elements should be used\n• Plus signs (+) are used for a one or more match\n• Asterisks (*) are used for a zero or more match\n• Question marks (?) are used for a zero or one match\n\nFor example, \" \" means \"In this order, one element, at most one element, one or element (but not both), one or more elements, and any number of elements.\" Regex veterans should be able to jump right in, and those not so savvy can always copy-paste W3C's content model definitions into HTML Purifier and hope for the best.\n\nA word of warning: while the regex format is extremely flexible on the developer's side, it is quite unforgiving on the user's side. If the user input does not exactly match the specification, the entire contents of the element will be nuked. This is why there is are specific content model types like Optional and Required: while they could be implemented as , the custom classes contain special recovery measures that make sure as much of the user's original content gets through. HTML Purifier's core, as a rule, does not use Custom.\n\nOne final note: you can also use Content Sets inside your valid elements lists or regular expressions. In fact, the three shorthand content models mentioned above are just that: abbreviations:\n\nWhen the definition is compiled, Inline will be replaced with a horizontal-bar separated list of inline elements. Also, notice that it does not contain text: you have to specify that yourself.\n\nCongratulations: you have just gotten over the proverbial hump (Allowed children). Common attributes is much simpler, and boils down to one question: does your element have the , , , and attributes? If so, you'll want to specify the attribute collection, which contains these five attributes that are found on almost every HTML element in the specification.\n\nThere are a few more collections, but they're really edge cases:\n\nCommon is a combination of the above-mentioned collections.\n\nIf you didn't read the previous section on adding attributes, read it now. The last parameter is simply array of attribute names to attribute implementations, in the exact same format as .\n\nPutting it all together\n\nWe're going to implement . Before we embark, lets grab a reference implementation from over at the transitional DTD:\n\nJuicy! With just this, we can answer four of our five questions:\n• What is the element's name? form\n• What content set does this element belong to? Block (this needs a little sleuthing, I find the easiest way is to search the DTD for and determine which set it is in.)\n• What are the allowed children of this element? One or more flow elements, but no nested s\n• What attributes does the element allow that are general? Common\n• What attributes does the element allow that are specific to this element? A whole bunch, see ATTLIST; we're going to the vital ones: , and\n\nEach of the parameters corresponds to one of the questions we asked. Notice that we added an asterisk to the end of the attribute to indicate that it is required. If someone specifies a without that attribute, the tag will be axed. Also, the extra line at the end is a special extra declaration that prevents forms from being nested within each other.\n\nAnd that's all there is to it! Implementing the rest of the form module is left as an exercise to the user; to see more examples check the directory in your local HTML Purifier installation.\n\nPerceptive users may have realized that, to a certain extent, we have simply re-implemented the facilities of XML Schema or the Document Type Definition. What you are seeing here, however, is not just an XML Schema or Document Type Definition: it is a fully expressive method of specifying the definition of HTML that is a portable superset of the capabilities of the two above-mentioned schema languages. What makes HTMLDefinition so powerful is the fact that if we don't have an implementation for a content model or an attribute definition, you can supply it yourself by writing a PHP class.\n\nThere are many facets of HTMLDefinition beyond the Advanced API I have walked you through today. To find out more about these, you can check out these source files:"
    },
    {
        "link": "https://craftcms.stackexchange.com/questions/16366/how-to-customize-html-purifier",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]