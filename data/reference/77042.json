[
    {
        "link": "https://jmeter.apache.org/usermanual/get-started.html",
        "document": "If you plan on doing JMeter development, then you will need one or more optional packages listed below. If you want to build the JMeter source or develop JMeter plugins, then you will need a fully compliant JDK 8 or higher. JMeter comes with Apache's Xerces XML parser. You have the option of telling JMeter to use a different XML parser. To do so, include the classes for the third-party parser in JMeter's classpath, and update the jmeter.properties file with the full classname of the parser implementation. JMeter has extensive Email capabilities. It can send email based on test results, and has a POP3(S)/IMAP(S) sampler. It also has an SMTP(S) sampler. To test a web server using SSL encryption (HTTPS), JMeter requires that an implementation of SSL be provided, as is the case with Sun Java 1.4 and above. If your version of Java does not include SSL support, then it is possible to add an external implementation. Include the necessary encryption packages in JMeter's classpath. Also, update system.properties to register the SSL Provider. JMeter HTTP defaults to protocol level TLS. This can be changed by editing the JMeter property https.default.protocol in jmeter.properties or user.properties. The JMeter HTTP samplers are configured to accept all certificates, whether trusted or not, regardless of validity periods, etc. This is to allow the maximum flexibility in testing servers. If the server requires a client certificate, this can be provided. There is also the SSL Manager, for greater control of certificates. The JMeter proxy server (see below) supports recording HTTPS (SSL) The SMTP sampler can optionally use a local trust store or trust all certificates. You will need to add your database vendor's JDBC driver to the classpath if you want to do JDBC testing. Make sure the file is a jar file, not a zip. JMeter now includes the JMS API from Apache Geronimo, so you just need to add the appropriate JMS Client implementation jar(s) from the JMS provider. Please refer to their documentation for details. There may also be some information on the JMeter Wiki. You will need to add the jar activemq-all-X.X.X.jar to your classpath, e.g. by storing it in the lib/ directory. See the JMeter Classpath section for more details on installing additional jars.\n\n\n\n To run JMeter, run the jmeter.bat (for Windows) or jmeter (for Unix) file. These files are found in the bin directory. After a short time, the JMeter GUI should appear. GUI mode should only be used for creating the test script, CLI mode (NON GUI) must be used for load testing There are some additional scripts in the bin directory that you may find useful. Windows script files (the .CMD files require Win2K or later): run JMeter without the windows shell console (in GUI mode by default) drop a JMX file on this to run a CLI mode test drop a JMX file on this to run a CLI mode test remotely drop a JMX file on this to load it in GUI mode The special name can be used with , and and means the last test plan that was run interactively. There are a few environment variables, that can be used to customize the JVM settings for JMeter. An easy way to set those is by creating a file named setenv.bat in the bin directory. Such a file could look like: rem This is the content of bin\\setenv.bat, rem it will be called by bin\\jmeter.bat set JVM_ARGS=-Xms1024m -Xmx1024m -Dpropname=value The JVM_ARGS can be used to override JVM settings in the jmeter.bat script and will get set when starting JMeter, e.g.: The following environment variables can be defined: JVM options to influence usage of direct draw, e.g. . Default is empty. JVM memory settings used when starting JMeter. Defaults to JMeter bin directory (must end in ). Value will have been guessed, when is called. If set indicates, that and are to be used, only. All other options like and will be ignored. Default is empty. installation directory. Will be guessed from location of Java runtime options to specify used language. Defaults to: Name of the java executable, like (default) or Java options to be used when starting JMeter. These will be added last to the java command. Default is empty Un*x script files; should work on most Linux/Unix systems: run JMeter (in GUI mode by default). Defines some JVM settings which may not work for all JVMs. start JMeter in server mode (calls jmeter script with appropriate parameters) very basic JMeter script (You may need to adapt JVM options like memory settings). It may be necessary to set a few environment variables to configure the JVM used by JMeter. Those variables can be either set directly in the shell starting the jmeter script. For example setting the variable JVM_ARGS will override most pre-defined settings, for example will override the HEAP settings in the script. To set those variables permanently, you can place them in a file called setenv.sh in the bin directory. This file will be sourced when running JMeter by calling the jmeter script. An example for bin/setenv.sh could look like: # This is the file bin/setenv.sh, # it will be sourced in by bin/jmeter # Use a bigger heap, but a smaller metaspace, than the default export HEAP=\"-Xms1G -Xmx1G -XX:MaxMetaspaceSize=192m\" # Try to guess the locale from the OS. The space as value is on purpose! export JMETER_LANGUAGE=\" \" The following environment variables can be defined: Java runtime options to specify JVM garbage collection algorithm. Defaults to Java runtime options for memory management used when JMeter is started. Defaults to Must point at your Java Development Kit installation. Required to run the with the \" \" argument. On some OSes it JMeter will try its best to guess the location of the JVM. If set indicates, that and are to be used, only. All other options like and will be ignored. Default is empty. May point to your JMeter install dir. If empty it will be set relative to the script. Java runtime options to specify used language. Defaults to Java runtime options used when JMeter is started. Special options for operating systems might be added by JMeter. Must point at your Java Runtime installation. Defaults to if empty. If and are both empty, JMeter will try to guess . If and are both set, is used. Java options to be used when starting JMeter. These will be added before and after the other JVM options. Default is empty JMeter automatically finds classes from jars in the following directories: used for JMeter components and plugins If you have developed new JMeter components, then you should jar them and copy the jar into JMeter's lib/ext directory. JMeter will automatically find JMeter components in any jars found here. Do not use lib/ext for utility jars or dependency jars used by the plugins; it is only intended for JMeter components and plugins. If you don't want to put JMeter plugin jars in the lib/ext directory, then define the property search_paths in jmeter.properties. Utility and dependency jars (libraries etc) can be placed in the lib directory. If you don't want to put such jars in the lib directory, then define the property user.classpath or plugin_dependency_paths in jmeter.properties. See below for an explanation of the differences. Other jars (such as JDBC, JMS implementations and any other support libraries needed by the JMeter code) should be placed in the lib directory - not the lib/ext directory, or added to user.classpath. JMeter will only find files, not . You can also install utility Jar files in $JAVA_HOME/jre/lib/ext, or you can set the property user.classpath in jmeter.properties Note that setting the CLASSPATH environment variable will have no effect. This is because JMeter is started with \"java -jar\", and the java command silently ignores the CLASSPATH variable, and the -classpath/-cp options when -jar is used. This occurs with all Java programs, not just JMeter. You have the ability to create a new Test Plan from existing template. To do so you use the menu File → Templates… or Templates icon: A popup appears, you can then choose a template among the list: Some templates may need parameters input from the user. For theses ones, after a click on the create button, a new window will appear as follow : When you are done with parameters, click on the Validate button and the template will be created. A documentation for each template explains what to do once test plan is created from template. You can create your own templates following documentation here If you are testing from behind a firewall/proxy server, you may need to provide JMeter with the firewall/proxy server hostname and port number. To do so, run the jmeter[.bat] file from a command line with the following parameters: [proxy scheme to use - optional - for non-http] Example: You can also use --proxyScheme, --proxyHost, --proxyPort, --username, and --password as parameter names Parameters provided on a command-line may be visible to other users on the system. If the proxy scheme is provided, then JMeter sets the following System properties: If the proxy host and port are provided, then JMeter sets the following System properties: The user and password used for a proxy can be given by the System properties http.proxyUser and http.proxyUser. They will get overridden by the above arguments or values set in the HTTP Samplers. If a nonproxy host list is provided, then JMeter sets the following System properties: So if you don't wish to set both http and https proxies, you can define the relevant properties in system.properties instead of using the command-line parameters. Proxy Settings can also be defined in a Test Plan, using either the HTTP Request Defaults configuration or the HTTP Request sampler elements. JMeter also has its own in-built Proxy Server, the HTTP(S) Test Script Recorder . This is only used for recording HTTP or HTTPS browser sessions. This is not to be confused with the proxy settings described above, which are used when JMeter makes HTTP or HTTPS requests itself. For load testing, you must run JMeter in this mode (Without the GUI) to get the optimal results from it. To do so, use the following command options: This specifies JMeter is to run in cli mode [name of JMX file that contains the Test Plan]. [name of JTL file to log sample results to]. Run the test in the servers specified by the JMeter property \" \" [list of remote servers] Run the test in the specified remote servers output folder where to generate the report dashboard after load test. Folder must not exist or be empty The script also lets you specify the optional firewall/proxy server information: Example If the property jmeterengine.stopfail.system.exit is set to true (default is false), then JMeter will invoke System.exit(1) if it cannot stop all threads. Normally this is not necessary. For distributed testing, run JMeter in server mode on the remote node(s), and then control the server(s) from the GUI. You can also use CLI mode to run remote tests. To start the server(s), run jmeter-server[.bat] on each server host. The script also lets you specify the optional firewall/proxy server information: Example: If you want the server to exit after a single test has been run, then define the JMeter property server.exitaftertest=true. To run the test from the client in CLI mode, use the following command: where: is used to define JMeter properties to be set in the servers means exit the servers at the end of the test can be used instead of to provide a list of servers to start. Overrides , but does not define the property. If the property jmeterengine.remote.system.exit is set to true (default is false), then JMeter will invoke System.exit(0) after stopping RMI at the end of a test. Normally this is not necessary. Java system properties and JMeter properties can be overridden directly on the command lin (instead of modifying jmeter.properties). To do so, use the following options: defines a JMeter property to be sent to all remote servers. defines a file containing JMeter properties to be sent to all remote servers. overrides a logging setting, setting a particular category to the given priority level. The -L flag can also be used without the category name to set the root logging level. The command line properties are processed early in startup, but after the logging system has been set up. any more, but it is configured through a in the directory from which JMeter was launched, by default) instead. Also, every code including JMeter and plugins MUST use Since 3.2, JMeter logging is not configured through properties file(s) such asany more, but it is configured through a Apache Log4j 2 configuration file (in the directory from which JMeter was launched, by default) instead. Also, every code including JMeter and plugins MUST use SLF4J library to leave logs since 3.2. Here is an example log4j2.xml file which defines two log appenders and loggers for each category. <Configuration status=\"WARN\" packages=\"org.apache.jmeter.gui.logging\"> <Appenders> <!-- The main log file appender to jmeter.log in the directory from which JMeter was launched, by default. --> <File name=\"jmeter-log\" fileName=\"${sys:jmeter.logfile:-jmeter.log}\" append=\"false\"> <PatternLayout> <pattern>%d %p %c{1.}: %m%n</pattern> </PatternLayout> </File> <!-- Log appender for GUI Log Viewer. See below. --> <GuiLogEvent name=\"gui-log-event\"> <PatternLayout> <pattern>%d %p %c{1.}: %m%n</pattern> </PatternLayout> </GuiLogEvent> </Appenders> <Loggers> <!-- Root logger --> <Root level=\"info\"> <AppenderRef ref=\"jmeter-log\" /> <AppenderRef ref=\"gui-log-event\" /> </Root> <!-- SNIP --> <!-- # Apache HttpClient logging examples --> <!-- # Enable header wire + context logging - Best for Debugging --> <!-- <Logger name=\"org.apache.http\" level=\"debug\" /> <Logger name=\"org.apache.http.wire\" level=\"error\" /> --> <!-- SNIP --> </Loggers> </Configuration> So, if you want to change the log level for org.apache.http category to debug level for instance, you can simply add (or uncomment) the following logger element in log4j2.xml file before launching JMeter. For more detail on how to configure log4j2.xml file, please see Apache Log4j 2 Configuration page. Log level for specific categories or root logger can be overridden directly on the command line (instead of modifying log4j2.xml) as well. To do so, use the following options: Overrides a logging setting, setting a particular category to the given priority level. Since 3.2, it is recommended to use a full category name (e.g, or ), but if the category name starts with either or , will be prepended internally to the category name input to construct a full category name (i.e, or ) for backward compatibility. Differences in Logging : Old vs New Practices: As JMeter uses SLF4J as logging API and Apache Log4j 2 as a logging framework since 3.2, not every log level used before 3.2 can match exactly with one of the new available log levels provided by SLF4J/Log4j2. Therefore, please keep the following differences and new suggested practices in mind if you need to migrate any existing logging configurations and logging code. Use SLF4J API with either category or explicit class: Mapping to New Levels through SLF4J/Log4j2: Since is not supported by SLF4J API, it is treated as instead for existing code not to break. There is also the log level option. level, which is less specific than , is supported additionally since 3.2. Look up SLF4J or Apache Log4J 2 documentations for details. JMeter does not generally use pop-up dialog boxes for errors, as these would interfere with running tests. Nor does it report any error for a mis-spelt variable or function; instead the reference is just used as is. See Functions and Variables for more information If JMeter detects an error during a test, a message will be written to the log file. The log file name is defined in the log4j2.xml file (or using the -j option, see below). It defaults to jmeter.log, and will be found in the directory from which JMeter was launched. The menu Options → Log Viewer displays the log file in a bottom pane on main JMeter window. In the GUI mode, the number of error/fatal messages logged in the log file is displayed at top-right. The command-line option -j jmeterlogfile allow to process after the initial properties file is read, and before any further properties are processed. It therefore allows the default of jmeter.log to be overridden. The jmeter scripts that take a test plan name as a parameter (e.g. jmeter-n.cmd) have been updated to define the log file using the test plan name, e.g. for the test plan Test27.jmx the log file is set to Test27.log. When running on Windows, the file may appear as just jmeter unless you have set Windows to show file extensions. [Which you should do anyway, to make it easier to detect viruses and other nasties that pretend to be text files …] As well as recording errors, the jmeter.log file records some information about the test run. For example: 2017-03-01 12:19:20,314 INFO o.a.j.JMeter: Version 3.2.20170301 2017-03-01 12:19:45,314 INFO o.a.j.g.a.Load: Loading file: c:\\mytestfiles\\BSH.jmx 2017-03-01 12:19:52,328 INFO o.a.j.e.StandardJMeterEngine: Running the test! 2017-03-01 12:19:52,384 INFO o.a.j.e.StandardJMeterEngine: Starting 1 threads for group BSH. Ramp up = 1. 2017-03-01 12:19:52,485 INFO o.a.j.e.StandardJMeterEngine: Continue on error 2017-03-01 12:19:52,589 INFO o.a.j.t.JMeterThread: Thread BSH1-1 started 2017-03-01 12:19:52,590 INFO o.a.j.t.JMeterThread: Thread BSH1-1 is done 2017-03-01 12:19:52,691 INFO o.a.j.e.StandardJMeterEngine: Test has ended The log file can be helpful in determining the cause of an error, as JMeter does not interrupt a test to display an error dialogue. Invoking JMeter as \"jmeter -?\" will print a list of all the command-line options. These are shown below. --? print command line options and exit -h, --help print usage information and exit -v, --version print the version information and exit -p, --propfile <argument> the jmeter property file to use -q, --addprop <argument> additional JMeter property file(s) -t, --testfile <argument> the jmeter test(.jmx) file to run -l, --logfile <argument> the file to log samples to -i, --jmeterlogconf <argument> jmeter logging configuration file (log4j2.xml) -j, --jmeterlogfile <argument> jmeter run log file (jmeter.log) -n, --nongui run JMeter in nongui mode -s, --server run the JMeter server -H, --proxyHost <argument> Set a proxy server for JMeter to use -P, --proxyPort <argument> Set proxy server port for JMeter to use -N, --nonProxyHosts <argument> Set nonproxy host list (e.g. *.apache.org|localhost) -u, --username <argument> Set username for proxy server that JMeter is to use -a, --password <argument> Set password for proxy server that JMeter is to use -J, --jmeterproperty <argument>=<value> Define additional JMeter properties -G, --globalproperty <argument>=<value> Define Global properties (sent to servers) e.g. -Gport=123 or -Gglobal.properties -D, --systemproperty <argument>=<value> Define additional system properties -S, --systemPropertyFile <argument> additional system property file(s) -f, --forceDeleteResultFile force delete existing results files and web report folder if present before starting the test -L, --loglevel <argument>=<value> [category=]level e.g. jorphan=INFO, jmeter.util=DEBUG or com.example.foo=WARN -r, --runremote Start remote servers (as defined in remote_hosts) -R, --remotestart <argument> Start these remote servers (overrides remote_hosts) -d, --homedir <argument> the jmeter home directory to use -X, --remoteexit Exit the remote servers at end of test (CLI mode) -g, --reportonly <argument> generate report dashboard only, from a test results file -e, --reportatendofloadtests generate report dashboard after load test -o, --reportoutputfolder <argument> output folder for report dashboard Note: the JMeter log file name is formatted as a SimpleDateFormat (applied to the current date) if it contains paired single-quotes, .e.g. 'jmeter_'yyyyMMddHHmmss'.log' If the special name LAST is used for the -t, -j or -l flags, then JMeter takes that to mean the last test plan that was run in interactive mode. Prior to version 2.5.1, JMeter invoked System.exit() when a CLI mode test completed. This caused problems for applications that invoke JMeter directly, so JMeter no longer invokes System.exit() for a normal test completion. [Some fatal errors may still invoke System.exit()] JMeter will exit all the non-daemon threads it starts, but it is possible that some non-daemon threads may still remain; these will prevent the JVM from exiting. To detect this situation, JMeter starts a new daemon thread just before it exits. This daemon thread waits a short while; if it returns from the wait, then clearly the JVM has not been able to exit, and the thread prints a message to say why. The property jmeter.exit.check.pause can be used to configure the delay before printing non-daemon threads. If set to 0 (default value), then JMeter does not print non-terminated threads at the end of the test.\n\nIf you wish to modify the properties with which JMeter runs you need to either modify the user.properties in the /bin directory or create your own copy of the jmeter.properties and specify it in the command line. Note: You can define additional JMeter properties in the file defined by the JMeter property which has the default value . The file will be automatically loaded if it is found in the current directory or if it is found in the JMeter bin directory. Similarly, is used to update system properties. You can specify the class for your SSL implementation if you don't want to use the built-in Java implementation. You can specify an implementation as your XML parser. The default value is: Comma-delimited list of remote JMeter hosts (or if required). If you are running JMeter in a distributed environment, list the machines where you have JMeter remote servers running. This will allow you to control those servers from this machine's GUI A list of components you do not want to see in JMeter's menus. As JMeter has more and more components added, you may wish to customize your JMeter to show only those components you are interested in. You may list their classname or their class label (the string that appears in JMeter's UI) here, and they will no longer appear in the menus. List of paths (separated by ) that JMeter will search for JMeter plugin classes, for example additional samplers. A path item can either be a jar file or a directory. Any jar file in such a directory will be automatically included in , jar files in sub directories are ignored. The given value is in addition to any jars found in the directory. List of paths that JMeter will search for utility and plugin dependency classes. Use your platform path separator to separate multiple paths. A path item can either be a jar file or a directory. Any jar file in such a directory will be automatically included in , jar files in sub directories are ignored. The given value is in addition to any jars found in the lib directory. All entries will be added to the class path of the system class loader and also to the path of the JMeter internal loader. List of paths (separated by ) that JMeter will search for utility and plugin dependency classes. A path item can either be a jar file or a directory. Any jar file in such a directory will be automatically included in , jar files in sub directories are ignored. The given value is in addition to any jars found in the directory or given by the property. All entries will be added to the path of the JMeter internal loader only. For plugin dependencies using should be preferred over . Name of file containing additional JMeter properties. These are added after the initial property file, but before the and options are processed. Name of file containing additional system properties. These are added before the and options are processed. The command line options and properties files are processed in the following order:\n• (or the file from the option) is then loaded\n• all other command-line options are processed See also the comments in the jmeter.properties, user.properties and system.properties files for further information on other settings you can change."
    },
    {
        "link": "https://jmeter.apache.org/usermanual/component_reference.html",
        "document": "Samplers perform the actual work of JMeter. Each sampler (except Flow Control Action) generates one or more sample results. The sample results have various attributes (success/fail, elapsed time, data size etc.) and can be viewed in the various listeners. This controller lets you send an FTP \"retrieve file\" or \"upload file\" request to an FTP server. If you are going to send multiple requests to the same FTP server, consider using a FTP Request Defaults Configuration Element so you do not have to enter the same information for each FTP Request Generative Controller. When downloading a file, it can be stored on disk (Local File) or in the Response Data, or both. Latency is set to the time it takes to login. Descriptive name for this sampler that is shown in the tree. Domain name or IP address of the FTP server. Port to use. If this is , then this specific port is used, otherwise JMeter uses the default FTP port. File to retrieve or name of destination file to upload. File to upload, or destination for downloads (defaults to remote file name). Provides the contents for the upload, overrides the Local File property. Whether to retrieve or upload a file. Check this to use Binary mode (default ASCII) Whether to store contents of retrieved file in response data. If the mode is ASCII, then the contents will be visible in the View Results Tree FTP account password. N.B. This will be visible in the test plan. This sampler lets you send an HTTP/HTTPS request to a web server. It also lets you control whether or not JMeter parses HTML files for images and other embedded resources and sends HTTP requests to retrieve them. The following types of embedded resource are retrieved:\n• stylesheets (CSS) and resources referenced from those files The default parser is org.apache.jmeter.protocol.http.parser.LagartoBasedHtmlParser. This can be changed by using the property \"htmlparser.className\" - see jmeter.properties for details. If you are going to send multiple requests to the same web server, consider using an HTTP Request Defaults Configuration Element so you do not have to enter the same information for each HTTP Request. Or, instead of manually adding HTTP Requests, you may want to use JMeter's HTTP(S) Test Script Recorder to create them. This can save you time if you have a lot of HTTP requests or requests with many parameters. There are three different test elements used to define the samplers: uses the Tomcat mod_jk protocol (allows testing of Tomcat in AJP mode without needing Apache httpd) The AJP Sampler does not support multiple file upload; only the first file will be used. this has an implementation drop-down box, which selects the HTTP protocol implementation to be used: uses the HTTP implementation provided by the JVM. This has some limitations in comparison with the HttpClient implementations - see below. does not set implementation on HTTP Samplers, so relies on HTTP Request Defaults if present or on property defined in this is a GUI variation of the HTTP Request to provide more convenient UI elements to view or edit GraphQL Query, Variables and Operation Name, while converting them into HTTP Arguments automatically under the hood using the same sampler. This hides or customizes the following UI elements as they are less convenient for or irrelevant to GraphQL over HTTP/HTTPS requests:\n• Method: Only POST and GET methods are available conforming the GraphQL over HTTP specification. POST method is selected by default.\n• Parameters and Post Body tabs: you may view or edit parameter content through Query, Variables and Operation Name UI elements instead.\n• Embedded Resources from HTML Files section in the Advanced tab: irrelevant in GraphQL JSON responses. The Java HTTP implementation has some limitations:\n• There is no control over how connections are re-used. When a connection is released by JMeter, it may or may not be re-used by the same thread.\n• The API is best suited to single-threaded usage - various settings are defined via system properties, and therefore apply to all connections.\n• It does not support client based certificate testing with Keystore Config.\n• It does not support virtual hosts.\n• It supports only the following methods: , , , , , and\n• Better control on DNS Caching with DNS Cache Manager Note: the protocol is intended for testing purposes only. It is handled by the same code regardless of which HTTP Sampler is used. If the request requires server or proxy login authorization (i.e. where a browser would create a pop-up dialog box), you will also have to add an HTTP Authorization Manager Configuration Element. For normal logins (i.e. where the user enters login information in a form), you will need to work out what the form submit button does, and create an HTTP request with the appropriate method (usually POST) and the appropriate parameters from the form definition. If the page uses HTTP, you can use the JMeter Proxy to capture the login sequence. A separate SSL context is used for each thread. If you want to use a single SSL context (not the standard behaviour of browsers), set the JMeter property: By default, since version 5.0, the SSL context is retained during a Thread Group iteration and reset for each test iteration. If in your test plan the same user iterates multiple times, then you should set this to false. Note: this does not apply to the Java HTTP implementation. JMeter defaults to the SSL protocol level TLS. If the server needs a different level, e.g. , change the JMeter property, for example: By default, since version 5.0, the SSL context is retained during a Thread Group iteration and reset for each test iteration. If in your test plan the same user iterates multiple times, then you should set this to false.JMeter defaults to the SSL protocol level TLS. If the server needs a different level, e.g., change the JMeter property, for example: JMeter also allows one to enable additional protocols, by changing the property https.socket.protocols. If the request uses cookies, then you will also need an HTTP Cookie Manager. You can add either of these elements to the Thread Group or the HTTP Request. If you have more than one HTTP Request that needs authorizations or cookies, then add the elements to the Thread Group. That way, all HTTP Request controllers will share the same Authorization Manager and Cookie Manager elements. If the request uses a technique called \"URL Rewriting\" to maintain sessions, then see section 6.1 Handling User Sessions With URL Rewriting for additional configuration steps. Descriptive name for this sampler that is shown in the tree. . [Do not include the prefix.] Note: If the \" \" header is defined in a Header Manager, then this will be used as the virtual host name.\n• it is provided by HTTP Request Defaults\n• or a full URL including scheme, host and port ( ) is set in Path field Domain name or IP address of the web server, e.g.. [Do not include theprefix.] Note: If the \"\" header is defined in a Header Manager, then this will be used as the virtual host name. Port the web server is listening to. Default: Connection Timeout. Number of milliseconds to wait for a connection to open. Response Timeout. Number of milliseconds to wait for a response. Note that this applies to each wait for a response. If the server response is sent in several chunks, the overall elapsed time may be longer than the timeout. A Duration Assertion can be used to detect responses that take too long to complete. Hostname or IP address of a proxy server to perform request. [Do not include the prefix.] Port the proxy server is listening to. No, unless proxy hostname is specified , . If not specified (and not defined by HTTP Request Defaults), the default depends on the value of the JMeter property , failing that, the HttpClient4 implementation is used. , , , , , , , (not supported for implementation). With , the following methods related to WebDav are also allowed: , , , , , , , , , . (not supported forimplementation). With, the following methods related to WebDav are also allowed: More methods can be pre-defined for the HttpClient4 by using the JMeter property httpsampler.user_defined_methods. Content encoding to be used (for , , and ). This is the character encoding to be used, and is not related to the Content-Encoding HTTP header. and requests. The HttpClient sampler will reject attempts to use it for or . Warning: see below for information on cookie and header handling. Sets the underlying http protocol handler to automatically follow redirects, so they are not seen by JMeter, and thus will not appear as samples. Should only be used forandrequests. The HttpClient sampler will reject attempts to use it foror \" is not enabled. If set, the JMeter sampler will check if the response is a redirect and follow it if so. The initial redirect and further responses will appear as additional samples. The URL and data fields of the parent sample will be taken from the final (non-redirected) sample, but the parent byte count and elapsed time include all samples. The latency is taken from the initial response. Note that the HttpClient sampler may log the following message: This can be ignored. \n\n JMeter will collapse paths of the form ' ' in both absolute and relative redirect URLs. For example will be collapsed into . If necessary, this behaviour can be suppressed by setting the JMeter property This only has any effect if \"\" is not enabled. If set, the JMeter sampler will check if the response is a redirect and follow it if so. The initial redirect and further responses will appear as additional samples. The URL and data fields of the parent sample will be taken from the final (non-redirected) sample, but the parent byte count and elapsed time include all samples. The latency is taken from the initial response. Note that the HttpClient sampler may log the following message:This can be ignored.JMeter will collapse paths of the form '' in both absolute and relative redirect URLs. For examplewill be collapsed into. If necessary, this behaviour can be suppressed by setting the JMeter property JMeter sets the Connection: header. This does not work properly with the default HTTP implementation, as connection re-use is not under user-control. It does work with the Apache HttpComponents HttpClient implementations. When using , this suppresses the and headers; only the header is sent. ). If the resource requires query string parameters, add them below in the \"Send Parameters With the Request\" section. As a special case, if the path starts with \" \" or \" \" then this is used as the full URL. In this case, the server, port and protocol fields are ignored; parameters are also ignored for and methods. Also please note that the path is not encoded - apart from replacing spaces with - so unsafe characters may need to be encoded to avoid errors such as . The path to resource (for example,). If the resource requires query string parameters, add them below in the \"Send Parameters With the Request\" section.In this case, the server, port and protocol fields are ignored; parameters are also ignored forandmethods. Also please note that the path is not encoded - apart from replacing spaces with- so unsafe characters may need to be encoded to avoid errors such as and , the options to encode the parameter, and an option to include or exclude an equals sign (some applications don't expect an equals sign when the value is the empty string). The query string will be generated in the correct fashion, depending on the choice of \"Method\" you made (i.e. if you chose or , the query string will be appended to the URL, if or , then it will be sent separately). Also, if you are sending a file using a multipart form, the query string will be created using the multipart form specifications. See below for some further information on parameter handling. The query string will be generated from the list of parameters you provide. Each parameter has aand, the options to encode the parameter, and an option to include or exclude an equals sign (some applications don't expect an equals sign when the value is the empty string). The query string will be generated in the correct fashion, depending on the choice of \"Method\" you made (i.e. if you choseor, the query string will be appended to the URL, ifor, then it will be sent separately). Also, if you are sending a file using a multipart form, the query string will be created using the multipart form specifications. Additionally, you can specify whether each parameter should be URL encoded. If you are not sure what this means, it is probably best to select it. If your values contain characters such as the following then encoding is usually required.:\n• Reserved characters:URLs use some characters for special use in defining their syntax. When these characters are not used in their special role inside a URL, they need to be encoded, example: ' ', ' ', ' ', ' ' , ' ', ' ', ' ', ' ', ' ', ' '\n• Unsafe characters: Some characters present the possibility of being misunderstood within URLs for various reasons. These characters should also always be encoded, example: ' ', ' ', ' ', ' ', ' ', … Name of the file to send. If left blank, JMeter does not send a file, if filled in, JMeter automatically sends the request as a multipart form request. When MIME Type is empty, JMeter will try to guess the MIME type of the given file. If it is a POST or PUT or PATCH request and there is a single file whose 'Parameter name' attribute (below) is omitted, then the file is sent as the entire body of the request, i.e. no wrappers are added. This allows arbitrary bodies to be sent. This functionality is present for POST requests, and also for PUT requests. See below for some further information on parameter handling. Value of the \" \" web request parameter. MIME type (for example, ). If it is a or or request and either the ' ' attribute (below) are omitted or the request body is constructed from parameter values only, then the value of this field is used as the value of the request header. Tell JMeter to parse the HTML file and send HTTP/HTTPS requests for all images, Java applets, JavaScript files, CSSs, etc. referenced in the file. See below for more details. If this is selected, then the response is not stored in the sample result. Instead, the 32 character MD5 hash of the data is calculated and stored instead. This is intended for testing large amounts of data. If present, this must be a regular expression that is used to match against any embedded URLs found. So if you only want to download embedded resources from , use the expression: If present, this must be a regular expression that is used to filter out any embedded URLs found. So if you don't want to download PNG or SVG files from any source, use the expression: Use a pool of concurrent connections to get embedded resources. Pool size for concurrent connections used to get embedded resources. [Only for HTTP Request with HTTPClient implementation] \n\n To distinguish the source address value, select the type of these:\n• Select IP/Hostname to use a specific IP address or a (local) hostname\n• Select Device to pick the first available address for that interface which this may be either IPv4 or IPv6\n• Select Device IPv4 to select the IPv4 address of the device name (like , , , etc.)\n• Select Device IPv6 to select the IPv6 address of the device name (like , , , etc.) To distinguish the source address value, select the type of these: [Only for HTTP Request with HTTPClient implementation] \n\n This property is used to enable IP Spoofing. It overrides the default local IP address for this sample. The JMeter host must have multiple IP addresses (i.e. IP aliases, network interfaces, devices). The value can be a host name, IP address, or a network interface device such as \" \" or \" \" or \" \". \n\n If the property is defined, that is used for all HttpClient requests. The following parameters are available only for GraphQL HTTP Request: GraphQL query (or mutation) variables in a valid JSON string. Note: If the input string is not a valid JSON string, this will be ignored with an ERROR log. Optional GraphQL operation name when making a request for multi-operation documents. When using Automatic Redirection, cookies are only sent for the initial URL. This can cause unexpected behaviour for web-sites that redirect to a local server. E.g. if redirects to . In this case the server will probably return cookies for both URLs, but JMeter will only see the cookies for the last host, i.e. . If the next request in the test plan uses , rather than , it will not get the correct cookies. Likewise, Headers are sent for the initial request, and won't be sent for the redirect. This is generally only a problem for manually created test plans, as a test plan created using a recorder would continue from the redirected URL. Parameter Handling: \n\n For the POST and PUT method, if there is no file to send, and the name(s) of the parameter(s) are omitted, then the body is created by concatenating all the value(s) of the parameters. Note that the values are concatenated without adding any end-of-line characters. These can be added by using the __char() function in the value fields. This allows arbitrary bodies to be sent. The values are encoded if the encoding flag is set. See also the MIME Type above how you can control the content-type request header that is sent. \n\n For other methods, if the name of the parameter is missing, then the parameter is ignored. This allows the use of optional parameters defined by variables. \n\n You have the option to switch to Body Data tab when a request has only unnamed parameters (or no parameters at all). This option is useful in the following cases (amongst others): Note that once you leave the Tree node, you cannot switch back to the parameter tab unless you clear the tab from its data. In Body Data mode, each line will be sent with CRLF appended, apart from the last line. To send a CRLF after the last line of data, just ensure that there is an empty line following it. (This cannot be seen, except by noting whether the cursor can be placed on the subsequent line.) Method Handling: \n\n The GET, DELETE, POST, PUT and PATCH request methods work similarly, except that as of 3.1, only POST method supports multipart requests or file upload. The PUT and PATCH method body must be provided as one of the following:\n• define the body as a file with empty Parameter name field; in which case the MIME Type is used as the Content-Type\n• define the body as parameter value(s) with no name The GET, DELETE and POST methods have an additional way of passing parameters by using the Parameters tab. GET, DELETE, PUT and PATCH require a Content-Type. If not using a file, attach a Header Manager to the sampler and define the Content-Type there. JMeter scan responses from embedded resources. It uses the property HTTPResponse.parsers, which is a list of parser ids, e.g. htmlParser, cssParser and wmlParser. For each id found, JMeter checks two further properties:\n• - the parser to be used to extract the embedded resources See jmeter.properties file for the details of the settings. If the HTTPResponse.parser property is not set, JMeter reverts to the previous behaviour, i.e. only text/html responses will be scanned Emulating slow connections: \n\n HttpClient4 and Java Sampler support emulation of slow connections; see the following entries in jmeter.properties: # Define characters per second > 0 to emulate slow connections #httpclient.socket.http.cps=0 #httpclient.socket.https.cps=0 However the sampler only supports slow HTTPS connections. The implementation does not include transport overhead such as chunk headers in the response body size. \n\n The implementation does include the overhead in the response body size, so the value may be greater than the number of bytes in the response content. Retry handling \n\n By default retry has been set to 0 for both HttpClient4 and Java implementations, meaning no retry is attempted. \n\n For HttpClient4, the retry count can be overridden by setting the relevant JMeter property, for example: With HC4 Implementation, retry will be done on Idempotent Http Methods by default. If you want to retry for all methods, then set property Note that the Java implementation does not retry neither by default, you can change this by setting Note that the Java implementation does not retry neither by default, you can change this by setting Note: Certificates does not conform to algorithm constraints \n\n You may encounter the following error: java.security.cert.CertificateException: Certificates does not conform to algorithm constraints if you run a HTTPS request on a web site with a SSL certificate (itself or one of SSL certificates in its chain of trust) with a signature algorithm using MD2 (like md2WithRSAEncryption) or with a SSL certificate with a size lower than 1024 bits. This error is related to increased security in Java 8. To allow you to perform your HTTPS request, you can downgrade the security of your Java installation by editing the Java jdk.certpath.disabledAlgorithms property. Remove the MD2 value or the constraint on size, depending on your case. This property is in this file: This sampler lets you send a JDBC Request (an SQL query) to a database. Before using this you need to set up a JDBC Connection Configuration Configuration element If the Variable Names list is provided, then for each row returned by a Select statement, the variables are set up with the value of the corresponding column (if a variable name is provided), and the count of rows is also set up. For example, if the Select statement returns 2 rows of 3 columns, and the variable list is A,,C, then the following variables will be set up: If the Select statement returns zero rows, then the A_# and C_# variables would be set to 0, and no other variables would be set. Old variables are cleared if necessary - e.g. if the first select retrieves six rows and a second select returns only three rows, the additional variables for rows four, five and six will be removed. The latency time is set from the time it took to acquire a connection. Descriptive name for this sampler that is shown in the tree. Variable Name of Pool declared in JDBC Connection Configuration ' field of a Name of the JMeter variable that the connection pool is bound to. This must agree with the '' field of a JDBC Connection Configuration\n• Update Statement - use this for Inserts and Deletes as well\n• Prepared Update Statement - use this for Inserts and Deletes as well\n• Edit - this should be a variable reference that evaluates to one of the above The types , , and are special, as they are ignoring the given SQL statements and are changing the state of the connection, only. Set this according to the statement type: There is generally no need to use and to enclose Callable statements; however they may be used if the database uses a non-standard syntax. The JDBC driver automatically converts the statement if necessary when it is enclosed in . For example: The second example assumes you are using Apache Derby. SQL query.There is generally no need to useandto enclose Callable statements; however they may be used if the database uses a non-standard syntax.For example:The second example assumes you are using Apache Derby. to indicate a parameter. (If required, the null string can be changed by defining the property \" \".) \n\n The list must be enclosed in double-quotes if any of the values contain a comma or double-quote, and any embedded double-quotes must be doubled-up, for example: There must be as many values as there are placeholders in the statement even if your parameters are ones. Be sure to set a value even if the value will not be used (for example in a CallableStatement). Comma-separated list of parameter values. Useto indicate aparameter. (If required, the null string can be changed by defining the property \"\".)The list must be enclosed in double-quotes if any of the values contain a comma or double-quote, and any embedded double-quotes must be doubled-up, for example: Yes, if a prepared or callable statement has parameters , , , ) or integer values of Constants. Those integer values can be used, when you use custom database types proposed by driver (For example could be represented by its integer value ). \n\n These are defined as fields in the class , see for example: \n\n Javadoc for java.sql.Types. \n\n Note: JMeter will use whatever types are defined by the runtime JVM, so if you are running on a different JVM, be sure to check the appropriate documentation If the callable statement has or parameters, then these must be indicated by prefixing the appropriate parameter types, e.g. instead of \" \", use \" \". \n\n If not specified, \" \" is assumed, i.e. \" \" is the same as \" \". \n\n If the type is not one of the fields found in , JMeter also accepts the corresponding integer number, e.g. since , you can use \" \". \n\n There must be as many types as there are placeholders in the statement. Comma-separated list of SQL parameter types (e.g.) or integer values of Constants. Those integer values can be used, when you use custom database types proposed by driver (For examplecould be represented by its integer value).These are defined as fields in the class, see for example:If not specified, \"\" is assumed, i.e. \"\" is the same as \"\".If the type is not one of the fields found in, JMeter also accepts the corresponding integer number, e.g. since, you can use \"\".There must be as many types as there are placeholders in the statement. Yes, if a prepared or callable statement has parameters Comma-separated list of variable names to hold values returned by Select statements, Prepared Select Statements or CallableStatement. Note that when used with CallableStatement, list of variables must be in the same sequence as the parameters returned by the call. If there are less variable names than parameters only as many results shall be stored in the thread-context variables as variable names were supplied. If more variable names than parameters exist, the additional variables will be ignored \n\n If specified, this will create an Object variable containing a list of row maps. Each map contains the column name as the key and the column data as the value. Usage: Set a timeout in seconds for query, empty value means 0 which is infinite. means don't set any query timeout which might be needed for use case or when certain drivers don't support timeout. Defaults to 0. Limits the number of rows to iterate through the ResultSet. Empty value means , e.g. no limitation, which is also the default. This can help to reduce the amount of data to be fetched from the database via the JDBC driver, but affects all possible options of respectively – e.g. incomplete ResultSet and a record count ≤ the limit.\n• (default) - All variables on Variable Names list are stored as strings, will not iterate through a when present on the list. s will be converted to Strings. s will be converted to Strings as if they were an UTF-8 encoded byte-array. Both s and s will be cut off after bytes.\n• - Variables of type on Variables Names list will be stored as Object and can be accessed in subsequent tests/scripts and iterated, will not iterate through the . s will be handled as if was selected. will be stored as a byte array. Both s and s will be cut off after bytes.\n• - Variables of types will be iterated through showing the count of records as result. Variables will be stored as Strings. For s the size of the object will be stored. Defines how ResultSet returned from callable statements be handled: Current Versions of JMeter use UTF-8 as the character encoding. Previously the platform default was used. Ensure Variable Name is unique across Test Plan. This sampler lets you control a java class that implements the org.apache.jmeter.protocol.java.sampler.JavaSamplerClient interface. By writing your own implementation of this interface, you can use JMeter to harness multiple threads, input parameter control, and data collection. The pull-down menu provides the list of all such implementations found by JMeter in its classpath. The parameters can then be specified in the table below - as defined by your implementation. Two simple examples (JavaTest and SleepTest) are provided. The JavaTest example sampler can be useful for checking test plans, because it allows one to set values in almost all the fields. These can then be used by Assertions, etc. The fields allow variables to be used, so the values of these can readily be seen. is not overridden by a subclass of , its method will not be called. This reduces JMeter memory requirements. This will not have any impact on existing Test plans. If the methodis not overridden by a subclass of, itsmethod will not be called. This reduces JMeter memory requirements. This will not have any impact on existing Test plans. The Add/Delete buttons don't serve any purpose at present. Descriptive name for this sampler that is shown in the tree. The specific implementation of the JavaSamplerClient interface to be sampled. A list of arguments that will be passed to the sampled class. All arguments are sent as Strings. See below for specific settings. The following parameters apply to the SleepTest and JavaTest implementations: How long to sleep for (ms) \n\n The sleep time is calculated as follows: How much \"randomness\" to add:The sleep time is calculated as follows: The following parameters apply additionally to the JavaTest implementation: The label to use. If provided, overrides If provided, sets the SampleResult Status. If this equals \" \" (ignoring case) then the status is set to success, otherwise the sample is marked as failed. , , and ) to an LDAP server. This Sampler lets you send a different LDAP request(and) to an LDAP server. If you are going to send multiple requests to the same LDAP server, consider using an LDAP Request Defaults Configuration Element so you do not have to enter the same information for each LDAP Request. The same way the The same way the Login Config Element also using for Login and password. There are two ways to create test cases for testing an LDAP Server. There are four test scenarios of testing LDAP. The tests are given below:\n• Add Test\n• Inbuilt test: This will add a pre-defined entry in the LDAP Server and calculate the execution time. After execution of the test, the created entry will be deleted from the LDAP Server.\n• User defined test: This will add the entry in the LDAP Server. User has to enter all the attributes in the table.The entries are collected from the table to add. The execution time is calculated. The created entry will not be deleted after the test.\n• Modify Test\n• Inbuilt test: This will create a pre-defined entry first, then will modify the created entry in the LDAP Server.And calculate the execution time. After execution of the test, the created entry will be deleted from the LDAP Server.\n• User defined test: This will modify the entry in the LDAP Server. User has to enter all the attributes in the table. The entries are collected from the table to modify. The execution time is calculated. The entry will not be deleted from the LDAP Server.\n• Search Test\n• Inbuilt test: This will create the entry first, then will search if the attributes are available. It calculates the execution time of the search query. At the end of the execution,created entry will be deleted from the LDAP Server.\n• User defined test: This will search the user defined entry(Search filter) in the Search base (again, defined by the user). The entries should be available in the LDAP Server. The execution time is calculated.\n• Delete Test\n• Inbuilt test: This will create a pre-defined entry first, then it will be deleted from the LDAP Server. The execution time is calculated.\n• User defined test: This will delete the user-defined entry in the LDAP Server. The entries should be available in the LDAP Server. The execution time is calculated. Descriptive name for this sampler that is shown in the tree. Domain name or IP address of the LDAP server. JMeter assumes the LDAP server is listening on the default port ( ). Port to connect to (default is ). Base DN to use for LDAP operations LDAP server password. (N.B. this is stored unencrypted in the test plan) You have to set the right attributes of the object yourself. So if you want to add you have to add in the table and to and . the name of the context to create or Modify; may not be empty. Yes, if User Defined Test and Add Test or Modify Test is selected the name of the context to Delete; may not be empty Yes, if User Defined Test and Delete Test is selected the name of the context or object to search Yes, if User Defined Test and Search Test is selected the filter expression to use for the search; may not be null Yes, if User Defined Test and Search Test is selected Use these , pairs for creation of the new object in the given context Yes, if User Defined Test and add Test is selected Use these , pairs for modification of the given context object Yes, if User Defined Test and Modify Test is selected This Sampler can send all 8 different LDAP requests to an LDAP server. It is an extended version of the LDAP sampler, therefore it is harder to configure, but can be made much closer resembling a real LDAP session. If you are going to send multiple requests to the same LDAP server, consider using an LDAP Extended Request Defaults Configuration Element so you do not have to enter the same information for each LDAP Request. There are nine test operations defined. These operations are given below: Any LDAP request is part of an LDAP session, so the first thing that should be done is starting a session to the LDAP server. For starting this session a thread bind is used, which is equal to the LDAP \"bind\" operation. The user is requested to give a username (Distinguished name) and password, which will be used to initiate a session. When no password, or the wrong password is specified, an anonymous session is started. Take care, omitting the password will not fail this test, a wrong password will. (N.B. this is stored unencrypted in the test plan) Descriptive name for this sampler that is shown in the tree. The name (or IP-address) of the LDAP server. The port number that the LDAP server is listening to. If this is omitted JMeter assumes the LDAP server is listening on the default port(389). The distinguished name of the base object that will be used for any subsequent operation. It can be used as a starting point for all operations. You cannot start any operation on a higher level than this DN! Full distinguished name of the user as which you want to bind. Password for the above user. If omitted it will result in an anonymous bind. If it is incorrect, the sampler will return an error and revert to an anonymous bind. (N.B. this is stored unencrypted in the test plan) Timeout for connection, if exceeded connection will be aborted Use scheme instead of Trust all certificates, only used if is checked This is simply the operation to end a session. It is equal to the LDAP \"unbind\" operation. Descriptive name for this sampler that is shown in the tree. This is a combination of the LDAP \"bind\" and \"unbind\" operations. It can be used for an authentication request/password check for any user. It will open a new session, just to check the validity of the user/password combination, and end the session again. Descriptive name for this sampler that is shown in the tree. Full distinguished name of the user as which you want to bind. Password for the above user. If omitted it will result in an anonymous bind. If it is incorrect, the sampler will return an error. (N.B. this is stored unencrypted in the test plan) This is the LDAP \"moddn\" operation. It can be used to rename an entry, but also for moving an entry or a complete subtree to a different place in the LDAP tree. Descriptive name for this sampler that is shown in the tree. The current distinguished name of the object you want to rename or move, relative to the given DN in the thread bind operation. The new distinguished name of the object you want to rename or move, relative to the given DN in the thread bind operation. This is the LDAP \"add\" operation. It can be used to add any kind of object to the LDAP server. Descriptive name for this sampler that is shown in the tree. Distinguished name of the object you want to add, relative to the given DN in the thread bind operation. A list of attributes and their values you want to use for the object. If you need to add a multiple value attribute, you need to add the same attribute with their respective values several times to the list. This is the LDAP \"delete\" operation, it can be used to delete an object from the LDAP tree Descriptive name for this sampler that is shown in the tree. Distinguished name of the object you want to delete, relative to the given DN in the thread bind operation. This is the LDAP \"search\" operation, and will be used for defining searches. Descriptive name for this sampler that is shown in the tree. Distinguished name of the subtree you want your search to look in, relative to the given DN in the thread bind operation. searchfilter, must be specified in LDAP syntax. Use for baseobject-, for onelevel- and for a subtree search. (Default= ) Specify the maximum number of results you want back from the server. (default= , which means no limit.) When the sampler hits the maximum number of results, it will fail with errorcode Specify the maximum amount of (cpu)time (in milliseconds) that the server can spend on your search. Take care, this does not say anything about the response time. (default is , which means no limit) Specify the attributes you want to have returned, separated by a semicolon. An empty field will return all attributes Whether the object will be returned ( ) or not ( ). Default= If , it will dereference aliases, if , it will not follow them (default= ) If , the search results will be added to the response data. If , a marker - whether results where found or not - will be added to the response data. This is the LDAP \"modify\" operation. It can be used to modify an object. It can be used to add, delete or replace values of an attribute. Descriptive name for this sampler that is shown in the tree. Distinguished name of the object you want to modify, relative to the given DN in the thread bind operation The attribute-value-opCode triples. \n\n The can be any valid LDAP operationCode ( , , or ). \n\n If you don't specify a value with a operation, all values of the given attribute will be deleted. \n\n If you do specify a value in a operation, only the given value will be deleted. \n\n If this value is non-existent, the sampler will fail the test. This is the LDAP \"compare\" operation. It can be used to compare the value of a given attribute with some already known value. In reality this is mostly used to check whether a given person is a member of some group. In such a case you can compare the DN of the user as a given value, with the values in the attribute \"member\" of an object of the type groupOfNames. If the compare operation fails, this test fails with errorcode 49. Descriptive name for this sampler that is shown in the tree. The current distinguished name of the object of which you want to compare an attribute, relative to the given DN in the thread bind operation. AccessLogSampler was designed to read access logs and generate http requests. For those not familiar with the access log, it is the log the webserver maintains of every request it accepted. This means every image, CSS file, JavaScript file, html file, … Tomcat uses the common format for access logs. This means any webserver that uses the common log format can use the AccessLogSampler. Server that use common log format include: Tomcat, Resin, Weblogic, and SunOne. Common log format looks like this: The current implementation of the parser only looks at the text within the quotes that contains one of the HTTP protocol methods ( , , , , …). Everything else is stripped out and ignored. For example, the response code is completely ignored by the parser. For the future, it might be nice to filter out entries that do not have a response code of 200. Extending the sampler should be fairly simple. There are two interfaces you have to implement: The current implementation of AccessLogSampler uses the generator to create a new HTTPSampler. The servername, port and get images are set by AccessLogSampler. Next, the parser is called with integer 1, telling it to parse one entry. After that, HTTPSampler.sample() is called to make the request. The required methods in are: Classes implementing Generator interface should provide concrete implementation for all the methods. For an example of how to implement either interface, refer to StandardGenerator and TCLogParser. Descriptive name for this sampler that is shown in the tree. Domain name or IP address of the web server. Port the web server is listening to. The log parser class is responsible for parsing the logs. The filter class is used to filter out certain lines. The location of the access log file. The TCLogParser processes the access log independently for each thread. The SharedTCLogParser and OrderPreservingLogParser share access to the file, i.e. each thread gets the next entry in the log. The SessionFilter is intended to handle Cookies across threads. It does not filter out any entries, but modifies the cookie manager so that the cookies for a given IP are processed by a single thread at a time. If two threads try to process samples from the same client IP address, then one will be forced to wait until the other has completed. The LogFilter is intended to allow access log entries to be filtered by filename and regex, as well as allowing for the replacement of file extensions. However, it is not currently possible to configure this via the GUI, so it cannot really be used. This sampler allows you to write a sampler using the BeanShell scripting language. For full details on using BeanShell, please see the BeanShell website. Migration to JSR223 Sampler +Groovy is highly recommended for performance, support of new Java features and limited maintenance of the BeanShell library. The test element supports the ThreadListener and TestListener interface methods. These must be defined in the initialisation file. See the file BeanShellListeners.bshrc for example definitions. The BeanShell sampler also supports the Interruptible interface. The interrupt() method can be defined in the script or the init file. Descriptive name for this sampler that is shown in the tree. The name is stored in the script variable Label If this option is selected, then the interpreter will be recreated for each sample. This may be necessary for some long running scripts. For further information, see Best Practices - BeanShell scripting string containing the parameters as a single variable Parameters to pass to the BeanShell script. This is intended for use with script files; for scripts defined in the GUI, you can use whatever variable and function references you need within the script itself. The parameters are stored in the following variables: A file containing the BeanShell script to run. The file name is stored in the script variable The BeanShell script to run. The return value (if not ) is stored as the sampler result. Yes (unless script file is provided) N.B. Each Sampler instance has its own BeanShell interpreter, and Samplers are only called from a single thread If the property \"beanshell.sampler.init\" is defined, it is passed to the Interpreter as the name of a sourced file. This can be used to define common methods and variables. There is a sample init file in the bin directory: BeanShellSampler.bshrc. If a script file is supplied, that will be used, otherwise the script will be used. JMeter processes function and variable references before passing the script field to the interpreter, so the references will only be resolved once. Variable and function references in script files will be passed verbatim to the interpreter, which is likely to cause a syntax error. In order to use runtime variables, please use the appropriate props methods, e.g. \n\n BeanShell does not currently support Java 5 syntax such as generics and the enhanced for loop. Before invoking the script, some variables are set up in the BeanShell interpreter: The contents of the Parameters field is put into the variable \"Parameters\". The string is also split into separate tokens using a single space as the separator, and the resulting list is stored in the String array bsh.args. The full list of BeanShell variables that is set up is as follows:\n• - the file name, if any\n• - the parameters, split as described above When the script completes, control is returned to the Sampler, and it copies the contents of the following script variables into the corresponding variables in the SampleResult: The SampleResult ResponseData is set from the return value of the script. If the script returns null, it can set the response directly, by using the method SampleResult.setResponseData(data), where data is either a String or a byte array. The data type defaults to \"text\", but can be set to binary by using the method SampleResult.setDataType(SampleResult.BINARY). The SampleResult variable gives the script full access to all the fields and methods in the SampleResult. For example, the script has access to the methods setStopThread(boolean) and setStopTest(boolean). Here is a simple (not very useful!) example script: if (bsh.args[0].equalsIgnoreCase(\"StopThread\")) { log.info(\"Stop Thread detected!\"); SampleResult.setStopThread(true); } return \"Data from sample with Label \"+Label; //or SampleResult.setResponseData(\"My data\"); return null; Another example: \n\n ensure that the property beanshell.sampler.init=BeanShellSampler.bshrc is defined in jmeter.properties. The following script will show the values of all the variables in the ResponseData field: For details on the methods available for the various classes (JMeterVariables, SampleResult etc.) please check the Javadoc or the source code. Beware however that misuse of any methods can cause subtle faults that may be difficult to find. The JSR223 Sampler allows JSR223 script code to be used to perform a sample or some computation required to create/update variables. This call will have the following impact:\n• SampleResult will not be delivered to SampleListeners like View Results Tree, Summariser ...\n• SampleResult will not be evaluated in Assertions nor PostProcessors\n• SampleResult will be evaluated to computing last sample status (${JMeterThread.last_sample_ok}), and ThreadGroup \"Action to be taken after a Sampler error\" (since JMeter 5.4) If you don't want to generate a SampleResult when this sampler is run, call the following method:This call will have the following impact: The JSR223 test elements have a feature (compilation) that can significantly increase performance. To benefit from this feature:\n• Use Script files instead of inlining them. This will make JMeter compile them if this feature is available on ScriptEngine and cache them.\n• Or Use Script Text and check property. When using this feature, ensure your script code does not use JMeter variables or JMeter function calls directly in script code as caching would only cache first replacement. Instead use script parameters. interface (Groovy is one of these, java, beanshell and javascript are not) To benefit from caching and compilation, the language engine used for scripting must implement JSR223interface (Groovy is one of these, java, beanshell and javascript are not) (while caching is recommended), you should set this JVM Property due to a Groovy Memory leak as of version 2.4.6, see: When using Groovy as scripting language and not checking(while caching is recommended), you should set this JVM Propertydue to a Groovy Memory leak as of version 2.4.6, see: Cache size is controlled by the following JMeter property ( ): Unlike the BeanShell Sampler , the interpreter is not saved between invocations. JSR223 Test Elements using Script file or Script text + checked are now compiled if ScriptEngine supports this feature, this enables great performance enhancements. Cache size is controlled by the following JMeter property (): JMeter processes function and variable references before passing the script field to the interpreter, so the references will only be resolved once. Variable and function references in script files will be passed verbatim to the interpreter, which is likely to cause a syntax error. In order to use runtime variables, please use the appropriate props methods, e.g. Descriptive name for this sampler that is shown in the tree. \n\n Notice that some languages such as Velocity may use a different syntax for JSR223 variables, e.g. for Velocity. There are other languages supported than those that appear in the drop-down list. Others may be available if the appropriate jar is installed in the JMeter lib directory.Notice that some languages such as Velocity may use a different syntax for JSR223 variables, e.g.for Velocity. Name of the JSR223 scripting language to be used. Name of a file to be used as a JSR223 script, if a relative file path is used, then it will be relative to directory referenced by \" \" System property List of parameters to be passed to the script file or the script. interface (Groovy is one of these, java, beanshell and javascript are not), JMeter will compile the Script and cache it using its MD5 hash as unique cache key If checked (advised) and the language used supportsinterface (Groovy is one of these, java, beanshell and javascript are not), JMeter will compile the Script and cache it using its MD5 hash as unique cache key Script to be passed to JSR223 language Yes (unless script file is provided) If a script file is supplied, that will be used, otherwise the script will be used. Before invoking the script, some variables are set up. Note that these are JSR223 variables - i.e. they can be used directly in the script.\n• - the file name, if any\n• - the parameters, split as described above The SampleResult ResponseData is set from the return value of the script. If the script returns null, it can set the response directly, by using the method SampleResult.setResponseData(data), where data is either a String or a byte array. The data type defaults to \"text\", but can be set to binary by using the method SampleResult.setDataType(SampleResult.BINARY). The SampleResult variable gives the script full access to all the fields and methods in the SampleResult. For example, the script has access to the methods setStopThread(boolean) and setStopTest(boolean). Unlike the BeanShell Sampler, the JSR223 Sampler does not set the ResponseCode, ResponseMessage and sample status via script variables. Currently the only way to changes these is via the SampleResult methods: The TCP Sampler opens a TCP/IP connection to the specified server. It then sends the text, and waits for a response. If \"Re-use connection\" is selected, connections are shared between Samplers in the same thread, provided that the exact same host name string and port are used. Different hosts/port combinations will use different connections, as will different threads. If both of \"Re-use connection\" and \"Close connection\" are selected, the socket will be closed after running the sampler. On the next sampler, another socket will be created. You may want to close a socket at the end of each thread loop. If an error is detected - or \"Re-use connection\" is not selected - the socket is closed. Another socket will be reopened on the next sample. The following properties can be used to control its operation: name of property file to convert status codes to messages Name of TCP Handler class (default ) - only used if not specified on the GUI The class that handles the connection is defined by the GUI, failing that the property . If not found, the class is then searched for in the package . The class that handles the connection is defined by the GUI, failing that the property. If not found, the class is then searched for in the package Users can provide their own implementation. The class must extend org.apache.jmeter.protocol.tcp.sampler.TCPClient. The following implementations are currently provided. The implementations behave as follows: This implementation is fairly basic. When reading the response, it reads until the end of line byte, if this is defined by setting the property , otherwise until the end of the input stream. You can control charset encoding by setting , which will default to Platform default encoding. This implementation converts the GUI input, which must be a hex-encoded string, into binary, and performs the reverse when reading the response. When reading the response, it reads until the end of message byte, if this is defined by setting the property , otherwise until the end of the input stream. This implementation extends BinaryTCPClientImpl by prefixing the binary message data with a binary length byte. The length prefix defaults to 2 bytes. This can be changed by setting the property . If the timeout is set, the read will be terminated when this expires. So if you are using an / , make sure the timeout is sufficiently long, otherwise the read will be terminated early. If is defined, then the response message is searched for the text following that up to the suffix. If any such text is found, it is used to set the response code. The response message is then fetched from the properties file (if provided). For example, if the prefix = \" \" and the suffix = \" \", then the following response: would have the response code . For example, if the prefix = \"\" and the suffix = \"\", then the following response:would have the response code Response codes in the range \" \"-\" \" and \" \"-\" \" are currently regarded as failures; all others are successful. [This needs to be made configurable!] The login name/password are not used by the supplied TCP implementations. \n\n Sockets are disconnected at the end of a test run. The implementations behave as follows:Sockets are disconnected at the end of a test run. Descriptive name for this element that is shown in the tree. Name of the TCPClient class. Defaults to the property , failing that . If selected, the connection is kept open. Otherwise it is closed when the data has been read. If selected, the connection will be closed after running the sampler. Enable/disable with the specified linger time in seconds when a socket is created. If you set \" \" value as , you may prevent large numbers of sockets sitting around with a status. Byte value for end of line, set this to a value outside the range to to skip checking. You may set this in file as well with property. If you set this in TCP Sampler Config and in file at the same time, the setting value in the TCP Sampler Config will be used. See . If selected, this will disable Nagle's algorithm, otherwise Nagle's algorithm will be used. User Name - not used by default implementation Password - not used by default implementation (N.B. this is stored unencrypted in the test plan) JMS Publisher will publish messages to a given destination (topic/queue). For those not familiar with JMS, it is the J2EE specification for messaging. There are numerous JMS servers on the market and several open source options. \n\n JMeter does not include any JMS implementation jar; this must be downloaded from the JMS provider and put in the lib directory Descriptive name for this element that is shown in the tree. use . Note that the file must be on the classpath - e.g. by updating the JMeter property. If this option is not selected, JMeter uses the \" \" and \" \" fields to create the connection. Name of the context factory The URL for the JMS provider Yes, unless using jndi.properties The message destination (topic or queue name) The destination setup type. With , the destination name is static (i.e. always same name during the test), with , the destination name is dynamic and is evaluate at each sample (i.e. the destination name may be a variable) Password (N.B. this is stored unencrypted in the test plan) The expiration time (in milliseconds) of the message before it becomes obsolete. If you do not specify an expiration time, the default value is (never expires). The priority level of the message. There are ten priority levels from (lowest) to (highest). If you do not specify a priority level, the default level is . Regular expression for JMSException error codes which force reconnection. If empty no reconnection will be done means the referenced file will be read and reused by all samples. If file name changes it is reloaded since JMeter 3.0 Random File from folder specified below means a random file will be selected from folder specified below, this folder must contain either files with extension for Bytes Messages, or files with extension or for Object or Text messages The Message to use either for Text or Object message Where to obtain the message: No variable support from the file and load it with default system charset. Load file with default system encoding, except for XML which relies on XML prolog. If the file contain variables, they will be processed. The specified encoding (valid or not) is used for reading the file and processing variables Specify the encoding for reading the message source file: Whether to set (defaults to ) The JMS Properties are properties specific for the underlying messaging system. You can setup the name, the value and the class (type) of value. Default type is . For example: for WebSphere 5.1 web services you will need to set the JMS Property targetService to test webservices through JMS. For the MapMessage type, JMeter reads the source as lines of text. Each line must have 3 fields, delimited by commas. The fields are:\n• Object class name, e.g. \" \" (assumes package if not specified)\n• Put the JAR that contains your object and its dependencies in folder\n• Serialize your object as XML using XStream\n• Either put result in a file suffixed with or or put XML content directly in Text Area Note that if message is in a file, replacement of properties will not occur while it will if you use Text Area. The Object message is implemented and works as follow:Note that if message is in a file, replacement of properties will not occur while it will if you use Text Area. The following table shows some values which may be useful when configuring JMS: JMS Subscriber will subscribe to messages in a given destination (topic or queue). For those not familiar with JMS, it is the J2EE specification for messaging. There are numerous JMS servers on the market and several open source options. \n\n JMeter does not include any JMS implementation jar; this must be downloaded from the JMS provider and put in the lib directory Descriptive name for this element that is shown in the tree. use . Note that the file must be on the classpath - e.g. by updating the JMeter property. If this option is not selected, JMeter uses the \" \" and \" \" fields to create the connection. Name of the context factory The URL for the JMS provider the message destination (topic or queue name) The ID to use for a durable subscription. On first use the respective queue will automatically be generated by the JMS provider if it does not exist yet. The Client ID to use when you use a durable subscription. Be sure to add a variable like when you have more than one Thread. Message Selector as defined by JMS specification to extract only messages that respect the Selector condition. Syntax uses subpart of SQL 92. The destination setup type. With , the destination name is static (i.e. always same name during the test), with , the destination name is dynamic and is evaluated at each sample (i.e. the destination name may be a variable) Password (N.B. this is stored unencrypted in the test plan) should the sampler store the response. If not, only the response length is returned. Specify the timeout to be applied, in milliseconds. =none. This is the overall aggregate timeout, not per sample. calls for every requested message. Retains the connection between samples, but does not fetch messages unless the sampler is active. This is best suited to Queue subscriptions. establishes a Listener that stores all incoming messages on a queue. The listener remains active after the sampler completes. This is best suited to Topic subscriptions. Which client implementation to use. Both of them create connections which can read messages. However they use a different strategy, as described below: If selected, then JMeter calls at the end of each sample (and calls before each sample). This may be useful in some cases where multiple samples/threads have connections to the same queue. If not selected, JMeter calls at the start of the thread, and does not call until the end of the thread. Separator used to separate messages when there is more than one (related to setting Number of samples to aggregate). Note that , , are accepted. Regular expression for JMSException error codes which force reconnection. If empty no reconnection will be done Pause in milliseconds that Subscriber will make when an error occurs This sampler sends and optionally receives JMS Messages through point-to-point connections (queues). It is different from pub/sub messages and is generally used for handling transactions. request_only will typically be used to put load on a JMS System. \n\n request_reply will be used when you want to test response time of a JMS service that processes messages sent to the Request Queue as this mode will wait for the response on the Reply queue sent by this service. \n\n browse returns the current queue depth, i.e. the number of messages on the queue. \n\n read reads a message from the queue (if any). \n\n clear clears the queue, i.e. remove all messages from the queue. \n\n JMeter use the properties java.naming.security.[principal|credentials] - if present - when creating the Queue Connection. If this behaviour is not desired, set the JMeter property JMSSampler.useSecurity.properties=false \n\n JMeter does not include any JMS implementation jar; this must be downloaded from the JMS provider and put in the lib directory Descriptive name for this element that is shown in the tree. The JNDI name of the queue connection factory to use for connecting to the messaging system. This is the JNDI name of the queue to which the messages are sent. The JNDI name of the receiving queue. If a value is provided here and the communication style is this queue will be monitored for responses to the requests sent. Number of samples to aggregate. Only applicable for Communication style Read. Message Selector as defined by JMS specification to extract only messages that respect the Selector condition. Syntax uses subpart of SQL 92. (also known as Fire and Forget), , , , : will only send messages and will not monitor replies. As such it can be used to put load on a system. will send messages and monitor the replies it receives. Behaviour depends on the value of the JNDI Name Reply Queue. If JNDI Name Reply Queue has a value, this queue is used to monitor the results. Matching of request and reply is done with the message id of the request and the correlation id of the reply. If the JNDI Name Reply Queue is empty, then temporary queues will be used for the communication between the requestor and the server. This is very different from the fixed reply queue. With temporary queues the sending thread will block until the reply message has been received. With mode, you need to have a Server that listens to messages sent to Request Queue and sends replies to queue referenced by . will read a message from an outgoing queue which has no listeners attached. This can be convenient for testing purposes. This method can be used if you need to handle queues without a binding file (in case the jmeter-jms-skip-jndi library is used), which only works with the JMS Point-to-Point sampler. In case binding files are used, one can also use the JMS Subscriber Sampler for reading from a queue. will determine the current queue depth without removing messages from the queue, returning the number of messages on the queue. will clear the queue, i.e. remove all messages from the queue. The Communication style can be(also known as Fire and Forget), if selected, the request JMSMessageID will be used, otherwise the request JMSCorrelationID will be used. In the latter case the correlation id must be specified in the request. if selected, the response JMSMessageID will be used, otherwise the response JMSCorrelationID will be used. There are two frequently used JMS Correlation patterns: i.e. match request and response on their correlation Ids => deselect both checkboxes, and provide a correlation id. i.e. match request message id with response correlation id => select \"Use Request Message Id\" only. In both cases the JMS application is responsible for populating the correlation ID as necessary. if the same queue is used to send and receive messages, then the response message will be the same as the request message. In which case, either provide a correlation id and clear both checkboxes; or select both checkboxes to use the message Id for correlation. This can be useful for checking raw JMS throughput. These check-boxes select the fields which will be used for matching the response message with the original request.There are two frequently used JMS Correlation patterns:In both cases the JMS application is responsible for populating the correlation ID as necessary. The timeout in milliseconds for the reply-messages. If a reply has not been received within the specified time, the specific testcase fails and the specific reply message received after the timeout is discarded. Default value is ms. means no timeout. The expiration time (in milliseconds) of the message before it becomes obsolete. If you do not specify an expiration time, the default value is (never expires). The priority level of the message. There are ten priority levels from (lowest) to (highest). If you do not specify a priority level, the default level is . The content of the message. The JMS Properties are properties specific for the underlying messaging system. You can setup the name, the value and the class (type) of value. Default type is . For example: for WebSphere 5.1 web services you will need to set the JMS Property targetService to test webservices through JMS. The Initial Context Factory is the factory to be used to look up the JMS Resources. The JNDI Properties are the specific properties for the underlying JNDI implementation. The URL for the JMS provider. and . The sampler works like the\n• rather than use JMeter's test interface, it scans the jar files for classes extending JUnit's class. That includes any class or subclass.\n• JUnit test jar files should be placed in instead of directory. You can also use the \" \" property to specify where to look for classes.\n• JUnit sampler does not use name/value pairs for configuration like the Java Request. The sampler assumes and will configure the test correctly.\n• The sampler measures the elapsed time only for the test method and does not include and .\n• Each time the test method is called, JMeter will pass the result to the listeners.\n• Support for and is done as a method. Since JMeter is multi-threaded, we cannot call / the same way Maven does it.\n• The sampler reports unexpected exceptions as errors. There are some important differences between standard JUnit test runners and JMeter's implementation. Rather than make a new instance of the class for each test, JMeter creates 1 instance per sampler and reuses it. This can be changed with checkbox \" \". The current implementation of the sampler will try to create an instance using the string constructor first. If the test class does not declare a string constructor, the sampler will look for an empty constructor. Example below: By default, JMeter will provide some default values for the success/failure code and message. Users should define a set of unique success and failure codes and use them uniformly across all tests. If you use and , make sure the methods are declared public. If you do not, the test may not run properly. \n\n Here are some general guidelines for writing JUnit tests so they work well with JMeter. Since JMeter runs multi-threaded, it is important to keep certain things in mind.\n• Write the and methods so they are thread safe. This generally means avoid using static members.\n• Make the test methods discrete units of work and not long sequences of actions. By keeping the test method to a discrete operation, it makes it easier to combine test methods to create new test plans.\n• Avoid making test methods depend on each other. Since JMeter allows arbitrary sequencing of test methods, the runtime behavior is different than the default JUnit behavior.\n• If a test method is configurable, be careful about where the properties are stored. Reading the properties from the Jar file is recommended.\n• Each sampler creates an instance of the test class, so write your test so the setup happens in and . If you useand, make sure the methods are declared public. If you do not, the test may not run properly.Here are some general guidelines for writing JUnit tests so they work well with JMeter. Since JMeter runs multi-threaded, it is important to keep certain things in mind. The current implementation supports standard JUnit convention and extensions. It also includes extensions likeand. The sampler works like the Java Request with some differences.The current implementation of the sampler will try to create an instance using the string constructor first. If the test class does not declare a string constructor, the sampler will look for an empty constructor. Example below:By default, JMeter will provide some default values for the success/failure code and message. Users should define a set of unique success and failure codes and use them uniformly across all tests. Descriptive name for this element that is shown in the tree. Select this to search for JUnit4 tests ( annotations) Comma separated list of packages to show. Example, , . Fully qualified name of the JUnit test class. String pass to the string constructor. If a string is set, the sampler will use the string constructor instead of the empty constructor. An unique code indicating the test was successful. Some code for errors. Does not need to be unique. Do not call setUp and tearDown Set the sampler not to call and . By default, and should be called. Not calling those methods could affect the test and make it inaccurate. This option should only be used with calling and . If the selected method is or , this option should be checked. Whether or not to append assertion errors to the response message. Whether or not to append runtime exceptions to the response message. Only applies if \" \" is not selected. Whether or not to create a new JUnit instance for each sample. Defaults to false, meaning JUnit is created one and reused. The following JUnit4 annotations are recognised: used to find test methods and classes. The \" \" and \" \" attributes are supported. treated the same as in JUnit3 treated the same as in JUnit3 treated as test methods so they can be run independently as required Note that JMeter currently runs the test methods directly, rather than leaving it to JUnit. This is to allow the / methods to be excluded from the sample time. As a consequence, the sampler time excludes the time taken to call / methods and their annotation based alternatives. The Mail Reader Sampler can read (and optionally delete) mail messages using POP3(S) or IMAP(S) protocols. Descriptive name for this element that is shown in the tree. The protocol used by the provider: e.g. , , , . or another string representing the server protocol. For example for use with the read-only mail file provider. The actual provider names for POP3 and IMAP are and Hostname or IP address of the server. See below for use with protocol. Port to be used to connect to the server (optional) User login password (N.B. this is stored unencrypted in the test plan) The IMAP(S) folder to use. See below for use with protocol. Set this to retrieve all or some messages If selected, only the message headers will be retrieved. If set, messages will be deleted after retrieval Whether to store the message as MIME. If so, then the entire raw message is stored in the Response Data; the headers are not stored as they are available in the data. If not, the message headers are stored as Response Headers. A few headers are stored ( , , , ) in the body. Indicates that the connection to the server does not use any security protocol. Indicates that the connection to the server must use the SSL protocol. Indicates that the connection to the server should attempt to start the TLS protocol. If the server does not start the TLS protocol the connection will be terminated. When selected it will accept all certificates independent of the CA. When selected it will only accept certificates that are locally trusted. Path to file containing the trusted certificates. Relative paths are resolved against the current directory. \n\n Failing that, against the directory containing the test script (JMX file). any of the properties described You can pass mail related environment properties by adding toany of the properties described here Messages are stored as subsamples of the main sampler. Multipart message parts are stored as subsamples of the message. Special handling for \"file\" protocol: \n\n The file JavaMail provider can be used to read raw messages from files. The server field is used to specify the path to the parent of the folder. Individual message files should be stored with the name n.msg, where n is the message number. Alternatively, the server field can be the name of a file which contains a single message. The current implementation is quite basic, and is mainly intended for debugging purposes. The Flow Control Action sampler is a sampler that is intended for use in a conditional controller. Rather than generate a sample, the test element either pauses or stops the selected target. This sampler can also be useful in conjunction with the Transaction Controller, as it allows pauses to be included without needing to generate a sample. For variable delays, set the pause time to zero, and add a Timer as a child. The \"Stop\" action stops the thread or test after completing any samples that are in progress. The \"Stop Now\" action stops the test without waiting for samples to complete; it will interrupt any active samples. If some threads fail to stop within the 5 second time-limit, a message will be displayed in GUI mode. You can try using the Stop command to see if this will stop the threads, but if not, you should exit JMeter. In CLI mode, JMeter will exit if some threads fail to stop within the 5 second time limit. The time to wait can be changed using the JMeter property . The time is given in milliseconds. Descriptive name for this element that is shown in the tree. / (ignored for and Go to next loop iteration ) / / / Go to next loop iteration How long to pause for (milliseconds) Yes, if Pause is selected The SMTP Sampler can send mail messages using SMTP/SMTPS protocol. It is possible to set security protocols for the connection (SSL and TLS), as well as user authentication. If a security protocol is used a verification on the server certificate will occur. \n\n Two alternatives to handle this verification are available: \n\n With this option the certificate chain will be validated against the local truststore file. Hostname or IP address of the server. See below for use with protocol. Port to be used to connect to the server. Defaults are: SMTP=25, SSL=465, StartTLS=587 Connection timeout value in milliseconds (socket level). Default is infinite timeout. Read timeout value in milliseconds (socket level). Default is infinite timeout. The from address that will appear in the e-mail Yes, unless CC or BCC is specified Indicates if the SMTP server requires user authentication User login password (N.B. this is stored unencrypted in the test plan) Indicates that the connection to the SMTP server does not use any security protocol. Indicates that the connection to the SMTP server must use the SSL protocol. Indicates that the connection to the SMTP server should attempt to start the TLS protocol. If the server does not start the TLS protocol the connection will be terminated. When selected it will accept all certificates independent of the CA. When selected it will only accept certificates that are locally trusted. Path to file containing the trusted certificates. Relative paths are resolved against the current directory. \n\n Failing that, against the directory containing the test script (JMX file). Specify a custom SSL/TLS protocol as space separated list to use on handshake example . Defaults to all supported protocols. If selected, the \" \" header is omitted from the mail that is sent. This is different from sending an empty \" \" header, though some e-mail clients may display it identically. Includes the in the subject line. Additional headers can be defined using this button. , if possible. If the message body is empty and there is a single file, then send the file contents as the message body. Note: If the message body is not empty, and there is at least one attached file, then the body is sent as . If selected, then send the body as a plain message, i.e. not, if possible. If the message body is empty and there is a single file, then send the file contents as the message body. Files to be attached to the message. If set, the file will be sent instead of the entries in the , , and fields Calculates the message size and stores it in the sample result. If set, then the \" \" property is set to \" \" The OS Process Sampler is a sampler that can be used to execute commands on the local machine. \n\n It should allow execution of any command that can be run from the command line. \n\n Validation of the return code can be enabled, and the expected return code can be specified. \n\n Note that OS shells generally provide command-line parsing. This varies between OSes, but generally the shell will split parameters on white-space. Some shells expand wild-card file names; some don't. The quoting mechanism also varies between OSes. The sampler deliberately does not do any parsing or quote handling. The command and its parameters must be provided in the form expected by the executable. This means that the sampler settings will not be portable between OSes. Many OSes have some built-in commands which are not provided as separate executables. For example the Windows DIR command is part of the command interpreter (CMD.EXE). These built-ins cannot be run as independent programs, but have to be provided as arguments to the appropriate command interpreter. For example, the Windows command-line: DIR C:\\TEMP needs to be specified as follows: The program name to execute. Directory from which command will be executed, defaults to folder referenced by \" \" System property Parameters passed to the program name. Name of file from which input is to be taken ( ). Name of output file for standard output ( ). If omitted, output is captured and returned as the response data. Name of output file for standard error ( ). If omitted, output is captured and returned as the response data. If checked, sampler will compare return code with . Expected return code for System Call, required if \" \" is checked. Note 500 is used as an error indicator in JMeter so you should not use it. Timeout for command in milliseconds, defaults to , which means no timeout. If the timeout expires before the command finishes, JMeter will attempt to kill the OS process. This sampler lets you send a Request to a MongoDB. Before using this you need to set up a MongoDB Source Config Configuration element which takes a global write lock causing a performance impact on the database, see This Element currently useswhich takes a global write lock causing a performance impact on the database, see . So it is better to avoid using this element for load testing and use JSR223+Groovy scripting using MongoDBHolder instead. MongoDB Script is more suitable for functional testing or test setup (setup/teardown threads) Descriptive name for this sampler that is shown in the tree. Name of the JMeter variable that the MongoDB connection is bound to. This must agree with the ' ' field of a MongoDB Source Config. Database Name, will be used in your script Mongo script as it would be used in MongoDB shell Ensure Variable Name is unique across Test Plan. ^ This sampler allows you to run Cypher queries through the Bolt protocol. Before using this you need to set up a Bolt Connection Configuration Every request uses a connection acquired from the pool and returns it to the pool when the sampler completes. The connection pool size defaults to 100 and is configurable. The measured response time corresponds to the \"full\" query execution, including both the time to execute the cypher query AND the time to consume the results sent back by the database. Descriptive name for this sampler that is shown in the tree. Whether to add or not query result data to the sampler response (default false). Note that activating this has a memory overhead, use it wisely. Whether to access the database in WRITE or READ mode. Use WRITE for a standalone Neo4j instance. For a Neo4j cluster, select mode depending on whether the query writes to the database. That setting will allow correct routing to the cluster leader, followers or read replicas. The database to run the query against. Required for Neo4j 4.0+, unless querying the default database. Must be undefined for Neo4j 3.5. It is strongly advised to use query parameters, allowing the database to cache and reuse execution plans. ^\n\n\n\nLogic Controllers determine the order in which Samplers are processed. The Simple Logic Controller lets you organize your Samplers and other Logic Controllers. Unlike other Logic Controllers, this controller provides no functionality beyond that of a storage device. Descriptive name for this controller that is shown in the tree. Download this example (see Figure 6). In this example, we created a Test Plan that sends two Ant HTTP requests and two Log4J HTTP requests. We grouped the Ant and Log4J requests by placing them inside Simple Logic Controllers. Remember, the Simple Logic Controller has no effect on how JMeter processes the controller(s) you add to it. So, in this example, JMeter sends the requests in the following order: Ant Home Page, Ant News Page, Log4J Home Page, Log4J History Page. Note, the File Reporter is configured to store the results in a file named \"simple-test.dat\" in the current directory. If you add Generative or Logic Controllers to a Loop Controller, JMeter will loop through them a certain number of times, in addition to the loop value you specified for the Thread Group. For example, if you add one HTTP Request to a Loop Controller with a loop count of two, and configure the Thread Group loop count to three, JMeter will send a total of 2 * 3 = 6 HTTP Requests. JMeter will expose the looping index as a variable named . So for example, if your Loop Controller is named LC, then you can access the looping index through . Index starts at 0 Descriptive name for this controller that is shown in the tree. The number of times the subelements of this controller will be iterated each time through a test run. The value -1 is equivalent to checking the Forever toggle. Special Case: The Loop Controller embedded in the Thread Group element behaves slightly different. Unless set to forever, it stops the test after the given number of iterations have been done. will evaluate it to a different value for each child samplers of Loop Controller and result into unwanted behaviour. When using a function in this field, be aware it may be evaluated multiple times. Example usingwill evaluate it to a different value for each child samplers of Loop Controller and result into unwanted behaviour. Yes, unless \"Forever\" is checked Download this example (see Figure 4). In this example, we created a Test Plan that sends a particular HTTP Request only once and sends another HTTP Request five times. We configured the Thread Group for a single thread and a loop count value of one. Instead of letting the Thread Group control the looping, we used a Loop Controller. You can see that we added one HTTP Request to the Thread Group and another HTTP Request to a Loop Controller. We configured the Loop Controller with a loop count value of five. JMeter will send the requests in the following order: Home Page, News Page, News Page, News Page, News Page, and News Page. Note, the File Reporter is configured to store the results in a file named \" \" in the current directory. The Once Only Logic Controller tells JMeter to process the controller(s) inside it only once per Thread, and pass over any requests under it during further iterations through the test plan. The Once Only Controller will now execute always during the first iteration of any looping parent controller. Thus, if the Once Only Controller is placed under a Loop Controller specified to loop 5 times, then the Once Only Controller will execute only on the first iteration through the Loop Controller (i.e. every 5 times). Note this means the Once Only Controller will still behave as previously expected if put under a Thread Group (runs only once per test per Thread), but now the user has more flexibility in the use of the Once Only Controller. For testing that requires a login, consider placing the login request in this controller since each thread only needs to login once to establish a session. Screenshot of Control-Panel of Once Only Controller Descriptive name for this controller that is shown in the tree. Download this example (see Figure 5). In this example, we created a Test Plan that has two threads that send HTTP request. Each thread sends one request to the Home Page, followed by three requests to the Bug Page. Although we configured the Thread Group to iterate three times, each JMeter thread only sends one request to the Home Page because this request lives inside a Once Only Controller. Figure 5. Once Only Controller Example Each JMeter thread will send the requests in the following order: Home Page, Bug Page, Bug Page, Bug Page. Note, the File Reporter is configured to store the results in a file named \"loop-test.dat\" in the current directory. If you add Generative or Logic Controllers to an Interleave Controller, JMeter will alternate among each of the other controllers for each loop iteration. Descriptive name for this controller that is shown in the tree. If checked, the interleave controller will treat sub-controllers like single request elements and only allow one request per controller at a time. If checked, the interleave controller will alternate among each of its children controllers for each loop iteration but across all threads, for example in a configuration with 4 threads and 3 child controllers, on first iteration thread 1 will run first child, thread 2 second child, thread 3 third child, thread 4 first child, on next iteration each thread will run the following child controller Download this example (see Figure 1). In this example, we configured the Thread Group to have two threads and a loop count of five, for a total of ten requests per thread. See the table below for the sequence JMeter sends the HTTP Requests. Because there are no more requests in the controller, \n\n JMeter starts over and sends the first HTTP Request, which is the News Page. Download another example (see Figure 2). In this example, we configured the Thread Group to have a single thread and a loop count of eight. Notice that the Test Plan has an outer Interleave Controller with two Interleave Controllers inside of it. The outer Interleave Controller alternates between the two inner ones. Then, each inner Interleave Controller alternates between each of the HTTP Requests. Each JMeter thread will send the requests in the following order: Home Page, Interleaved, Bug Page, Interleaved, CVS Page, Interleaved, and FAQ Page, Interleaved. Note, the File Reporter is configured to store the results in a file named \"interleave-test2.dat\" in the current directory. If the two interleave controllers under the main interleave controller were instead simple controllers, then the order would be: Home Page, CVS Page, Interleaved, Bug Page, FAQ Page, Interleaved. However, if \"ignore sub-controller blocks\" was checked on the main interleave controller, then the order would be: Home Page, Interleaved, Bug Page, Interleaved, CVS Page, Interleaved, and FAQ Page, Interleaved. The Random Logic Controller acts similarly to the Interleave Controller, except that instead of going in order through its sub-controllers and samplers, it picks one at random at each pass. Interactions between multiple controllers can yield complex behavior. This is particularly true of the Random Controller. Experiment before you assume what results any given interaction will give Descriptive name for this controller that is shown in the tree. If checked, the interleave controller will treat sub-controllers like single request elements and only allow one request per controller at a time. The Random Order Controller is much like a Simple Controller in that it will execute each child element at most once, but the order of execution of the nodes will be random. Descriptive name for this controller that is shown in the tree. The Throughput Controller allows the user to control how often it is executed. There are two modes: causes the controller to execute a certain percentage of the iterations through the test plan. causes the controller to stop executing after a certain number of executions have occurred. Like the Once Only Controller, this setting is reset when a parent Loop Controller restarts. This controller is badly named, as it does not control throughput. Please refer to the Constant Throughput Timer for an element that can be used to adjust the throughput. Like the Once Only Controller, this setting is reset when a parent Loop Controller restarts. The Throughput Controller can yield very complex behavior when combined with other controllers - in particular with interleave or random controllers as parents (also very useful). Descriptive name for this controller that is shown in the tree. Whether the controller will run in percent executions or total executions mode. A number. For percent execution mode, a number from - that indicates the percentage of times the controller will execute. \" \" means the controller will execute during half the iterations through the test plan. For total execution mode, the number indicates the total number of times the controller will execute. If checked, per user will cause the controller to calculate whether it should execute on a per user (per thread) basis. If unchecked, then the calculation will be global for all users. For example, if using total execution mode, and uncheck \" \", then the number given for throughput will be the total number of executions made. If \" \" is checked, then the total number of executions would be the number of users times the number given for throughput. The Runtime Controller controls how long its children will run. Controller will run its children until configured Runtime(s) is exceeded. Descriptive name for this controller that is shown in the tree, and used to name the transaction. The If Controller allows the user to control whether the test elements below it (its children) are run or not. By default, the condition is evaluated only once on initial entry, but you have the option to have it evaluated for every runnable element contained in the controller. The best option (default one) is to check Interpret Condition as Variable Expression?, then in the condition field you have 2 options:\n• Option 1: Use a variable that contains or If you want to test if last sample was successful, you can use\n• Option 2: Use a function ( is advised) to evaluate an expression that must return or For example, previously one could use the condition: and this would be evaluated as / , the result would then be passed to JavaScript which would then return / . If the Variable Expression option is selected, then the expression is evaluated and compared with \" \", without needing to use JavaScript. , expression will be: Or use: to test if a variable is defined and is not null. To test if a variable is undefined (or null) do the following, suppose var is named, expression will be:Or use:to test if a variable is defined and is not null. If you uncheck , will internally use javascript to evaluate the condition which has a performance penalty that can be very big and make your test less scalable. For example, previously one could use the condition:and this would be evaluated as, the result would then be passed to JavaScript which would then return. If the Variable Expression option is selected, then the expression is evaluated and compared with \"\", without needing to use JavaScript.If you uncheckwill internally use javascript to evaluate the condition which has a performance penalty that can be very big and make your test less scalable. Screenshot of Control-Panel of If Controller Descriptive name for this controller that is shown in the tree. By default the condition is interpreted as JavaScript code that returns \" \" or \" \", but this can be overridden (see below) \" (case is ignored). For example, or . Unlike the JavaScript case, the condition is only checked to see if it matches \" \" (case is ignored). or function in Condition is advised for performances Checking this and usingorfunction in Condition is advised for performances If this is selected, then the condition must be an expression that evaluates to \"\" (case is ignored). For example,or. Unlike the JavaScript case, the condition is only checked to see if it matches \"\" (case is ignored). Should condition be evaluated for all children? If not checked, then the condition is only evaluated on entry. If there is an error interpreting the code, the condition is assumed to be , and a message is logged in . \n\n \n\n When using take care to not use variable replacement in the string, otherwise if using a variable that changes the script cannot be cached. Instead get the variable using: See the Groovy examples below. Note it is advised to avoid using JavaScript mode for performance.When usingtake care to not use variable replacement in the string, otherwise if using a variable that changes the script cannot be cached. Instead get the variable using:See the Groovy examples below. If there is an error interpreting the code, the condition is assumed to be, and a message is logged in The While Controller runs its children until the condition is \"false\". JMeter will expose the looping index as a variable named . So for example, if your While Controller is named WC, then you can access the looping index through . Index starts at 0\n• blank - exit loop when last sample in loop fails\n• - exit loop when last sample in loop fails. If the last sample just before the loop failed, don't enter loop.\n• Otherwise - exit (or don't enter) the loop when the condition is equal to the string \" \" \". This allows the use of , function, properties or variables as needed. The condition can be any variable or function that eventually evaluates to the string \"\". This allows the use offunction, properties or variables as needed. \n\n ) can introduce issues. Note that the condition is evaluated twice, once before starting sampling children and once at end of children sampling, so putting non idempotent functions in Condition (like) can introduce issues. \n\n For example:\n• - where is set to false by some other test element\n• - where property is set to \" \" somewhere else Screenshot of Control-Panel of While Controller Descriptive name for this controller that is shown in the tree, and used to name the transaction. The Switch Controller acts like the Interleave Controller in that it runs one of the subordinate elements on each iteration, but rather than run them in sequence, the controller runs the element defined by the switch value. The switch value can also be a name. If the switch value is out of range, it will run the zeroth element, which therefore acts as the default for the numeric case. It also runs the zeroth element if the value is the empty string. If the value is non-numeric (and non-empty), then the Switch Controller looks for the element with the same name (case is significant). If none of the names match, then the element named \"default\" (case not significant) is selected. If there is no default, then no element is selected, and the controller will not run anything. Descriptive name for this controller that is shown in the tree. The number (or name) of the subordinate element to be invoked. Elements are numbered from 0. Defaults to 0 A ForEach controller loops through the values of a set of related variables. When you add samplers (or controllers) to a ForEach controller, every sample (or controller) is executed one or more times, where during every loop the variable has a new value. The input should consist of several variables, each extended with an underscore and a number. Each such variable must have a value. So for example when the input variable has the name inputVar, the following variables should have been defined: Note: the \"_\" separator is now optional. When the return variable is given as \"returnVar\", the collection of samplers and controllers under the ForEach controller will be executed 4 consecutive times, with the return variable having the respective above values, which can then be used in the samplers. JMeter will expose the looping index as a variable named . So for example, if your Loop Controller is named FEC, then you can access the looping index through . Index starts at 0 It is especially suited for running with the regular expression post-processor. This can \"create\" the necessary input variables out of the result data of a previous request. By omitting the \"_\" separator, the ForEach Controller can be used to loop through the groups by using the input variable refName_g, and can also loop through all the groups in all the matches by using an input variable of the form refName_${C}_g, where C is a counter variable. The ForEach Controller does not run any samples if is . This would be the case if the Regular Expression returned no matches. Descriptive name for this controller that is shown in the tree. Prefix for the variable names to be used as input. Defaults to an empty string as prefix. Start index (exclusive) for loop over variables (first element is at start index + 1) The name of the variable which can be used in the loop for replacement in the samplers. Defaults to an empty variable name, which is most probably not wanted. If not checked, the \" \" separator is omitted. Download this example (see Figure 7). In this example, we created a Test Plan that sends a particular HTTP Request only once and sends another HTTP Request to every link that can be found on the page. We configured the Thread Group for a single thread and a loop count value of one. You can see that we added one HTTP Request to the Thread Group and another HTTP Request to the ForEach Controller. After the first HTTP request, a regular expression extractor is added, which extracts all the html links out of the return page and puts them in the inputVar variable In the ForEach loop, a HTTP sampler is added which requests all the links that were extracted from the first returned HTML page. Here is another example you can download. This has two Regular Expressions and ForEach Controllers. The first RE matches, but the second does not match, so no samples are run by the second ForEach Controller The Thread Group has a single thread and a loop count of two. Sample 1 uses the JavaTest Sampler to return the string \"a b c d\". The Regex Extractor uses the expression (\\w)\\s which matches a letter followed by a space, and returns the letter (not the space). Any matches are prefixed with the string \"inputVar\". The ForEach Controller extracts all variables with the prefix \"inputVar_\", and executes its sample, passing the value in the variable \"returnVar\". In this case it will set the variable to the values \"a\" \"b\" and \"c\" in turn. The For 1 Sampler is another Java Sampler which uses the return variable \"returnVar\" as part of the sample Label and as the sampler Data. Sample 2, Regex 2 and For 2 are almost identical, except that the Regex has been changed to \"(\\w)\\sx\", which clearly won't match. Thus the For 2 Sampler will not be run. The Module Controller provides a mechanism for substituting test plan fragments into the current test plan at run-time. A test plan fragment consists of a Controller and all the test elements (samplers etc.) contained in it. The fragment can be located in any Thread Group. If the fragment is located in a Thread Group, then its Controller can be disabled to prevent the fragment being run except by the Module Controller. Or you can store the fragments in a dummy Thread Group, and disable the entire Thread Group. There can be multiple fragments, each with a different series of samplers under them. The module controller can then be used to easily switch between these multiple test cases simply by choosing the appropriate controller in its drop down box. This provides convenience for running many alternate test plans quickly and easily. A fragment name is made up of the Controller name and all its parent names. For example: Any fragments used by the Module Controller must have a unique name, as the name is used to find the target controller when a test plan is reloaded. For this reason it is best to ensure that the Controller name is changed from the default - as shown in the example above - otherwise a duplicate may be accidentally created when new elements are added to the test plan. Descriptive name for this controller that is shown in the tree. The module controller provides a list of all controllers loaded into the gui. Select the one you want to substitute in at runtime. The include controller is designed to use an external JMX file. To use it, create a Test Fragment underneath the Test Plan and add any desired samplers, controllers etc. below it. Then save the Test Plan. The file is now ready to be included as part of other Test Plans. For convenience, a Thread Group can also be added in the external JMX file for debugging purposes. A Module Controller can be used to reference the Test Fragment. The Thread Group will be ignored during the include process. If the test uses a Cookie Manager or User Defined Variables, these should be placed in the top-level test plan, not the included file, otherwise they are not guaranteed to work. This element does not support variables/functions in the filename field. \n\n However, if the property is defined, the contents are used to prefix the pathname. When using Include Controller and including the same JMX file, ensure you name the Include Controller differently to avoid facing known issue Bug 50898 If the file cannot be found at the location given by prefix+Filename, then the controller attempts to open the Filename relative to the JMX launch directory. The Transaction Controller generates an additional sample which measures the overall time taken to perform the nested test elements. Note: when the check box \" Include duration of timer and pre-post processors in generated sample \" is checked, the time includes all processing within the controller scope, not just the samples. There are two modes of operation:\n• additional sample is added after the nested samples\n• additional sample is added as a parent of the nested samples The generated sample time includes all the times for the nested samplers excluding by default (since 2.11) timers and processing time of pre/post processors unless checkbox \"Include duration of timer and pre-post processors in generated sample\" is checked. Depending on the clock resolution, it may be slightly longer than the sum of the individual samplers plus timers. The clock might tick after the controller recorded the start time but before the first sample starts. Similarly at the end. The generated sample is only regarded as successful if all its sub-samples are successful. In parent mode, the individual samples can still be seen in the Tree View Listener, but no longer appear as separate entries in other Listeners. Also, the sub-samples do not appear in CSV log files, but they can be saved to XML files. In parent mode, Assertions (etc.) can be added to the Transaction Controller. However by default they will be applied to both the individual samples and the overall transaction sample. To limit the scope of the Assertions, use a Simple Controller to contain the samples, and add the Assertions to the Simple Controller. Parent mode controllers do not currently properly support nested transaction controllers of either type. Descriptive name for this controller that is shown in the tree, and used to name the transaction. If checked, then the sample is generated as a parent of the other samples, otherwise the sample is generated as an independent sample. Include duration of timer and pre-post processors in generated sample Whether to include timer, pre- and post-processing delays in the generated sample. Default is The Recording Controller is a place holder indicating where the proxy server should record samples to. During test run, it has no effect, similar to the Simple Controller. But during recording using the HTTP(S) Test Script Recorder, all recorded samples will by default be saved under the Recording Controller. Descriptive name for this controller that is shown in the tree. The Critical Section Controller ensures that its children elements (samplers/controllers, etc.) will be executed by only one thread as a named lock will be taken before executing children of controller. The figure below shows an example of using Critical Section Controller, in the figure below 2 Critical Section Controllers ensure that:\n• is executed only by one thread at a time\n• is executed only by one thread at a time Lock that will be taken by controller, ensure you use different lock names for unrelated sections Critical Section Controller takes locks only within one JVM, so if using Distributed testing ensure your use case does not rely on all threads of all JVMs blocking. ^\n\n\n\n Configuration elements can be used to set up defaults and variables for later use by samplers. Note that these elements are processed at the start of the scope in which they are found, i.e. before any samplers in the same scope. \n\n CSV Data Set Config is used to read lines from a file, and split them into variables. It is easier to use than the __CSVRead() and __StringFromFile() functions. It is well suited to handling large numbers of variables, and is also useful for testing with \"random\" and unique values. Generating unique random values at run-time is expensive in terms of CPU and memory, so just create the data in advance of the test. If necessary, the \"random\" data from the file can be used in conjunction with a run-time parameter to create different sets of values from each run - e.g. using concatenation - which is much cheaper than generating everything at run-time. JMeter allows values to be quoted; this allows the value to contain a delimiter. If \"allow quoted data\" is enabled, a value may be enclosed in double-quotes. These are removed. To include double-quotes within a quoted field, use two double-quotes. For example: JMeter supports CSV files which have a header line defining the column names. To enable this, leave the \"Variable Names\" field empty. The correct delimiter must be provided. By default, the file is only opened once, and each thread will use a different line from the file. However the order in which lines are passed to threads depends on the order in which they execute, which may vary between iterations. Lines are read at the start of each test iteration. The file name and mode are resolved in the first iteration. See the description of the Share mode below for additional options. If you want each thread to have its own set of values, then you will need to create a set of files, one for each thread. For example test1.csv, test2.csv, …, testn.csv. Use the filename test${__threadNum}.csv and set the \"Sharing mode\" to \"Current thread\". etc. are processed at run-time. CSV Dataset variables are defined at the start of each test iteration. As this is after configuration processing is completed, they cannot be used for some configuration items - such as JDBC Config - that process their contents at configuration time (see Bug 40394 ) However the variables do work in the HTTP Auth Manager, as theetc. are processed at run-time. As a special case, the string \"\\t\" (without quotes) in the delimiter field is treated as a Tab. When the end of file ( ) is reached, and the recycle option is true, reading starts again with the first line of the file. If the recycle option is false, and stopThread is false, then all the variables are set to <EOF> when the end of file is reached. This value can be changed by setting the JMeter property csvdataset.eofstring. If the Recycle option is false, and Stop Thread is true, then reaching will cause the thread to be stopped. Descriptive name for this element that is shown in the tree. Name of the file to be read. Relative file names are resolved with respect to the path of the active test plan. For distributed testing, the CSV file must be stored on the server host system in the correct relative directory to where the JMeter server is started. Absolute file names are also supported, but note that they are unlikely to work in remote mode, unless the remote server has the same directory structure. If the same physical file is referenced in two different ways - e.g. and - then these are treated as different files. If the OS does not distinguish between upper and lower case, would also be opened separately. The encoding to be used to read the file, if not the platform default. List of variable names. The names must be separated by the delimiter character. They can be quoted using double-quotes. JMeter supports CSV header lines: if the variable name field empty, then the first line of the file is read and interpreted as the list of column names. Use first line as Variable Names Ignore first line of CSV file, it will only be used if Variable Names is not empty, if Variable Names is empty the first line must contain the headers. Delimiter to be used to split the records in the file. If there are fewer values on the line than there are variables the remaining variables are not updated - so they will retain their previous value (if any). Should the CSV file allow values to be quoted? If enabled, then values can be enclosed in - double-quote - allowing values to contain a delimiter. Should the file be re-read from the beginning on reaching ? (default is ) Should the thread be stopped on , if Recycle is false? (default is )\n• - (the default) the file is shared between all the threads.\n• - each file is opened once for each thread group in which the element appears\n• - each file is opened separately for each thread\n• - all threads sharing the same identifier share the same file. So for example if you have 4 thread groups, you could use a common id for two or more of the groups to share the file between them. Or you could use the thread number to share the file between the same thread numbers in different thread groups. The DNS Cache Manager element allows to test applications, which have several servers behind load balancers (CDN, etc.), when user receives content from different IP's. By default JMeter uses JVM DNS cache. That's why only one server from the cluster receives load. DNS Cache Manager resolves names for each thread separately each iteration and saves results of resolving to its internal DNS Cache, which is independent from both JVM and OS DNS caches. A mapping for static hosts can be used to simulate something like /etc/hosts file. These entries will be preferred over the custom resolver. Use custom DNS resolver has to be enabled, if you want to use this mapping. Say, you have a test server, that you want to reach with a name, that is not (yet) set up in your DNS servers. For our example, this would be www.example.com for the server name, which you want to reach at the IP of the server a123.another.example.org. You could change your workstation and add an entry to your /etc/hosts file - or the equivalent for your OS, or add an entry to the Static Host Table of the DNS Cache Manager. You would type www.example.com into the first column (Host) and a123.another.example.org into the second column (Hostname or IP address). As the name of the second column implies, you could even use the IP address of your test server there. The IP address for the test server will be looked up by using the custom DNS resolver. When none is given, the system DNS resolver will be used. Now you can use www.example.com in your HTTPClient4 samplers and the requests will be made against a123.another.example.org with all headers set to www.example.com. DNS Cache Manager is designed for using in the root of Thread Group or Test Plan. Do not place it as child element of particular HTTP Sampler DNS Cache Manager works only with HTTP requests using HTTPClient4 implementation. Descriptive name for this element that is shown in the tree. If selected, DNS cache of every Thread is cleared each time new iteration is started. System DNS resolver will be used. For correct work edit and add Custom DNS resolver (from dnsjava library) will be used. List of DNS servers to use. If empty, network configuration DNS will used. Add an entry to the DNS servers table. Mapping of hostnames to a static host entry which will be resolved using the custom DNS resolver. Add an entry to the static hosts table. Delete the currently selected static host in the table. The Authorization Manager lets you specify one or more user logins for web pages that are restricted using server authentication. You see this type of authentication when you use your browser to access a restricted page, and your browser displays a login dialog box. JMeter transmits the login information when it encounters this type of page. The Authorization headers may not be shown in the Tree View Listener \"Request\" tab. The Java implementation does pre-emptive authentication, but it does not return the Authorization header when JMeter fetches the headers. The HttpComponents (HC 4.5.X) implementation defaults to pre-emptive since 3.2 and the header will be shown. To disable this, set the values as below, in which case authentication will only be performed in response to a challenge. Note: the above settings only apply to the HttpClient sampler. When looking for a match against a URL, JMeter checks each entry in turn, and stops when it finds the first match. Thus the most specific URLs should appear first in the list, followed by less specific ones. Duplicate URLs will be ignored. If you want to use different usernames/passwords for different threads, you can use variables. These can be set up using a CSV Data Set Config Element (for example). If there is more than one Authorization Manager in the scope of a Sampler, there is currently no way to specify which one is to be used. Descriptive name for this element that is shown in the tree. Used by Kerberos authentication. If checked, authentication will be done on each iteration of Main Thread Group loop even if it has already been done in a previous one. This is usually useful if each main thread group iteration represents behaviour of one Virtual User. A partial or complete URL that matches one or more HTTP Request URLs. As an example, say you specify a Base URL of \" \" with a of \" \" and a of \" \". If you send an HTTP request to the URL \" \", the Authorization Manager sends the login information for the user named, \" \". The password for the user. (N.B. this is stored unencrypted in the test plan) The domain to use for NTLM. The realm to use for NTLM. Type of authentication to perform. JMeter can perform different types of authentications based on used Http Samplers: The Realm only applies to the HttpClient sampler. \n\n Kerberos Configuration: To configure Kerberos you need to setup at least two JVM system properties: You can also configure those two properties in the file bin/system.properties. Look at the two sample configuration files (krb5.conf and jaas.conf) located in the JMeter bin folder for references to more documentation, and tweak them to match your Kerberos configuration. Delegation of credentials is disabled by default for SPNEGO. If you want to enable it, you can do so by setting the property kerberos.spnego.delegate_cred to true. When generating a SPN for Kerberos SPNEGO authentication IE and Firefox will omit the port number from the URL. Chrome has an option (--enable-auth-negotiate-port) to include the port number if it differs from the standard ones (80 and 443). That behavior can be emulated by setting the following JMeter property as below. \n\n Controls:\n• Button - Add an entry to the authorization table.\n• Button - Load a previously saved authorization table and add the entries to the existing authorization table entries. When you save the Test Plan, JMeter automatically saves all of the authorization table entries - including any passwords, which are not encrypted. Download this example. In this example, we created a Test Plan on a local server that sends three HTTP requests, two requiring a login and the other is open to everyone. See figure 10 to see the makeup of our Test Plan. On our server, we have a restricted directory named, \"secret\", which contains two files, \"index.html\" and \"index2.html\". We created a login id named, \"kevin\", which has a password of \"spot\". So, in our Authorization Manager, we created an entry for the restricted directory and a username and password (see figure 11). The two HTTP requests named \"SecretPage1\" and \"SecretPage2\" make requests to \"/secret/index.html\" and \"/secret/index2.html\". The other HTTP request, named \"NoSecretPage\" makes a request to \"/index.html\". When we run the Test Plan, JMeter looks in the Authorization table for the URL it is requesting. If the Base URL matches the URL, then JMeter passes this information along with the request. You can download the Test Plan, but since it is built as a test for our local server, you will not be able to run it. However, you can use it as a reference in constructing your own Test Plan. The HTTP Cache Manager is used to add caching functionality to HTTP requests within its scope to simulate browser cache feature. Each Virtual User thread has its own Cache. By default, Cache Manager will store up to 5000 items in cache per Virtual User thread, using LRU algorithm. Use property \"maxSize\" to modify this value. Note that the more you increase this value the more HTTP Cache Manager will consume memory, so be sure to adapt the -Xmx JVM option accordingly. If a sample is successful (i.e. has response code 2xx) then the Last-Modified and Etag (and Expired if relevant) values are saved for the URL. Before executing the next sample, the sampler checks to see if there is an entry in the cache, and if so, the If-Last-Modified and If-None-Match conditional headers are set for the request. Additionally, if the \"Use Cache-Control/Expires header\" option is selected, then the Cache-Control/Expires value is checked against the current time. If the request is a GET request, and the timestamp is in the future, then the sampler returns immediately, without requesting the URL from the remote server. This is intended to emulate browser behaviour. Note that if Cache-Control header is \"no-cache\", the response will be stored in cache as pre-expired, so will generate a conditional GET request. If Cache-Control has any other value, the \"max-age\" expiry option is processed to compute entry lifetime, if missing then expire header will be used, if also missing entry will be cached as specified in RFC 2616 section 13.2.4 using Last-Modified time and response Date. If the requested document has not changed since it was cached, then the response body will be empty. Likewise if the date is in the future. This may cause problems for Assertions. Descriptive name for this element that is shown in the tree. If selected, then the cache is cleared at the start of the thread. Use Cache Control/Expires header when processing GET requests The Cookie Manager element has two functions: \n\n First, it stores and sends cookies just like a web browser. If you have an HTTP Request and the response contains a cookie, the Cookie Manager automatically stores that cookie and will use it for all future requests to that particular web site. Each JMeter thread has its own \"cookie storage area\". So, if you are testing a web site that uses a cookie for storing session information, each JMeter thread will have its own session. Note that such cookies do not appear on the Cookie Manager display, but they can be seen using the View Results Tree Listener. JMeter checks that received cookies are valid for the URL. This means that cross-domain cookies are not stored. If you have bugged behaviour or want Cross-Domain cookies to be used, define the JMeter property \"CookieManager.check.cookies=false\". Received Cookies can be stored as JMeter thread variables. To save cookies as variables, define the property \"CookieManager.save.cookies=true\". Also, cookies names are prefixed with \"COOKIE_\" before they are stored (this avoids accidental corruption of local variables) To revert to the original behaviour, define the property \"CookieManager.name.prefix= \" (one or more spaces). If enabled, the value of a cookie with the name TEST can be referred to as ${COOKIE_TEST}. Second, you can manually add a cookie to the Cookie Manager. However, if you do this, the cookie will be shared by all JMeter threads. Note that such Cookies are created with an Expiration time far in the future Cookies with null values are ignored by default. This can be changed by setting the JMeter property: CookieManager.delete_null_cookies=false. Note that this also applies to manually defined cookies - any such cookies will be removed from the display when it is updated. Note also that the cookie name must be unique - if a second cookie is defined with the same name, it will replace the first. If there is more than one Cookie Manager in the scope of a Sampler, there is currently no way to specify which one is to be used. Also, a cookie stored in one cookie manager is not available to any other manager, so use multiple Cookie Managers with care. Descriptive name for this element that is shown in the tree. If selected, all server-defined cookies are cleared each time the main Thread Group loop is executed. Any cookie defined in the GUI are not cleared. \" is the default since 3.0, and should work in most cases. See \" is equivalent to omitting the CookieManager.] The cookie policy that will be used to manage the cookies. \"\" is the default since 3.0, and should work in most cases. See Cookie specifications and CookieSpec implementations [Note: \"\" is equivalent to omitting the CookieManager.] (HttpClient 4.5.X API). Default is since 3.0. \n\n [Note: If you have a website to test with IPv6 address, choose (IPv6 compliant)] This gives you the opportunity to use hardcoded cookies that will be used by all threads during the test execution. \n\n The \" \" is the hostname of the server (without ); the port is currently ignored. No (discouraged, unless you know what you're doing) Add an entry to the cookie table. Load a previously saved cookie table and add the entries to the existing cookie table entries. Save the current cookie table to a file (does not save any cookies extracted from HTTP Responses). This element lets you set default values that your HTTP Request controllers use. For example, if you are creating a Test Plan with 25 HTTP Request controllers and all of the requests are being sent to the same server, you could add a single HTTP Request Defaults element with the \"Server Name or IP\" field filled in. Then, when you add the 25 HTTP Request controllers, leave the \"Server Name or IP\" field empty. The controllers will inherit this field value from the HTTP Request Defaults element. All port values are treated equally; a sampler that does not specify a port will use the HTTP Request Defaults port, if one is provided. Descriptive name for this element that is shown in the tree. Domain name or IP address of the web server. E.g. . [Do not include the prefix. Port the web server is listening to. Connection Timeout. Number of milliseconds to wait for a connection to open. Response Timeout. Number of milliseconds to wait for a response. , . If not specified the default depends on the value of the JMeter property , failing that, the implementation is used. The encoding to be used for the request. The path to resource (for example, ). If the resource requires query string parameters, add them below in the \" \" section. Note that the path is the default for the full path, not a prefix to be applied to paths specified on the HTTP Request screens. The query string will be generated from the list of parameters you provide. Each parameter has a name and value. The query string will be generated in the correct fashion, depending on the choice of \" \" you made (i.e. if you chose , the query string will be appended to the URL, if , then it will be sent separately). Also, if you are sending a file using a multipart form, the query string will be created using the multipart form specifications. Hostname or IP address of a proxy server to perform request. [Do not include the prefix.] Port the proxy server is listening to. No, unless proxy hostname is specified Tell JMeter to parse the HTML file and send HTTP/HTTPS requests for all images, Java applets, JavaScript files, CSSs, etc. referenced in the file. Use a pool of concurrent connections to get embedded resources. Pool size for concurrent connections used to get embedded resources. If present, this must be a regular expression that is used to match against any embedded URLs found. So if you only want to download embedded resources from , use the expression: If present, this must be a regular expression that is used to filter out any embedded URLs found. So if you don't want to download PNG or SVG files from any source, use the expression: Note: radio buttons only have two states - on or off. This makes it impossible to override settings consistently - does off mean off, or does it mean use the current default? JMeter uses the latter (otherwise defaults would not work at all). So if the button is off, then a later element can set it on, but if the button is on, a later element cannot set it off. The Header Manager lets you add or override HTTP request headers. JMeter now supports multiple Header Managers. The header entries are merged to form the list for the sampler. If an entry to be merged matches an existing header name, it replaces the previous entry. This allows one to set up a default set of headers, and apply adjustments to particular samplers. Note that an empty value for a header does not remove an existing header, it justs replace its value. Descriptive name for this element that is shown in the tree. Name of the request header. Two common request headers you may want to experiment with are \" \" and \" \". No (You should have at least one, however) No (You should have at least one, however) Add an entry to the header table. Load a previously saved header table and add the entries to the existing header table entries. Download this example. In this example, we created a Test Plan that tells JMeter to override the default \"User-Agent\" request header and use a particular Internet Explorer agent string instead. (see figures 12 and 13). The Java Request Defaults component lets you set default values for Java testing. See the Java Request. Creates a database connection (used by JDBC Request Sampler) from the supplied JDBC Connection settings. The connection may be optionally pooled between threads. Otherwise each thread gets its own connection. The connection configuration name is used by the JDBC Sampler to select the appropriate connection. The used pool is DBCP, see BasicDataSource Configuration Parameters Descriptive name for the connection configuration that is shown in the tree. Each name must be different. If there are two configuration elements using the same name, only one will be saved. JMeter logs a message if a duplicate name is detected. The name of the variable the connection is tied to. Multiple connections can be used, each tied to a different variable, allowing JDBC Samplers to select the appropriate connection. Maximum number of connections allowed in the pool. In most cases, set this to zero (0). This means that each thread will get its own pool with a single connection in it, i.e. the connections are not shared between threads. \n\n If you really want to use shared pooling (why?), then set the max count to the same as the number of threads to ensure threads don't wait on each other. Pool throws an error if the timeout period is exceeded in the process of trying to retrieve a connection, see BasicDataSource.html#getMaxWaitMillis \", 1 minute). See The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. (Defaults to \"\", 1 minute). See BasicDataSource.html#getTimeBetweenEvictionRunsMillis Turn auto commit on or off for the connections. Max number of Prepared Statements to pool per connection. \" disables the pooling and \" \" means unlimited number of Prepared Statements to pool. (Defaults to \" \") The connection pool can be initialized instantly. If set to (default), the JDBC request samplers using this pool might measure higher response times for the first queries – as the connection establishment time for the whole pool is included. A Collection of SQL statements that will be used to initialize physical connections when they are first created. These statements are executed only once - when the configured connection factory creates the connection. Test idle connections of the pool, see BasicDataSource.html#getTestWhileIdle . Validation Query will be used to test it. connections remain in the pool. See Minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the idle object evictor, with the extra condition that at leastconnections remain in the pool. See BasicDataSource.html#getSoftMinEvictableIdleTimeMillis . Defaults to 5000 (5 seconds) ' method of the jdbc driver, which is suitable for many databases. However some may require a different query; for example Oracle something like ' ' could be used. A simple query used to determine if the database is still responding. This defaults to the '' method of the jdbc driver, which is suitable for many databases. However some may require a different query; for example Oracle something like '' could be used. The list of the validation queries can be configured with jdbc.config.check.query property and are by default: The list come from stackoverflow entry on different database validation queries and it can be incorrect Note this validation query is used on pool creation to validate it even if \" \" suggests query would only be used on idle connections. This is DBCP behaviour. file into JMeter's directory). Fully qualified name of driver class. (Must be in JMeter's classpath - easiest to copyfile into JMeter'sdirectory). The list of the preconfigured jdbc driver classes can be configured with jdbc.config.jdbc.driver.class property and are by default: Name of user to connect as. Password to connect with. (N.B. this is stored unencrypted in the test plan) Connection Properties to set when establishing connection (like for Oracle for example) Different databases and JDBC drivers require different JDBC settings. The Database URL and JDBC Driver class are defined by the provider of the JDBC implementation. Some possible settings are shown below. Please check the exact details in the JDBC driver documentation. If JMeter reports No suitable driver, then this could mean either:\n• The driver class was not found. In this case, there will be a log message such as\n• The driver class was found, but the class does not support the connection string. This could be because of a syntax error in the connection string, or because the wrong classname was used. If the database server is not running or is not accessible, then JMeter will report a java.net.ConnectException. Some examples for databases and their parameters are given below. The above may not be correct - please check the relevant JDBC driver documentation. The Keystore Config Element lets you configure how Keystore will be loaded and which keys it will use. This component is typically used in HTTPS scenarios where you don't want to take into account keystore initialization into account in response time. To use this element, you need to setup first a Java Key Store with the client certificates you want to test, to do that:\n• Create your certificates either with Java utility or through your PKI\n• If created by PKI, import your keys in Java Key Store by converting them to a format acceptable by JKS\n• Then reference the keystore file through the two JVM properties (or add them in ): To use PKCS11 as the source for the store, you need to set javax.net.ssl.keyStoreType to PKCS11 and javax.net.ssl.keyStore to NONE. Descriptive name for this element that is shown in the tree. Whether or not to preload Keystore. Setting it to is usually the best option. Variable name that will contain the alias to use for authentication by client certificate. Variable value will be filled from CSV Data Set for example. In the screenshot, \" \" will also be a variable in CSV Data Set. Defaults to The index of the first key to use in Keystore, 0-based. The index of the last key to use in Keystore, 0-based. When using \" \" ensure it is large enough so that all keys are loaded at startup. Default to -1 which means load all.\n• is set in or\n• You use HTTPClient 4 implementation for HTTP Request To make JMeter use more than one certificate you need to ensure that: The Login Config Element lets you add or override username and password settings in samplers that use username and password as part of their setup. Descriptive name for this element that is shown in the tree. The default username to use. The default password to use. (N.B. this is stored unencrypted in the test plan) The LDAP Request Defaults component lets you set default values for LDAP testing. See the LDAP Request. The LDAP Extended Request Defaults component lets you set default values for extended LDAP testing. See the LDAP Extended Request. The TCP Sampler Config provides default data for the TCP Sampler Descriptive name for this element that is shown in the tree. Name of the TCPClient class. Defaults to the property , failing that . If selected, the connection is kept open. Otherwise it is closed when the data has been read. If selected, the connection will be closed after running the sampler. Enable/disable with the specified linger time in seconds when a socket is created. If you set \" \" value as , you may prevent large numbers of sockets sitting around with a status. Byte value for end of line, set this to a value outside the range to to skip EOL checking. You may set this in file as well with the property. If you set this in TCP Sampler Config and in file at the same time, the setting value in the TCP Sampler Config will be used. Should the nodelay property be set? The User Defined Variables element lets you define an initial set of variables, just as in the Test Plan. Note that all the UDV elements in a test plan - no matter where they are - are processed at the start. So you cannot reference variables which are defined as part of a test run, e.g. in a Post-Processor. So you cannot reference variables which are defined as part of a test run, e.g. in a Post-Processor. UDVs should not be used with functions that generate different results each time they are called. Only the result of the first function call will be saved in the variable. However, UDVs can be used with functions such as __P(), for example: which would define the variable \"HOST\" to have the value of the JMeter property \"host\", defaulting to \"localhost\" if not defined. For defining variables during a test run, see User Parameters. UDVs are processed in the order they appear in the Plan, from top to bottom. For simplicity, it is suggested that UDVs are placed only at the start of a Thread Group (or perhaps under the Test Plan itself). Once the Test Plan and all UDVs have been processed, the resulting set of variables is copied to each thread to provide the initial set of variables. If a runtime element such as a User Parameters Pre-Processor or Regular Expression Extractor defines a variable with the same name as one of the UDV variables, then this will replace the initial value, and all other test elements in the thread will see the updated value. If you have more than one Thread Group, make sure you use different names for different values, as UDVs are shared between Thread Groups. Also, the variables are not available for use until after the element has been processed, so you cannot reference variables that are defined in the same element. You can reference variables defined in earlier UDVs or on the Test Plan. Descriptive name for this element that is shown in the tree. Variable name/value pairs. The string under the \" \" column is what you'll need to place inside the brackets in constructs to use the variables later on. The whole will then be replaced by the string in the \" \" column. The Random Variable Config Element is used to generate random numeric strings and store them in variable for use later. It's simpler than using User Defined Variables together with the __Random() function. The output variable is constructed by using the random number generator, and then the resulting number is formatted using the format string. The number is calculated using the formula minimum+Random.nextInt(maximum-minimum+1). Random.nextInt() requires a positive integer. This means that maximum-minimum - i.e. the range - must be less than 2147483647, however the minimum and maximum values can be any long values so long as the range is OK. As the random value is evaluated at the start of each iteration, it is probably not a good idea to use a variable other than a property as a value for the minimum or maximum. It would be zero on the first iteration. Descriptive name for this element that is shown in the tree. The name of the variable in which to store the random string. The format string to be used. For example \" \" which will generate numbers with at least 3 digits, or \" \" which will generate output of the form . If not specified, the default is to generate the number using The minimum value ( ) of the generated random number. The maximum value ( ) of the generated random number. , you will get the same value for each Thread as per The seed for the random number generator. If you use the same seed value with Per Thread set to, you will get the same value for each Thread as per Random class. If no seed is set, Default constructor of Random will be used. If , the generator is shared between all threads in the thread group. If , then each thread has its own random generator. Allows the user to create a counter that can be referenced anywhere in the Thread Group. The counter config lets the user configure a starting point, a maximum, and the increment. The counter will loop from the start to the max, and then start over with the start, continuing on like that until the test is ended. The counter uses a long to store the value, so the range is from -2^63 to 2^63-1. Descriptive name for this element that is shown in the tree. The starting value for the counter. The counter will equal this value during the first iteration (defaults to 0). How much to increment the counter by after each iteration (defaults to 0, meaning no increment). If the counter exceeds the maximum, then it is reset to the . Default is Optional format, e.g. will format as , , etc. This is passed to , so any valid formats can be used. If there is a problem interpreting the format, then it is ignored. [The default format is generated using ] , you can then access it using as explained in but this is highly discouraged) This will be the variable name under which the counter value is available. If you name it, you can then access it usingas explained in user-defined values (By default, it creates an empty string variable that can be accessed usingbut this is highly discouraged) In other words, is this a global counter, or does each user get their own counter? If unchecked, the counter is global (i.e., user #1 will get value \" \", and user #2 will get value \" \" on the first iteration). If checked, each user has an independent counter. This option is only available when counter is tracked per User, if checked, counter will be reset to value on each Thread Group iteration. This can be useful when Counter is inside a Loop Controller. The Simple Config Element lets you add or override arbitrary values in samplers. You can choose the name of the value and the value itself. Although some adventurous users might find a use for this element, it's here primarily for developers as a basic GUI that they can use while developing new JMeter components. Descriptive name for this element that is shown in the tree. The name of each parameter. These values are internal to JMeter's workings and are not generally documented. Only those familiar with the code will know these values. The value to apply to that parameter. Creates a MongoDB connection (used by MongoDB Script Sampler) from the supplied Connection settings. Each thread gets its own connection. The connection configuration name is used by the JDBC Sampler to select the appropriate connection. You can then access com.mongodb.DB object in Beanshell or JSR223 Test Elements through the element MongoDBHolder using this code import com.mongodb.DB; import org.apache.jmeter.protocol.mongodb.config.MongoDBHolder; DB db = MongoDBHolder.getDBFromSource(\"value of property MongoDB Source\", \"value of property Database Name\"); … Descriptive name for the connection configuration that is shown in the tree. Each name must be different. If there are two configuration elements using the same name, only one will be saved. The name of the variable the connection is tied to. , the driver will keep trying to connect to the same server in case that the socket cannot be established. \n\n There is maximum amount of time to keep retrying, which is 15s by default. \n\n This can be useful to avoid some exceptions being thrown when a server is down temporarily by blocking the operations. \n\n It can also be useful to smooth the transition to a new primary node (so that a new primary node is elected within the retry time).\n• for a replica set, the driver will try to connect to the old primary node for that time, instead of failing over to the new one right away\n• this does not prevent exception from being thrown in read/write operations on the socket, which must be handled by application. Even if this flag is false, the driver already has mechanisms to automatically recreate broken connections and retry the read operations. Note that when using this flagEven if this flag is false, the driver already has mechanisms to automatically recreate broken connections and retry the read operations. Default is . If, the driver will keep trying to connect to the same server in case that the socket cannot be established.There is maximum amount of time to keep retrying, which is 15s by default.This can be useful to avoid some exceptions being thrown when a server is down temporarily by blocking the operations.It can also be useful to smooth the transition to a new primary node (so that a new primary node is elected within the retry time).Default is The connection timeout in milliseconds. \n\n It is used solely when establishing a new connection \n\n Default is and means no timeout. The maximum amount of time in milliseconds to spend retrying to open connection to the same server. \n\n Default is , which means to use the default 15s if is on. The maximum wait time in milliseconds that a thread may wait for a connection to become available. \n\n Default is . The socket timeout in milliseconds It is used for I/O socket read and write operations \n\n Default is and means no timeout. This flag controls the socket keep alive feature that keeps a connection alive through firewalls \n\n Default is . This multiplier, multiplied with the connectionsPerHost setting, gives the maximum number of threads that may be waiting for a connection to become available from the pool. \n\n All further threads will get an exception right away. \n\n For example if is and is , then up to 50 threads can wait for a connection. \n\n Default is . If the driver will use a of for all operations. \n\n If , , or are specified, this setting is ignored. \n\n Default is . The value of the global . \n\n Default is . The value of the global . \n\n Default is . The value of the global . \n\n Default is . The value of the global . \n\n Default is . If batch inserts should continue after the first error ^ Creates a Bolt connection pool (used by Bolt Request Sampler) from the supplied Connection settings. Descriptive name for this sampler that is shown in the tree. Max size of the Neo4j driver Bolt connection pool. Raise the value if running large number of concurrent threads, so that JMeter threads are not blocked waiting for a connection to be released to the pool. ^\n\n\n\n You can apply a multiplication factor on the sleep delays computed by Random timer by setting property where float number is a decimal positive number. \n\n JMeter will multiply this factor by the computed sleep delay. This feature can be used by: Since version 3.1, a new feature (in Beta mode as of JMeter 3.1 and subject to changes) has been implemented which provides the following feature.You can apply a multiplication factor on the sleep delays computed by Random timer by setting propertywhere float number is a decimal positive number.JMeter will multiply this factor by the computed sleep delay. This feature can be used by: before each sampler in the scope in which they are found; if there are several timers in the same scope, all the timers will be processed before each sampler. \n\n Timers are only processed in conjunction with a sampler. A timer which is not in the same scope as a sampler will not be processed at all. \n\n To apply a timer to a single sampler, add the timer as a child element of the sampler. The timer will be applied before the sampler is executed. To apply a timer after a sampler, either add it to the next sampler, or add it as the child of a Note that timers are processedeach sampler in the scope in which they are found; if there are several timers in the same scope,the timers will be processedsampler.Timers are only processed in conjunction with a sampler. A timer which is not in the same scope as a sampler will not be processed at all.To apply a timer to a single sampler, add the timer as a child element of the sampler. The timer will be applied before the sampler is executed. To apply a timer after a sampler, either add it to the next sampler, or add it as the child of a Flow Control Action Sampler. If you want to have each thread pause for the same amount of time between requests, use this timer. Descriptive name for this timer that is shown in the tree. This timer pauses each thread request for a random amount of time, with most of the time intervals occurring near a particular value. The total delay is the sum of the Gaussian distributed value (with mean 0.0 and standard deviation 1.0) times the deviation value you specify, and the offset value. Another way to explain it, in Gaussian Random Timer, the variation around constant offset has a Gaussian curve distribution. Descriptive name for this timer that is shown in the tree Number of milliseconds to pause in addition to the random delay. This timer pauses each thread request for a random amount of time, with each time interval having the same probability of occurring. The total delay is the sum of the random value and the offset value. Descriptive name for this timer that is shown in the tree. Number of milliseconds to pause in addition to the random delay. This timer introduces variable pauses, calculated to keep the total throughput (in terms of samples per minute) as close as possible to a given figure. Of course the throughput will be lower if the server is not capable of handling it, or if other timers or time-consuming test elements prevent it. N.B. although the Timer is called the Constant Throughput timer, the throughput value does not need to be constant. It can be defined in terms of a variable or function call, and the value can be changed during a test. The value can be changed in various ways:\n• using a , function to provide a changing value\n• using the remote BeanShell server to change a JMeter property See Best Practices for further details. Note that the throughput value should not be changed too often during a test - it will take a while for the new value to take effect. Descriptive name for this timer that is shown in the tree. Throughput we want the timer to try to generate.\n• - each thread will try to maintain the target throughput. The overall throughput will be proportional to the number of active threads.\n• - the target throughput is divided amongst all the active threads in the group. Each thread will delay as needed, based on when it last ran.\n• - the target throughput is divided amongst all the active threads in all Thread Groups. Each thread will delay as needed, based on when it last ran. In this case, each other Thread Group will need a Constant Throughput timer with the same settings.\n• - as above, but each thread is delayed based on when any thread in the group last ran.\n• - as above; each thread is delayed based on when any thread last ran. The shared and non-shared algorithms both aim to generate the desired throughput, and will produce similar results. \n\n The shared algorithm should generate a more accurate overall transaction rate. \n\n The non-shared algorithm should generate a more even spread of transactions across threads. This timer introduces variable pauses, calculated to keep the total throughput (e.g. in terms of samples per minute) as close as possible to a given figure. The timer does not generate threads, so the resulting throughput will be lower if the server is not capable of handling it, or if other timers add too big delays, or if there's not enough threads, or time-consuming test elements prevent it. Note: in many cases, Open Model Thread Group would be a better choice for generating the desired load profile Note: if you alter timer configuration on the fly, then it might take time to adapt to the new settings. For instance, if the timer was initially configured for 1 request per hour, then it assigns incoming threads with 3600+sec pauses. Then, if the load configuration is altered to 1 per second, then the threads are not interrupted from their delays, and the threads keep waiting. Although the Timer is called Precise Throughput Timer, it does not aim to produce precisely the same number of samples over one-second intervals during the test. The timer works best for rates under 36000 requests/hour, however your mileage might vary (see monitoring section below if your goals are vastly different). Best location of a Precise Throughput Timer in a Test Plan As you might know, the timers are inherited by all the siblings and their child elements. That is why one of the best places for Precise Throughput Timer is under the first element in a test loop. For instance, you might add a dummy sampler at the beginning, and place the timer under that dummy sampler Precise Throughput Timer models Poisson arrivals schedule. That schedule often happens in a real-life, so it makes sense to use that for load testing. For instance, it naturally might generate samples that are close together thus it might reveal concurrency issues. Even if you manage to generate Poisson arrivals with Poisson Random Timer, it would be susceptible to the issues listed below. For instance, true Poisson arrivals might have indefinitely long pause, and that is not practical for load testing. For instance, \"regular\" Poisson arrivals with 1 per second rate might end up with 50 samples over 60 second long test. Constant Throughput Timer converges to the specified rate, however it tends to produce samples at even intervals. You might used \"ramp-up\" or similar approaches to avoid a spike at the test start. For instance, if you configure Thread Group to have 100 threads, and set Ramp-up Period to 0 (or to a small number), then all the threads would start at the same time, and it would produce an unwanted spike of the load. On top of that, if you set Ramp-up Period too high, it might result in \"too few\" threads being available at the very beginning to achieve the required load. Precise Throughput Timer schedules executions in a random way, so it can be used to generate constant load, and it is recommended to set both Ramp-up Period and Delay to 0. Multiple thread groups starting at the same time A variation of Ramp-up issue might appear when Test Plan includes multiple Thread Groups. To mitigate that issue one typically adds \"random\" delay to each Thread Group so threads start at different times. Precise Throughput Timer avoids that issue since it schedules executions in a random way. You do not need to add extra random delays to mitigate startup spike One of the basic requirements is to issue N samples per M minutes. Let it be 60 iterations per hour. Business customers would not understand if you report load test results with 57 executions \"just because the random was random\". In order to generate 60 iterations per hour, you need to configure as follows (other parameters could be left with their default values) The first two options set the throughput. Even though 60/3600, 30/1800, and 120/7200 represent exactly the same load level, pick the one that represents business requirements better. For instance, if the requirement is to test for \"60 sample per hour\", then set 60/3600. If the requirement is to test \"1 sample per minute\", then set 1/60. Test duration (seconds) is there so the timer ensures exact number of samples for a given test duration. Precise Throughput Timer creates a schedule for the samples at the test startup. For instance, if you wish to perform 5 minutes test with 60 per hour throughput, you would set Test duration (seconds) to 300. This enables to configure throughput in a business-friendly way. Note: Test duration (seconds) does not limit test duration. It is just a hint for the timer. Number of threads and think times One of the common pitfalls is to adjust number of threads and think times in order to end up with the desired throughput. Even though it might work, that approach results in lots of time spent on the test runs. It might require to adjust threads and delays again when new application version arrives. Precise Throughput Timer enables to set throughput goal and go for it no matter how well application performs. In order to do that, Precise Throughput Timer creates a schedule at the test startup, then it uses that schedule to release threads. The main driver for the think times and number of threads should be business requirements, not the desire to match throughput somehow. For instance, if you application is used by support engineers in a call center. Suppose there are 2 engineers in the call center, and the target throughput is 1 per minute. Suppose it takes 4 minutes for the engineer to read and review the web page. For that case you should set 2 threads in the group, use 4 minutes for think time delays, and specify 1 per minute in Precise Throughput Timer. Of course it would result in something around 2samples/4minutes=0.5 per minute and the result of such a test means \"you need more support engineers in a call center\" or \"you need to reduce the time it takes an engineer to fulfill a task\". Testing at low rates (e.g. 60 per hour) requires to know the desired test profile. For instance, if you need to inject load at even intervals (e.g. 60 seconds in between) then you'd better use Constant Throughput Timer. However, if you need to have randomized schedule (e.g. to model real users that execute reports), then Precise Throughput Timer is your friend. When comparing outcomes of multiple load tests, it is useful to be able to repeat exactly the same test profile. For instance, if action X (e.g. \"Profit Report\") is invoked after 5 minutes of the test start, then it would be nice to replicate that pattern for subsequent test executions. Replicating the same load pattern simplifies analysis of the test results (e.g. CPU% chart). Random seed (change from 0 to random) enables to control the seed value that is used by Precise Throughput Timer. By default it is initialized with 0 and that means random seed is used for each test execution. If you need to have repeatable load pattern, then change Random seed so some random value. The general advice is to use non-zero seed, and \"0 by default\" is an implementation limit. Note: when using multiple thread groups with same throughput rates and same non-zero seed it might result in unwanted firing the samples at the same time. Precise Throughput Timer generates the schedule and keeps it in memory. In most cases it should not be a problem, however, remember that you might want to keep the schedule shorter than 1'000'000 samples. It takes ~200ms to generate a schedule for 1'000'000 samples, and the schedule consumes 8 megabytes in the heap. Schedule for 10 million entries takes 1-2 second to build and it consumes 80 megabytes in the heap. For instance, if you want to perform 2-week long test with 5'000 per hour rate, then you probably want to have exactly 5'000 samples for each hour. You can set Test duration (seconds) property of the timer of the timer to 1 hour. Then the timer would create a schedule of 5'000 samples for an hour, and when the schedule is exhausted, the timer would generate a schedule for the next hour. At the same time, you can set Test duration (seconds) to 2 weeks, and the timer would generate a schedule with 168'000 samples = 2 weeks * 5'000 samples/hour = 2*7*24*500. The schedule would take ~30ms to generate, and it would consume a little more than 1 megabyte. There might be a case when all the samples should come in pairs, triples, etc. Certain cases might be solved via Synchronizing Timer, however Precise Throughput Timer has native way to issue requests in packs. This behavior is disabled by default, and it is controlled with \"Batched departures\" settings\n• Number of threads in the batch (threads) . Specifies the number of samples in a batch. Note the overall number of samples will still be in line with\n• Delay between threads in the batch (ms) . For instance, if set to 42, and the batch size is 3, then threads will depart at x, x+42ms, x+84ms Even though property values (e.g. throughput) can be defined via expressions, it is recommended to keep the value more or less the same through the test, as it takes time to recompute the new schedule to adapt new values. As next schedule is generated, Precise Throughput Timer logs a message to jmeter.log: 2018-01-04 17:34:03,635 INFO o.a.j.t.ConstantPoissonProcessGenerator: Generated 21 timings (... 20 required, rate 1.0, duration 20, exact lim 20000, i21) in 0 ms. First 15 events will be fired at: 1.1869653574244292 (+1.1869653574244292), 1.4691340403043207 (+0.2821686828798915), 3.638151706179226 (+2.169017665874905), 3.836357090410566 (+0.19820538423134026), 4.709330071408575 (+0.8729729809980085), 5.61330076999953 (+0.903970698590955), ... This shows that schedule generation took 0ms, and it shows absolute timestamps in seconds. In the case above, the rate was set to be 1 per second, and the actual timestamps became 1.2 sec, 1.5 sec, 3.6 sec, 3.8 sec, 4.7 sec, and so on. Descriptive name for this timer that is shown in the tree Maximum number of samples you want to obtain per \"throughput period\", including all threads in group, from all affected samplers. Throughput period. For example, if \"throughput\" is set to 42 and \"throughput period\" to 21 sec, then you'll get 2 samples per second. This is used to ensure you'll get throughput*duration samples during \"test duration\" timeframe. Number of threads in the batch (threads) If the value exceeds 1, then multiple threads depart from the timer simultaneously. Average throughput still meets \"throughput\" value. Delay between threads in the batch (ms) For instance, if set to 42, and the batch size is 3, then threads will depart at x, x+42ms, x+84ms. Note: different timers should better have different seed values. Constant seed ensures timer generates the same delays each test start. The value of \"0\" means the timer is truly random (non-repeatable from one execution to another).. The purpose of the SyncTimer is to block threads until X number of threads have been blocked, and then they are all released at once. A SyncTimer can thus create large instant loads at various points of the test plan. Descriptive name for this timer that is shown in the tree. Number of Simultaneous Users to Group by Number of threads to release at once. Setting it to is equivalent to setting it to Number of threads in Thread Group. If set to , Timer will wait for the number of threads to reach the value in \" \". If superior to , then timer will wait at max \" \" for the number of Threads. If after the timeout interval the number of users waiting is not reached, timer will stop waiting. Defaults to If timeout in milliseconds is set to and number of threads never reaches \" Number of Simultaneous Users to Group by \" then Test will pause infinitely. Only a forced stop will stop it. Setting Timeout in milliseconds is an option to consider in this case. Synchronizing timer blocks only within one JVM, so if using Distributed testing ensure you never set \" Number of Simultaneous Users to Group by \" to a value superior to the number of users of its containing Thread group considering 1 injector only. The BeanShell Timer can be used to generate a delay. For full details on using BeanShell, please see the BeanShell website. Migration to JSR223 Timer +Groovy is highly recommended for performance, support of new Java features and limited maintenance of the BeanShell library. The test element supports the ThreadListener and TestListener methods. These should be defined in the initialisation file. See the file BeanShellListeners.bshrc for example definitions. Descriptive name for this element that is shown in the tree. The name is stored in the script variable If this option is selected, then the interpreter will be recreated for each sample. This may be necessary for some long running scripts. For further information, see Best Practices - BeanShell scripting\n• - string containing the parameters as a single variable Parameters to pass to the BeanShell script. The parameters are stored in the following variables: A file containing the BeanShell script to run. The file name is stored in the script variable The return value is used as the number of milliseconds to wait. The BeanShell script. The return value is used as the number of milliseconds to wait. Yes (unless script file is provided) Before invoking the script, some variables are set up in the BeanShell interpreter:\n• - (Logger) - can be used to write to the log file\n• - (JMeterContext) - gives access to the context\n• - (SampleResult) - gives access to the previous (if any) For details of all the methods available on each of the above variables, please check the Javadoc If the property beanshell.timer.init is defined, this is used to load an initialisation file, which can be used to define methods etc. for use in the BeanShell script. The JSR223 Timer can be used to generate a delay using a JSR223 scripting language, Descriptive name for this element that is shown in the tree. The scripting language to be used.\n• - string containing the parameters as a single variable Parameters to pass to the script. The parameters are stored in the following variables: A file containing the script to run, if a relative file path is used, then it will be relative to directory referenced by \" \" System property The return value is converted to a long integer and used as the number of milliseconds to wait. interface (Groovy is one of these, java, beanshell and javascript are not) See note in JSR223 Sampler Java System property if you're using Groovy without checking this option Unique String across Test Plan that JMeter will use to cache result of Script compilation if language used supportsinterface (Groovy is one of these, java, beanshell and javascript are not) The script. The return value is used as the number of milliseconds to wait. Yes (unless script file is provided) Before invoking the script, some variables are set up in the script interpreter:\n• - (Logger) - can be used to write to the log file\n• - (JMeterContext) - gives access to the context\n• - the name of the Timer\n• - the file name (if any) For details of all the methods available on each of the above variables, please check the Javadoc This timer pauses each thread request for a random amount of time, with most of the time intervals occurring near a particular value. The total delay is the sum of the Poisson distributed value, and the offset value. Note: if you want to model Poisson arrivals, consider using Precise Throughput Timer instead. Descriptive name for this timer that is shown in the tree Number of milliseconds to pause in addition to the random delay. ^\n\nAs the name suggests, Post-Processors are applied after samplers. Note that they are applied to all the samplers in the same scope, so to ensure that a post-processor is applied only to a particular sampler, add it as a child of the sampler. Note: Unless documented otherwise, Post-Processors are not applied to sub-samples (child samples) - only to the parent sample. In the case of JSR223 and BeanShell post-processors, the script can retrieve sub-samples using the method which returns an array of SampleResults. The array will be empty if there are none. Post-Processors are run before Assertions, so they do not have access to any Assertion Results, nor will the sample status reflect the results of any Assertions. If you require access to Assertion Results, try using a Listener instead. Also note that the variable JMeterThread.last_sample_ok is set to \"true\" or \"false\" after all Assertions have been run. Allows the user to extract values from a server response using a Perl-type regular expression. As a post-processor, this element will execute after each Sample request in its scope, applying the regular expression, extracting the requested values, generate the template string, and store the result into the given variable name. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - extraction is to be applied to the contents of the named variable Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match for the regex, (i.e. 4 matches in total). For match number = , Sub-samples only, the extractor will match the 3rd sub-sample. For match number = , Main sample and sub-samples, the extractor will match the 2nd sub-sample (1st match is main sample). For match number = or negative, all qualifying samples will be processed. For match number > , matching will stop as soon as enough matches have been found. This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller.Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match for the regex, (i.e. 4 matches in total). For match number =, Sub-samples only, the extractor will match the 3sub-sample. For match number =, Main sample and sub-samples, the extractor will match the 2sub-sample (1match is main sample). For match number =or negative, all qualifying samples will be processed. For match number >, matching will stop as soon as enough matches have been found.\n• - the body of the response, e.g. the content of a web-page (excluding headers)\n• - the body of the response, with all Html escape codes replaced. Note that Html escapes are processed without regard to context, so some incorrect substitutions may be made. Note that this option highly impacts performances, so use it only when absolutely necessary and be aware of its impacts\n• - the extract text from various type of documents via Apache Tika (see View Results Tree Document view section). Note that the Body as a Document option can impact performances, so ensure it is OK for your test\n• - may not be present for non-HTTP samples\n• - may not be present for non-HTTP samples Headers can be useful for HTTP samples; it may not be present for other sample types. The following fields can be checked:Headers can be useful for HTTP samples; it may not be present for other sample types. The name of the JMeter variable in which to store the result. Also note that each group is stored as , where is the string you entered as the reference name, and is the group number, where group is the entire match, group is the match from the first set of parentheses, etc. The regular expression used to parse the response data. This must contain at least one set of parentheses \" \" to capture a portion of the string, unless using the group . Do not enclose the expression in - unless of course you want to match these characters as well. The template used to create a string from the matches found. This is an arbitrary string with special elements to refer to groups within the regular expression. The syntax to refer to a group is: ' ' to refer to group , ' ' to refer to group , etc. refers to whatever the entire expression matches.\n• Use a value of zero to indicate JMeter should choose a match at random.\n• Negative numbers are used in conjunction with the ForEach Controller - see below. Indicates which match to use. The regular expression may match multiple times. If the regular expression does not match, then the reference variable will be set to the default value. This is particularly useful for debugging tests. If no default is provided, then it is difficult to tell whether the regular expression did not match, or the RE element was not processed or maybe the wrong variable is being used. However, if you have several test elements that set the same variable, you may wish to leave the variable unchanged if the expression does not match. In this case, remove the default value once debugging is complete. If the checkbox is checked and is empty, then JMeter will set the variable to empty string instead of not setting it. Thus when you will for example use (if is var) in your Test Plan, if the extracted value is not found then will be equal to empty string instead of containing which may be useful if extracted value is optional. If the match number is set to a non-negative number, and a match occurs, the variables are set as follows:\n• - the value of the template\n• , where = , , - the groups for the match\n• - the number of groups in the Regex (excluding ) If no match occurs, then the refName variable is set to the default (unless this is absent). Also, the following variables are removed: If the match number is set to a negative number, then all the possible matches in the sampler data are processed. The variables are set as follows:\n• - the number of matches found; could be\n• , where = , , etc. - the strings as generated by the template\n• , where = , , - the groups for match\n• - always set to the default value Note that the refName variable is always set to the default value in this case, and the associated group variables are not set. See also Response Assertion for some examples of how to specify modifiers, and for further information on JMeter regular expressions. Allows the user to extract values from a server HTML response using a CSS Selector syntax. As a post-processor, this element will execute after each Sample request in its scope, applying the CSS/JQuery expression, extracting the requested nodes, extracting the node as text or attribute value and store the result into the given variable name. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - extraction is to be applied to the contents of the named variable Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match for the regex, (i.e. 4 matches in total). For match number = , Sub-samples only, the extractor will match the 3rd sub-sample. For match number = , Main sample and sub-samples, the extractor will match the 2nd sub-sample (1st match is main sample). For match number = or negative, all qualifying samples will be processed. For match number > , matching will stop as soon as enough matches have been found. This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller.Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match for the regex, (i.e. 4 matches in total). For match number =, Sub-samples only, the extractor will match the 3sub-sample. For match number =, Main sample and sub-samples, the extractor will match the 2sub-sample (1match is main sample). For match number =or negative, all qualifying samples will be processed. For match number >, matching will stop as soon as enough matches have been found. If selector is set to empty, default implementation(JSoup) will be used. 2 Implementations for CSS/JQuery based syntax are supported:If selector is set to empty, default implementation(JSoup) will be used. The name of the JMeter variable in which to store the result.\n• - child elements that descend from ancestor, e.g. finds elements anywhere under a block with class \" \"\n• - find elements whose sibling index (i.e. its position in the DOM tree relative to its parent) is less than ; e.g.\n• - find elements that contain the given . The search is case-insensitive; e.g. For more details on syntax, see: The CSS/JQuery selector used to select nodes from the response data. Selector, selectors combination and pseudo-selectors are supported, examples:For more details on syntax, see: \n\n This is the equivalent \n\n \n\n If empty this is the equivalent of Name of attribute (as per HTML syntax) to extract from nodes that matched the selector. If empty, then the combined text of this element and all its children will be returned.This is the equivalent Element#attr(name) function for JSoup if an attribute is set.If empty this is the equivalent of Element#text() function for JSoup if not value is set for attribute.\n• Use a value of zero to indicate JMeter should choose a match at random.\n• Negative numbers are used in conjunction with the ForEach Controller - see below. Indicates which match to use. The CSS/JQuery selector may match multiple times. If the expression does not match, then the reference variable will be set to the default value. This is particularly useful for debugging tests. If no default is provided, then it is difficult to tell whether the expression did not match, or the CSS/JQuery element was not processed or maybe the wrong variable is being used. However, if you have several test elements that set the same variable, you may wish to leave the variable unchanged if the expression does not match. In this case, remove the default value once debugging is complete. If the checkbox is checked and is empty, then JMeter will set the variable to empty string instead of not setting it. Thus when you will for example use (if is var) in your Test Plan, if the extracted value is not found then will be equal to empty string instead of containing which may be useful if extracted value is optional. If the match number is set to a non-negative number, and a match occurs, the variables are set as follows:\n• - the value of the template If no match occurs, then the refName variable is set to the default (unless this is absent). If the match number is set to a negative number, then all the possible matches in the sampler data are processed. The variables are set as follows:\n• - the number of matches found; could be\n• , where = , , , etc. - the strings as generated by the template\n• - always set to the default value Note that the refName variable is always set to the default value in this case. This test element allows the user to extract value(s) from structured response - XML or (X)HTML - using XPath2 query language. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - extraction is to be applied to the contents of the named variable XPath matching is applied to all qualifying samples in turn, and all the matching results will be returned. This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller.XPath matching is applied to all qualifying samples in turn, and all the matching results will be returned. If selected, the fragment will be returned rather than the text content. \n\n For example would return \" \" rather than \" \". \n\n In this case, would return \" \". The name of the JMeter variable in which to store the result. Element query in XPath 2.0 language. Can return more than one match.\n• means extract all results, they will be named as (where goes from 1 to Number of results)\n• : means extract the Xth result. If this Xth is greater than number of matches, then nothing is returned. Default value will be used If the XPath Path query leads to many results, you can choose which one(s) to extract as Variables: Default value returned when no match found. It is also returned if the node has no value and the fragment option is not selected. List of namespaces aliases you want to use to parse the document, one line per declaration. You must specify them as follow: . This implementation makes it easier to use namespaces than with the old XPathExtractor version. To allow for use in a ForEach Controller, it works exactly the same as the above XPath Extractor XPath2 Extractor provides some interestings tools such as an improved syntax and much more functions than in its first version. extracts 2nd absolute value of the page from a book extracts the average number of page from all the books in the libraries return Integer value equal 0 to if the 2nd page of the first book is equal to the 2nd page of the 2nd book, else return -1. To see more information about these functions, please check xPath2 functions Since JMeter 5.0, you should use XPath2 Extractor as it provides better and easier namespace management, better performances and support for XPath 2.0 This test element allows the user to extract value(s) from structured response - XML or (X)HTML - using XPath query language. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - extraction is to be applied to the contents of the named variable XPath matching is applied to all qualifying samples in turn, and all the matching results will be returned. This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller.XPath matching is applied to all qualifying samples in turn, and all the matching results will be returned.\n• \" \" should be checked on for HTML response. Such response is converted to valid XHTML (XML compatible HTML) using Tidy\n• \" \" should be unchecked for both XHTML or XML response (for example RSS) For HTML, CSS Selector Extractor is the correct and performing solution. Don't use XPath for HTML extractions. If checked use Tidy to parse HTML response into XHTML. If a Tidy error occurs, then set the Assertion accordingly If checked, then the XML parser will use namespace resolution.(see note below on NAMESPACES) Note that currently only namespaces declared on the root element will be recognised. See below for user-definition of additional workspace names. Check the document against its schema. If selected, the fragment will be returned rather than the text content. \n\n For example would return \" \" rather than \" \". \n\n In this case, would return \" \". The name of the JMeter variable in which to store the result. Element query in XPath language. Can return more than one match.\n• means extract all results (default value), they will be named as (where goes from 1 to Number of results)\n• : means extract the Xth result. If this Xth is greater than number of matches, then nothing is returned. Default value will be used If the XPath Path query leads to many results, you can choose which one(s) to extract as Variables: Default value returned when no match found. It is also returned if the node has no value and the fragment option is not selected. To allow for use in a ForEach Controller, the following variables are set on return:\n• - set to first (or only) match; if no match, then set to default\n• - set to number of matches (may be )\n• - = , , , etc. Set to the 1st, 2nd 3rd match etc. Note: The next variable is set to - e.g. if there are 2 matches, then is set to , and if there are no matches, then is set to . XPath is query language targeted primarily for XSLT transformations. However it is useful as generic query language for structured data too. See XPath Reference or XPath specification for more information. Here are few examples: extracts value attribute of option element that match text ' ' inside of select element with name attribute ' ' inside of form with name attribute ' ' \" is checked on - resulting XML document may slightly differ from original HTML response:\n• All elements and attribute names are converted to lowercase\n• Tidy attempts to correct improperly nested elements. For example - original (incorrect) becomes correct See When \"\" is checked on - resulting XML document may slightly differ from original HTML response:See Tidy homepage for more information. NAMESPACES \n\n As a work-round for namespace limitations of the Xalan XPath parser (implementation on which JMeter is based) you need to:\n• provide a Properties file (if for example your file is named ) which contains mappings for the namespace prefixes:\n• reference this file in file using the property: As a work-round for namespace limitations of the Xalan XPath parser (implementation on which JMeter is based) you need to: This test element allows the user to extract value(s) from JSON response using JMESPath query language. In the XPATH Extractor we support to extract multiple xpaths at the same time, but in JMES Extractor only one JMES Expression can be entered at a time. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - extraction is to be applied to the contents of the named variable This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller. The name of the JMeter variable in which to store the result. Element query in JMESPath query language. Can return the matched result.\n• means extract all results (default value), they will be named as (where goes from 1 to Number of results)\n• : means extract the Xth result. If this Xth is greater than number of matches, then nothing is returned. Default value will be used If the JMESPath query leads to many results, you can choose which one(s) to extract as Variables: Default value returned when no match found. It is also returned if the node has no value and the fragment option is not selected. JMESPath is a query language for JSON. It is described in an ABNF grammar with a complete specification. This ensures that the language syntax is precisely defined. See JMESPath Reference for more information. Here are also some examples JMESPath Example. This test element allows the user to stop the thread or the whole test if the relevant sampler failed. Descriptive name for this element that is shown in the tree. Action to be taken after a Sampler error\n• - ignore the error and continue with the test\n• - does not execute samplers following the sampler in error for the current iteration and restarts the loop on next iteration\n• - the entire test is stopped at the end of any current samples.\n• - the entire test is stopped abruptly. Any current samplers are interrupted if possible. Determines what happens if a sampler error occurs, either because the sample itself failed or an assertion failed. The possible choices are: The BeanShell PreProcessor allows arbitrary code to be applied after taking a sample. For full details on using BeanShell, please see the BeanShell website. Migration to JSR223 PostProcessor +Groovy is highly recommended for performance, support of new Java features and limited maintenance of the BeanShell library. The test element supports the ThreadListener and TestListener methods. These should be defined in the initialisation file. See the file BeanShellListeners.bshrc for example definitions. Descriptive name for this element that is shown in the tree. The name is stored in the script variable If this option is selected, then the interpreter will be recreated for each sample. This may be necessary for some long running scripts. For further information, see Best Practices - BeanShell scripting\n• - string containing the parameters as a single variable Parameters to pass to the BeanShell script. The parameters are stored in the following variables: A file containing the BeanShell script to run. The file name is stored in the script variable The BeanShell script. The return value is ignored. Yes (unless script file is provided) The following BeanShell variables are set up for use by the script:\n• - (Logger) - can be used to write to the log file\n• - (JMeterContext) - gives access to the context\n• - (SampleResult) - gives access to the previous SampleResult\n• - (byte [])- gives access to the current sample data For details of all the methods available on each of the above variables, please check the Javadoc If the property beanshell.postprocessor.init is defined, this is used to load an initialisation file, which can be used to define methods etc. for use in the BeanShell script. The JSR223 PostProcessor allows JSR223 script code to be applied after taking a sample. Descriptive name for this element that is shown in the tree. The JSR223 language to be used\n• - string containing the parameters as a single variable Parameters to pass to the script. The parameters are stored in the following variables: A file containing the script to run, if a relative file path is used, then it will be relative to directory referenced by \" \" System property interface (Groovy is one of these, java, beanshell and javascript are not) See note in JSR223 Sampler Java System property if you're using Groovy without checking this option Unique String across Test Plan that JMeter will use to cache result of Script compilation if language used supportsinterface (Groovy is one of these, java, beanshell and javascript are not) Yes (unless script file is provided) Before invoking the script, some variables are set up. Note that these are JSR223 variables - i.e. they can be used directly in the script.\n• - (Logger) - can be used to write to the log file\n• - the script file name (if any)\n• - the parameters as a String array (split on whitespace)\n• - (JMeterContext) - gives access to the context\n• - (SampleResult) - gives access to the previous SampleResult (if any)\n• - (Sampler)- gives access to the current sampler For details of all the methods available on each of the above variables, please check the Javadoc The JDBC PostProcessor enables you to run some SQL statement just after a sample has run. This can be useful if your JDBC Sample changes some data and you want to reset state to what it was before the JDBC sample run. In the linked test plan, \"JDBC PostProcessor\" JDBC PostProcessor calls a stored procedure to delete from Database the Price Cut-Off that was created by PreProcessor. The JSON PostProcessor enables you extract data from JSON responses using JSON-PATH syntax. This post processor is very similar to Regular expression extractor. It must be placed as a child of HTTP Sampler or any other sampler that has responses. It will allow you to extract in a very easy way text content, see JSON Path syntax. Descriptive name for this element that is shown in the tree. only applies to the main sample only applies to the sub-samples JMeter Variable Name to use extraction is to be applied to the contents of the named variable This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller. Semicolon separated names of variables that will contain the results of JSON-PATH expressions (must match number of JSON-PATH expressions) Semicolon separated default values if JSON-PATH expressions do not return any result(must match number of variables)\n• means extract all results, they will be named as (where goes from 1 to Number of results)\n• : means extract the Xth result. If this Xth is greater than number of matches, then nothing is returned. Default value will be used The numbers have to be given as a Semicolon separated list. The number of elements in that list have to match the number of given JSON Path Expressions. If left empty, the value will be used as default for every expression. For each JSON Path Expression, if the JSON Path query leads to many results, you can choose which one(s) to extract as Variables:The numbers have to be given as a Semicolon separated list. The number of elements in that list have to match the number of given JSON Path Expressions. If left empty, the valuewill be used as default for every expression. If many results are found, plugin will concatenate them using ‘ ’ separator and store it in a var named Allows the user to extract values from a server response using left and right boundaries. As a post-processor, this element will execute after each Sample request in its scope, testing the boundaries, extracting the requested values, generate the template string, and store the result into the given variable name. Descriptive name for this element that is shown in the tree.\n• - only applies to the main sample\n• - only applies to the sub-samples\n• JMeter Variable Name to use - assertion is to be applied to the contents of the named variable Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match test, (i.e. 4 matches in total). For match number = , Sub-samples only, the extractor will match the 3rd sub-sample. For match number = , Main sample and sub-samples, the extractor will match the 2nd sub-sample (1st match is main sample). For match number = or negative, all qualifying samples will be processed. For match number > , matching will stop as soon as enough matches have been found. This is for use with samplers that can generate sub-samples, e.g. HTTP Sampler with embedded resources, Mail Reader or samples generated by the Transaction Controller.Matching is applied to all qualifying samples in turn. For example if there is a main sample and 3 sub-samples, each of which contains a single match test, (i.e. 4 matches in total). For match number =, Sub-samples only, the extractor will match the 3sub-sample. For match number =, Main sample and sub-samples, the extractor will match the 2sub-sample (1match is main sample). For match number =or negative, all qualifying samples will be processed. For match number >, matching will stop as soon as enough matches have been found.\n• - the body of the response, e.g. the content of a web-page (excluding headers)\n• - the body of the response, with all Html escape codes replaced. Note that Html escapes are processed without regard to context, so some incorrect substitutions may be made. Note that this option highly impacts performances, so use it only when absolutely necessary and be aware of its impacts\n• - the extract text from various type of documents via Apache Tika (see View Results Tree Document view section). Note that the Body as a Document option can impact performances, so ensure it is OK for your test\n• - may not be present for non-HTTP samples\n• - may not be present for non-HTTP samples Headers can be useful for HTTP samples; it may not be present for other sample types. The following fields can be checked:Headers can be useful for HTTP samples; it may not be present for other sample types. The name of the JMeter variable in which to store the result. Also note that each group is stored as , where is the string you entered as the reference name, and is the group number, where group is the entire match, group is the match from the first set of parentheses, etc. Left boundary of value to find Right boundary of value to find\n• Use a value of zero to indicate JMeter should choose a match at random.\n• Negative numbers are used in conjunction with the ForEach Controller - see below. Indicates which match to use. The boundaries may match multiple times. If the boundaries do not match, then the reference variable will be set to the default value. This is particularly useful for debugging tests. If no default is provided, then it is difficult to tell whether the boundaries did not match, or maybe the wrong variable is being used. However, if you have several test elements that set the same variable, you may wish to leave the variable unchanged if the expression does not match. In this case, remove the default value once debugging is complete. If the match number is set to a non-negative number, and a match occurs, the variables are set as follows:\n• - the value of the extraction If no match occurs, then the refName variable is set to the default (unless this is absent). If the match number is set to a negative number, then all the possible matches in the sampler data are processed. The variables are set as follows:\n• - the number of matches found; could be\n• , where = , , etc. - the strings as generated by the template\n• , where = , , - the groups for match\n• - always set to the default value Note that the refName variable is always set to the default value in this case, and the associated group variables are not set. If both left and right boundary are null, the whole data selected in scope is returned\n\nThe Test Plan is where the overall settings for a test are specified. Static variables can be defined for values that are repeated throughout a test, such as server names. For example the variable SERVER could be defined as www.example.com, and the rest of the test plan could refer to it as ${SERVER}. This simplifies changing the name later. If the same variable name is reused on one of more User Defined Variables Configuration elements, the value is set to the last definition in the test plan (reading from top to bottom). Such variables should be used for items that may change between test runs, but which remain the same during a test run. Note that the Test Plan cannot refer to variables it defines. If you need to construct other variables from the Test Plan variables, use a If you need to construct other variables from the Test Plan variables, use a User Defined Variables test element. Selecting Functional Testing instructs JMeter to save the additional sample information - Response Data and Sampler Data - to all result files. This increases the resources needed to run a test, and may adversely impact JMeter performance. If more data is required for a particular sampler only, then add a Listener to it, and configure the fields as required. The option does not affect CSV result files, which cannot currently store such information. Also, an option exists here to instruct JMeter to run the Thread Group serially rather than in parallel. Run tearDown Thread Groups after shutdown of main threads: if selected, the tearDown groups (if any) will be run after graceful shutdown of the main threads. The tearDown threads won't be run if the test is forcibly stopped. Test plan now provides an easy way to add classpath setting to a specific test plan. The feature is additive, meaning that you can add jar files or directories, but removing an entry requires restarting JMeter. Note that this cannot be used to add JMeter GUI plugins, because they are processed earlier. However it can be useful for utility jars such as JDBC drivers. The jars are only added to the search path for the JMeter loader, not for the system class loader. However it can be useful for utility jars such as JDBC drivers. The jars are only added to the search path for the JMeter loader, not for the system class loader. JMeter properties also provides an entry for loading additional classpaths. In jmeter.properties, edit \"user.classpath\" or \"plugin_dependency_paths\" to include additional libraries. See JMeter's Classpath and Configuring JMeter for details. This thread group is experimental, and it might change in the future releases. Please provide your feedback on what works and what could be improved. Open Model Thread Group defines a pool of users that will execute a particular test case against the server. The users are generated according to the schedule. The load profile consists of a sequence of constant, increasing or decreasing load. The basic configuration is rate(1/sec) random_arrivals(2 min) rate(3/sec) which means the load will increase linearly from one request per second to three requests per second during a period of two-minutes. If you omit rate at the end, then it will be set to the same value as that from the start. For example, rate(1/sec) random_arrivals(2 min) is exactly the same as rate(1/sec) random_arrivals(2 min) rate(1/sec). That is why rate(1/sec) random_arrivals(2 min) random_arrivals(3 min) rate(4/sec) is exactly the same as rate(1/sec) random_arrivals(2 min) rate(1/sec) random_arrivals(3 min) rate(4/sec), so the load is one request per second during the first two minutes, after which it increases linearly from one request per second to four requests per second during three minutes. Here are examples for using the schedule: constant load rate of ten requests per second during one minute linearly increase the load from zero requests per second to ten requests per second during one minute linearly increase the load from zero requests per second to ten requests per second during one minute, then hold the load during one minute, then linearly decrease the load from ten requests per second to zero during one minute linearly increase the load from zero requests per second to ten requests per second during one minute, then hold the load during one minute, then linearly decrease the load from ten requests per second to zero requests per second during one minute run with constant load of ten requests per second during one minute, then make two second pause, then resume the load of ten requests per second for one minute The following commands are available: configures target load rate. The following time units are supported: , , , , . You can omit time unit in case the rate is 0: configures random arrivals schedule with the given duration. The starting load rate is configured before , and the finish load rate is configured after . For example, 10 minute test from five requests per second at the beginning to fifteen request per second at the end could be configured as . \n\n The implicit rate at the beginning of the test is . If the finish rate is not provided (or if several steps go one after another), then the load is constant. For instance, configures constant rate of three requests per second for the first minute, and then the load increases from three requests per second to six requests per second during the next two minutes. The time units are the same as in . configures even arrivals (TODO: not implemented yet). For instance, if the desired load is one request per second, then would lauch samples with exactly one second intervals. configures a pause for the given duration. The rate is restored after the pause, so generates random arrivals with two requests per second rate, then a pause for five seconds (no new arrivals), then five more seconds with two requests per second rate. \n\n Note: duration is always honoured, even if all the scenarios are complete, and no new ones will be scheduled. For instance, if you use , the thread group would always last for sixty-one minutes no matter how much time do individual scenarios take. can be used to clarify the schedule or temporary disable some steps. Comments cannot be nested. can be used to clarify the schedule or temporary disable some steps. Line comment lasts till the end of the line. The thread groups terminates threads as soon as the schedule ends. In other words, the threads are interrupted after all arrivals and pause intervals. If you want to let the threads complete safely, consider adding pause(5 min) at the end of the schedule. That will add five minutes for the threads to continue. There are no special functions for generating the load profile in a loop, however, the default JMeter templating functions can be helpful for generating the schedule. For example, the following pattern would generate a sequence of 10 steps where each step lasts 10 seconds: 10/sec, 20/sec, 30/sec, ... ${__groovy((1..10).collect { \"rate(\" + it*10 + \"/sec) random_arrivals(10 sec) pause(1 sec)\" }.join(\" \"))} You can get variables from properties as follows: rate(${__P(beginRate,40)}) random_arrivals(${__P(testDuration, 10)} sec) rate(${__P(endRate,40)}) Currently, the load profile is evaluated at the beginning of the test only, so if you use dynamic functions, then only the first result will be used. Descriptive name for this thread group that is shown in the tree The expression that configures schedule. For example: Note: different thread groups should better have different seed values. Constant seed ensures thread group generates the same delays each test start. The value of \"0\" means the schedule is truly random (non-repeatable from one execution to another).. A Thread Group defines a pool of users that will execute a particular test case against your server. In the Thread Group GUI, you can control the number of users simulated (number of threads), the ramp up time (how long it takes to start all the threads), the number of times to perform the test, and optionally, a start and stop time for the test. See also tearDown Thread Group and setUp Thread Group. When using the scheduler, JMeter runs the thread group until either the number of loops is reached or the duration/end-time is reached - whichever occurs first. Note that the condition is only checked between samples; when the end condition is reached, that thread will stop. JMeter does not interrupt samplers which are waiting for a response, so the end time may be delayed arbitrarily. Since JMeter 3.0, you can run a selection of Thread Group by selecting them and right clicking. A popup menu will appear: \n\n Notice you have three options to run the selection of Thread Groups: Start the selected thread groups only but without running the timers Start the selected thread groups only using validation mode. Per default this runs the Thread Group in validation mode (see below) Validation Mode: \n\n This mode enables rapid validation of a Thread Group by running it with one thread, one iteration, no timers and no set to . Behaviour can be modified with some properties by setting in : Number of threads to use to validate a Thread Group, by default Ignore timers when validating the thread group of plan, by default Number of iterations to use to validate a Thread Group Whether to force Throughput Controller in percentage mode to run as if percentage was 100 %. Defaults to Descriptive name for this element that is shown in the tree. Action to be taken after a Sampler error\n• - ignore the error and continue with the test\n• - ignore the error, start next loop and continue with the test\n• - the entire test is stopped at the end of any current samples.\n• - the entire test is stopped abruptly. Any current samplers are interrupted if possible. Determines what happens if a sampler error occurs, either because the sample itself failed or an assertion failed. The possible choices are: The first thread will always start directly, so if you configured one thread, the ramp-up time is effectively zero. For the same reason, the tenth thread in the above example will actually be started after 90 seconds and not 100 seconds. How long JMeter should take to get all the threads started. If there are 10 threads and a ramp-up time of 100 seconds, then each thread will begin 10 seconds after the previous thread started, for a total time of 100 seconds to get the test fully up to speed. Same user on each iteration \n\n If not selected, cookie and cache data from the first sampler response are not used in subsequent requests. If not selected, a new connection will be opened between iterations which will result in increased response times and consume more resources (memory and cpu). If selected, cookie and cache data from the first sampler response are used in subsequent requests (requires a global Cookie and Cache Manager respectively).If not selected, cookie and cache data from the first sampler response are not used in subsequent requests. Number of times to perform the test case. Alternatively, \" \" can be selected causing the test to run until manually stopped or end of the thread lifetime is reached. Yes, unless Infinite is selected Same user on each iteration \n\n If not selected, cookie and cache data from the first sampler response are not used in subsequent requests. If not selected, a new connection will be opened between iterations which will result in increased response times and consume more resources (memory and cpu). If selected, cookie and cache data from the first sampler response are used in subsequent requests (requires a global Cookie and Cache Manager respectively).If not selected, cookie and cache data from the first sampler response are not used in subsequent requests. If selected, threads are created only when the appropriate proportion of the ramp-up time has elapsed. This is most appropriate for tests with a ramp-up time that is significantly longer than the time to execute a single thread. I.e. where earlier threads finish before later ones start. \n\n If not selected, all threads are created when the test starts (they then pause for the appropriate proportion of the ramp-up time). This is the original default, and is appropriate for tests where threads are active throughout most of the test. If selected, confines Thread operation time to the given bounds If the scheduler checkbox is selected, one can choose a relative end time. JMeter will use this to calculate the End Time. If the scheduler checkbox is selected, one can choose a relative startup delay. JMeter will use this to calculate the Start Time. This mode enables rapid validation of a Thread Group by running it with one thread, one iteration, no timers and noset to. Behaviour can be modified with some properties by setting in The SSL Manager is a way to select a client certificate so that you can test applications that use Public Key Infrastructure (PKI). It is only needed if you have not set up the appropriate System properties. If you want to test client certificate authentication, see Keystore Configuration Choosing a Client Certificate You may either use a Java Key Store (JKS) format key store, or a Public Key Certificate Standard #12 (PKCS12) file for your client certificates. There is a feature of the JSSE libraries that require you to have at least a six character password on your key (at least for the keytool utility that comes with your JDK). To select the client certificate, choose Options → SSL Manager from the menu bar. You will be presented with a file finder that looks for PKCS12 files by default. Your PKCS12 file must have the extension '.p12' for SSL Manager to recognize it as a PKCS12 file. Any other file will be treated like an average JKS key store. If JSSE is correctly installed, you will be prompted for the password. The text box does not hide the characters you type at this point -- so make sure no one is looking over your shoulder. The current implementation assumes that the password for the keystore is also the password for the private key of the client you want to authenticate as. Or you can set the appropriate System properties - see the system.properties file. The next time you run your test, the SSL Manager will examine your key store to see if it has at least one key available to it. If there is only one key, SSL Manager will select it for you. If there is more than one key, it currently selects the first key. There is currently no way to select other entries in the keystore, so the desired key must be the first. Things to Look Out For You must have your Certificate Authority (CA) certificate installed properly if it is not signed by one of the five CA certificates that ships with your JDK. One method to install it is to import your CA certificate into a JKS file, and name the JKS file \"jssecacerts\". Place the file in your JRE's lib/security folder. This file will be read before the \"cacerts\" file in the same directory. Keep in mind that as long as the \"jssecacerts\" file exists, the certificates installed in \"cacerts\" will not be used. This may cause problems for you. If you don't mind importing your CA certificate into the \"cacerts\" file, then you can authenticate against all of the CA certificates installed. The HTTP(S) Test Script Recorder allows JMeter to intercept and record your actions while you browse your web application with your normal browser. JMeter will create test sample objects and store them directly into your test plan as you go (so you can view samples interactively while you make them). \n\n Ensure you read this wiki page to setup correctly JMeter. To use the recorder, add the HTTP(S) Test Script Recorder element. Right-click on the Test Plan element to get the Add menu: (Add → Non-Test Elements → HTTP(S) Test Script Recorder ). The recorder is implemented as an HTTP(S) proxy server. You need to set up your browser use the proxy for all HTTP and HTTPS requests. Do not use JMeter as the proxy for any other request types - FTP, etc. - as JMeter cannot handle them. Ideally use private browsing mode when recording the session. This should ensure that the browser starts with no stored cookies, and prevents certain changes from being saved. For example, Firefox does not allow certificate overrides to be saved permanently. HTTPS connections use certificates to authenticate the connection between the browser and the web server. When connecting via HTTPS, the server presents the certificate to the browser. To authenticate the certificate, the browser checks that the server certificate is signed by a Certificate Authority (CA) that is linked to one of its in-built root CAs. Browsers also check that the certificate is for the correct host or domain, and that it is valid and not expired. If any of the browser checks fail, it will prompt the user who can then decide whether to allow the connection to proceed. If any of the browser checks fail, it will prompt the user who can then decide whether to allow the connection to proceed. JMeter needs to use its own certificate to enable it to intercept the HTTPS connection from the browser. Effectively JMeter has to pretend to be the target server. JMeter will generate its own certificate(s). These are generated with a validity period defined by the property proxy.cert.validity, default 7 days, and random passwords. If JMeter detects that it is running under Java 8 or later, it will generate certificates for each target server as necessary (dynamic mode) unless the following property is defined: proxy.cert.dynamic_keys=false. When using dynamic mode, the certificate will be for the correct host name, and will be signed by a JMeter-generated CA certificate. By default, this CA certificate won't be trusted by the browser, however it can be installed as a trusted certificate. Once this is done, the generated server certificates will be accepted by the browser. This has the advantage that even embedded HTTPS resources can be intercepted, and there is no need to override the browser checks for each new server. Browsers don't prompt for embedded resources. So with earlier versions, embedded resources would only be downloaded for servers that were already 'known' to the browser Unless a keystore is provided (and you define the property proxy.cert.alias), JMeter needs to use the keytool application to create the keystore entries. JMeter includes code to check that keytool is available by looking in various standard places. If JMeter is unable to find the keytool application, it will report an error. If necessary, the system property keytool.directory can be used to tell JMeter where to find keytool. This should be defined in the file system.properties. The JMeter certificates are generated (if necessary) when the Start button is pressed. Certificate generation can take some while, during which time the GUI will be unresponsive. The cursor is changed to an hour-glass whilst this is happening. When certificate generation is complete, the GUI will display a pop-up dialogue containing the details of the certificate for the root CA. This certificate needs to be installed by the browser in order for it to accept the host certificates generated by JMeter; see The cursor is changed to an hour-glass whilst this is happening. When certificate generation is complete, the GUI will display a pop-up dialogue containing the details of the certificate for the root CA. This certificate needs to be installed by the browser in order for it to accept the host certificates generated by JMeter; see below for details. If necessary, you can force JMeter to regenerate the keystore (and the exported certificates - ApacheJMeterTemporaryRootCA[.usr|.crt]) by deleting the keystore file proxyserver.jks from the JMeter directory. This certificate is not one of the certificates that browsers normally trust, and will not be for the correct host. \n\n As a consequence:\n• The browser should display a dialogue asking if you want to accept the certificate or not. For example: 1) The server's name \" \" does not match the certificate's name \" _ JMeter Root CA for recording (INSTALL ONLY IF IT S YOURS) \". Somebody may be trying to eavesdrop on you. 2) The certificate for \" _ JMeter Root CA for recording (INSTALL ONLY IF IT S YOURS) \" is signed by the unknown Certificate Authority \" _ JMeter Root CA for recording (INSTALL ONLY IF IT S YOURS) \". It is not possible to verify that this is a valid certificate. You will need to accept the certificate in order to allow the JMeter Proxy to intercept the SSL traffic in order to record it. However, do not accept this certificate permanently; it should only be accepted temporarily. Browsers only prompt this dialogue for the certificate of the main URL, not for the resources loaded in the page, such as images, CSS or JavaScript files hosted on a secured external CDN. If you have such resources (gmail has for example), you'll have to first browse manually to these other domains in order to accept JMeter's certificate for them. Check in for secure domains that you need to register certificate for.\n• If the browser has already registered a validated certificate for this domain, the browser will detect JMeter as a security breach and will refuse to load the page. If so, you have to remove the trusted certificate from your browser's keystore. Versions of JMeter from 2.10 onwards still support this method, and will continue to do so if you define the following property: proxy.cert.alias The following properties can be used to change the certificate that is used:\n• - the directory in which to find the certificate (default = JMeter )\n• - name of the keystore file (default \" \")\n• - keystore password (default \" \") [Ignored if using JMeter certificate]\n• - certificate key password (default \" \") [Ignored if using JMeter certificate]\n• - the certificate type (default \" \") [Ignored if using JMeter certificate]\n• - the factory (default \" \") [Ignored if using JMeter certificate]\n• - the alias for the key to be used. If this is defined, JMeter does not attempt to generate its own certificate(s).\n• - the protocol to be used (default \" \") and . This setting will also be needed when running the generated test plan. If your browser currently uses a proxy (e.g. a company intranet may route all external requests via a proxy), then you need to tell JMeter to use that proxy before starting JMeter, using the command-line options and. This setting will also be needed when running the generated test plan. As mentioned above, when run under Java 8, JMeter can generate certificates for each server. For this to work smoothly, the root CA signing certificate used by JMeter needs to be trusted by the browser. The first time that the recorder is started, it will generate the certificates if necessary. The root CA certificate is exported into a file with the name ApacheJMeterTemporaryRootCA in the current launch directory. When the certificates have been set up, JMeter will show a dialog with the current certificate details. At this point, the certificate can be imported into the browser, as per the instructions below. Note that once the root CA certificate has been installed as a trusted CA, the browser will trust any certificates signed by it. Until such time as the certificate expires or the certificate is removed from the browser, it will not warn the user that the certificate is being relied upon. So anyone that can get hold of the keystore and password can use the certificate to generate certificates which will be accepted by any browsers that trust the JMeter root CA certificate. For this reason, the password for the keystore and private keys are randomly generated and a short validity period used. The passwords are stored in the local preferences area. Please ensure that only trusted users have access to the host with the keystore. Just click ok and proceed further. The popup that displays once you start the Recorder is an informational popup:Just click ok and proceed further.\n• Browse to the JMeter launch directory, and click on the file , press\n• Click and check that the certificate details agree with the ones displayed by the JMeter Test Script Recorder\n• If OK, select \" \", and press\n• Close dialogs by pressing as necessary Installing the certificate in Chrome or Internet Explorer Both Chrome and Internet Explorer use the same trust store for certificates.\n• Browse to the JMeter launch directory, and click on the file , and open it\n• Click on the \" \" tab and check that the certificate details agree with the ones displayed by the JMeter Test Script Recorder\n• If OK, go back to the \" \" tab, and click on \" \" and follow the Wizard prompts\n• Browse to the JMeter launch directory, and click on the file , and open it Descriptive name for this element that is shown in the tree. The port that the HTTP(S) Test Script Recorder listens to. is the default, but you can change it. List of domain (or host) names for HTTPS. Use this to pre-generate certificates for all servers you wish to record. \n\n For example, \n\n Note that wildcard domains only apply to one level, i.e. matches but not The controller where the proxy will store the generated samples. By default, it will look for a Recording Controller and store them there wherever it is.\n• - store all recorded samplers sequentially, without any grouping.\n• - add a controller named \" \" to create a visual separation between the groups. Otherwise the samplers are all stored sequentially.\n• Put each group in a new controller - create a new Simple Controller for each group, and store all samplers for that group in it.\n• Store 1st sampler of each group only - only the first request in each group will be recorded. The \" \" and \" \" flags will be turned on in those samplers.\n• Put each group in a new transaction controller - create a new Transaction Controller for each group, and store all samplers for that group in it. The property determines the minimum gap that JMeter needs between requests to treat them as separate \"clicks\". The default is (milliseconds) i.e. 5 seconds. If you are using grouping, please ensure that you leave the required gap between clicks. Whether to group samplers for requests from a single \"click\" (requests received without significant time separation), and how to represent that grouping in the recording:The propertydetermines the minimum gap that JMeter needs between requests to treat them as separate \"clicks\". The default is(milliseconds) i.e. 5 seconds. If you are using grouping, please ensure that you leave the required gap between clicks. Should headers be added to the plan? If specified, a Header Manager will be added to each HTTP Sampler. The Proxy server always removes Cookie and Authorization headers from the generated Header Managers. By default it also removes and headers. These are used to determine if the browser cache items are up to date; when recording one normally wants to download all the content. To change which additional headers are removed, define the JMeter property as a comma-separated list of headers. Use Regex Matching when replacing variables? If checked replacement will use word boundaries, i.e. it will only replace word matching values of variable, not part of a word. A word boundary follows Perl5 definition and is equivalent to . More information below in the paragraph about \" \". Add a prefix to sampler name during recording (Prefix mode). Or replace sampler name by user chosen name (Transaction name) Select the naming scheme for sampler names during recording. Default is If is selected as naming scheme, a freestyle format can be given. Placeholders for the transaction name, scheme, host, port, path and counter can be given by , , , , , and . A simple format could be \" \", which would be equivalent to the numbered default naming scheme. For more complex formatting Java formatting for MessageFormat can be used, as in \" \", which would print the counter filled with up to three zeroes. Note that scheme is called in the sampler GUI and host is called . Default is an empty string. Can be used to reset the counter to a given value. Note, that the next sample will first increment and then use the value. If the first sampler should start with , reset the counter to . Inactivity time between two requests needed to consider them in two separate groups. Which type of sampler to generate (the HTTPClient default or Java) \n\n Note: see \"Recording and redirects\" section below for important information. Set Use Keep-Alive in the generated samplers? Set Retrieve all Embedded Resources in the generated samplers? - e.g. \" \". The fields are regular expressions which are checked to see if they are contained in the . [Does not have to match the entire field]. The include filter is checked first, then the exclude filter. Samples which are filtered out will not be stored. Note: this filtering is applied to the content type of the response Filter the requests based on the- e.g. \"\". The fields are regular expressions which are checked to see if they are contained in the. [Does not have to match the entire field]. The include filter is checked first, then the exclude filter. Samples which are filtered out will not be stored. / fields are recorded. If both and are left empty, then everything is recorded (which can result in dozens of samples recorded for each page, as images, stylesheets, etc. are recorded). If there is at least one entry in the field, then only requests that match one or more patterns are recorded . Regular expressions that are matched against the full URL that is sampled. Allows filtering of requests that are recorded. All requests pass through, but only those that meet the requirements of thefields are recorded. If bothandare left empty, then everything is recorded (which can result in dozens of samples recorded for each page, as images, stylesheets, etc. are recorded). Any requests that match one or more pattern are not recorded . Regular expressions that are matched against the URL that is sampled. Any response that match one or more pattern is not delivered to Child Listeners (View Results Tree) . Start the proxy server. JMeter writes the following message to the console once the proxy server has started up and is ready to take requests: \" \". Stops and restarts the proxy server. This is useful when you change/add/delete an include/exclude filter expression. During recording, the browser will follow a redirect response and generate an additional request. The Proxy will record both the original request and the redirected request (subject to whatever exclusions are configured). The generated samples have \"Follow Redirects\" selected by default, because that is generally better. Redirects may depend on the original request, so repeating the originally recorded sample may not always work. Now if JMeter is set to follow the redirect during replay, it will issue the original request, and then replay the redirect request that was recorded. To avoid this duplicate replay, JMeter tries to detect when a sample is the result of a previous redirect. If the current response is a redirect, JMeter will save the redirect URL. When the next request is received, it is compared with the saved redirect URL and if there is a match, JMeter will disable the generated sample. It also adds comments to the redirect chain. This assumes that all the requests in a redirect chain will follow each other without any intervening requests. To disable the redirect detection, set the property proxy.redirect.disabling=false The include and exclude patterns are treated as regular expressions (using Jakarta ORO). They will be matched against the host name, port (actual or implied), path and query (if any) of each browser request. If the URL you are browsing is \n\n \"http://localhost/jmeter/index.html?username=xxxx\", \n\n then the regular expression will be tested against the string: \n\n \"localhost:80/jmeter/index.html?username=xxxx\". \n\n Thus, if you want to include all .html files, your regular expression might look like: \n\n \".*\\.html(\\?.*)?\" - or \".*\\.html if you know that there is no query string or you only want html pages without query strings. If there are any include patterns, then the URL must match at least one of the patterns , otherwise it will not be recorded. If there are any exclude patterns, then the URL must not match any of the patterns , otherwise it will not be recorded. Using a combination of includes and excludes, you should be able to record what you are interested in and skip what you are not. N.B. the string that is matched by the regular expression must be the same as the whole host+path string. \n\n Thus \" \" will not match JMeter is able to capture binary POST data. To configure which content-types are treated as binary, update the JMeter property proxy.binary.types. The default settings are as follows: # These content-types will be handled by saving the request in a file: proxy.binary.types=application/x-amf,application/x-java-serialized-object # The files will be saved in this directory: proxy.binary.directory=user.dir # The files will be created with this file filesuffix: proxy.binary.filesuffix=.binary It is also possible to have the proxy add timers to the recorded script. To do this, create a timer directly within the HTTP(S) Test Script Recorder component. The proxy will place a copy of this timer into each sample it records, or into the first sample of each group if you're using grouping. This copy will then be scanned for occurrences of variable ${T} in its properties, and any such occurrences will be replaced by the time gap from the previous sampler recorded (in milliseconds). When you are ready to begin, hit \"start\". You will need to edit the proxy settings of your browser to point at the appropriate server and port, where the server is the machine JMeter is running on, and the port # is from the Proxy Control Panel shown above. Where Do Samples Get Recorded? JMeter places the recorded samples in the Target Controller you choose. If you choose the default option \"Use Recording Controller\", they will be stored in the first Recording Controller found in the test object tree (so be sure to add a Recording Controller before you start recording). If the Proxy does not seem to record any samples, this could be because the browser is not actually using the proxy. To check if this is the case, try stopping the proxy. If the browser still downloads pages, then it was not sending requests via the proxy. Double-check the browser options. If you are trying to record from a server running on the same host, then check that the browser is not set to \"Bypass proxy server for local addresses\" (this example is from IE7, but there will be similar options for other browsers). If JMeter does not record browser URLs such as http://localhost/ or http://127.0.0.1/, try using the non-loopback hostname or IP address, e.g. http://myhost/ or http://192.168.0.2/. If the HTTP(S) Test Script Recorder finds enabled HTTP Request Defaults directly within the controller where samples are being stored, or directly within any of its parent controllers, the recorded samples will have empty fields for the default values you specified. You may further control this behaviour by placing an HTTP Request Defaults element directly within the HTTP(S) Test Script Recorder, whose non-blank values will override those in the other HTTP Request Defaults. See Best Practices with the HTTP(S) Test Script Recorder for more info. Similarly, if the HTTP(S) Test Script Recorder finds User Defined Variables (UDV) directly within the controller where samples are being stored, or directly within any of its parent controllers, the recorded samples will have any occurrences of the values of those variables replaced by the corresponding variable. Again, you can place User Defined Variables directly within the HTTP(S) Test Script Recorder to override the values to be replaced. See Best Practices with the Test Script Recorder for more info. Please note that matching is case-sensitive. Replacement by Variables: by default, the Proxy server looks for all occurrences of UDV values. If you define the variable WEB with the value www, for example, the string www will be replaced by ${WEB} wherever it is found. To avoid this happening everywhere, set the \"Regex Matching\" check-box. This tells the proxy server to treat values as Regexes (using the perl5 compatible regex matchers provided by ORO). If \"Regex Matching\" is selected every variable will be compiled into a perl compatible regex enclosed in \\b( and )\\b. That way each match will start and end at a word boundary. Note that the boundary characters are not part of the matching group, e.g. to match out of . If you don't want your regex to be enclosed with those boundary matchers, you have to enclose your regex within parens, e.g ('.*?') to match 'name' out of You can call me 'name'. The variables will be checked in random order. So ensure, that the potential matches don't overlap. Overlapping matchers would be (which matches anything) and (which matches only). Non-overlapping matchers would be (matches a sequence of 's) and (matches a sequence of 's). If you want to match a whole string only, enclose it in (^ and $), e.g. (^thus$). The parens are necessary, since the normally added boundary characters will prevent ^ and $ to match. If you want to match /images at the start of a string only, use the value (^/images). Jakarta ORO also supports zero-width look-ahead, so one can match /images/… but retain the trailing / in the output by using (^/images(?=/)). Note that the current version of Jakarta ORO does not support look-behind - i.e. or . Look out for overlapping matchers. For example the value .* as a regex in a variable named regex will partly match a previous replaced variable, which will result in something like ${{regex}, which is most probably not the desired result. If there are any problems interpreting any variables as patterns, these are reported in jmeter.log, so be sure to check this if UDVs are not working as expected. When you are done recording your test samples, stop the proxy server (hit the \"stop\" button). Remember to reset your browser's proxy settings. Now, you may want to sort and re-order the test script, add timers, listeners, a cookie manager, etc. How can I record the server's responses too? Just place a View Results Tree listener as a child of the HTTP(S) Test Script Recorder and the responses will be displayed. You can also add a Save Responses to a file Post-Processor which will save the responses to files. If you define the property proxy.number.requests=true JMeter will add a number to each sampler and each response. Note that there may be more responses than samplers if excludes or includes have been used. Responses that have been excluded will have labels enclosed in [ and ], for example [23 /favicon.ico] If the server you are testing against uses cookies, remember to add an HTTP Cookie Manager to the test plan when you have finished recording it. During recording, the browser handles any cookies, but JMeter needs a Cookie Manager to do the cookie handling during a test run. The JMeter Proxy server passes on all cookies sent by the browser during recording, but does not save them to the test plan because they are likely to change between runs. The HTTP(S) Test Script Recorder grabs \"Authentication\" header, tries to compute the Auth Policy. If Authorization Manager was added to target controller manually, HTTP(S) Test Script Recorder will find it and add authorization (matching ones will be removed). Otherwise Authorization Manager will be added to target controller with authorization object. You may have to fix automatically computed values after recording. Some browsers (e.g. Firefox and Opera) don't include the full name of a file when uploading files. This can cause the JMeter proxy server to fail. One solution is to ensure that any files to be uploaded are in the JMeter working directory, either by copying the files there or by starting JMeter in the directory containing the files. Recording HTTP Based Non Textual Protocols not natively available in JMeter You may have to record an HTTP protocol that is not handled by default by JMeter (Custom Binary Protocol, Adobe Flex, Microsoft Silverlight, … ). Although JMeter does not provide a native proxy implementation to record these protocols, you have the ability to record these protocols by implementing a custom SamplerCreator. This Sampler Creator will translate the binary format into a HTTPSamplerBase subclass that can be added to the JMeter Test Case. For more details see \"Extending JMeter\". The HTTP Mirror Server is a very simple HTTP server - it simply mirrors the data sent to it. This is useful for checking the content of HTTP requests. Port on which Mirror server listens, defaults to . If set to a value > , number of threads serving requests will be limited to the configured number, if set to a value ≤ a new thread will be created to serve each incoming request. Defaults to Size of queue used for holding tasks before they are executed by Thread Pool, when Thread pool is exceeded, incoming requests will be held in this queue and discarded when this queue is full. This parameter is only used if Max Number of Threads is greater than . Defaults to Note that you can get more control over the responses by adding an HTTP Header Manager with the following name/value pairs: Time to sleep in ms before sending response Cookies to be set on response Response status, see HTTP Status responses , example 200 OK, 500 Internal Server Error, …. Size of response, this trims the response to the requested size if that is less than the total size Pipe separated list of headers, example: \n\n would set to and to . You can also use the following query parameters: Verbose flag, writes some details to standard output, e.g. first line and redirect location if specified The Property Display shows the values of System or JMeter properties. Values can be changed by entering new text in the Value column. Descriptive name for this element that is shown in the tree. The Debug Sampler generates a sample containing the values of all JMeter variables and/or properties. The values can be seen in the View Results Tree Listener Response Data pane. Descriptive name for this element that is shown in the tree. The Debug PostProcessor creates a subSample with the details of the previous Sampler properties, JMeter variables, properties and/or System Properties. The values can be seen in the View Results Tree Listener Response Data pane. Descriptive name for this element that is shown in the tree. The Test Fragment is used in conjunction with the Include Controller and Module Controller. Descriptive name for this element that is shown in the tree. When using Test Fragment with Module Controller , ensure you disable the Test Fragment to avoid the execution of Test Fragment itself. This is done by default since JMeter 2.13. A special type of ThreadGroup that can be utilized to perform Pre-Test Actions. The behavior of these threads is exactly like a normal Thread Group element. The difference is that these type of threads execute before the test proceeds to the executing of regular Thread Groups. A special type of ThreadGroup that can be utilized to perform Post-Test Actions. The behavior of these threads is exactly like a normal Thread Group element. The difference is that these type of threads execute after the test has finished executing its regular Thread Groups. Note that by default it won't run if Test is gracefully shutdown, if you want to make it run in this case, ensure you check option \" \" on Test Plan element. If Test Plan is stopped, tearDown will not run even if option is checked. ^"
    },
    {
        "link": "https://jmeter.apache.org/usermanual/jmeter_tutorial.html",
        "document": "29. How to write a plugin for JMeter¶\n\nOn more than one occasion, users have complained JMeter's developer documentation is out of date and not very useful. In an effort to make it easier for developers, I decided to write a simple step-by-step tutorial. When I mentioned this to mike, he had some ideas about what the tutorial should cover.\n\nBefore we dive into the tutorial, I'd like to say writing a plugin isn't necessarily easy, even for someone with several years of java experience. The first extension I wrote for JMeter was a simple utility to parse HTTP access logs and produce requests in XML format. It wasn't really a plugin, since it was a stand alone command line utility. My first real plugin for JMeter was the webservice sampler. I was working on a .NET project and needed to stress test a webservice. Most of the commercial tools out there for testing .NET webservices suck and cost too much. Rather than fork over several hundred dollars for a lame testing tool, or a couple thousand dollars for a good one, I decided it was easier and cheaper to write a plugin for JMeter.\n\nAfter a two weeks of coding on my free time, I had a working prototype using Apache Soap driver. I submitted it back to JMeter and mike asked me if I want to be a committer. I had contributed patches to Jakarta JSTL and tomcat in the past, so I considered it an honor. Since then, I've written the access log sampler, Tomcat 5 monitor and distribution graph. Mike has since then improved the access log sampler tremendously and made it much more useful.\n\nOne of my primary goals in designing JMeter was to make it easy to write plugins to enhance as many of JMeter's features as possible. Part of the benefit of being open-source is that a lot of people could potentially lend their efforts to improve the application. I made a conscious decision to sacrifice some simplicity in the code to make plugin writing a way of life for a JMeter developer.\n\nWhile some folks have successfully dug straight into the code and made improvements to JMeter, a real tutorial on how to do this has been lacking. I tried a long time ago to write some documentation about it, but most people did not find it useful. Hopefully, with Peter's help, this attempt will be more successful.\n\nJMeter is organized by protocols and functionality. This is done so that developers can build new jars for a single protocol without having to build the entire application. We'll go into the details of building JMeter later in the tutorial. Since most of the JMeter developers use eclipse, the article will use eclipse directory as a reference point. contains the and files for starting JMeter. It also contains and properties file contains the required jar files for JMeter contains the core jar files for JMeter and the protocols contains subdirectory for each protocol and component Directory that contains test-related code that might be reused in other modules XML files for documentation. JMeter generates its documentation from XML. As the tutorial progresses, an explanation of the subdirectories will be provided. For now, lets focus on src directory. contains non-protocol-specific components like visualizers, assertions, etc. the core code of JMeter including all core interfaces and abstract classes. code related to testing the distribution. It is the place to look for when you want to update the contents of the resulting source/binary archive example sampler demonstrating how to use the new bean framework standard functions used by all components code to generate a test plan with all elements. Used for testing the distribution code to help start and stop JMeter through API contains information about the licenses used in JMeters dependencies contains the different protocols JMeter supports Within protocol directory, are the protocol specific components. As a general rule, all samplers related to HTTP will reside in http directory. The exception to the rule is the Tomcat5 monitor. It is separate, because the functionality of the monitor is slightly different than stress or functional testing. It may eventually be reorganized, but for now it is in its own directory. In terms of difficulty, writing visualizers is probably one of the harder plugins to write.\n\nJMeter uses classpath scanning to detect plugins (e.g. functions, components, views). However, classpath scanning is expensive, so JMeter also provides a service lookup mechanism to allow plugins to be found without scanning the classpath. That is if a plugin registers a Java service with META-INF/services, then JMeter won't need to scan the classpath to find it. Some of the existing features already use the new service lookup mechanism, but it is not yet used for all features. The interfaces that are supported for service loading are marked with org.apache.jorphan.reflect.JMeterService annotation. Implementing a service the same as regular interface implementation, except you need to register the service in a META-INF/services/fully.qualified.interface.name. For instance you could use @AutoService to generate the file automatically at the build time. Here's how __counter function is declared in JMeter itself: For backward compatibility reasons, JMeter would still try searching the implementations with classpath scanning, so you don't have to use META-INF/services for registering services. However, service lookup is much faster, so exposing services would improve startup time, especially when there are many plugins. As you add META-INF/services to your plugins, you can add JMeter-Skip-Class-Scanning: true manifest attribute so JMeter knows there's no need to scan the jar as it provides all the plugins via services.\n\nWhen writing any JMeter component, there are certain contracts you must be aware of – ways a JMeter component is expected to behave if it will run properly in the JMeter environment. This section describes the contract that the GUI part of your component must fulfill. GUI code in JMeter is strictly separated from Test Element code. Therefore, when you write a component, there will be a class for the Test Element, and another for the GUI presentation. The GUI presentation class is stateless in the sense that it should never hang onto a reference to the Test Element (there are exceptions to this though). A GUI element should extend the appropriate abstract class provided: These abstract classes provide so much plumbing work for you that not extending them, and instead implementing the interfaces directly is hardly an option. If you have some burning need to not extend these classes, then you can join me in IRC where I can convince you otherwise :-). So, you've extended the appropriate GUI class, what's left to do? Follow these steps:\n• Implement\n• This method should return the name of the resource that represents the title/name of the component. The resource will have to be entered into JMeters file (and possibly translations as well).\n• Override method so it returns the appropriate . JMeter will use when user creates the element from the UI. In most cases it should be just creating the test element like .\n• Create your GUI. Whatever style you like, layout your GUI. Your class ultimately extends , so your layout must be in your class's own . Do not hook up GUI elements to your class via actions and events. Let swing's internal model hang onto all the data as much as you possibly can.\n• Some standard GUI stuff should be added to all JMeter GUI components:\n• Call for your class. This will give it the standard JMeter border\n• Add the title pane via . Usually this is the first thing added to your GUI, and should be done in a Box vertical layout scheme, or with JMeter's class. Here is an example method:\n• Then you need to wire UI elements with the properties of the new . If you create for your test element (see ), then you could use automatic wiring with\n• If you do not use schema for wiring properties to UI control, or if you have non-trivial controls, you might customize properties to UI control mapping by overriding\n• Be sure to call . This will populate some of the data for you, like the name of the element. Note: JMeter reuses UI elements when user changes the active element in test tree, so you need to set all the text fields in method to avoid displaying stale contents.\n• Use this method to set data into your GUI elements. Example:\n• If you do not use schema for wiring UI controls to properties, or if you want customized behavior, you might override . It is the logical reverse of method.\n• Call . This will take care of some default data for you.\n• Note: in most cases, you want to treat \"empty field\" as \"absent property\", so make sure to remove the property if the input field is empty.\n• If your UI includes controls that do not map to properties (sliders, tabs), then you might want to reset them when user switches the controls. You can do that by overriding method and resetting the controls there. The reason you cannot hold onto a reference for your Test Element is because JMeter reuses instance of GUI class objects for multiple Test Elements. This saves a lot of memory. It also makes it incredibly easy to write the GUI part of your new component. You still have to struggle with the layout in Swing, but you don't have to worry about creating the right events and actions for getting the data from the GUI elements into the TestElement where it can do some good. JMeter knows when to call your configure, and modifyTestElement methods where you can do it in a very straightforward way. Writing Visualizers is somewhat of a special case, however.\n\nLoad Testing in GUI mode being a bad practice, you should not develop such plugin. Have a look at more up to date components like: Of the component types, visualizers require greater depth in Swing than something like controllers, functions or samplers. You can find the full source for the distribution graph in components/org/apache/jmeter/visualizers/. The distribution graph visualizer is divided into two classes. The easiest way to write a visualizer is to do the following:\n• Implement any additional interfaces need for call back and event notification. For example, the implements the following interfaces:\n• – according to the comments in the class, is out of date and isn't used anymore. AbstractVisualizer provides some common functionality, which most visualizers like Graph Results use. The common functionality provided by the abstract class includes:\n• Configure test elements – This means it create a new , sets the file and sets the error log\n• Update the test element when changes are made In some cases, you may not want to display the menu for the file textbox. In that case, you can override the init() method. Here is the implementation for DistributionGraphVisualizer. /** * Initialize the GUI. */ private void init() { this.setLayout(new BorderLayout()); // MAIN PANEL Border margin = new EmptyBorder(10, 10, 5, 10); this.setBorder(margin); // Set up the graph with header, footer, Y axis and graph display JPanel graphPanel = new JPanel(new BorderLayout()); graphPanel.add(createGraphPanel(), BorderLayout.CENTER); graphPanel.add(createGraphInfoPanel(), BorderLayout.SOUTH); // Add the main panel and the graph this.add(makeTitlePanel(), BorderLayout.NORTH); this.add(graphPanel, BorderLayout.CENTER); } The first thing the init method does is create a new BorderLayout. Depending on how you want to layout the widgets, you may want to use a different layout manager. Keep mind using different layout managers is for experts. The second thing the init method does is create a border. If you want to increase or decrease the border, change the four integer values. Each integer value represents pixels. If you want your visualizer to have no border, skip lines 8 and 9. Line 13 calls createGraphPanel, which is responsible for configuring and adding the DistributionGraph to the visualizer. At line 5, the graph component is added to the graph panel. The constructor is where a new instance of DistributionGraph is created. The constructor of DistributionGraphVisualizer is responsible for creating the model and the graph. Every time a new result is complete, the engine passes the result to all the listeners by calling add(SampleResult res). The visualizer passes the new SampleResult to the model. In the case of the DistributionGraphVisualizer, the add method doesn't actually update the graph. Instead, it calls updateGui in line three. public synchronized void updateGui(Sample s) { // We have received one more sample if (delay == counter) { updateGui(); counter = 0; } else { counter++; } } Unlike GraphVisualizer, the distribution graph attempts to show how the results clump; therefore the DistributionGraphVisualizer delays the update. The default delay is 10 sampleresults. Lines 2 to 3 are suppose to resize the graph, if the user resizes the window or drags the divider. Line 7 updates the panel containing the graph. Line 8 triggers the update of the DistributionGraph. Before we cover writing graphs, there are a couple of important methods visualizer must implement. The label resource retrieves the name of the visualizer from the properties file. The file is located in core/org/apache/jmeter/resources. It's best not to hardcode the name of the visualizer. Message.properties file is organized alphabetically, so adding a new entry is easy. Every component in JMeter should implement logic for clear() method. If this isn't done, the component will not clear the UI or model when the user tries to clear the last results and run a new test. If clear is not implemented, it can result in a memory leak. The last method visualizers should implement is getPrintableComponent(). The method is responsible for returning the JComponent that can be saved or printed. This feature was recently added so that users can save a screen capture of any given visualizer.\n\nLoad Testing in GUI mode being a bad practice, you should not develop such plugin. Have a look at more up to date components like: Visualizers should implement GraphListener. This is done to make it simpler to add new Sample instances to listeners. As a general rule, if the custom graph does not plot every single sample, it does not need to implement the interface. The important method in the interface is updateGui(Sample s). From DistributionGraphVisualizer, we see it calls graph.repaint() to refresh the graph. In most cases, the implementation of updateGui(Sample s) should do just that. ItemListenerVisualizers generally do not need to implement this interface. The interface is used with combo boxes, checkbox and lists. If your visualizer uses one of these and needs to know when it has been updated, the visualizer will need to implement the interface. For an example of how to implement the interface, please look at GraphVisualizer.\n\nLoad Testing in GUI mode being a bad practice, you should not develop such plugin. Have a look at more up to date components like: For those new to Swing and haven't written custom JComponents yet, I would suggest getting a book on Swing and get a good feel for how Swing widgets work. This tutorial will not attempt to explain basic Swing concepts and assumes the reader is already familiar with the Swing API and MVC (Model View Controller) design pattern. From the constructor of DistributionGraphVisualizer, we see a new instance of DistributionGraph is created with an instance of the model. The implementation of setModel method is straight forward. Notice the method calls repaint after it sets the model. If repaint isn't called, it can cause the GUI to not draw the graph. Once the test starts, the graph would redraw, so calling repaint isn't critical. The other important aspect of updating the widget is placing the call to drawSample within a synchronized block. If drawSample wasn't synchronized, JMeter would throw a ConcurrentModificationException at runtime. Depending on the test plan, there may be a dozen or more threads adding results to the model. The synchronized block does not affect the accuracy of each individual request and time measurement, but it does affect JMeter's ability to generate large loads. As the number of threads in a test plan increases, the likelihood a thread will have to wait until the graph is done redrawing before starting a new request increases. Here is the implementation of drawSample. private void drawSample(SamplingStatCalculator model, Graphics g) { width = getWidth(); double height = (double)getHeight() - 1.0; // first lets draw the grid for (int y=0; y < 4; y++){ int q1 = (int)(height - (height * 0.25 * y)); g.setColor(Color.lightGray); g.drawLine(xborder,q1,width,q1); g.setColor(Color.black); g.drawString(String.valueOf((25 * y) + \"%\"),0,q1); } g.setColor(Color.black); // draw the X axis g.drawLine(xborder,(int)height,width,(int)height); // draw the Y axis g.drawLine(xborder,0,xborder,(int)height); // the test plan has to have more than 200 samples // for it to generate half way decent distribution // graph. The larger the sample, the better the // results. if (model != null && model.getCount() > 50) { // now draw the bar chart Number ninety = model.getPercentPoint(0.90); Number fifty = model.getPercentPoint(0.50); total = model.getCount(); Collection values = model.getDistribution().values(); Object[] objval = new Object[values.size()]; objval = values.toArray(objval); // we sort the objects Arrays.sort(objval,new NumberComparator()); int len = objval.length; for (int count=0; count < len; count++) { // calculate the height Number[] num = (Number[])objval[count]; double iper = (double)num[1].intValue() / (double)total; double iheight = height * iper; // if the height is less than one, we set it // to one pixel if (iheight < 1) { iheight = 1.0; } int ix = (count * 4) + xborder + 5; int dheight = (int)(height - iheight); g.setColor(Color.blue); g.drawLine(ix -1,(int)height,ix -1,dheight); g.drawLine(ix,(int)height,ix,dheight); g.setColor(Color.black); // draw a red line for 90% point if (num[0].longValue() == ninety.longValue()) { g.setColor(Color.red); g.drawLine(ix,(int)height,ix,55); g.drawLine(ix,(int)35,ix,0); g.drawString(\"90%\",ix - 30,20); g.drawString( String.valueOf(num[0].longValue()), ix + 8, 20); } // draw an orange line for 50% point if (num[0].longValue() == fifty.longValue()) { g.setColor(Color.orange); g.drawLine(ix,(int)height,ix,30); g.drawString(\"50%\",ix - 30,50); g.drawString( String.valueOf(num[0].longValue()), ix + 8, 50); } } } } In general, the rendering of the graph should be fairly quick and shouldn't be a bottleneck. As a general rule, it is a good idea to profile custom plugins. The only way to make sure a visualizer isn't a bottleneck is to run it with a tool like Borland OptimizeIt. A good way to test a plugin is to create a simple test plan and run it. The heap and garbage collection behavior should be regular and predictable."
    },
    {
        "link": "https://blazemeter.com/blog/jmeter-plugin-development",
        "document": ""
    },
    {
        "link": "https://jmeter-plugins.org/wiki/PluginsManager",
        "document": "The idea of JMeter Plugins Manager is simple: instead of installing various plugins manually, it will do it for you through nice UI. No need to mess with JARs anymore. Install Plugins Manager once and it will do it all for you: installing, upgrading, uninstalling. The plugins it manages include usual plugins from JMeter-Plugins.org, various third-party plugins and even core JMeter plugins. This is important, because removing rarely used features like JDBC and LDAP will tidy up huge popup menus from unused items. As a bonus you will get the increased JMeter startup time. You can observe the catalogue of plugins here. As the first experiment, try to uninstall all the plugins and see how bare JMeter looks like. Then install something. Then install something more. Have fun! Download the Plugins Manager JAR file and put it into JMeter's directory. Then start JMeter and go to \"Options\" menu to access the Plugins Manager. The label on the menu item will say \"has upgrades\" in case any of your installed plugins have upgrades for it. Clicking on menu item will bring up the plugins manager dialog: The dialog has three tabs, \"Review Changes\" area and \"Apply\" button. Removing ticks from plugins on \"Installed\" tab will uninstall them. Setting ticks on \"Available\" tab will install the plugin. The plugins that have upgrades will show in the list with italic font. Choose the new version you want to install for them from \"Version\" drop-down. By default, all upgradable plugins are selected for upgrade and listed on \"Upgrades\" tab. The \"Review Changes\" pane is important, it lists all the changes that supposed to be done after you click \"Apply\" button. Sometimes plugins have dependencies from each other, so there might be additional plugins uninstalled. There is no hurry for important business, so review the changes prior to applying it. Right mouse click over checkbox lists opens \"Toggle All\" option, which takes some time to toggle all items in the list. If you want to use the Plugins Manager from command-line or programmatically, please read this guide. If you see empty dialog, this means that most likely you have proxy requirement for Internet connection. Please read following instructions If you face some issues where new plugins do not appear, then Plugins Manager might be using an outdated cached information. In this case, you can clear the folder referenced by . Now there is an opportunity for anyone who creates the JMeter plugins to quickly make them available to wide audience of JMeter-Plugins.org. You don't have to contribute your source code into our repository, you can just create your project and maintain it, just using JPGC as distribution infrastructure. If you are interested, please raise the topic on our community forum to get more detailed instructions. If you have need to serve additional internal plugins repository within your organization, you can do so by setting JMeter property, adding URL for your proprietary plugins repository after semicolon like this: First item is default plugins repository, second is \"custom internal\". You can have as many repos as you want, splitting them with semicolon character. Plugins repository JSON has to satisfy requirements for its content. In case of plugins-ID conflict the earliest declared has precedence. By default, Plugins Manager sends some anonymous information to JMeter-Plugins.org, specifically: full version of JMeter used, list of installed plugins with their versions, anonymous unique ID for the installation. No personal identifiable information is sent. We analyze that information to learn more about which plugins deserve more development according to their popularity. Also, we share the statistics derived from usage reports on statistics page. The information is completely anonymous, you can validate that through our source code. You are free to disable these reporting by setting in JMeter properties."
    },
    {
        "link": "https://stackoverflow.com/questions/41020498/jmeter-maven-plugin-libraries-management",
        "document": "I have such plugin configuration in my\n\nAfter I run I get such libsat :\n\nand in log file I see that jmeter fails from time to time with such exception:\n\njmeter.extractor.json.jsonpath.JSONPostProcessor: Error processing JSON content in Select Team Name, message:Could not compile inline filter : [?(@.id==\"29011\")]\n\nNote that this is only a part of expression. Full expression is looks like similar to this:\n\nI expect that this error somehow related to this multiple libs"
    },
    {
        "link": "https://github.com/jmeter-maven-plugin/jmeter-maven-plugin",
        "document": "A Maven plugin that provides the ability to run JMeter tests as part of your build\n\nSee the CHANGELOG for change information.\n\nAll the documentation you need to configure the plugin is available on the Github Wiki.\n\nThe latest version is 3.8.0, it requires Maven >= 3.9.0 and defaults to Apache JMeter 5.6.2.\n\nThis plugin requires a JDK between 8 and 17. If using Java 11, ensure you use a recent version to avoid facing this Bug, also read This.\n\nOnce you have added the plugin to your project you will be able to invoke the JMeter GUI using the following command:\n\nSee the associated Wiki entry for more information.\n\nAdd the plugin to the build section of your pom's project :\n\nOnce you have created your JMeter tests, you'll need to copy them to .\n\n By default this plugin will pick up all the .jmx files in that directory, you can also put data files in this folder and reference them in your plan. To specify which tests should be run, see the Selecting-Tests-To-Run section of the Wiki.\n\nAll your tests will run in maven!\n\nAll the plugin configuration documentation is available on the Github Wiki.\n\nBeginners should start with the Basic Configuration section.\n\nFor advanced POM configuration settings have a look at the Advanced Configuration section.\n• Shift left your performance tests with JMeter and Maven\n\nIf you'd like to help support the maintainers you can donate using the sponsorship button at the top of the page, or you can purchase this book:\n\nHave a look at our list of outstanding issues:\n\nA place to discuss usage of the maven-jmeter-plugin, let people know how you use it here.\n\nA place to discuss the development of the maven-jmeter-plugin, or ask about features you would like to see added.\n\nThe official website is available at https://jmeter.lazerycode.com\n\nWe love it when people Contribute!"
    },
    {
        "link": "https://stackoverflow.com/questions/18361835/jmeter-plugins-when-executing-from-maven",
        "document": "Although this answer is accepted, it only works for versions before 2.X. But for version higher than 2.X, see this answer.\n\nYup, you can add any libraries you require by adding dependencies to the plugin, any explicitly defined dependencies will be copied to your jmeter/lib directory.\n\nIf the dependency is a JMeter plugin you can specify this in your configuration and then that dependency will be copied to your meter/lib/ext directory:\n\nThis functionality was broken before version 1.9.0."
    },
    {
        "link": "https://blazemeter.com/blog/how-use-jmeter-maven-plugin",
        "document": ""
    },
    {
        "link": "https://medium.com/@gabriel.starczewski/running-jmeter-tests-with-maven-and-maven-wrapper-6725aa025bd9",
        "document": "Maven is a well-known JAVA -oriented build and dependency management tool. Today we will look at how we can use Maven/Maven Wrapper and jmeter-maven-plugin to run JMeter performance tests. Maven and jmeter-maven-plugin make it easy to\n• integrate performance tests with CI/CD tools & technologies such as Jenkins/Jenkinsfiles or Azure/Azure pipelines and cloud build agents\n• run your tests with different versions of JMeter\n• ship only the code and depend on the plugins to provide run-time tools Our main motivation for using Maven will beto prepare ourselves to run tests in CI/CD tools and Cloud Providers. I assume that the reader has JMeter 5.x and Git/Git Bash for Windows already installed.\n\nOpen JMeter GUI and create a simple test with one thread group and one parameter for Loop Count: ${__P(loops,1)} Let us use bing.com for HTTP Request and save our plan as jmeter-maven.jmx Next, let us follow official instruction and download latest maven from https://maven.apache.org/download.cgi (at the time of writing that was 3.6.3) and unzip it to somewhere in your home directory e.g. for me it is C:\\Users\\gstarczewski\\tools\\apache-maven-3.6.3 Since you have JMeter that implies you already downloaded JAVA. Therefore the only thing left is to add C:/Users/gabriel/apache-maven-3.6.3/bin to environment variables. Click Start and type Edit environment variables .. and let us add %MAVEN_HOME%\\bin to PATH: Open new powershell window and type mvn -v to ensure all works: Go to GitHub and create a new repository. I called mine jmeter-maven-wrapper. That is where you can find the complete code for this post. Then open a new Git Bash window and execute the GitHub instructions: Create maven project by executing the following maven archetype command in Git Bash: Note: Archetype command creates a maven project according to desired template. For us quickstart is more than enough. ArtifactId and GroupId are commonly known as GAVC (Group and Artifact Virtual Coordinates) and together uniquely identify your maven project in entire maven space. Now we need to add jmeter-maven-plugin to our project. Open jmeter-maven-wrapper/pom.xml file in your text editor (e..g Notepad++) and add below section within<plugins> … </plugins> block. That is how it should look like: Copy our test jmeter-maven.jmx to src/test/jmeter because that is the location where plugin expects to find it. and run the command in bash shell (run it from the same location where pom.xml is) : That is what a successful run looks like: If you want to pass a parameter to your script add the following section to your pom file just below closing execution tag. Maven most important file is pom.xml. It is an XML file that describes your project and defines dependencies and plugins that your code uses. By default Maven expects that you run commands from the folder where pom.xml is.\n• - validate the project is correct and all necessary information is available\n• - compile the source code of the project\n• - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed\n• - take the compiled code and package it in its distributable format, such as a JAR.\n• - run any checks on results of integration tests to ensure quality criteria are met\n• - install the package into the local repository, for use as a dependency in other projects locally\n• - done in the build environment, copies the final package to the remote repository for sharing with other developers and projects. You probably also noticed that our JMeter tests have been run in verify phase. I recommend that you experiment and run all of the above for your project and study contents of pom.xml briefly. When maven phase is run you will notice that a new folder called “target” is created. This folder contains build files such as temporary files and any artifacts produces by your build (you always add this folder to .gitignore file). Command mvn clean wipes out the target directory.\n\nLet us look at some of the commonly used execution patterns. The simplest run of your test is (need to be run from pom.xml file location): If you want to run it from any location you can provide path to pom.xml with -f switch. If you want to start JMeter GUI run this. Note that this is an extra cool feature as it allows to “ship” by means of maven dependencies a JMeter binary with your code. So you can start it at the server or your colleague can fetch the right version of JMeter when doing code review. If you want to change JMeter version run this If you do that you can run into an issue about missing artifacts. If you do not want to deal with it you you can follow my tip below. Note: as pointed out by Mark Collin the issue you could be seeing with missing artifacts is due to different versions of JMeter having different dependencies. As well as changing the version number you may also need to change the default JMeter dependency list, see https://github.com/jmeter-maven-plugin/jmeter-maven-plugin/wiki/Specifying-JMeter-Version. The bullet-proof way of changing the version is to scale down the plugin version as each comes with a default jmeter version. For instance I could force plugin version to be 2.8.6 to get default JMeter 5.1. Obviously that comes at the cost of missing some bug fixes and features available in the latest version . Use it if the proper way does not work. I hope someone will fix the repositories in the meantime.\n\nSometimes we want to provide parameters to our script as properties file. The easiest way to do it is to create user.properties file in src/test/jmeter with e.g.: If you want to pass parameters to your project from command line you can do that with -D switch. Any parameter you add this way is available in your pom.xml file as ${variable_name} so in our case ${loops}. To translate maven variables into JMeter properties we need to add one extra configuration block below </executions> closing tag. You can observe that number of request changed accordingly. Remember, that command-line parameter overwrite properties files. It is a good idea to define most common values for all your properties in user.properties file and only overwrite them from command-line when necessary.\n\nVery often in real life we test against multiple environments, for instance test, dev or prod. It is convinient to manage configurations for environments in user.properties. Why? After the test is done you could store both results and configuration in one place e.g. Artifactory or Azure Artifacts. This way you keep code in repository and store run results and configuration in a place designed for it. When you browse through it later you do not need to guess the config anymore. In order to run our tests per env with separate user.properties like this a) We need to add default value for env Maven variable b) Configure jmeter plugin to use it to construct the path for environment-specific user.properties file c) Provide files in specified location. In our case Now you can manage your environmanet configurations: That is how the complete pom.xml You can find all the files we used in my github repository. That concludes most commonly used maven run configurations. Add to our repository maven wrapper and use that instead Maven wrapper allows the user/client executing your tests (be it human or a machine) not to have Maven. Thanks to the wrapper it will be downloaded on demand. That limits the clients requirements to JAVA only. You install the wrapper with the following command: When you do you will notice that a new .mvn folder appeared in your project The plugin has just installed maven wrapper in your project. You can now run all your commands with mvnw (Maven Wrapper) script. Maven wrapper will fetch maven for you so you no longer need it on your PC. That is extremely helpful because it allows your code reviewers to run your tests without need to install maven globally on the system. Another great advantage of it is that you do not need to expect your CI/CD systems such as Jenkins/TeamCity or Azure build agents to have Maven in the desired version. That simplifies your infrastructure configuration. JAVA is all you really need and Maven will be downloaded by the wrapper. If you want to use another version of Maven than the default you can either initialize it with the rigth one at the start: Or change it by editing distribution.url in .mvn/wrapper/maven-wrapper.properties e.g. to version 3.6.2 Use that command to confirm the current version used by the wrapper: That is all. Thanks to Maven, Maven Wrapper and jmeter-maven-plugin you ship your performance tests code with ability for other users and CI/CD systems to execute your code without need to install anything else than JAVA. JMeter and Maven will be downloaded for you. JMeter plugin also provides GUI access so you can edit your tests with the version of JMeter it requires. That is only the beginning and in the next posts I will show you how to use this knowledge to execute tests with Azure pipelines in normal and distributed modes."
    }
]