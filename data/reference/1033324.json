[
    {
        "link": "https://vuejs.org/api/sfc-script-setup",
        "document": "is a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal syntax:\n• More succinct code with less boilerplate\n• Ability to declare props and emitted events using pure TypeScript\n• Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n• Better IDE type-inference performance (less work for the language server to extract types from code)\n\nTo opt-in to the syntax, add the attribute to the block:\n\nThe code inside is compiled as the content of the component's function. This means that unlike normal , which only executes once when the component is first imported, code inside will execute every time an instance of the component is created.\n\nWhen using , any top-level bindings (including variables, function declarations, and imports) declared inside are directly usable in the template:\n\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the option:\n\nReactive state needs to be explicitly created using Reactivity APIs. Similar to values returned from a function, refs are automatically unwrapped when referenced in templates:\n\nValues in the scope of can also be used directly as custom component tag names:\n\nThink of as being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent also works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\n\nSince components are referenced as variables instead of registered under string keys, we should use dynamic binding when using dynamic components inside :\n\nNote how the components can be used as variables in a ternary expression.\n\nAn SFC can implicitly refer to itself via its filename. E.g. a file named can refer to itself as in its template.\n\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\n\nYou can use component tags with dots like to refer to components nested under object properties. This is useful when you import multiple components from a single file:\n\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with , but they must follow the naming scheme :\n\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\n\nTo declare options like and with full type inference support, we can use the and APIs, which are automatically available inside :\n• None and are compiler macros only usable inside . They do not need to be imported, and are compiled away when is processed.\n• None accepts the same value as the option, while accepts the same value as the option.\n• None and provide proper type inference based on the options passed.\n• None The options passed to and will be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it can reference imported bindings since they are in the module scope as well.\n\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to or :\n• None or can only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.\n• None When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\n• None In dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here is inferred from the type. If the type is a reference to an imported type, the inferred result will be (equal to type) since the compiler does not have information of external files.\n• None In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into )\n• None In version 3.2 and below, the generic type parameter for were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nIn Vue 3.5 and above, variables destructured from the return value of are reactive. Vue's compiler automatically prepends when code in the same block accesses variables destructured from :\n\nThe above is compiled to the following equivalent:\n\nIn addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:\n\nIn 3.5 and above, default values can be naturally declared when using Reactive Props Destructure. But in 3.4 and below, Reactive Props Destructure is not enabled by default. In order to declare props default values with type-based declaration, the compiler macro is needed:\n\nThis will be compiled to equivalent runtime props options. In addition, the helper provides type checks for the default values, and ensures the returned type has the optional flags removed for properties that do have default values declared.\n• Only available in 3.4+\n\nThis macro can be used to declare a two-way binding prop that can be consumed via from the parent component. Example usage is also discussed in the Component guide.\n\nUnder the hood, this macro declares a model prop and a corresponding value update event. If the first argument is a literal string, it will be used as the prop name; Otherwise the prop name will default to . In both cases, you can also pass an additional object which can include the prop's options and the model ref's value transform options.\n\nTo access modifiers used with the directive, we can destructure the return value of like this:\n\nWhen a modifier is present, we likely need to transform the value when reading or syncing it back to the parent. We can achieve this by using the and transformer options:\n\nLike and , can also receive type arguments to specify the types of the model value and the modifiers:\n\nComponents using are closed by default - i.e. the public instance of the component, which is retrieved via template refs or chains, will not expose any of the bindings declared inside .\n\nTo explicitly expose properties in a component, use the compiler macro:\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape (refs are automatically unwrapped just like on normal instances).\n\nThis macro can be used to declare component options directly inside without having to use a separate block:\n• This is a macro. The options will be hoisted to module scope and cannot access local variables in that are not literal constants.\n\nThis macro can be used to provide type hints to IDEs for slot name and props type checking.\n\nonly accepts a type parameter and no runtime arguments. The type parameter should be a type literal where the property key is the slot name, and the value type is the slot function. The first argument of the function is the props the slot expects to receive, and its type will be used for slot props in the template. The return type is currently ignored and can be , but we may leverage it for slot content checking in the future.\n\nIt also returns the object, which is equivalent to the object exposed on the setup context or returned by .\n\nUsage of and inside should be relatively rare, since you can access them directly as and in the template. In the rare case where you do need them, use the and helpers respectively:\n\nand are actual runtime functions that return the equivalent of and . They can be used in normal composition API functions as well.\n\ncan be used alongside normal . A normal may be needed in cases where we need to:\n• Declare options that cannot be expressed in , for example or custom options enabled via plugins (Can be replaced by in 3.3+).\n• Run side effects or create objects that should only execute once.\n\nSupport for combining and in the same component is limited to the scenarios described above. Specifically:\n• Do NOT use a separate section for options that can already be defined using , such as and .\n• Variables created inside are not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\n\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit function, instead of using .\n\nTop-level can be used inside . The resulting code will be compiled as :\n\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the .\n\nImport statements in vue follow ECMAScript module specification. In addition, you can use aliases defined in your build tool configuration:\n\nGeneric type parameters can be declared using the attribute on the tag:\n\nThe value of works exactly the same as the parameter list between in TypeScript. For example, you can use multiple parameters, constraints, default types, and reference imported types:\n\nIn order to use a reference to a generic component in a you need to use the library as won't work.\n• Due to the difference in module execution semantics, code inside relies on the context of an SFC. When moved into external or files, it may lead to confusion for both developers and tools. Therefore, cannot be used with the attribute."
    },
    {
        "link": "https://learnvue.co/articles/script-setup",
        "document": "If you’ve been working in Vite and Vue 3 recently, you’ll notice that when you start a new project, your script section looks like this with this script syntax in your Vue components.\n\nYou may be wondering, “What is this? Is this the Options API? Composition API? where’s the setup method?”\n\nThe <script setup> type is a proposed change in the Vue’s Git RFCs. To be clear, this is not intended to completely replace any of the current ways to write code. Its purpose is to provide developers with a more concise syntax to write their single file components.\n\nIn this article, we’re going to be taking a look at exactly how it works and some of the ways that it can be useful.\n\nIn , we don’t have to declare an and a method – instead, all top-level bindings are exposed to the template\n\nIn the Composition API, we’re used to having to create our setup method and then return anything that we want exposed. Something like this…\n\nBut with , we can rewrite the same code like this..\n\nAnd it’s not just data, computed properties, and methods! Even imported directives and components that are on the top level of our setup scope are automatically available in our template.\n\nLook at this example of importing a component.\n\nSo….what’s the point of this?\n\nIn the exact words of the RFC, “the proposal’s main goal is reducing the verbosity of Composition API usage inside SFCs by directly exposing the context of script setup to the template.”\n\nAnd that’s exactly what we just saw, by not having to worry about creating a method and returning exactly what we want to expose, we can simplify our code.\n\nPlus there’s no worry of forgetting to return something from our setup method (something I know I do all the time).\n\nNow that we know what even is and why it can be useful, let’s take a look at some of its more advanced features.\n\nFirst off, you may be wondering how to perform standard Vue operations like….\n\nIn the Composition API, these were simply arguments on our setup method,\n\nHowever, in the script setup syntax, we can access these same options with 3 imports from Vue.\n• – as the name suggests, allows us to define props for our component\n• – lets us define the events that our component can emit\n• – gives us access to the slots and attributes of our component\n\nWith these 3 imports we can get the functionality that we’re used to having on our traditional setup method.\n\nAnother cool feature of the script setup is how easy it is to create an async setup function.\n\nThis is useful for loading in apis as your component is created, and even tying in your code to the experimental suspense feature.\n\nAll we have to do to make our setup function asynchronous, is use a top level await inside our script setup.\n\nFor example, if we’re using the Fetch API, we can just use await like this…\n\n…and our resulting function will be asynchronous just like that.\n\ncreates its own script scope for its top level bindings. But in certain cases, there is code that must be executed in the module scope.\n\nThe 2 specific examples in this RFC are…\n• Creating global side effects that only execute once.\n\nThis can be done by adding a normal block alongside your script setup like this.\n\nAnd there you have it\n\nCurrently, this script setup is opt-in only so if you want to try it out, just add setup to your script tag.\n\nIf you never want to think about it and just want to write your code the way you’re used to, go for it. The choice is yours.\n\nTo learn more about the script setup, here’s the link to the full RFC with its motivations, exact syntax, and more technical implementations.\n\nSo that’s all for this article, I hope it helped clear up what this new syntax that’s inside your Vite app!\n\nIf you have any questions, leave them in the comments below!"
    },
    {
        "link": "https://stackoverflow.com/questions/66382293/how-to-use-props-in-script-setup-in-vue3",
        "document": "To use props with you need to call with the component prop options as the argument, this defines the props on the component instance and returns a object with the props which you can use as follows:\n\nIf you are using typescript the alternative way to do this is pass a type only declaration and infer the prop types from that. Pro's are that you'll get stricter type safety but you cannot have default values.\n\nDefaults with type only props are now possible:"
    },
    {
        "link": "https://medium.com/@AzilenTech/using-script-setup-for-vue-3-ec4b6173b7f4",
        "document": "With Vue 3, it introduced a <script setup> feature. It is compile-time syntactic sugar for using Composition API in Single File Components. This syntax allows developers to define components without having to export anything from the JavaScript code block. It exposes all its top-level bindings to the template. Long story short, this syntax makes Single File Components simpler and makes you feel you’re working with native JavaScript code.\n• Performance\n\n A<script setup> has better runtime performance as it compiles a template into the render method with the same scope with no intermediate proxy. A <script> compiles a template with an intermediate proxy.\n• Code Syntax\n\n In a<script> block, we need to export the module with boilerplate code. The <script setup> allows us to define components without having to export anything. In a <script setup> block, we can have more concise code with less boilerplate.\n• Execution Flow\n\n The<script> block gets executed while we import a component for the first time. The <script setup> block will execute every time an instance of a component gets created.\n• Organizing Code\n\n We can organize the code as per the business logic inside the<script setup> block. It’s not possible with <script> block, as we’ve to follow the coding structure for the Options API or Composition API of Vue.\n\nWe only have to import the component to use them in a template, as the compiler automatically adds them to our application. We can use PascalCase or kebab-case for a component name in the template. However, PascalCase’s component names are strongly recommended for consistency. It also helps to differentiate from native custom elements.\n\nThe <script setup> exposes all its top-level bindings (including variables, methods, and imports) to the template. We can directly use an imported helper method in template expressions without having to expose it via the methods option.\n\nA single File Component can implicitly refer to itself via its filename. For example, a component with a filename as ListRenderer.vue can refer to itself as < ListRenderer /> in its template.\n\nAll imported components are referenced as variables, so we can use them with :is binding for dynamic component binding in a template.\n\nWe can register for a lifecycle hook of the component by using onX methods, which we can import from the vue library.\n\nA Reactive state needs to be created using Reactive APIs. For example, refs are automatically unwrapped when referenced in the template.\n\nTo define emits, we need to use the defineEmits API method, which fully supports type inference. defineEmits accepts the same value as emits option.\n\nTo define props, we need to use the defineProps API method, which fully supports type inference. defineProps accepts the same value as the props option.\n\nBelow solutions can help you to overcome the no-undef issue:\n\nReacting to Changes with watch\n\nWe can react to data changes through the watch option provided by Vue. This is most useful when we want to perform asynchronous or expensive operations in response to changes.\n\nWe can declare a computed property that automatically gets updated whenever, depending on property or data changed.\n\nA <script setup> can be used alongside normal, <script> as the <script setup> creates its own scope for its top-level bindings. Vue will mix all together for you, so your Composition code and Options code remain separate.\n\nA normal <script> is needed in certain cases when we require code that must be executed in module scope. Few pointers like below:\n• Declare options that cannot be expressed in <script setup>, for example inheritAttrs\n• Run side effects or create objects that should only execute once\n• The framework like Nuxt that provide additional methods to the standard options API syntax that are not exposed in <script setup>"
    },
    {
        "link": "https://github.com/stackblitz/core/issues/1964",
        "document": "I'm a Vue lover and I want to use Composition API in Vue3. But the <script setup> label seems not to work. In any project.\n\nI've tried in the official forked Vue3 project and the version number is above 3.2."
    },
    {
        "link": "https://element-plus.org/en-US/component/table",
        "document": "Display multiple data with similar format. You can sort, filter, compare your data in a table.\n\nBasic table is just for data display.\n\nStriped table makes it easier to distinguish different rows.\n\nYou can highlight your table content to distinguish between \"success, information, warning, danger\" and other states.\n\nWhen the content is too long, it will break into multiple lines, you can use to keep it in one line.\n\nWhen there are too many rows, you can use a fixed header.\n\nWhen there are too many columns, you can fix some of them.\n\nWhen you have huge chunks of data to put in a table, you can fix the header and columns at the same time.\n\nWhen the the data is dynamically changed, you might want the table to have a maximum height rather than a fixed height and to show the scroll bar if needed.\n\nWhen the data structure is complex, you can use group header to show the data hierarchy.\n\nYou can also select multiple rows.\n\nAfter 2.8.3, supports the third parameter to determine whether to ignore the selectable attribute.\n\nSort the data to find or compare data quickly.\n\nCustomize table column so it can be integrated with other components.\n\nCustomize table header so it can be even more customized.\n\nWhen the row content is too long and you do not want to display the horizontal scroll bar, you can use the expandable row feature.\n\nAfter 2.9.7, is added to control whether to preserve expanded row content in DOM when collapsed.\n\nFor table of numbers, you can add an extra row at the table footer displaying each column's sum.\n\nConfiguring rowspan and colspan allows you to merge cells\n\nYou can customize row index in columns.\n\nThe table-layout property sets the algorithm used to lay out table cells, rows, and columns.\n\nYou can use to customize the tooltip content.\n\nHow to use image preview in the table? ​\n\nWhy column is not rendered when use DOM templates? ​\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag\n\nFor more details please refer to vue docs"
    },
    {
        "link": "https://github.com/element-plus/element-plus/blob/dev/docs/en-US/component/table.md",
        "document": "Display multiple data with similar format. You can sort, filter, compare your data in a table.\n\nBasic table is just for data display.\n\n:::demo After setting attribute of with an object array, you can use (corresponding to a key of the object in array) in to insert data to table columns, and set the attribute to define the column name. You can also use the attribute to define the width of columns.\n\nStriped table makes it easier to distinguish different rows.\n\n:::demo Attribute accepts a . If , table will be striped.\n\n:::demo By default, Table has no vertical border. If you need it, you can set attribute to .\n\nYou can highlight your table content to distinguish between \"success, information, warning, danger\" and other states.\n\n:::demo Use in to add custom classes to a certain row. Then you can style it with custom classes.\n\nWhen the content is too long, it will break into multiple lines, you can use to keep it in one line.\n\n:::demo Attribute , which accepts a value. When set , the extra content will show in tooltip when hover on the cell.\n\nWhen there are too many rows, you can use a fixed header.\n\n:::demo By setting the attribute of , you can fix the table header without any other codes.\n\nWhen there are too many columns, you can fix some of them.\n\n:::demo Attribute is used in , it accepts a . If , the column will be fixed at left. It also accepts two string literals: 'left' and 'right', both indicating that the column will be fixed at corresponding direction.\n\nWhen you have huge chunks of data to put in a table, you can fix the header and columns at the same time.\n\n:::demo Fix columns and header at the same time by combining the above two examples.\n\nWhen the the data is dynamically changed, you might want the table to have a maximum height rather than a fixed height and to show the scroll bar if needed.\n\n:::demo By setting the attribute of , you can fix the table header. The table body scrolls only if the height of the rows exceeds the max height value.\n\nWhen the data structure is complex, you can use group header to show the data hierarchy.\n\n:::demo Only need to place el-table-column inside a el-table-column, you can achieve group header.\n\n:::demo The attribute of the group header is determined by the outermost\n\n:::demo Table supports single row selection. You can activate it by adding the attribute. An event called will be triggered when row selection changes, and its parameters are the rows after and before this change: and . If you need to display row index, you can add a new with its attribute assigned to , and you will see the index starting from 1.\n\nYou can also select multiple rows.\n\nAfter ^(2.8.3), supports the third parameter to determine whether to ignore the selectable attribute.\n\n:::demo Activating multiple selection is easy: simply add an with its set to .\n\nSort the data to find or compare data quickly.\n\n:::demo Set attribute in a certain column to sort the data based on this column. It accepts with a default value . Set table attribute to determine default sort column and order. To apply your own sorting rules, use or . If you need remote sorting from backend, set to , and listen to the event on Table. In the event handler, you have access to the sorting column and sorting order so that you can fetch sorted table data from API. In this example we use another attribute named to format the value of certain columns. It accepts a function which has two parameters: and . You can handle it according to your own needs.\n\n:::demo Set attribute and in makes this column filterable. is an array, and is a function deciding which rows are displayed. It has three parameters: , and .\n\nCustomize table column so it can be integrated with other components.\n\n:::demo You have access to the following data: row, column, $index and store (state management of Table) by slot.\n\nCustomize table header so it can be even more customized.\n\n:::demo You can customize how the header looks by header slots.\n\nWhen the row content is too long and you do not want to display the horizontal scroll bar, you can use the expandable row feature.\n\nAfter ^(2.9.7), is added to control whether to preserve expanded row content in DOM when collapsed.\n\n:::demo Activate expandable row by adding type=\"expand\" and slot. The template for el-table-column will be rendered as the contents of the expanded row, and you can access the same attributes as when you are using in custom column templates.\n\n:::demo You can display tree structure data. When row contains the field, it is treated as nested data. For rendering nested data, the prop is required. Also, child row data can be loaded asynchronously. Set property of Table to true and the function . Specify attribute in row to determine which row contains children. Both and can be configured via .\n\n:::demo When is true, the selection state of parent and child nodes is no longer associated, that is, when the parent node is selected, its child nodes will not be selected; when is false, the selection state of parent and child nodes will be associated with the selection state of child nodes, that is, when the parent node is selected, all its child nodes will be selected.\n\nFor table of numbers, you can add an extra row at the table footer displaying each column's sum.\n\n:::demo You can add the summary row by setting to . By default, for the summary row, the first column does not sum anything up but always displays 'Sum' (you can configure the displayed text using ), while other columns sum every number in that column up and display them. You can of course define your own sum behaviour. To do so, pass a method to , which returns an array, and each element of the returned array will be displayed in the columns of the summary row, It can be a VNode or string. The second table of this example is a detailed demo.\n\nConfiguring rowspan and colspan allows you to merge cells\n\n:::demo Use the attribute to configure rowspan and colspan. It accepts a method, and passes an object to that method including current row , current column , current row index and current column index . The method should return an array of two numbers, the first number being and second . It can also return an object with and props.\n\nYou can customize row index in columns.\n\n:::demo To customize row indices, use attribute on with . If it is assigned to a number, all indices will have an offset of that number. It also accepts a method with each index (starting from ) as parameter, and the returned value will be displayed as index.\n\nThe table-layout property sets the algorithm used to lay out table cells, rows, and columns.\n\nYou can use to customize the tooltip content.\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag\n\nFor more details please refer to vue docs"
    },
    {
        "link": "https://element-plus.org/en-US/component/table-v2",
        "document": "Along with evolutionary web development, table component has always been the most popular component in our web apps especially for dashboards, data analysis. For Table V1, with even just 1000 records of data, it can be very annoying when using it, because of the poor performance.\n\nWith Virtualized Table, you can render massive chunks of data in a blink of an eye.\n\nThis component is still under testing, use at your own risk. If you find any bugs or issues, please report them at GitHub for us to fix. Also there were some APIs which are not mentioned in this documentation, some of them were not fully developed yet, which is why they are not mentioned here. Even though Virtualized Table is efficient, when the data load is too large, your network and memory size can become the bottleneck of your app. So keep in mind that Virtualized Table is never the ultimate solution for everything, consider paginating your data, adding filters etc.\n\nLet's demonstrate the performance of the Virtualized Table by rendering a basic example with 10 columns and 1000 rows.\n\nWhen you do not want to manually pass the and properties to the table, you can wrap the table component with the AutoResizer. This will automatically update the width and height for you.\n\nResize your browser to see how it works.\n\nOf course, you can render the table cell according to your needs. Here's a simple example of how to customize your cell.\n\nUsing customized cell renderer to allow selection for your table.\n\nJust as we demonstrated with selections above, you can use the same method to enable inline editing.\n\nYou can highlight your table content to distinguish between \"success, information, warning, danger\" and other states.\n\nTo customize the appearance of rows, use the attribute. For example, every 10th row is highlighted using the class, and every 5th row with the class.\n\nYou can make some rows stick to the top of the table, and that can be very easily achieved by using the attribute.\n\nYou can dynamically set the sticky row based on scroll events, as shown in this example.\n\nIf you want to have columns stick to the left or right for some reason, you can achieve this by adding special attributes to the table.\n\nYou can set the column's attribute to (representing ) or or\n\nBy customizing your header renderer, you can group your header as shown in this example.\n\nVirtualized Table provides custom header renderers for creating customized headers. We can then utilize these to render filters.\n\nYou can sort the table with sort state.\n\nYou can define multiple sortable columns as needed. Keep in mind that if you define multiple sortable columns, the UI may appear confusing to your users, as it becomes unclear which column is currently being sorted.\n\nWhen dealing with a large list, it's easy to lose track of the current row and column you are visiting. In such cases, using this feature can be very helpful.\n\nThe virtualized table doesn't use the built-in element, so and behave a bit differently compared to TableV1. However, with a customized row renderer, these features can still be implemented. In this section, we'll demonstrate how to achieve this.\n\nSince we have covered Colspan, it's worth noting that we also have row span. It's a little bit different from colspan but the idea is basically the same.\n\nWe can combine rowspan and colspan together to meet your business goal!\n\nVirtual Table can also render data in a tree-like structure. By clicking the arrow icon, you can expand or collapse the tree nodes.\n\nVirtual Table is capable of rendering rows with dynamic heights. If you're working with data and are uncertain about the content size, this feature is ideal for rendering rows that adjust to the content's height. To enable this, pass down the attribute. The closer the estimated height matches the actual content, the smoother the rendering experience.\n\nUsing dynamic height rendering, you can also display a detailed view within the table.\n\nRender a customized footer when you want to show a concluding message or information.\n\nRender an overlay on top of the table when you want to show a loading indicator or something else.\n\nUse the methods provided by Table V2 to scroll manually/programmatically with desired offset/rows.\n\nHow do I render a list with a checkbox in the first column? ​\n\nSince you are allowed to define your own cell renderer, you can do what the example Customize Cell Renderer did to render yourself, and maintain the state by yourself.\n\nWhy does virtualized table provide less features than TableV1 ​\n\nFor virtualized table, we intend to provide less feature and let our users implement their own features as needed. Integrating too many features makes the code hard to maintain and for most users the basic features are enough. Some key features were not developed yet. We would love to hear from you. Join Discord to stay tuned."
    },
    {
        "link": "https://element-plus.czwang.top/en-US/component/table",
        "document": "Made with ❤️ by Element Plus"
    },
    {
        "link": "https://github.com/element-plus/element-plus/blob/dev/docs/en-US/component/table-v2.md",
        "document": "Along with evolutionary web development, table component has always been the most popular component in our web apps especially for dashboards, data analysis. For Table V1, with even just 1000 records of data, it can be very annoying when using it, because of the poor performance.\n\nWith Virtualized Table, you can render massive chunks of data in a blink of an eye.\n\nThis component is still under testing, use at your own risk. If you find any bugs or issues, please report them at GitHub for us to fix. Also there were some APIs which are not mentioned in this documentation, some of them were not fully developed yet, which is why they are not mentioned here.\n\nEven though Virtualized Table is efficient, when the data load is too large, your network and memory size can become the bottleneck of your app. So keep in mind that Virtualized Table is never the ultimate solution for everything, consider paginating your data, adding filters etc.\n\nLet's demonstrate the performance of the Virtualized Table by rendering a basic example with 10 columns and 1000 rows.\n\nWhen you do not want to manually pass the and properties to the table, you can wrap the table component with the AutoResizer. This will automatically update the width and height for you.\n\nResize your browser to see how it works.\n\nMake sure the parent node of the HAS A FIXED HEIGHT, since its default height value is set to 100%. Alternatively, you can define it by passing the attribute to .\n\nOf course, you can render the table cell according to your needs. Here's a simple example of how to customize your cell.\n\nUsing customized cell renderer to allow selection for your table.\n\nJust as we demonstrated with selections above, you can use the same method to enable inline editing.\n\nYou can highlight your table content to distinguish between \"success, information, warning, danger\" and other states.\n\nTo customize the appearance of rows, use the attribute. For example, every 10th row is highlighted using the class, and every 5th row with the class.\n\nYou can make some rows stick to the top of the table, and that can be very easily achieved by using the attribute.\n\nYou can dynamically set the sticky row based on scroll events, as shown in this example.\n\nIf you want to have columns stick to the left or right for some reason, you can achieve this by adding special attributes to the table.\n\nYou can set the column's attribute to (representing ) or or\n\nBy customizing your header renderer, you can group your header as shown in this example.\n\nIn this case we used feature which is not supported in the playground. You may try them out in your local environment or on online IDEs such as .\n\nIt is recommended that you write your table component in JSX, since it contains VNode manipulations.\n\nVirtualized Table provides custom header renderers for creating customized headers. We can then utilize these to render filters.\n\nYou can sort the table with sort state.\n\nYou can define multiple sortable columns as needed. Keep in mind that if you define multiple sortable columns, the UI may appear confusing to your users, as it becomes unclear which column is currently being sorted.\n\nWhen dealing with a large list, it's easy to lose track of the current row and column you are visiting. In such cases, using this feature can be very helpful.\n\nThe virtualized table doesn't use the built-in element, so and behave a bit differently compared to TableV1. However, with a customized row renderer, these features can still be implemented. In this section, we'll demonstrate how to achieve this.\n\nSince we have covered Colspan, it's worth noting that we also have row span. It's a little bit different from colspan but the idea is basically the same.\n\nWe can combine rowspan and colspan together to meet your business goal!\n\nVirtual Table can also render data in a tree-like structure. By clicking the arrow icon, you can expand or collapse the tree nodes.\n\nVirtual Table is capable of rendering rows with dynamic heights. If you're working with data and are uncertain about the content size, this feature is ideal for rendering rows that adjust to the content's height. To enable this, pass down the attribute. The closer the estimated height matches the actual content, the smoother the rendering experience.\n\nEach row's height is dynamically measured during rendering the rows. As a result, if you're trying to display a large amount of data, the UI might be bouncing.\n\nUsing dynamic height rendering, you can also display a detailed view within the table.\n\nRender a customized footer when you want to show a concluding message or information.\n\nRender an overlay on top of the table when you want to show a loading indicator or something else.\n\nUse the methods provided by Table V2 to scroll manually/programmatically with desired offset/rows.\n\nThe second parameter for is the scrolling strategy which by default is , it calculates the position to scroll by itself. If you wish to scroll to a specific position, you can define the strategy yourself. The available options are\n\nThe difference between and is that is a subset of scroll strategy.\n\nNote that these are Objects, so you CANNOT USE kebab-case for these attributes\n\nSince you are allowed to define your own cell renderer, you can do what the example Customize Cell Renderer did to render yourself, and maintain the state by yourself.\n\nFor virtualized table, we intend to provide less feature and let our users implement their own features as needed. Integrating too many features makes the code hard to maintain and for most users the basic features are enough. Some key features were not developed yet. We would love to hear from you. Join Discord to stay tuned."
    },
    {
        "link": "https://element-plus.org/en-US/component/input",
        "document": "Display value within it's situation with , and we usually use at the same time.\n\nAdd an icon to indicate input type.\n\nResizable for entering multiple lines of text information. Add attribute to change into native .\n\nSetting the prop for a textarea type of Input makes the height to automatically adjust based on the content. An options object can be provided to to specify the minimum and maximum number of lines the textarea can automatically adjust.\n\nPrepend or append an element, generally a label or a button.\n\nand attributes of input, they declare a limit on the number of characters a user can input. The \"number of characters\" is measured using JavaScript string length.Setting the prop for a text or textarea type of Input can limit the length of input value, allows you to show word count by setting to at the same time.\n\nWhy is the width of the ElInput component expanded by clearable? ​\n\nPS: Since the ElInput component does not have a default width, when the clearable icon is displayed, the width of the component will be expanded, which can be solved by setting width."
    },
    {
        "link": "https://stackoverflow.com/questions/72323066/element-plus-input-component-for-vue-3",
        "document": "When autosizing an input (textarea) I’ve created with Element Plus for Vue 3, a new line is created before the text reaches the end of the line being typed. This makes the input box unnecessarily large, and there’s unneeded white space after the text.\n\nHere's my code for the component:\n\nAny ideas how to fix? Thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/78160819/how-do-i-style-the-place-holder-and-background-of-an-input-form-using-vue-js-and",
        "document": "I'm trying to change the font-style, font-size, font-weight and some others for the the placeholder and the internal part of an input form in vue3 and element plus.\n\ni've tried styling it separately in the style section but it doesn't sem to work unless i use inline styling.\n\nso far ive been only able to style the outer part but i can't seem to figure out hoe to do that of the inner part of the input form.\n\nI've tried using inspect on the browser but still no improvement.\n\ni know most of element-plus have their styling already but i can't seem to figure out how to customize them the way i want.\n\nI'm still new to using vue3 and element-plus\n\nthis is the code i wrote in the tag\n\nI used the class names which were given when i inspected the code on the web browser"
    },
    {
        "link": "https://element-plus.org/en-US/component/form",
        "document": "Form consists of , , , and so on. With form, you can collect, verify and submit data.\n\nIt includes all kinds of input items, such as , , and .\n\nWhen the vertical space is limited and the form is relatively simple, you can put it in one line.\n\nDepending on your design, there are several different ways to align your label element.\n\nYou can set of separately 2.7.7. If the value is empty, the of is used.\n\nForm component allows you to verify your data, helping you find and correct errors.\n\nThis example shows how to customize your own validation rules to finish a two-factor password verification.\n\nAll components in a Form inherit their attribute from that Form. Similarly, FormItem also has a attribute.\n\nWhen only a single input (or related control such as select or checkbox) is inside of a , the form item's label will automatically be attached to that input. However, if multiple inputs are inside of the , the form item will be assigned the WAI-ARIA role of group instead. In this case, it is your responsibility to assign assistive labels to the individual inputs."
    },
    {
        "link": "https://medium.com/@ukchukx/creating-an-inline-editable-component-in-vue-and-publishing-to-npm-ad7ef6403694",
        "document": "While squashing some bugs on and making some updates to my address book, I decided to change the input fields to the inline editable style found on Trello (show below), Google Sheets, etc.\n\nI’d like to use this component in other apps so we’ll be making it a standalone component in this tutorial.\n\nSince this is a single component, it’s easier testing in an online sandbox like this one on Sandbox.io instead of creating a full-fledged app.\n\nFirstly, we’ll create the folder and files we need by running the following commands:\n\nBefore jumping into writing the actual component, let’s take care of the git and build configurations.\n\nThe only thing we need to ignore in our is the node_modules directory, so add it to the file.\n\nOur will contain:\n\nNow we’re done with housekeeping, it’s time to dive into the actual component. This is a good place to create a commit.\n\nThe default state of an inline editable component is to display a static element. When the component is clicked, it transforms into an input field that accepts user input. When focus goes away from the element, it toggles back to a static element.\n\nOur component will handle , , and inputs.\n\nWe’ll leave styling up to users. At the least, you should show a pointer cursor when the mouse hovers over the static element.\n\nOur default state is a static element. We’ll use a span as our static element. When the span is clicked, we hide the span and show our input element (via the handler on the span).\n\nWhen the span is clicked, is called which does two things. It hides the span by setting to true and it places the focus on our input so it can accept user input without the user needed to click on the input again. That's one of the reasons we're holding a ref to the input via ; the other reasons are to read its value directly (which is simpler than using in this case) and take focus away from the input.\n\nWhen focus leaves the input, we handle the blur event fired via . This function calls to hide the input and show the span and calls to pass the input value back to the parent component.\n\nWe also want to toggle the component when the user presses the Enter key. We handle that via which just takes away focus from the input element which will cause to be called.\n\nWhen the user changes the input value, we call . It checks if the parent component wants us to only pass the input values after the user is done ( i.e. is true) rather than in real-time (which is the default). If real-time updates are needed, we send the value to the parent component via .\n\nis for select inputs. It sends the selected value when the user makes a new selection.\n\nsends updates to the parent component by firing an element. This enables the parent component to use the directive to listen for updates. If is set to , we convert the value to a number before passing it along.\n\nThe and props are to give the user full control over styling as we're not going to do any styling.\n\nOur computed prop controls what is shown when the static element is shown. For number inputs, we only show when nothing has been input; otherwise we show the user input (this ensures that 0 is shown, for example). For text inputs, we show if is empty.\n\nThat’s all that’s needed for text and number input. We’ll go ahead and create a commit here.\n\nIn textareas, Enter is a normal input and it would be bad UX to toggle the component when Enter is pressed. That’s the reason we handled Enter separately from other inputs. This way, we only have to not add the handler to the textarea, instead of modifying to differentiate s from other input and textareas for number and text. This would make our function more complex and more error-prone.\n\nThe only addition is the and props to give the parent component control over sizing. They are initialized to their HTML default values if the parent component does not supply values.\n\nThat’s all that’s needed to support textareas. Let’s make a commit here.\n\nFor selects we need an array of options which is supplied through the prop, which is an array of objects that have and keys.\n\nIn the span element we show a caret to indicate that it’s a select. We added the caret in a named slot to enable the user change the default.\n\nIn our computed prop, for selects we display the label of the currently selected value.\n\nWith that, we have added support for inputs. As we've done previously, we make a commit here.\n\nBefore we publish, we need to fill our README with helpful text and build the component.\n\nTo publish, I first login to my NPM account with:\n\nThen, from the root directory I run:\n\nAfter successfully publishing, we can use our component in Node.js projects by installing it with:\n\nor in the browser using https://unpkg.com/vue-inline-input.\n\nThe GitHub repository can be found here."
    }
]