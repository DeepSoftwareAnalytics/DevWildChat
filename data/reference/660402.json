[
    {
        "link": "https://github.com/google/gson",
        "document": "Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.\n\nThere are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.\n\nGson's main focus is on Java. Using it with other JVM languages such as Kotlin or Scala might work fine in many cases, but language-specific features such as Kotlin's non- types or constructors with default arguments are not supported. This can lead to confusing and incorrect behavior.\n\n When using languages other than Java, prefer a JSON library with explicit support for that language.\n• Provide simple and methods to convert Java objects to JSON and vice-versa\n• Allow pre-existing unmodifiable objects to be converted to and from JSON\n• Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)\n\nGson jar downloads are available from Maven Central.\n\nDespite supporting older Java versions, Gson also provides a JPMS module descriptor (module name ) for users of Java 9 or newer.\n\nThese are the optional Java Platform Module System (JPMS) JDK modules which Gson depends on. This only applies when running Java 9 or newer.\n• (optional since Gson 2.8.9)\n\n When this module is present, Gson provides default adapters for some SQL date and time classes.\n• , respectively class (optional)\n\n When this module is present, Gson can use the class to create instances of classes without no-args constructor. However, care should be taken when relying on this. is not available in all environments and its usage has some pitfalls, see .\n\nOlder Gson versions may also support lower API levels, however this has not been verified.\n• User guide: This guide contains examples on how to use Gson in your code\n• Troubleshooting guide: Describes how to solve common issues when using Gson\n• Releases and change log: Latest releases and changes in these versions; for older releases see\n• Design document: This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion\n\nPlease use the 'gson' tag on StackOverflow, GitHub Discussions or the google-gson Google group to discuss Gson or to post questions.\n\nGson uses Maven to build the project:\n\nJDK 11 or newer is required for building, JDK 17 or 21 is recommended. Newer JDKs are currently not supported for building (but are supported when using Gson).\n\nSee the contributing guide.\n\n Please perform a quick search to check if there are already existing issues or pull requests related to your contribution.\n\nKeep in mind that Gson is in maintenance mode. If you want to add a new feature, please first search for existing GitHub issues, or create a new one to discuss the feature and get feedback.\n\nGson is released under the Apache 2.0 license.\n\nThis is not an officially supported Google product."
    },
    {
        "link": "http://google.github.io/gson/UserGuide.html",
        "document": "\n• Using Gson\n• Serializing and Deserializing Collection with Objects of Arbitrary Types\n\nGson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.\n\nGson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.\n• Provide easy to use mechanisms like and constructor (factory method) to convert Java to JSON and vice-versa\n• Allow pre-existing unmodifiable objects to be converted to and from JSON\n\nHere are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class .\n• Strings: Deserialized strings of over 25MB without any problems (see method in )\n• Large collections:\n• Serialized a collection of 1.4 million objects (see method in )\n• Deserialized a collection of 87,000 objects (see in )\n• Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.\n\nNote: Delete the prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.\n\nGson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.\n\nThe primary class to use is which you can just create by calling . There is also a class available that can be used to create a Gson instance with various settings like version control and so on.\n\nThe Gson instance does not maintain any state while invoking JSON operations. So, you are free to reuse the same object for multiple JSON serialization and deserialization operations.\n\nTo use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:\n\nThat is it, now your Maven project is Gson enabled.\n\nNote that you can not serialize objects with circular references since that will result in infinite recursion.\n• It is perfectly fine (and recommended) to use private fields.\n• There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.\n• If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.\n• This implementation handles nulls correctly.\n• While serializing, a null field is omitted from the output.\n• While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.\n• If a field is synthetic, it is ignored and not included in JSON serialization or deserialization.\n• Fields corresponding to the outer classes in inner classes are ignored and not included in serialization or deserialization.\n• Anonymous and local classes are excluded. They will be serialized as JSON and when deserialized their JSON value is ignored and is returned. Convert the classes to nested classes to enable serialization and deserialization for them.\n\nGson can also deserialize static nested classes. However, Gson can not automatically deserialize the pure inner classes since their no-args constructor also need a reference to the containing Object which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:\n\nNOTE: The above class B can not (by default) be serialized with Gson.\n\nGson can not deserialize into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.\n\nThe above is possible, but not recommended.\n\nWe also support multi-dimensional arrays, with arbitrarily complex element types.\n\nFairly hideous: note how we define the type of collection. Unfortunately, there is no way to get around this in Java.\n\nGson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type. This makes sense, and is rarely a problem when following good Java coding practices.\n\nGson by default serializes any implementation as a JSON object. Because JSON objects only support strings as member names, Gson converts the Map keys to strings by calling on them, and using for keys:\n\nFor deserialization Gson uses the method of the registered for the Map key type. Similar to the Collection example shown above, for deserialization a has to be used to tell Gson what types the Map keys and values have:\n\nGson also supports using complex types as Map keys. This feature can be enabled with . If enabled, Gson uses the method of the registered for the Map key type to serialize the keys, instead of using . When any of the keys is serialized by the adapter as JSON array or JSON object, Gson will serialize the complete Map as JSON array, consisting of key-value pairs (encoded as JSON array). Otherwise, if none of the keys is serialized as a JSON array or JSON object, Gson will use a JSON object to encode the Map:\n\nImportant: Because Gson by default uses to serialize Map keys, this can lead to malformed encoded keys or can cause mismatch between serialization and deserialization of the keys, for example when is not properly implemented. A workaround for this can be to use to make sure the registered for the Map key type is used for deserialization and serialization. As shown in the example above, when none of the keys are serialized by the adapter as JSON array or JSON object, the Map is serialized as a regular JSON object, as desired.\n\nNote that when deserializing enums as Map keys, if Gson is unable to find an enum constant with a matching value respectively annotation, it falls back to looking up the enum constant by its value. This is to work around the issue described above, but only applies to enum constants.\n\nWhen you call , Gson calls to get information on the fields to serialize. Similarly, you can typically pass object in the method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:\n\nThe above code fails to interpret value as type Bar because Gson invokes to get its class information, but this method returns a raw class, . This means that Gson has no way of knowing that this is an object of type , and not just plain .\n\nYou can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the class.\n\nThe idiom used to get actually defines an anonymous local inner class containing a method that returns the fully parameterized type.\n\nSerializing and Deserializing Collection with Objects of Arbitrary Types\n\nSometimes you are dealing with JSON array that contains mixed types. For example:\n\nThe equivalent containing this is:\n\nwhere the class is defined as:\n\nYou can serialize the collection with Gson without doing anything specific: would write out the desired output.\n\nHowever, deserialization with will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericized version of the collection type in . So, you have three options:\n• Use Gson’s parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use on each of the array elements.This is the preferred approach. Here is an example that demonstrates how to do this.\n• Register a type adapter for that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.\n• Register a type adapter for and use with .\n\nThis approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type .\n\nGson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate, for instance\n• to match it with strings like\n• to match it with strings like\n\nFor many more, see the internal class .\n\nYou can also find source code for some commonly used classes such as JodaTime at this page.\n\nSometimes the default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc.). Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:\n• JSON Serializers: Need to define custom serialization for an object\n• Instance Creators: Not needed if no-args constructor is available or a deserializer is registered\n• if the type adapter implements more than one of these interfaces, in that case it registers the adapter for all of them.\n• if the type adapter is for the Object class or JsonElement or any of its subclasses, in that case it throws IllegalArgumentException because overriding the built-in adapters for these types is not supported.\n\nHere is an example of how to write a custom serializer for JodaTime class.\n\nGson calls when it runs into a object during serialization.\n\nHere is an example of how to write a custom deserializer for JodaTime DateTime class.\n\nGson calls when it needs to deserialize a JSON string fragment into a DateTime object\n\nOften you want to register a single handler for all generic types corresponding to a raw type\n• For example, suppose you have an class for id representation/translation (i.e. an internal vs. external representation).\n• type that has same serialization for all generic types\n• Essentially write out the id value\n• Deserialization is very similar but not exactly the same\n• Need to call which returns an instance of\n\nGson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say needed special handling). The parameter for the and contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.\n\nWhile deserializing an Object, Gson needs to create a default instance of the class. Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.\n\nTypically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor\n\nType could be of a corresponding generic type\n• Very useful to invoke constructors which need specific generic type information\n• For example, if the class stores the class for which the Id is being created\n\nSometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:\n\nHowever, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the method. Here is an example:\n\nIn the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, . The object in this case is the Java parameterized type representation of where the actual instance should be bound to . Since class has just one parameterized type parameter, , we use the zeroth element of the type array returned by which will hold in this case.\n\nThe default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, “null” fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the Null Object Support section for information on configure Gson to output all null values.\n\nIf you would like to use the Pretty Print feature, you must configure your instance using the . The is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default that has default line length of 80 character, 2 character indentation, and 4 character right margin.\n\nThe following is an example shows how to configure a instance to use the default instead of the :\n\nThe default behaviour that is implemented in Gson is that object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.\n\nHere’s how you would configure a instance to output null:\n\nNOTE: when serializing s with Gson, it will add a element to the structure. Therefore, this object can be used in custom serialization/deserialization.\n\nMultiple versions of the same object can be maintained by using @Since annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your instance to ignore any field/object that is greater than some version number. If no version is set on the instance then it will serialize and deserialize all fields and classes regardless of the version.\n\nGson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use custom serializers and deserializers.\n\nBy default, if you mark a field as , it will be excluded. As well, if a field is marked as then by default it will be excluded. If you want to include some transient fields then you can do the following:\n\nNOTE: you can give any number of the constants to the method. For example:\n\nThis feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using . The Gson instance created will exclude all fields in a class that are not marked with annotation.\n\nIf the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the JavaDoc for more information.\n\nThe following example shows how to exclude fields marked with a specific annotation and excludes top-level types (or declared field type) of class .\n\nGson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case — ) to a JSON field name (i.e., or ). See the FieldNamingPolicy class for information on the pre-defined naming policies.\n\nIt also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise “Runtime” exceptions if an invalid field name is provided as the annotation value.\n\nThe following is an example of how to use both Gson naming policy features:\n\nIf you have a need for custom naming policy (see this discussion), you can use the @SerializedName annotation.\n\nSometimes you need to share state across custom serializers/deserializers (see this discussion). You can use the following three strategies to accomplish this:\n• Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state\n\n1 and 2 are not thread-safe options, but 3 is.\n\nIn addition Gson’s object model and data binding, you can use Gson to read from and write to a stream. You can also combine streaming and object model access to get the best of both approaches.\n\nSee the Gson design document for a discussion of issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for JSON conversion.\n\nFor the latest list of proposed enhancements or if you’d like to suggest new ones, see the Issues section under the project website."
    },
    {
        "link": "https://medium.com/@alexandre.therrien3/personalized-serializer-and-deserializer-using-java-gson-library-c079de3974d4",
        "document": "Before I begin, let me say that this tutorial applies to a very few. There are only some rare cases where this needs to be done. I did it because I created my own linked list and wanted to convert it into JSON. By default, Gson can automatically convert objects to their corresponding JSON format. However, the Gson library did not find a way to correctly convert my customized linked list to JSON.\n\nI used this website to help me find this solution. Towards the end of the web page, there is some information about customizing the serializer and deserializer. If you need basic examples, this is the place to visit.\n\nIf you need any help with JSON syntax, you should refer to this website.\n\nI knew the conversion was not being done well, because I ended up with ‘TreeNode’ elements (or something with a similar name) in my custom linked list. This is when I started to search for a solution online. You can look here for examples, although I feel having it explained would be a lot simpler.\n\nThe skeleton of any Gson Serializer resumes to this:\n\n(Code block 1.1)\n\nWhere SomeObject is the object that you desire to read to put into a JSON file.\n\nThe first thing you need to do is start by creating an object of type JsonObject. Then, you will need to add your values to that JsonObject instance. If the values added are primitive values, you only need to convert your values to JsonPrimitive objects. If the values added are arrays, you would need to extract all of the indexes of those arrays and add them into a JsonArray one by one. If the values added are objects, then you need to create other JsonObjects to your main JsonObject. The following sections will show how it is done.\n\nCreating the JSON Object\n\nTo create the JSON object that will store the object being serialized, do the following:\n\nAdding a String, Integer, or Double\n\nTo add any value to the JSON object (being String, Integer, or Double), you need to do the following:\n\nThis code shows that there is the need to create a new JsonPrimitive object. Gson only understands values being passed as JsonPrimitive objects. Also, the string title is the key that is going to be associated to our value.\n\nAdding an Array of Values\n\nTo add an array of values to our JSON object, you need to do the following:\n\nEssentially, the first line of this code block is irrelevant; this is the way I get the array of information from the object. The next lines, however, are important. First, a JsonArray having the same size as the array of reference (someArray in this case) must be created. Then, iterating over the indexes of the array of reference is done. For each index, a primitive value is being added to the JsonArray using the add() method. Finally, once the array is completed, the array is added to jsonObject using the add() method. The first argument of that method is the key that will be associated with the array. The second argument is the actual JsonArray that was just created.\n\nAdding an Array of Objects\n\nTo create an array of objects, it would pretty much look like the previous section. the only difference would be that you would be adding objects instead of strings with the add() method from the JsonArray object. To do so, you would need to instantiate a JsonObject object and put key/value pairs in it, as shown from the section Adding a String, Integer, or Double in this article.\n\nTo conclude this section, do not forget to return your main JsonObject at the end of the function as the serialize method returns a JsonElement! (refer to code block 1.1)\n\nTo be able to use your custom serializer, you have to reference it somewhere in your code. To do so, you would follow the common procedure as referenced in the Gson documentation, but with an extra line of code. This line of code would identify the custom serializer as the way to translate the object to JSON. Refer to the Custom Instance Creators in GSON on this website for more information.\n\nEssentially, all you have to do is assign the builder object to a builder that considers the custom serializer that was built (look at line 2. This is the line that matters the most, only briefly mentioned in Gson documentation). Note that the class for the custom serializer that was designed in this tutorial was SomeSerializer, and that the object that was serialized was called SomeObject.\n\nThe variables PATH_TO_JSON and titleOfJsonFile are variables that determine where the file is going to be stored.\n\nThe variable someObjectInstance is an object of type SomeObject that we want to have serialized.\n\nAlso, I am able to write the object of type SomeObject to a file in JSON using the gson.toJson() function.\n\nThe skeleton of any Gson Deserializer resumes to this:\n\n(Code block 2.1)\n\nWhere SomeObject is the object that you desire to create after having read a JSON file. The JsonElement object contains all the data that Gson could extract from the JSON file. This is the only parameter that is required to extract the content of a JSON file.\n\nThe first step in the deserializer is to get the content of the JSON file. To do so, refer to the next section. The second step is to extract the values from the JSON file by using the keys associated with the values that you want to extract. The final step is to return the object built as a result of deserializing the JSON file. Following from code block 2.1, that would be the SomeObject instance.\n\nExtracting the JSON Content\n\nTo extract the JSON content from a file, all you need to do is:\n\nThe jsonElement object is of type JsonElement and is from the parameter list of your function deserialize (refer to Code block 2.1). You can get the content of your file from this function as the syntax of a JSON file starts with a { and ends with a }.\n\nExtracting Primitive Values from JSON\n\nTo extract primitive values from a JSON file (either integer, double, or string) can simply be done from the corresponding functions:\n\nYou can extract those values from the corresponding JSON element you have chosen.\n\nInside the jsonObject of type JsonObject, there was a field called title. The function get() returns an object of type JsonElement. This object only comes to use to us when using either the getAsString(), getAsDouble(), or getAsInt() method.\n\nIn this previous code block, I extract the string value associated with the key title.\n\nIn this previous code block, I extract the double value associated with the key quantity.\n\nIn this previous code block, I extract the integer value associated with the key unit.\n\nTo extract the content of some JSON array, use the following:\n\nThis example speaks for itself. From your JsonObject jsonObject, get the associated value with the key someArray. Using the function size() from the JsonArray class to know when the array ends, iterate over the JsonArray and extract all the primitive values from it. The get() function from the JsonArray class will allow you to get a value at a certain index.\n\nThis code extracts the content of a common JSON array, which is some thing of the sort:\n\nExtracting the Content of a Custom JSON Array\n\nThe difference between a custom JSON array and a common JSON array is that the custom one contains JSON objects as indexes, and the other contains primitive values as indexes. Below is an example of how to extract data from a custom JSON array.\n\nIn this example, I get the array with the key ingredients. Then, I define a for loop the same way I did when extracting data from a common JSON array (see previous section).\n\nBecause indexes are now objects, I extract the content of indexes using the function getAsJsonObject(). Within that object, I get the values I want using the keys that I defined in those (nameIngredient, quantity, and unit).\n\nLast but not least, do not forget to return the object you just built from your JSON file!\n\nThere is not much difference from the Referencing the Custom Serializer section of this article. The only difference is that you now reference a deserializer instead of a serializer. Of course, after the Gson object is created, things get really different. Because we are reading a JSON file, we have to use a BufferedReader object to be able to convert the content of the file to a JSON object. Using the gson.fromJson() method we accomplish this goal. Refer to the Custom Instance Creators in GSON on this website for more information.\n\nRemember that the SomeObject class is only used as an example. The value of canonicalPathToFile is the path to the file.\n\nTo conclude, I would like to remind the readers to use the same key fields for serializing and deserializing the object. Otherwise, there will be errors because the values you will be looking for will not be found. What I mean by that is you need to match the key value when serializing the object (say, title) with the one you will extract when deserializing the object. If you put anything else than title, Gson will not find it in the JSON file."
    },
    {
        "link": "https://github.com/google/gson/blob/main/UserGuide.md",
        "document": "\n• Using Gson\n• Serializing and Deserializing Collection with Objects of Arbitrary Types\n\nGson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.\n\nGson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.\n• Provide easy to use mechanisms like and constructor (factory method) to convert Java to JSON and vice-versa\n• Allow pre-existing unmodifiable objects to be converted to and from JSON\n\nHere are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class .\n• Strings: Deserialized strings of over 25MB without any problems (see method in )\n• Large collections:\n• Serialized a collection of 1.4 million objects (see method in )\n• Deserialized a collection of 87,000 objects (see in )\n• Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.\n\nNote: Delete the prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.\n\nGson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.\n\nThe primary class to use is which you can just create by calling . There is also a class available that can be used to create a Gson instance with various settings like version control and so on.\n\nThe Gson instance does not maintain any state while invoking JSON operations. So, you are free to reuse the same object for multiple JSON serialization and deserialization operations.\n\nTo use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:\n\nThat is it, now your Maven project is Gson enabled.\n\nNote that you can not serialize objects with circular references since that will result in infinite recursion.\n• It is perfectly fine (and recommended) to use private fields.\n• There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.\n• If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.\n• This implementation handles nulls correctly.\n• While serializing, a null field is omitted from the output.\n• While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.\n• If a field is synthetic, it is ignored and not included in JSON serialization or deserialization.\n• Fields corresponding to the outer classes in inner classes are ignored and not included in serialization or deserialization.\n• Anonymous and local classes are excluded. They will be serialized as JSON and when deserialized their JSON value is ignored and is returned. Convert the classes to nested classes to enable serialization and deserialization for them.\n\nGson can also deserialize static nested classes. However, Gson can not automatically deserialize the pure inner classes since their no-args constructor also need a reference to the containing Object which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:\n\nNOTE: The above class B can not (by default) be serialized with Gson.\n\nGson can not deserialize into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.\n\nThe above is possible, but not recommended.\n\nWe also support multi-dimensional arrays, with arbitrarily complex element types.\n\nFairly hideous: note how we define the type of collection. Unfortunately, there is no way to get around this in Java.\n\nGson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type. This makes sense, and is rarely a problem when following good Java coding practices.\n\nGson by default serializes any implementation as a JSON object. Because JSON objects only support strings as member names, Gson converts the Map keys to strings by calling on them, and using for keys:\n\nFor deserialization Gson uses the method of the registered for the Map key type. Similar to the Collection example shown above, for deserialization a has to be used to tell Gson what types the Map keys and values have:\n\nGson also supports using complex types as Map keys. This feature can be enabled with . If enabled, Gson uses the method of the registered for the Map key type to serialize the keys, instead of using . When any of the keys is serialized by the adapter as JSON array or JSON object, Gson will serialize the complete Map as JSON array, consisting of key-value pairs (encoded as JSON array). Otherwise, if none of the keys is serialized as a JSON array or JSON object, Gson will use a JSON object to encode the Map:\n\nImportant: Because Gson by default uses to serialize Map keys, this can lead to malformed encoded keys or can cause mismatch between serialization and deserialization of the keys, for example when is not properly implemented. A workaround for this can be to use to make sure the registered for the Map key type is used for deserialization and serialization. As shown in the example above, when none of the keys are serialized by the adapter as JSON array or JSON object, the Map is serialized as a regular JSON object, as desired.\n\nNote that when deserializing enums as Map keys, if Gson is unable to find an enum constant with a matching value respectively annotation, it falls back to looking up the enum constant by its value. This is to work around the issue described above, but only applies to enum constants.\n\nWhen you call , Gson calls to get information on the fields to serialize. Similarly, you can typically pass object in the method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:\n\nThe above code fails to interpret value as type Bar because Gson invokes to get its class information, but this method returns a raw class, . This means that Gson has no way of knowing that this is an object of type , and not just plain .\n\nYou can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the class.\n\nThe idiom used to get actually defines an anonymous local inner class containing a method that returns the fully parameterized type.\n\nSometimes you are dealing with JSON array that contains mixed types. For example:\n\nThe equivalent containing this is:\n\nwhere the class is defined as:\n\nYou can serialize the collection with Gson without doing anything specific: would write out the desired output.\n\nHowever, deserialization with will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericized version of the collection type in . So, you have three options:\n• Use Gson's parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use on each of the array elements.This is the preferred approach. Here is an example that demonstrates how to do this.\n• Register a type adapter for that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.\n• Register a type adapter for and use with .\n\nThis approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type .\n\nGson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate, for instance\n• to match it with strings like\n• to match it with strings like\n\nFor many more, see the internal class .\n\nYou can also find source code for some commonly used classes such as JodaTime at this page.\n\nSometimes the default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc.). Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:\n• JSON Serializers: Need to define custom serialization for an object\n• Instance Creators: Not needed if no-args constructor is available or a deserializer is registered\n• if the type adapter implements more than one of these interfaces, in that case it registers the adapter for all of them.\n• if the type adapter is for the Object class or JsonElement or any of its subclasses, in that case it throws IllegalArgumentException because overriding the built-in adapters for these types is not supported.\n\nHere is an example of how to write a custom serializer for JodaTime class.\n\nGson calls when it runs into a object during serialization.\n\nHere is an example of how to write a custom deserializer for JodaTime DateTime class.\n\nGson calls when it needs to deserialize a JSON string fragment into a DateTime object\n\nOften you want to register a single handler for all generic types corresponding to a raw type\n• For example, suppose you have an class for id representation/translation (i.e. an internal vs. external representation).\n• type that has same serialization for all generic types\n• Essentially write out the id value\n• Deserialization is very similar but not exactly the same\n• Need to call which returns an instance of\n\nGson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say needed special handling). The parameter for the and contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.\n\nWhile deserializing an Object, Gson needs to create a default instance of the class. Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.\n\nTypically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor\n\nType could be of a corresponding generic type\n• Very useful to invoke constructors which need specific generic type information\n• For example, if the class stores the class for which the Id is being created\n\nSometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:\n\nHowever, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the method. Here is an example:\n\nIn the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, . The object in this case is the Java parameterized type representation of where the actual instance should be bound to . Since class has just one parameterized type parameter, , we use the zeroth element of the type array returned by which will hold in this case.\n\nThe default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, \"null\" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the Null Object Support section for information on configure Gson to output all null values.\n\nIf you would like to use the Pretty Print feature, you must configure your instance using the . The is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default that has default line length of 80 character, 2 character indentation, and 4 character right margin.\n\nThe following is an example shows how to configure a instance to use the default instead of the :\n\nThe default behaviour that is implemented in Gson is that object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.\n\nHere's how you would configure a instance to output null:\n\nNOTE: when serializing s with Gson, it will add a element to the structure. Therefore, this object can be used in custom serialization/deserialization.\n\nMultiple versions of the same object can be maintained by using @Since annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your instance to ignore any field/object that is greater than some version number. If no version is set on the instance then it will serialize and deserialize all fields and classes regardless of the version.\n\nGson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use custom serializers and deserializers.\n\nBy default, if you mark a field as , it will be excluded. As well, if a field is marked as then by default it will be excluded. If you want to include some transient fields then you can do the following:\n\nNOTE: you can give any number of the constants to the method. For example:\n\nThis feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using . The Gson instance created will exclude all fields in a class that are not marked with annotation.\n\nIf the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the JavaDoc for more information.\n\nThe following example shows how to exclude fields marked with a specific annotation and excludes top-level types (or declared field type) of class .\n\nGson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- ) to a JSON field name (i.e., or ). See the FieldNamingPolicy class for information on the pre-defined naming policies.\n\nIt also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise \"Runtime\" exceptions if an invalid field name is provided as the annotation value.\n\nThe following is an example of how to use both Gson naming policy features:\n\nIf you have a need for custom naming policy (see this discussion), you can use the @SerializedName annotation.\n\nSometimes you need to share state across custom serializers/deserializers (see this discussion). You can use the following three strategies to accomplish this:\n• Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state\n\n1 and 2 are not thread-safe options, but 3 is.\n\nIn addition Gson's object model and data binding, you can use Gson to read from and write to a stream. You can also combine streaming and object model access to get the best of both approaches.\n\nSee the Gson design document for a discussion of issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for JSON conversion.\n\nFor the latest list of proposed enhancements or if you'd like to suggest new ones, see the Issues section under the project website."
    },
    {
        "link": "https://medium.com/@prathameshk3707/json-serialization-and-deserialization-with-gson-ba8420a4265d",
        "document": "In today’s interconnected world, handling JSON (JavaScript Object Notation) data is a fundamental part of many software applications. Whether you’re building web services, mobile apps, or server-side applications, efficiently converting Java objects to JSON and vice versa is crucial. Gson, a powerful Java library developed by Google, simplifies this process with its intuitive API and robust features.\n\nIn this blog post, we’ll dive deep into Gson, exploring its capabilities, usage patterns, and advanced features.\n\nBefore we delve into advanced features, let’s start with the basics of Gson. Gson provides a straightforward API for converting Java objects to JSON and vice versa. Let’s look at a simple example:\n\nIn this example, we define a simple with two fields ( and ). We then serialize an instance of to JSON using and deserialize it back to a Java object using .\n\nGson excels at handling complex object hierarchies. Let’s consider a scenario where we have a class hierarchy:\n\nTo serialize and deserialize objects of the class, Gson can handle the nested structure seamlessly:\n\nGson allows you to customize the serialization and deserialization process for specific scenarios. You can achieve this by implementing custom serializers and deserializers.\n\nFor example, suppose we have a class representing a date with custom formatting requirements:\n\nWe can create a custom serializer and deserializer for :\n\nSupport for Various Data Types and Collections\n\nGson provides built-in support for various data types and collections, including primitive types, arrays, lists, maps, and enums. Here’s a quick example:\n\nGson handles these data types and collections effortlessly during serialization and deserialization.\n\nGson is a powerful Java library for handling JSON serialization and deserialization tasks. In this blog post, we covered its basic usage, handling of complex object hierarchies, customization through custom serializers and deserializers, and support for various data types and collections.\n\nBy mastering Gson, you can streamline your JSON processing tasks and build more robust and efficient Java applications. Whether you’re working on web services, mobile apps, or backend systems, Gson is a valuable tool in your Java development toolkit."
    },
    {
        "link": "https://stackoverflow.com/questions/74280044/how-to-handle-socket-exceptions-to-make-a-continuous-flow-of-program-in-java",
        "document": "I am creating a skribbl clone in Java using JavaFX and socket programming.\n\nI am sending data over a TCP connection using a objectinput/outputstream.\n\nEvery 2/5 times the application runs without any exception but other time it shows numerous socket related exception and I am not able to figure out why it is happening.\n\nThere is one more exception which is the . I don't know why these exceptions are occurring sometimes but not all the time.\n\nI want to know if the objectoutput/inputstream will be suitable for this work or not.\n\nCan you suggest any other stream that will be useful for this purpose?\n\nThank You for all the replies and answer . I have changed the ObjectStream to BufferedReader and BufferedWriter and it solved my problem."
    },
    {
        "link": "https://stackoverflow.com/questions/32545270/best-practice-for-java-exception-handling",
        "document": "First of all the problem with \"best practice\" advice is that it tends to over-simplify the question and the answer. Then someone (like yourself) comes along and notices that it is contradictory1.\n\nIMO, best practice is to take \"best practice\" advice and people who regularly use that phrase with a healthy level of suspicion. Try to understand the real issues yourself, and reach your own conclusions ... rather than just relying someone else to tell you what is \"best practice\".\n\n1 - Or worse ... they don't notice the contradictions, edge-cases, etc, and blindly follow the so-called \"best practice\". And occasionally, they find themselves in a dark place, because the \"best practice\" recommendation was inappropriate.\n\nSo what's the problem here? It is this statement:\n\nIn fact, it is not normally good coding practice to catch generic exceptions like . But it is the right thing to do in some circumstances. And your example is one where it is appropriate.\n\nWell lets look a case where catching is a bad idea:\n\nWhy is that a bad idea? Because that is going to catch and handle unexpected exceptions; i.e. exceptions that you (the developer) did not think were possible, or that you did not even consider. That's OK ... but then the code logs the exception, and continues running as if nothing happened.\n\nThat's the real problem ... attempting to recover from an unexpected exception.\n\nThe (so-called) \"best practice\" advice to \"never catch generic exceptions\" deals with the issue, but in a crude way that doesn't deal with the edge cases. One of the edge cases is that catching (and logging) a generic exception is OK if you then immediately shut the application down ... like you are doing.\n\nNow contrast that with the (supposedly) good practice version in your question. What is the difference?\n• Your version produces more user friendly / less alarming diagnostics ... up to a point.\n• Your version is significantly more code.\n• Your version is unhelpful to someone trying to diagnose the problem because the stacktraces are not recorded.\n\nAnd the counterpoints to 1 and 2 are:\n• You can spend limitless time honing the \"user friendly\" diagnostics for an application, and still fail to help the kind of user who can't or won't understand ...\n• It also depends on who the typical user is.\n\nAs you can see, this is far more nuanced than \"catching generic exceptions is bad practice\"."
    },
    {
        "link": "https://theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Java-Exception-handling-best-practices",
        "document": ""
    },
    {
        "link": "https://exceptiondecoded.com/posts/java-socketexception",
        "document": "SocketException is a common exception that occurs in Java programming when there is an issue with the sockets, which are communication endpoints for sending and receiving data between two computers. In this article, we will explore SocketException in detail, its causes, and how to handle it effectively in your Java code. So, let’s dive in!\n\nIn Java, SocketException is a subclass of the IOException class, specifically designed to handle socket-related errors. It is thrown when there is an issue with socket communication or socket-related operations. SocketException inherits all the properties and methods of its superclass, making it a powerful tool for developers to troubleshoot and resolve socket-related issues.\n\nSocketException can occur due to various reasons, including but not limited to:\n\nThis exception is thrown when a client tries to connect to a server, but the server refuses the connection. This could happen when the server is not running, the server’s port is closed, or a firewall is blocking the connection.\n\nConsider the following code snippet to illustrate this scenario:\n\nSocketException can also occur if the connection establishment exceeds the specified timeout period. This can happen when the server is overloaded or the network is experiencing high latency.\n\nWhen a client attempts to connect to a remote host that is unreachable, a SocketException will be thrown. This can be caused by issues such as incorrect IP address, network connectivity problems, or DNS resolution failures.\n\nSocketException can occur when an operation is performed on a closed socket. This can happen when a socket is manually closed or due to an unexpected termination of the underlying connection.\n\nThese are just a few examples of the possible causes of SocketException in Java. Depending on your specific application and network environment, you may encounter other scenarios as well.\n• None Client-Server Communication: SocketException commonly occurs during client-server communication. For example, if the client fails to establish a connection with the server due to connection refusal or timeout, a SocketException will be thrown. It is crucial to handle such exceptions gracefully to provide a better user experience.\n• None Network Communication: SocketException also arises when there is a disruption in network communication. This can be caused by network congestion, hardware failures, or incorrect network configurations. By handling SocketException appropriately, you can monitor and recover from these network-related issues seamlessly.\n• None Socket Operations: Socket operations like reading from or writing to sockets can also trigger SocketException. For instance, if a socket is closed while a read/write operation is in progress, a SocketException will be thrown. Proper exception handling in such cases ensures the stability and reliability of your application.\n\nIt is important to note that SocketException is a checked exception, which means you need to handle it explicitly in your code using try-catch blocks or by declaring the exception in the method signature. Failing to do so will result in a compilation error.\n\nNow that we have gained insights into the causes of SocketException, let’s explore the best practices to handle this exception effectively in your Java code.\n\nTo handle SocketException, you need to catch it using try-catch blocks. Catching SocketException allows you to gracefully handle socket-related errors and perform necessary actions to recover from the exception. However, avoid catching generic exceptions like as it can hide critical issues and make debugging challenging.\n\nConsider the following example to demonstrate catching SocketException:\n\nIn scenarios where a SocketException is caused by temporary network issues or server overload, implementing a retry mechanism can be helpful. By retrying the operation after a short delay, you can increase the chances of successful communication. However, be cautious not to enter an infinite retry loop, which may lead to poor application performance and network congestion.\n\nHere’s an example of a basic retry mechanism to handle SocketException:\n\nWhen encountering a SocketException, it is important to recover gracefully and handle any errors that may arise. Depending on the specific scenario, you may want to retry the operation, prompt the user with an error message, log the error for future analysis, or perform any other necessary actions to ensure smooth functioning of your application.\n\nPrevention is always better than cure. By following best practices, you can minimize the occurrence of SocketException in your Java applications:\n\nEnsure that you release system resources associated with sockets appropriately. Close sockets after use using the method to prevent potential resource leaks and SocketExceptions.\n\nImplement robust error handling mechanisms to effectively catch and handle SocketException. Provide informative error messages to aid in troubleshooting and recovery. Error handling should be an integral part of your design and development process.\n\nMaintain a stable network environment by ensuring proper network configurations, minimizing network congestion, and monitoring network health. Regularly monitor network performance and address any issues promptly to prevent SocketExceptions caused by network disruptions.\n\nCarefully choose appropriate timeout values according to your specific requirements. Avoid keeping the timeout values too short or too long, as this may lead to frequent SocketExceptions due to connection timeout or extended waiting periods.\n\nSocketException is a crucial exception in Java that requires careful consideration while developing network-based applications. By understanding the causes, common scenarios, and best practices to handle and prevent SocketExceptions, you can ensure the robustness and efficiency of your Java code.\n\nIn this article, we explored the various causes of SocketException, such as connection refusal, timeout, host unreachability, and socket closure. We also discussed strategies to handle SocketException effectively using try-catch blocks, retry mechanisms, and graceful error handling. Finally, we covered best practices to prevent SocketExceptions by focusing on resource management, error handling, network stability, and optimal timeout settings.\n\nNow armed with this knowledge, you can confidently tackle SocketException in your Java projects and build robust and resilient network applications.\n\nFor further details on SocketException and its sibling exceptions, refer to the official Java documentation: Java SocketException"
    },
    {
        "link": "https://keyholesoftware.com/how-to-specify-handle-exceptions-in-java-effectively",
        "document": "Ever experienced a program crash at the worst possible moment? It’s frustrating, right? In Java, how you handle exceptions can make or break your application’s reliability. A single mismanaged error can ripple through your code, causing bugs, crashes, or even data loss. But with the right approach, you can turn potential chaos into seamless recovery, ensuring your software stays robust and user-friendly.\n\nLet’s explore Java’s best practices for exception handling. Discover strategies to help you write cleaner, more maintainable, and dependable code—ensuring your applications are ready to handle anything that comes their way.\n\nIn Java, exceptions occur when something goes wrong during the execution of a program. How you handle these exceptions can determine whether your application recovers gracefully or crashes unexpectedly. Proper exception handling ensures that errors are dealt with at the right time and in the right way, making your code more predictable and easier to maintain.\n\n10 Best Practices for Handling Exceptions in Java\n\nJava provides two main types of exceptions: checked and unchecked.\n• Checked exceptions: These are subclasses of Exception RuntimeException ). They should be used when the caller of your method can reasonably be expected to handle the error. Examples include FileNotFoundException SocketTimeoutException SQLException . While these exceptions make your code more explicit, overusing them can clutter your code with excessive try-catch\n• Unchecked exceptions: These are subclasses of RuntimeException and should be used for situations that are likely unrecoverable. Common examples include NullPointerException and IllegalArgumentException. These exceptions indicate bugs in the code that should be fixed rather than caught and handled.\n\nWhen throwing exceptions, always choose the most specific exception class that describes the problem. For instance, if invalid input is passed to a method, throw an IllegalArgumentException rather than a generic Exception.\n\nSimilarly, when catching exceptions, avoid using overly broad types such as Exception or Throwable. Catching specific exceptions helps you pinpoint problems quickly and makes your code easier to debug and maintain.\n\n3. Catch and Handle Exceptions Close to Their Source\n\nIt’s important to handle exceptions as close as possible to where they occur. This reduces the complexity of passing exceptions up the call chain unnecessarily. If a method throws an exception, handle it in the same method unless the calling code has a better understanding of how to address it. Only propagate exceptions when you truly don’t know how to handle them at the current level.\n\nNever catch an exception and do nothing with it. This is known as “swallowing” the exception, and it can lead to silent failures that are difficult to debug. Always log exceptions using frameworks like SLF4J or Log4J so that there’s a record of what went wrong. Proper logging is essential for tracking issues in production and understanding the cause of failures.\n\n5. Wrap and Rethrow Exceptions When Necessary\n\nSometimes you need to catch a lower-level exception and rethrow it as a higher-level custom exception with more context. When doing this, always include the original exception as a cause to preserve the stack trace. This practice helps provide more context to higher layers of your application without losing valuable debugging information.\n\nJava’s try-with-resources statement simplifies resource management by automatically closing resources like file streams, database connections, and sockets. This eliminates the need for explicit finally blocks and reduces the chances of resource leaks. Always prefer this approach when dealing with resources that need to be closed.\n\nExceptions are computationally expensive, both to create and handle. Using them for flow control (e.g., determining the next steps in your code based on an exception) can make your code harder to understand and maintain. Instead, use proper control flow constructs like conditionals.\n\nCustom exceptions can make your code more readable and easier to troubleshoot. If a specific error condition occurs often within your application, consider creating a custom exception for it. These custom exceptions should extend either RuntimeException (for unchecked exceptions) or Exception (for checked exceptions) and follow standard naming conventions that clearly describe the issue.\n\nIn larger applications, particularly Spring-based ones, you can centralize exception handling using the @ControllerAdvice annotation. This allows you to handle exceptions across all controllers in a consistent manner. For Java EE applications, you can use @ExceptionHandler to achieve similar functionality. Centralized handling reduces code duplication and ensures consistency in how errors are handled across your application.\n\nWhenever you throw an exception, always include a descriptive message that explains what went wrong. If possible, offer information about how the error could be corrected. Meaningful messages can greatly reduce debugging time and improve the overall usability of your application.\n• Overusing Checked Exceptions: Don’t clutter your code with too many try-catch blocks. Only use checked exceptions when the caller is expected to handle the error.\n• Catching Broad Exceptions: Exception Throwable unless absolutely necessary. It hides the true cause of the error and makes debugging harder.\n• Ignoring Exceptions: Never catch an exception without doing anything with it. Always log the error or rethrow it with more context.\n\nTo handle exceptions in Java effectively, it’s important to be specific, log errors, and use the right type of exception for the right scenario. By implementing these techniques, you can create code that is easier to maintain, debug, and optimize for reliability.\n\nNeed guidance on mastering exception handling? Contact us—we’re here to help you build resilient, efficient applications."
    }
]