[
    {
        "link": "https://flask.palletsprojects.com",
        "document": "Welcome to Flask’s documentation. Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications.\n\nGet started with Installation and then get an overview with the Quickstart. There is also a more detailed Tutorial that shows how to create a small but complete application with Flask. Common patterns are described in the Patterns for Flask section. The rest of the docs describe each component of Flask in detail, with a full reference in the API section.\n\nFlask depends on the Werkzeug WSGI toolkit, the Jinja template engine, and the Click CLI toolkit. Be sure to check their documentation as well as Flask’s when looking for information."
    },
    {
        "link": "https://devdocs.io/flask~2.1",
        "document": ""
    },
    {
        "link": "https://baach.de/Members/jhb/images/flask-2-1-x.pdf",
        "document": ""
    },
    {
        "link": "https://flask-fr.readthedocs.io/api",
        "document": "This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.\n\nRepresents a blueprint, a collection of routes and other app-related functions that can be registered on a real application later. A blueprint is an object that allows defining application functions without requiring an application object ahead of time. It uses the same decorators as , but defers the need for an application by recording them for later registration. Decorating a function with a blueprint creates a deferred function that is called with when the blueprint is registered on an application.\n• None name (str) – The name of the blueprint. Will be prepended to each endpoint name.\n• None import_name (str) – The name of the blueprint package, usually . This helps locate the for the blueprint.\n• None static_folder (Optional[str]) – A folder with static files that should be served by the blueprint’s static route. The path is relative to the blueprint’s root path. Blueprint static files are disabled by default.\n• None static_url_path (Optional[str]) – The url to serve static files from. Defaults to . If the blueprint does not have a , the app’s static route will take precedence, and the blueprint’s static files won’t be accessible.\n• None template_folder (Optional[str]) – A folder with templates that should be added to the app’s template search path. The path is relative to the blueprint’s root path. Blueprint templates are disabled by default. Blueprint templates have a lower precedence than those in the app’s templates folder.\n• None url_prefix (Optional[str]) – A path to prepend to all of the blueprint’s URLs, to make them distinct from the rest of the app’s routes.\n• None subdomain (Optional[str]) – A subdomain that blueprint routes will match on by default.\n• None url_defaults (Optional[dict]) – A dict of default values that blueprint routes will receive by default.\n• None root_path (Optional[str]) – By default, the blueprint will automatically set this based on . In certain situations this automatic detection can fail, so the path can be specified manually instead. Modifié dans la version 1.1.0: Blueprints have a group to register nested CLI commands. The parameter controls the name of the group under the command. Register a custom template filter, available application wide. Like but for a blueprint. Works exactly like the decorator.\n• None name (Optional[str]) – the optional name of the filter, otherwise the function name will be used. Register a custom template global, available application wide. Like but for a blueprint. Works exactly like the decorator.\n• None name (Optional[str]) – the optional name of the global, otherwise the function name will be used. Register a custom template test, available application wide. Like but for a blueprint. Works exactly like the decorator.\n• None name (Optional[str]) – the optional name of the test, otherwise the function name will be used. Like but for a blueprint. The endpoint for the function is prefixed with the name of the blueprint. Like but for a blueprint. Such a function is executed after each request, even if outside of the blueprint. Register a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use for that. A data structure of functions to call at the end of each request, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. Like but for a blueprint. Such a function is executed each request, even if outside of the blueprint. Like but for a blueprint. This handler is used for all requests, even if outside of the blueprint. Register a custom template filter, available application wide. Like but for a blueprint. name (Optional[str]) – the optional name of the filter, otherwise the function name will be used. Register a custom template global, available application wide. Like but for a blueprint. name (Optional[str]) – the optional name of the global, otherwise the function name will be used. Register a custom template test, available application wide. Like but for a blueprint. name (Optional[str]) – the optional name of the test, otherwise the function name will be used. Like . Such a function is executed before the first request to the application. Like . Such a function is executed before each request, even if outside of a blueprint. For example, this can be used to open a database connection, or to load the logged in user from the session. The function will be called without any arguments. If it returns a non- value, the value is handled as if it was the return value from the view, and further request handling is stopped. A data structure of functions to call at the beginning of each request, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. The Click command group for registering CLI commands for this object. The commands are available from the command once the application has been discovered and blueprints have been registered. Decorate a view function to register it for the given endpoint. Used if a rule is added without a with . endpoint (str) – The endpoint name to associate with the view function. A data structure of registered error handlers, in the format . The key is the name of a blueprint the handlers are active for, or for all requests. The key is the HTTP status code for , or for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. Register a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: Nouveau dans la version 0.7: Use instead of modifying directly, for application wide error handlers. Nouveau dans la version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the class. code_or_exception (Union[Type[flask.typing.GenericException], int]) – the code as integer for the handler, or an arbitrary exception Used by to determine the cache value for a given file path if it wasn’t passed. By default, this returns from the configuration of . This defaults to , which tells the browser to use conditional requests instead of a timed cache, which is usually preferable. Modifié dans la version 2.0: The default configuration is instead of 12 hours. The name of the package or module that this object belongs to. Do not change this once it is set by the constructor. The Jinja loader for this object’s templates. By default this is a class to if it is set. Blueprint local JSON decoder class to use. Set to to use the app’s . Blueprint local JSON encoder class to use. Set to to use the app’s . Creates an instance of object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state. Open a resource file relative to for reading. For example, if the file is next to the file where the app is defined, it can be opened with:\n• None resource (str) – Path to the resource relative to .\n• None mode (str) – Open the file in this mode. Only reading is supported, valid values are « r » (or « rt ») and « rb ». Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the method. Works like but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called. Called by to register all views and callbacks registered on the blueprint with the application. Creates a and calls each callback with it.\n• None app (Flask) – The application this blueprint is being registered with. Modifié dans la version 2.0.1: Nested blueprints are registered with their dotted name. This allows different blueprints with the same name to be nested at different locations. Modifié dans la version 2.0.1: The option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for . Modifié dans la version 2.0.1: Registering the same blueprint with the same name multiple times is deprecated and will become an error in Flask 2.1. Register a on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint. Modifié dans la version 2.0.1: The option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for . Alternative error attach function to the decorator that is more straightforward to use for non decorator usage. Absolute path to the package on the filesystem. Used to look up resources contained in the package. Decorate a view function to register it with the given URL rule and options. Calls , which has more details about the implementation. The endpoint name for the route defaults to the name of the view function if the parameter isn’t passed. The parameter defaults to . and are added automatically. The view function used to serve files from . A route is automatically registered for this view at if is set. The absolute path to the configured static folder. if no static folder is set. The URL prefix that the static route will be accessible from. If it was not configured during init, it is derived from . Like but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint. Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed. When is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors. When a teardown function was called because of an exception it will be passed an error object. The return values of teardown functions are ignored. In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the configuration variable. A data structure of functions to call at the end of each request even if an exception is raised, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call to pass extra context values when rendering templates, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. The path to the templates folder, relative to , to add to the template loader. if templates should not be added. A data structure of functions to call to modify the keyword arguments when generating URLs, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. Callback function for URL defaults for all view functions of the application. It’s called with the endpoint and values and should update the values passed in place. Register a URL value preprocessor function for all view functions in the application. These functions will be called before the functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored. A data structure of functions to call to modify the keyword arguments passed to the view function, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. To register a view function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time.\n\nThe request object used by default in Flask. Remembers the matched endpoint and view arguments. It is what ends up as . If you want to replace the request object used you can subclass this and set to your subclass. The request object is a subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones. List of charsets this client supports as object. List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at . List of languages this client accepts as object. List of mimetypes this client supports as object. Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set on the response to indicate which headers are allowed. Sent with a preflight request to indicate which method will be used for the cross origin request. Set on the response to indicate which methods are allowed. If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server. Decorate a function as responder that accepts the request as the last argument. This works like the decorator but the function is passed the request object as the last argument and the request object will be closed automatically: As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing. The parsed URL parameters (the part in the URL after the question mark). By default an is returned from this function. This can be changed by setting to a different type. This might be necessary if the order of the form data is important. The registered name of the current blueprint. This will be if the endpoint is not part of a blueprint, or if URL matching failed or has not been performed yet. This does not necessarily match the name the blueprint was created with. It may have been nested, or registered with a different name. The registered names of the current blueprint upwards through parent blueprints. This will be an empty list if there is no current blueprint, or if URL matching failed. A object for the incoming cache control headers. Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it. The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. A with the contents of all cookies transmitted with the request. Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle. The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. Modifié dans la version 2.0: The datetime object is timezone-aware. The endpoint that matched the request URL. This will be if matching failed or has not been performed yet. This in combination with can be used to reconstruct the same URL or a modified URL. The WSGI environment containing HTTP headers and information from the WSGI server. object containing all uploaded files. Each key in is the name from the . Each value in is a Werkzeug object. It basically behaves like a standard file object you know from Python, with the difference that it also has a function that can store the file on the filesystem. Note that will only contain data if the request method was POST, PUT or PATCH and the that posted to the request had . It will be empty otherwise. See the / documentation for more details about the used data structure. The form parameters. By default an is returned from this function. This can be changed by setting to a different type. This might be necessary if the order of the form data is important. Please keep in mind that file uploads will not end up here, but instead in the attribute. Modifié dans la version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests. Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object ( ) that allows to create multipart requests, support for cookies etc. This accepts the same options as the . Modifié dans la version 0.5: This method now accepts the same arguments as . Because of this the parameter is now called . This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting to . Usually it’s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set to . When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If is set to the return value will be a decoded string. If the mimetype does not indicate JSON (application/json, see ), this returns . If parsing fails, is called and its return value is used as the return value.\n• None force (bool) – Ignore the mimetype and always try to parse JSON.\n• None cache (bool) – Store the parsed JSON to return for subsequent calls. The headers received with the request. The host name the request was made to, including the port if it’s non-standard. Validated with . An object containing all the etags in the header. The parsed header as a datetime object. Modifié dans la version 2.0: The datetime object is timezone-aware. An object containing all the etags in the header. Modifié dans la version 2.0: is timezone-aware. The parsed header as a datetime object. Modifié dans la version 2.0: The datetime object is timezone-aware. In general it’s a bad idea to use this one because you can easily read past the boundary. Use the instead. Check if the mimetype indicates JSON data, either application/json or application/*+json. boolean that is if the application is served by a WSGI server that spawns multiple processes. boolean that is if the application is served by a multithreaded WSGI server. boolean that is if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it’s not guaranteed that the execution only happens one time. if the request was made with a secure protocol (HTTPS or WSS). Creates the form data parser. Instantiates the with some parameters. The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. The method the request was made with, such as . Like , but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is the mimetype would be . The mimetype parameters as dict. For example if the content type is the params would be . Called if parsing fails and isn’t silenced. If this method returns a value, it is used as the return value for . The default implementation raises . The host that the request originated from. Set on the response to indicate which origins are allowed. The path part of the URL after . This is the path used for routing within the application. The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. The part of the URL after the « ? ». This is the raw value, use for the parsed values. The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the « referrer », although the header field is misspelled). The address of the client sending the request. If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. The prefix that the application is mounted under, without a trailing slash. comes after this. The request URL scheme, host, and root path. This is the root that the application is accessed from. If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a exception or something similar. The URL scheme of the protocol the request used, such as or . The address of the server. , for unix sockets, or if not known. Set when creating the request object. If , reading from the request body will cause a . Useful to prevent modifying the stream from middleware. If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use which will give you that data as a string. The stream only returns the data once. Unlike this stream is properly guarded that you can’t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering. Modifié dans la version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened. The full request URL with the scheme, host, root path, path, and query string. The charset that is assumed for URLs. Defaults to the value of . Alias for . The URL with scheme, host, and root path. For example, . The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler ( ) etc. Though if the request’s method was invalid for the URL rule, the valid list is available in instead (an attribute of the Werkzeug exception ) because the request was never internally bound. The user agent. Use to get the header value. Set to a subclass of to provide parsing for the other properties or other extended data. Modifié dans la version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A subclass must be set to parse data from the string. A that combines and . For GET requests, only are present, not . Modifié dans la version 2.0: For GET requests, only are present, not . A dict of view arguments that matched the request. If an exception happened when matching, this will be . if the request method carries content. By default this is true if a is sent. To access incoming request data, you can use the global object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment. This is a proxy. See Notes On Proxies for more information. The request object is an instance of a .\n\nThe response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don’t have to create this object yourself because will take care of that for you. If you want to replace the response object used you can subclass this and set to your subclass. Modifié dans la version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON. The header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values and are common. Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request. Which headers can be sent with the cross origin request. Which methods can be used for the cross origin request. The origin or “*” for any origin that may make cross origin requests. Which headers can be shared by the browser to JavaScript code. The maximum age in seconds the access control settings can be cached for. Add an etag for the current response if there is none yet. Modifié dans la version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments. The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. Returns the content length if available or otherwise. Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator. Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it. Nouveau dans la version 0.9: Can now be used in a with statement. The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI. The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) The header as a object. Available even if the header is not set. The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the enum. Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the enum. A descriptor that calls and . The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. Modifié dans la version 2.0: The datetime object is timezone-aware.\n• None key (str) – the key (name) of the cookie to be deleted.\n• None path (str) – if the cookie that should be deleted was limited to a path, the path has to be defined here.\n• None domain (Optional[str]) – if the cookie that should be deleted was limited to a domain, that domain has to be defined here.\n• None secure (bool) – If , the cookie will only be available via HTTPS.\n• None samesite (Optional[str]) – Limit the scope of the cookie to only be attached to requests that are « same-site ». Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use instead of setting this manually. The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache. Modifié dans la version 2.0: The datetime object is timezone-aware. Enforce that the WSGI response is a response object of the current type. Werkzeug will use the internally in many situations like the exceptions. If you call on an exception you will get back a regular object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible! Make the response object ready to be pickled. Does the following:\n• None Buffer the response into a list, ignoring and .\n• None Generate an header if one is not already set. Modifié dans la version 2.0: An header is added, the parameter is deprecated and will be removed in Werkzeug 2.1. Modifié dans la version 0.6: The header is set. Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the callable returned by the function. This tries to resolve such edge cases automatically. But if you don’t get the expected output you should set to which enforces buffering. Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned. environ (WSGIEnvironment) – the WSGI environment of the request. The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting to . If is set to the return value will be a decoded string. Return a tuple in the form . If there is no ETag the return value is . If the mimetype does not indicate JSON (application/json, see ), this returns . Unlike , the result is not cached.\n• None force (bool) – Ignore the mimetype and always try to parse JSON. This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes. Modifié dans la version 0.6: Previously that function was called and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered. environ (WSGIEnvironment) – the WSGI environment of the request. Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is the response will be empty and only the headers and status code will be present. environ (WSGIEnvironment) – the WSGI environment of the request. Check if the mimetype indicates JSON data, either application/json or application/*+json. If the iterator is buffered, this property will be . A response object will consider an iterator to be buffered if the response attribute is a list or tuple. If the response is streamed (the response is not an iterable with a length information) this property is . In this case streamed means that there is no information about the number of iterations. This is usually if a generator is passed to the response object. This is useful for checking before applying some sort of post filtering that should not take place for streamed responses. Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless was activated. The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified. Modifié dans la version 2.0: The datetime object is timezone-aware. The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. Make the response conditional to the request. This method works best if an etag was defined for the response already. The method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it’s recommended that your response data object implements , and methods as described by . Objects returned by automatically implement those methods. It does not remove the body of the response because that’s something the function does for us automatically. Returns self so that you can do but modifies the object in-place.\n• None request_or_environ (WSGIEnvironment) – a request object or WSGI environment to be used to make the response conditional against.\n• None accept_ranges (Union[bool, str]) – This parameter dictates the value of header. If (default), the header is not set. If , it will be set to . If , it will be set to . If it’s a string, it will use this value.\n• None complete_length (Optional[int]) – Will be used only in valid Range Requests. It will set complete length value and compute real value. This parameter is mandatory for successful Range Requests completion. if header could not be parsed or satisfied. Modifié dans la version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error. Converts the response iterator in a list. By default this happens automatically if required. If is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items. The mimetype parameters as dict. For example if the content type is the params would be . The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. Modifié dans la version 2.0: The datetime object is timezone-aware. A warning is raised if the size of the cookie header exceeds , but the header will still be set.\n• None key (str) – the key (name) of the cookie to be set.\n• None value (str) – the value of the cookie.\n• None max_age (Optional[Union[datetime.timedelta, int]]) – should be a number of seconds, or (default) if the cookie should last only as long as the client’s browser session.\n• None expires (Optional[Union[str, datetime.datetime, int, float]]) – should be a object or UNIX timestamp.\n• None path (Optional[str]) – limits the cookie to a given path, per default it will span the whole domain.\n• None domain (Optional[str]) – if you want to set a cross-domain cookie. For example, will set a cookie that is readable by the domain , etc. Otherwise, a cookie will only be readable by the domain that set it.\n• None secure (bool) – If , the cookie will only be available via HTTPS.\n• None samesite (Optional[str]) – Limit the scope of the cookie to only be attached to requests that are « same-site ». Sets a new string as response. The value must be a string or bytes. If a string is set it’s encoded to the charset of the response (utf-8 by default). Set the etag, and override the old one if there was one. The HTTP status code as a string. The HTTP status code as a number. The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. The header in a parsed form.\n\nA proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can’t be imported, such as when using the application factory pattern or in blueprints and extensions. This is only available when an application context is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with . This is a proxy. See Notes On Proxies for more information. If you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable. Alternatively you can also just test any of the context bound objects (such as or ) for truthness: A helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context. Works like but for the application context. You can also just do a boolean check on the object instead. Generates a URL to the given endpoint with the method provided. Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is , the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot ( ). This will reference the index function local to the current blueprint: Configuration values and are only used when generating URLs outside of a request context. To integrate applications, has a hook to intercept URL build errors through . The function results in a when the current app does not have a URL for the given endpoint and values. When it does, the calls its if it is not , which can return a string to use as the result of (instead of ’s default to raise the exception) or re-raise the exception. An example: # This is an example of hooking the build_error_handler. # Re-raise the BuildError, in context of original traceback. # url_for will use this result, instead of raising BuildError. Here, is the instance of , and and are the arguments passed into . Note that this is for building URLs outside the current application, and not for handling 404 NotFound errors. Nouveau dans la version 0.10: The parameter was added. Nouveau dans la version 0.9: The and parameters were added. Nouveau dans la version 0.9: Calls on .\n• None endpoint (str) – the endpoint of the URL (name of the function)\n• None values (Any) – the variable arguments of the URL rule\n• None _external – if set to , an absolute URL is generated. Server address can be changed via configuration variable which falls back to the header, then to the IP and port of the request.\n• None _scheme – a string specifying the desired URL scheme. The parameter must be set to or a is raised. The default behavior uses the same scheme as the current request, or if no request context is available. This also can be set to an empty string to build protocol-relative URLs.\n• None _anchor – if provided this is added as anchor to the URL.\n• None _method – if provided this explicitly specifies an HTTP method. Raises an for the given status code or WSGI application. If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that: Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it’s not a real redirect and 304 because it’s the answer for a request with a request with defined If-Modified-Since headers. Nouveau dans la version 0.10: The class used for the Response object can now be passed in. Nouveau dans la version 0.6: The location can now be a unicode string that is encoded using the function.\n• None location (str) – the location the response should redirect to.\n• None Response (class) – a Response class to use when instantiating a response. The default is if unspecified. Sometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers. If view looked like this and you want to add a new header: This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code: The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators:\n• None if no arguments are passed, it creates a new response argument\n• None if one argument is passed, is invoked with it.\n• None if more than one argument is passed, the arguments are passed to the function as tuple. Executes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one. This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object. Send the contents of a file to the client. The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with . Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn’t intend. Use to safely serve user-requested paths from within a directory. If the WSGI server sets a in , it is used, otherwise Werkzeug’s built-in wrapper is used. Alternatively, if the HTTP server supports , configuring Flask with will tell the server to send the given path, which is much more efficient than reading it in Python.\n• None path_or_file (Union[os.PathLike, str, BinaryIO]) – The path to the file to send, relative to the current working directory if a relative path is given. Alternatively, a file-like object opened in binary mode. Make sure the file pointer is seeked to the start of the data.\n• None mimetype (Optional[str]) – The MIME type to send for the file. If not provided, it will try to detect it from the file name.\n• None as_attachment (bool) – Indicate to a browser that it should offer to save the file instead of displaying it.\n• None download_name (Optional[str]) – The default name browsers will use when saving the file. Defaults to the passed file name.\n• None conditional (bool) – Enable conditional and range responses based on request headers. Requires passing a file path and .\n• None etag (Union[bool, str]) – Calculate an ETag for the file, which requires passing a file path. Can also be a string to use instead.\n• None last_modified (Optional[Union[datetime.datetime, int, float]]) – The last modified time to send for the file, in seconds. If not provided, it will try to detect it from the file path.\n• None max_age (Optional[Union[int, Callable[[Optional[str]], Optional[int]]]]) – How long the client should cache the file, in seconds. If set, will be , otherwise it will be to prefer conditional caching. Modifié dans la version 2.0: replaces the parameter. If , it is passed with instead. Modifié dans la version 2.0: replaces the parameter. is enabled and is not set by default. Modifié dans la version 2.0: replaces the parameter. It can be a string to use instead of generating one. Modifié dans la version 2.0: Passing a file-like object that inherits from will raise a rather than sending an empty file. Nouveau dans la version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments. Modifié dans la version 1.1: may be a object. Modifié dans la version 1.1: Passing a object supports range requests. Modifié dans la version 1.0.3: Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers. Modifié dans la version 1.0: UTF-8 filenames as specified in RFC 2231 are supported. Modifié dans la version 0.12: The filename is no longer automatically inferred from file objects. If you want to use automatic MIME and etag support, pass a filename via or . Modifié dans la version 0.12: is preferred over for MIME detection. Modifié dans la version 0.9: defaults to . Modifié dans la version 0.7: MIME guessing and etag support for file-like objects was deprecated because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself. Modifié dans la version 0.5: The , and parameters were added. The default behavior is to add etags. This is a secure way to serve files from a folder, such as static files or uploads. Uses to ensure the path coming from the client is not maliciously crafted to point outside the specified directory. If the final path does not point to an existing regular file, raises a 404 error.\n• None directory (Union[os.PathLike, str]) – The directory that must be located under.\n• None path (Union[os.PathLike, str]) – The path to the file to send, relative to . Modifié dans la version 2.0: replaces the parameter. Nouveau dans la version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments. Safely join zero or more untrusted path components to a base directory to avoid escaping the base directory.\n• None pathnames (str) – The untrusted path components relative to the base directory. Replace the characters , , , , and in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the object has an method, it is called and the return value is assumed to already be safe for HTML. s – An object to be converted to a string and escaped. A string with the escaped text. A string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe. Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the class method instead. This implements the interface that some frameworks use. Passing an object that implements will wrap the output of that method, marking it safe. This is a subclass of . It has the same methods, but escapes their arguments and returns a instance. Escape a string. Calls and ensures that for subclasses the correct type is returned. the markup, remove tags, and normalize whitespace to single spaces. Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.\n\nFlask uses the built-in module for handling JSON. It will use the current blueprint’s or application’s JSON encoder and decoder for easier customization. By default it handles some extra data types:\n• None and are serialized to RFC 822 strings. This is the same as the HTTP date format.\n• None is serialized to a string.\n• None (or any object with a method) will call the method to get a string. Jinja’s filter is configured to use Flask’s function. The filter marks the output with automatically. Use the filter to render data inside tags. Serialize data to JSON and wrap it in a with the application/json mimetype. Uses to serialize the data, but and are treated as data rather than arguments to .\n• None Multiple arguments: Treated as a list of values. is the same as .\n• None Keyword arguments: Treated as a dict of values. is the same as .\n• None Passing both arguments and keyword arguments is not allowed as it’s not clear what should happen. Will return a JSON response like this: The default output omits indents and spaces after separators. In debug mode or if is , the output will be formatted to be easier to read. Modifié dans la version 0.11: Added support for serializing top-level arrays. This introduces a security risk in ancient browsers. See JSON Security. Serialize an object to a string of JSON. Takes the same arguments as the built-in , with some defaults from application configuration.\n• None app (Optional[Flask]) – Use this app’s config instead of the active app context or defaults. Modifié dans la version 2.0: is deprecated and will be removed in Flask 2.1. Modifié dans la version 1.0.3: can be passed directly, rather than requiring an app context for configuration. Serialize an object to JSON written to a file object. Takes the same arguments as the built-in , with some defaults from application configuration.\n• None app (Optional[Flask]) – Use this app’s config instead of the active app context or defaults. Modifié dans la version 2.0: Writing to a binary file, and the argument, is deprecated and will be removed in Flask 2.1. Deserialize an object from a string of JSON. Takes the same arguments as the built-in , with some defaults from application configuration.\n• None app (Optional[Flask]) – Use this app’s config instead of the active app context or defaults. Modifié dans la version 2.0: is deprecated and will be removed in Flask 2.1. The data must be a string or UTF-8 bytes. Modifié dans la version 1.0.3: can be passed directly, rather than requiring an app context for configuration. Takes the same arguments as the built-in , with some defaults from application configuration.\n• None app (Optional[Flask]) – Use this app’s config instead of the active app context or defaults. Modifié dans la version 2.0: is deprecated and will be removed in Flask 2.1. The file must be text mode, or binary mode with UTF-8 bytes. The default JSON encoder. Handles extra types compared to the built-in .\n• None and are serialized to RFC 822 strings. This is the same as the HTTP date format.\n• None is serialized to a string.\n• None (or any object with a method) will call the method to get a string. Assign a subclass of this to or to override the default. Convert to a JSON serializable type. See . Python does not support overriding how basic types like or are serialized, they are handled before this method. This does not change any behavior from the built-in . Assign a subclass of this to or to override the default. A compact representation for lossless serialization of non-standard JSON types. uses this to serialize the session data, but it may be useful in other places. It can be extended to support other types. Serializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to . Tag classes to bind when creating the serializer. Other tags can be added later using . Tag the value and dump it to a compact JSON string. Register a new tag with this serializer.\n• None tag_class (Type[flask.json.tag.JSONTag]) – tag class to register. Will be instantiated with this serializer instance.\n• None force (bool) – overwrite an existing tag. If false (default), a is raised.\n• None index (Optional[int]) – index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If (default), the tag is appended to the end of the order. KeyError – if the tag key is already registered and is not true. Convert a value to a tagged representation if necessary. Convert a tagged representation back to the original type. Check if the given value should be tagged by this tag. The tag to mark the serialized object with. If , this tag is only used as an intermediate step during tagging. Convert the value to a valid JSON type and add the tag structure around it. Convert the Python object to an object that is a valid JSON type. The tag will be added later. Convert the JSON representation back to the correct type. The tag will already be removed. Let’s see an example that adds support for . Dicts don’t have an order in JSON, so to handle this we will dump the items as a list of pairs. Subclass and give it the new key to identify the type. The session serializer processes dicts first, so insert the new tag at the front of the order since must be processed before .\n\nGenerally there are three ways to define rules for the routing system:\n• None You can directly access the underlying Werkzeug routing system which is exposed as . Variable parts in the route can be specified with angular brackets ( ). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using . Variable parts are passed to the view function as keyword arguments. An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply:\n• None If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached.\n• None If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised. This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely. You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page: This specifies that will be the URL for page one and will be the URL for page . If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, will be redirected to . If your route handles and requests, make sure the default route only handles , as redirects can’t preserve form data. Here are the parameters that and accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the parameter. the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated. the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the dictionary with the endpoint as key. A dictionary with defaults for this rule. See the example above for how defaults work. specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed. the options to be forwarded to the underlying object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to ( , etc.). By default a rule just listens for (and implicitly ). Starting with Flask 0.6, is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments."
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/changes",
        "document": "\n• None Error handlers for or will always be passed an instance of . If they are invoked due to an unhandled exception, that original exception is now available as rather than being passed directly to the handler. The same is true if the handler is for the base . This makes error handler behavior more consistent. #3266\n• None is called for all unhandled exceptions even if there is no error handler.\n• None takes the same name as (the value passed as . This reverts 1.0’s behavior of always logging to , in order to support multiple apps in the same process. A warning will be shown if old configuration is detected that needs to be moved. #2866\n• None includes the current session object in the request context copy. This prevents pointing to an out-of-date object. #2935\n• None Using built-in RequestContext, unprintable Unicode characters in Host header will result in a HTTP 400 response and not HTTP 500 as previously. #2994\n• None supports objects as described in PEP 519, to support in Python 3. #3059\n• None accepts the “rt” file mode. This still does the same thing as “r”. #3163\n• None The attribute set in a base class is used by subclasses. #3138\n• None is a instead of an to allow easier configuration. Changes must still be made before creating the environment. #3190\n• None Flask’s for the request and response wrappers was moved into Werkzeug. Use Werkzeug’s version with Flask-specific support. This bumps the Werkzeug dependency to >= 0.15. #3125\n• None The command entry point is simplified to take advantage of Werkzeug 0.15’s better reloader support. This bumps the Werkzeug dependency to >= 0.15. #3022\n• None Support empty without requiring setting an empty as well. #3124\n• None Allow customizing the used for routing. #3069\n• None The development server port can be set to 0, which tells the OS to pick an available port. #2926\n• None The return value from is more consistent with the documentation. It will return if python-dotenv is not installed, or if the given path isn’t a file. #2937\n• None Signaling support has a stub for the method when the Blinker library is not installed. #3208\n• None Add an option to the CLI command to specify extra files that will trigger the reloader on change. #2897\n• None Allow returning a dictionary from a view function. Similar to how returning a string will produce a response, returning a dict will call to produce a response. #3111\n• None Blueprints have a Click group like . CLI commands registered with a blueprint will be available as a group under the command. #1357.\n• None When using the test client as a context manager ( ), all preserved request contexts are popped when the block exits, ensuring nested contexts are cleaned up correctly. #3157\n• None Show a better error message when the view return type is not supported. #3214\n• None has been deprecated in favour of a new class . #3232\n• None The command no longer fails if Python is not built with SSL support. Using the option will show an appropriate error message. #3211\n• None URL matching now occurs after the request context is pushed, rather than when it’s created. This allows custom URL converters to access the app and request contexts, such as to query a database for an id. #3088\n• None Python 2.6 and 3.3 are no longer supported.\n• None Skip when a Flask application is run from the command line. This avoids some behavior that was confusing to debug.\n• None Change the default for to . returns a compact format by default, and an indented format in debug mode. #2193\n• None accepts the argument and sets it on . #1559\n• None accepts the argument and passes it as the argument when defining the static route. #1559\n• None accepts the argument to disable adding the method. #1489\n• None Errors caused while opening the session at the beginning of the request are handled by the app’s error handlers. #2254\n• None Blueprints gained and attributes to override the app’s encoder and decoder. #1898\n• None raises instead of for bad response types. The error messages have been improved to describe why the type is invalid. #2256\n• None Add CLI command to output routes registered on the application. #2259\n• None Show warning when session cookie domain is a bare hostname or an IP address, as these may not behave properly in some browsers, such as Chrome. #2282\n• None is set if it is detected through . #2282\n• None Factory functions are not required to take a parameter to work with the command. If they take a single parameter or a parameter named , the object will be passed. #2319\n• None can be set to an app factory, with arguments if needed, for example . #2326\n• None can point to local packages that are not installed in editable mode, although is still preferred. #2414\n• None The class attribute is set in , to be detected by . #2316\n• None Error handling will try handlers registered for , , , . #2314\n• None is added to the response’s header if the session is accessed at all during the request (and not deleted). #2288\n• None accepts and arguments for use when building the base URL. #1621\n• None Set to by default. This was already the implicit default when it was set to .\n• None is enabled by default in debug mode. has a message with the bad key in debug mode instead of the generic bad request message. #2348\n• None Allow registering new tags with to support storing other types in the session cookie. #2352\n• None Only open the session if the request has not been pushed onto the context stack yet. This allows generators to access the same session that the containing view uses. #2354\n• None Add keyword argument for the test client request methods. This will dump the given object as JSON and set the appropriate content type. #2358\n• None Extract JSON handling to a mixin applied to both the and classes. This adds the and methods to the response to make testing JSON response much easier. #2358\n• None Removed error handler caching because it caused unexpected results for some exception inheritance hierarchies. Register handlers explicitly for each exception if you want to avoid traversing the MRO. #2362\n• None Template auto reloading will honor debug mode even if was already accessed. #2373\n• None The following old deprecated code was removed. #2385\n• None - import extensions directly by their name instead of through the namespace. For example, becomes .\n• None - tracked by , use to register handlers.\n• None The property is no longer deprecated. #1421\n• None The command and will load environment variables from and files if python-dotenv is installed. #2416\n• None When passing a full URL to the test client, the scheme in the URL is used instead of . #2430\n• None has been simplified. and config was removed. The logger is always named . The level is only set on first access, it doesn’t check each time. Only one format is used, not different ones depending on . No handlers are removed, and a handler is only added if no handlers are already configured. #2436\n• None Blueprint view function names may not contain dots. #2450\n• None Fix a caused by invalid requests in some cases. #2526\n• None The development server uses threads by default. #2529\n• None Pass and options to to run the development server over HTTPS. #2606\n• None Added to control the attribute on the session cookie. #2607\n• None Added to create a Click runner that can invoke Flask CLI commands for testing. #2636\n• None Subdomain matching is disabled by default and setting does not implicitly enable it. It can be enabled by passing to the constructor. #2635\n• None A single trailing slash is stripped from the blueprint when it is registered with the app. #2629\n• None doesn’t cache the result if parsing fails when is true. #2651\n• None no longer accepts arbitrary encodings. Incoming JSON should be encoded using UTF-8 per RFC 8259, but Flask will autodetect UTF-8, -16, or -32. #2691\n• None Added and to control when Werkzeug warns about large cookies that browsers may ignore. #2693\n• None Updated documentation theme to make docs look better in small windows. #2709\n• None Rewrote the tutorial docs and example project to take a more structured approach to help new users avoid common pitfalls. #2676\n• None Added support to serializing top-level arrays to . This introduces a security risk in ancient browsers.\n• None Added to to support passing additional keyword arguments to the constructor of .\n• None Added config key that controls the set-cookie behavior. If set to a permanent session will be refreshed each request and get their lifetime extended, if set to it will only be modified if the session actually modifies. Non permanent sessions are not affected by this and will always expire if the browser window closes.\n• None Added support for returning tuples in the form from a view function.\n• None Templates are no longer automatically reloaded outside of debug mode. This can be configured with the new config key.\n• None Added support for explicit root paths when using Python 3.3’s namespace packages.\n• None Added and the module to start the local debug server through the click CLI system. This is recommended over the old method as it works faster and more reliable due to a different design and also replaces .\n• None Error handlers that match specific classes are now checked first, thereby allowing catching exceptions that are subclasses of HTTP exceptions (in ). This makes it possible for an extension author to create exceptions that will by default result in the HTTP error of their choosing, but may be caught with a custom error handler if desired.\n• None Flask will now log by default even if debug is disabled. The log format is now hardcoded but the default log handling can be disabled through the configuration key.\n• None Added the config flag which when enabled will instruct Flask to explain how it locates templates. This should help users debug when the wrong templates are loaded.\n• None Enforce blueprint handling in the order they were registered for template loading.\n• None Add “pretty” and “compressed” separators definitions in jsonify() method. Reduces JSON response size when by removing unnecessary white space included by default after separators.\n• None JSON responses are now terminated with a newline character, because it is a convention that UNIX text files end with a newline and some clients don’t deal well when this newline is missing. #1262\n• None The automatically provided method is now correctly disabled if the user registered an overriding rule with the lowercase-version . #1288\n• None Don’t leak exception info of already caught exceptions to context teardown handlers. #1393\n• None now has and methods.\n• None Turn on autoescape for by default. #1515\n• None now raises BadRequest if the filename is invalid on the server OS. #1763\n• None Exceptions during teardown handling will no longer leave bad application contexts lingering around.\n• None Raise an in with a useful message explaining why it is raised when a PEP 302 import hook is used without an method.\n• None Fixed an issue causing exceptions raised before entering a request or app context to be passed to teardown handlers.\n• None Fixed an issue with query parameters getting removed from requests in the test client when absolute URLs were requested.\n• None Fixed an etags bug when sending a file streams with a name.\n• None Fixed not expanding to the application root path correctly.\n• None Changed logic of before first request handlers to flip the flag after invoking. This will allow some uses that are potentially dangerous but should probably be permitted.\n• None Fixed Python 3 bug when a handler from reraises the .\n• None The now returns a JSON formatted response by default.\n• None The function now can generate anchors to the generated links.\n• None The function now can also explicitly generate URL rules specific to a given HTTP method.\n• None Logger now only returns the debug log setting if it was not set explicitly.\n• None Unregister a circular dependency between the WSGI environment and the request object when shutting down the request. This means that environ will be after the response was returned to the WSGI server but has the advantage that the garbage collector is not needed on CPython to tear down the request unless the user created circular dependencies themselves.\n• None Session is now stored after callbacks so that if the session payload is stored in the session you can still modify it in an after request callback.\n• None The class will avoid importing the provided import name if it can (the required first parameter), to benefit tools which build Flask instances programmatically. The Flask class will fall back to using import on systems with custom module hooks, e.g. Google App Engine, or when the import name is inside a zip archive (usually an egg) prior to Python 2.7.\n• None Blueprints now have a decorator to add custom template filters application wide, .\n• None The Flask and Blueprint classes now have a non-decorator method for adding custom template filters application wide, and .\n• None The function now allows rendering flashed message categories in separate blocks, through a argument.\n• None The method now accepts for and arguments, using default values when . This allows for calling run using configuration values, e.g. , with proper behavior whether or not a config file is provided.\n• None The method now accepts a either an iterable of template names or a single template name. Previously, it only accepted a single template name. On an iterable, the first template found is rendered.\n• None Added which works very similar to the request context but only provides access to the current application. This also adds support for URL generation without an active request context.\n• None View functions can now return a tuple with the first instance being an instance of . This allows for returning from a view function.\n• None and now provide a hook for subclasses to override behavior of serving static files from Flask when using (used for the default static file handler) and . This hook is provided a filename, which for example allows changing cache controls by file extension. The default max-age for and static files can be configured through a new configuration variable, which is used in the default implementation.\n• None Fixed an assumption in sessions implementation which could break message flashing on sessions implementations which use external storage.\n• None Changed the behavior of tuple return values from functions. They are no longer arguments to the response object, they now have a defined meaning.\n• None Added to allow a specific class to be used on creation of the instance of each request.\n• None Added attribute to view functions to force-add methods on registration.\n• None Added and the ability to push contexts multiple times without producing unexpected behavior.\n• None Refactored session support into a session interface so that the implementation of the sessions can be changed without having to override the Flask class.\n• None View functions can now opt out of getting the automatic OPTIONS implementation.\n• None HTTP exceptions and Bad Request errors can now be trapped so that they show up normally in the traceback.\n• None Flask in debug mode is now detecting some common problems and tries to warn you about them.\n• None Flask in debug mode will now complain with an assertion error if a view was attached after the first request was handled. This gives earlier feedback when users forget to import view code ahead of time.\n• None Added the ability to register callbacks that are only triggered once at the beginning of the first request with .\n• None Malformed JSON data will now trigger a bad request HTTP exception instead of a value error which usually would result in a 500 internal server error if not handled. This is a backwards incompatible change.\n• None Applications now not only have a root path where the resources and modules are located but also an instance path which is the designated place to drop files that are modified at runtime (uploads etc.). Also this is conceptually only instance depending and outside version control so it’s the perfect place to put configuration files etc.\n• None Implemented to easily modify sessions from the test environment.\n• None Refactored test client internally. The configuration variable as well as are now properly used by the test client as defaults.\n• None Fixed an issue where the test client if used with the “with” statement did not trigger the execution of the teardown handlers.\n• None HEAD requests to a method view now automatically dispatch to the method if no handler was implemented.\n• None Implemented the virtual package to import extensions from.\n• None The context preservation on exceptions is now an integral component of Flask itself and no longer of the test client. This cleaned up some internal logic and lowers the odds of runaway request contexts in unittests.\n• None Fixed the Jinja2 environment’s method not returning the correct names when blueprints or modules were involved.\n• None Added which can be used by subclasses to alter the default behavior for responses.\n• None Unbound locals now raise a proper instead of an .\n• None Mimetype guessing and etag support based on file objects is now deprecated for because it was unreliable. Pass filenames instead or attach your own etags and provide a proper mimetype by hand.\n• None Static file handling for modules now requires the name of the static folder to be supplied explicitly. The previous autodetection was not reliable and caused issues on Google’s App Engine. Until 1.0 the old behavior will continue to work but issue dependency warnings.\n• None Fixed a problem for Flask to run on jython.\n• None Added a configuration variable that can be used to flip the setting of exception propagation which previously was linked to alone and is now linked to either or .\n• None Flask no longer internally depends on rules being added through the function and can now also accept regular werkzeug rules added to the url map.\n• None Added an method to the flask application object which allows one to register a callback to an arbitrary endpoint with a decorator.\n• None Use Last-Modified for static file sending instead of Date which was incorrectly introduced in 0.6.\n• None Added decorator, for functions that should run at the end of a request regardless of whether an exception occurred. Also the behavior for was changed. It’s now no longer executed when an exception is raised.\n• None Deprecated . Override the method instead to achieve the same functionality.\n• None The automatic JSON request data unpacking now looks at the charset mimetype parameter.\n• None Don’t modify the session on if there are no messages in the session.\n• None handlers are now able to abort requests with errors.\n• None It is not possible to define user exception handlers. That way you can provide custom error messages from a central hub for certain errors that might occur during request processing (for instance database connection errors, timeouts from remote resources etc.)."
    },
    {
        "link": "https://cloud.google.com/video-intelligence/docs",
        "document": "The Video Intelligence API allows developers to use Google video analysis technology as part of their applications. The REST API enables users to annotate videos stored locally or in Cloud Storage, or live-streamed, with contextual information at the level of the entire video, per segment, per shot, and per frame. Learn more"
    },
    {
        "link": "https://api.video",
        "document": "Get a safehouse for all your AI generated videos\n\nGenerative AI Get a safehouse for all your AI generated videos\n\nIntegrate on-demand or live-stream videos into your website, software, or app in just minutes and let built-in AI features maximize their impact.\n\nWhether you are building an online learning platform, short-form video content, e-commerce site, or anything in between, add high-quality videos and low-latency live streams to any section of your website and app in minutes.\n\nAll-in-one developer platform to handle all your videos Get started with low-code integrations, plugins, or API clients Bring any video format and we will encode to make it work on any screen Use the video player to distribute videos and streams, and track engagement\n\nClick “Run Demo” to see how fast you can upload and encode a video. Edit the video URL to test the encoding speed of a video of your choice. The response will show here\n\nEmbrace simplicity and efficiency—no more juggling multiple APIs or external services for AI! Now, with just one API call, you can get instant AI transcription and summarization for all your videos hosted on our platform.\n\nDeliver videos anywhere, wherever your users are Our infrastructure handles heavy loads and scales in real time to meet your needs. Deliver video anywhere in the world with our robust CDN.\n\n60,000 developers, and digital agencies are building on api.video We were losing clients initially because of issues in the upload of videos. After having api.video onboard, the drop rate came down by 99% which was a great thing for our business. The api.video team was very helpful during the implementation. I felt like the whole api.video team was on the other side working to fix a problem and get rid of an issue on the same day! With api.video, I could just put my credit card, put my email, invite my team, make the implementation and go to production - it was that simple. Their documentation is super clear. As a CTO, it was a magical point for our business."
    },
    {
        "link": "https://wowza.com/blog/video-api",
        "document": "For anyone looking to build video functionality into their products or services, a video API is a great place to start. As an essential tool in any developer’s toolkit, APIs deliver the flexibility required to develop advanced applications. Video APIs also hide the complexity of content processing and distribution — making it easy to get started streaming without extensive video expertise.\n\nWatch the video above or keep reading to learn more.\n\nWhat Is an API?\n\nAn API, or an application programming interface, is a set of methods for performing tasks within a service or system using code. APIs accomplish these tasks by interacting with other software.\n\nBy doing so programmatically rather than through a graphical user interface (UI), APIs give unparalleled control and flexibility when building applications. This makes it easy to customize the products you’re building and integrate external services.\n\nA video streaming API is one that’s specifically designed to access a video streaming platform like Wowza. Video APIs support a wide range of functionality for creating, customizing, and controlling workflows from encode through playback. This allows developers to get video into the system, process it, configure security options, deliver content to end users, manage recorded assets, and view analytics across the workflow.\n\nWhile many video platforms also provide management capabilities via a UI, this doesn’t provide the same level of control and customization as an API. That’s because user interfaces often constrain developers to predefined tools and vendors, thus limiting access to more advanced configurations.\n\nFor instance, your video content management system (CMS) might come with simple analytics, but what if you’d prefer to gain more advanced insight? With an API, you’re able to pick and choose external services and functionality to integrate into your application — meaning that you aren’t tied to the specific analytics tool offered. API access to the raw data would also allow you to customize how the analytics is presented.\n\nPart of the beauty of an API lies in the fact that you don’t need to understand how it works.\n\nA lot goes on in the background when streaming live and video on demand (VOD) assets. The data must be encoded, packaged, and often transcoded for delivery to a variety of endpoints. With a video API, you’re able to accomplish all of these tasks and more without getting into the weeds.\n\nThat’s because a well-designed video API hides the intricacies of streaming media, while allowing you to quickly build applications with as much oversight as you’d like.\n\nThink of an API like a menu in a restaurant. The menu provides a list of items you can order and a brief description of each item. When you specify what menu items you want, the kitchen prepares your order and provides you with your dish. You don’t know exactly how the kitchen prepares that food, but you don’t need to know that to enjoy it.\n\nBy obscuring the complexity behind the scenes, video APIs take care of the technical heavy lifting. That way, developers are able to focus on the product they’re building — without doing everything from scratch.\n\nVideo APIs are often organized into categories such as live streaming, content management, and analytics, with distinct functions for each area. This allows developers to navigate documentation and examples more easily, while still allowing the use of all categories in their application as needed.\n\nAt Wowza, we provide API examples for the following workflows and tasks, with more to come:\n\nAPIs can also be differentiated by architecture style or language. One common style is REST. A REST or RESTful API conforms to the constraints of the Representational State Transfer architectural style. This describes an architectural structure that is resource-based, allowing interoperability between computer systems on the internet.\n\nIn its simplest form, REST dictates that the server only act on requests currently being made — without maintaining a ‘session’ or knowledge of previous requests. Although a REST service can be delivered over any protocol, the majority are delivered over HTTP. This makes implementation much simpler, as most developers have a general knowledge of the tools available to manage HTTP connections. REST APIs thus use standard HTTP request methods to create (PUT, POST), read (GET), update (PATCH), and delete (DELETE) resources.\n\nWhat to Look For in a Video API\n\nWhen choosing a video API, you should look for a solution that meets the needs of your workflow first and foremost. You’ll also want to make sure the API has complete documentation that updates with any API changes, and a good set of examples to walk you through simple workflows, ideally written in several languages.\n\nSpecifically, you’ll want to find a video API that offers:\n• Comprehensive functionality across the entire video streaming workflow, including live streaming, VOD, playback, and more. For this, your best bet is going with an integrated video platform.\n• Informational resources, including documentation, forums, and video tutorials for getting started quickly.\n• Developer tools, such as sample code, GitHub repositories, custom modules, and testing tools for streamlining the process.\n\nWhat the Wowza Video API Makes Possible\n\nWith Wowza Video, we’ve integrated all the functionality you need to build the video applications your business needs into a single, robust platform. The cloud-based solution delivers powerful features at every stage — with API coverage across the workflow.\n\nCurious about what the Wowza Video API is capable of and want to try it for yourself? Our video API is publicly available on GitHub and Postman so you can experiment and come up with ideas of what you want your video platform to look like in the process.\n\nCheck out these tutorials to get started using our video API features:\n\nLearn how to start and end a live stream, how to find important information about your stream (such as stream health, metadata, analytics, and more), and understand Wowza Video’s token-based system.\n\nWant to record your live streams so you can repurpose them later as VOD content? Find out how in this tutorial, as well as how to set custom stream targets and understand the difference between a recorder ID and a transcoder ID.\n\nOnce you’ve watched sessions one and two, session three will teach you about making more complicated changes to your stream with the Wowza Video platform API, scheduling, looping, and how to minimize both latency and risk of buffering.\n\nWebRTC isn’t just a protocol; it’s also a collection of JavaScript video APIs and other standards that make it the lowest-latency streaming framework out there. Unfortunately, one of WebRTC’s disadvantages is that it doesn’t scale very well — unless you use a streaming service with a custom CDN like Wowza Video to reach a million viewers instead of only a few dozen. Watch this tutorial to see how you can use WebRTC for both first and last-mile delivery alongside Wowza’s Real-Time Streaming at Scale feature.\n\nIf you produce a lot of streams and turn them into VOD content, this tutorial will teach you how to manage all your video assets, organize and search through your library, add tags, and retrieve essential file details without hassle.\n\nNow that your streams are up and going, dive into everything you can learn from their technical and social performances to make them better. How many people are watching, and where are they located? What are your stream health metrics? When is it necessary to adjust the bitrate? You can answer all of these questions with Wowza’s powerful API for video.\n\nReady to get started using the most robust video API around? You can sign up for a free trial and check out the full instructions for using the Wowza Video API in our reference documentation."
    },
    {
        "link": "https://developers.tiktok.com/doc/tiktok-api-v1-video-query?enter_method=left_navigation",
        "document": "There is a new version of this API available in TikTok API v2: Query Videos\n\nThe endpoint, given a user and a list of video ids, can check if the videos belong to the requesting user and fetch the data of videos belonging to the user. It can be used to refresh the given videos' cover image url TTL. Number of video ids should not be larger than 20 at a time.\n\nThe token that bears the authorization of the TikTok user, which is obtained through /oauth/access_token/."
    },
    {
        "link": "https://mux.com/docs/api-reference/video/assets",
        "document": ""
    }
]