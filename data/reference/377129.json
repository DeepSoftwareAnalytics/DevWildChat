[
    {
        "link": "https://pygame.org/docs",
        "document": "Welcome to pygame! Once you've got pygame installed ( or for most people), the next question is how to get a game loop running. Pygame, unlike some other libraries, gives you full control of program execution. That freedom means it is easy to mess up in your initial steps.\n\nHere is a good example of a basic setup (opens the window, updates the screen, and handles events)--\n\nHere is a slightly more fleshed out example, which shows you how to move something (a circle in this case) around on screen--\n\nFor more in depth reference, check out the Tutorials section below, check out a video tutorial (I'm a fan of this one), or reference the API documentation by module."
    },
    {
        "link": "https://pygame.org/docs/ref/display.html",
        "document": "This module offers control over the pygame display. Pygame has a single display Surface that is either contained in a window or runs full screen. Once you create the display you treat it as a regular Surface. Changes are not immediately visible onscreen; you must choose one of the two flipping functions to update the actual display.\n\nThe origin of the display, where x = 0 and y = 0, is the top left of the screen. Both axes increase positively towards the bottom right of the screen.\n\nThe pygame display can actually be initialized in one of several modes. By default, the display is a basic software driven framebuffer. You can request special modules like automatic scaling or OpenGL support. These are controlled by flags passed to .\n\nPygame can only have a single display active at any time. Creating a new one with will close the previous display. To detect the number and size of attached screens, you can use and then select appropriate window size and display index to pass to .\n\nFor backward compatibility allows precise control over the pixel format or display resolutions. This used to be necessary with old graphics cards and CRT screens, but is usually not needed any more. Use the functions , , and to query detailed information about the display.\n\nOnce the display Surface is created, the functions from this module affect the single existing display. The Surface becomes invalid if the module is uninitialized. If a new display mode is set, the existing Surface will automatically switch to operate on the new display.\n\nWhen the display mode is set, several events are placed on the pygame event queue. is sent when the user has requested the program to shut down. The window will receive events as the display gains and loses input focus. If the display is set with the flag, events will be sent when the user adjusts the window dimensions. Hardware displays that draw direct to the screen will get events when portions of the window must be redrawn.\n\nA new windowevent API was introduced in pygame 2.0.1. Check event module docs for more information on that\n\nSome display environments have an option for automatically stretching all windows. When this option is enabled, this automatic stretching distorts the appearance of the pygame window. In the pygame examples directory, there is example code (prevent_display_stretching.py) which shows how to disable this automatic stretching of the pygame display on Microsoft Windows (Vista or newer required).\n\nThis function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system. Note that calling this function implicitly initializes , if it was not initialized before. The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color. The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor. If no size is passed or is set to and pygame uses version 1.2.10 or above, the created Surface will have the same size as the current screen resolution. If only the width or height are set to , the Surface will have the same width or height as the screen resolution. Using a version prior to 1.2.10 will raise an exception. It is usually best to not pass the depth argument. It will default to the best and fastest color depth for the system. If your game requires a specific color format you can control the depth with this argument. Pygame will emulate an unavailable color depth which can be slow. When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size. On high resolution displays(4k, 1080p) and tiny graphics games (640x480) show up very small so that they are unplayable. SCALED scales up the window for you. The game thinks it's a 640x480 window, but really it can be bigger. Mouse events are scaled for you, so your game doesn't need to do it. Note that SCALED is considered an experimental API and may change in future releases. The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe \"|\" character). Here are the display flags you will want to choose from: New in pygame 2.0.0: , and By setting the parameter to , it is possible to get a display with vertical sync, but you are not guaranteed to get one. The request only works at all for calls to with the or flags set, and is still not guaranteed even with one of those set. What you get depends on the hardware and driver configuration of the system pygame is running on. Here is an example usage of a call to that may give you a display with vsync: Vsync behaviour is considered experimental, and may change in future releases. The display index means the default display is used. If no display index argument is provided, the default display can be overridden with an environment variable. Changed in pygame 2.1.3: pygame now ensures that subsequent calls to this function clears the window to black. On older versions, this was an implementation detail on the major platforms this function was tested with."
    },
    {
        "link": "https://pygame.org/docs/ref/surface.html",
        "document": "A pygame Surface is used to represent any image. The Surface has a fixed resolution and pixel format. Surfaces with 8-bit pixels use a color palette to map to 24-bit color.\n\nCall pygame object for representing images to create a new image object. The Surface will be cleared to all black. The only required arguments are the sizes. With no additional arguments, the Surface will be created in a format that best matches the display Surface.\n\nThe pixel format can be controlled by passing the bit depth or an existing Surface. The flags argument is a bitmask of additional features for the surface. You can pass any combination of these flags:\n\nBoth flags are only a request, and may not be possible for all displays and formats.\n\nAdvance users can combine a set of bitmasks with a depth value. The masks are a set of 4 integers representing which bits in a pixel will represent each color. Normal Surfaces should not require the masks argument.\n\nSurfaces can have many extra attributes like alpha planes, colorkeys, source rectangle clipping. These functions mainly effect how the Surface is blitted to other Surfaces. The blit routines will attempt to use hardware acceleration when possible, otherwise they will use highly optimized software blitting methods.\n\nThere are three types of transparency supported in pygame: colorkeys, surface alphas, and pixel alphas. Surface alphas can be mixed with colorkeys, but an image with per pixel alphas cannot use the other modes. Colorkey transparency makes a single color value transparent. Any pixels matching the colorkey will not be drawn. The surface alpha value is a single value that changes the transparency for the entire image. A surface alpha of 255 is opaque, and a value of 0 is completely transparent.\n\nPer pixel alphas are different because they store a transparency value for every pixel. This allows for the most precise transparency effects, but it also the slowest. Per pixel alphas cannot be mixed with surface alpha and colorkeys.\n\nThere is support for pixel access for the Surfaces. Pixel access on hardware surfaces is slow and not recommended. Pixels can be accessed using the and functions. These methods are fine for simple access, but will be considerably slow when doing of pixel work with them. If you plan on doing a lot of pixel level work, it is recommended to use a pygame object for direct pixel access of surfaces, which gives an array like view of the surface. For involved mathematical manipulations try the pygame module for accessing surface pixel data using array interfaces module (It's quite quick, but requires NumPy.)\n\nAny functions that directly access a surface's pixel data will need that surface to be lock()'ed. These functions can and the surfaces themselves without assistance. But, if a function will be called many times, there will be a lot of overhead for multiple locking and unlocking of the surface. It is best to lock the surface manually before making the function call many times, and then unlocking when you are finished. All functions that need a locked surface will say so in their docs. Remember to leave the Surface locked only while necessary.\n\nSurface pixels are stored internally as a single number that has all the colors encoded into it. Use the and to convert between individual red, green, and blue values into a packed integer for that Surface.\n\nSurfaces can also reference sections of other Surfaces. These are created with the method. Any change to either Surface will effect the other.\n\nEach Surface contains a clipping area. By default the clip area covers the entire Surface. If it is changed, all drawing operations will only effect the smaller area.\n\nreturns a copy of the surface with the RGB channels pre-multiplied by the alpha channel. Experimental: feature still in development available for testing and feedback. It may change. Please leave premul_alpha feedback with authors Returns a copy of the initial surface with the red, green and blue color channels multiplied by the alpha channel. This is intended to make it easier to work with the BLEND_PREMULTIPLED blend mode flag of the blit() method. Surfaces which have called this method will only look correct after blitting if the BLEND_PREMULTIPLED special flag is used. It is worth noting that after calling this method, methods that return the colour of a pixel such as get_at() will return the alpha multiplied colour values. It is not possible to fully reverse an alpha multiplication of the colours in a surface as integer colour channel data is generally reduced by the operation (e.g. 255 x 0 = 0, from there it is not possible to reconstruct the original 255 from just the two remaining zeros in the colour and alpha channels). If you call this method, and then call it again, it will multiply the colour channels by the alpha channel twice. There are many possible ways to obtain a surface with the colour channels pre-multiplied by the alpha channel in pygame, and it is not possible to tell the difference just from the information in the pixels. It is completely possible to have two identical surfaces - one intended for pre-multiplied alpha blending and one intended for normal blending. For this reason we do not store state on surfaces intended for pre-multiplied alpha blending. Surfaces without an alpha channel cannot use this method and will return an error if you use it on them. It is best used on 32 bit surfaces (the default on most platforms) as the blitting on these surfaces can be accelerated by SIMD versions of the pre-multiplied blitter. In general pre-multiplied alpha blitting is faster then 'straight alpha' blitting and produces superior results when blitting an alpha surface onto another surface with alpha - assuming both surfaces contain pre-multiplied alpha colours."
    },
    {
        "link": "https://pygame.org/docs/tut/newbieguide.html",
        "document": "The most important thing is to feel confident using python. Learning something as potentially complicated as graphics programming will be a real chore if you're also unfamiliar with the language you're using. Write a few sizable non-graphical programs in python -- parse some text files, write a guessing game or a journal-entry program or something. Get comfortable with string and list manipulation -- know how to split, slice and combine strings and lists. Know how works -- try writing a program that is spread across several source files. Write your own functions, and practice manipulating numbers and characters; know how to convert between the two. Get to the point where the syntax for using lists and dictionaries is second-nature -- you don't want to have to run to the documentation every time you need to slice a list or sort a set of keys. Get comfortable using file paths -- this will come in handy later when you start loading assets and creating save files. Resist the temptation to ask for direct help online when you run into trouble. Instead, fire up the interpreter and play with the problem for a few hours, or use print statements and debugging tools to find out what's going wrong in your code. Get into the habit of looking things up in the official Python documentation, and Googling error messages to figure out what they mean.\n\nPete Shinners' wrapper may have cool alpha effects and fast blitting speeds, but I have to admit my favorite part of pygame is the lowly class. A rect is simply a rectangle -- defined only by the position of its top left corner, its width, and its height. Many pygame functions take rects as arguments, and they also take 'rectstyles', a sequence that has the same values as a rect. So if I need a rectangle that defines the area between 10, 20 and 40, 50, I can do any of the following: For example, suppose I'd like to get a list of all the sprites that contain a point (x, y) -- maybe the player clicked there, or maybe that's the current location of a bullet. It's simple if each sprite has a .rect member -- I just do: Rects have no other relation to surfaces or graphics functions, other than the fact that you can use them as arguments. You can also use them in places that have nothing to do with graphics, but still need to be defined as rectangles. Every project I discover a few new places to use rects where I never thought I'd need them.\n\nThe second method uses the SDL event queue. This queue is a list of events -- events are added to the list as they're detected, and they're deleted from the queue as they're read off. In the queue system, however, each keypress arrives in the queue as a completely separate event, so you'd need to remember that the key was down, and hadn't come up yet, while checking for the key. A little more complicated. The lesson is: choose the system that meets your requirements. If you don't have much going on in your loop -- say you're just sitting in a loop, waiting for input, use or another state function; the latency will be lower. On the other hand, if every keypress is crucial, but latency isn't as important -- say your user is typing something in an editbox, use the event queue. Some key presses may be slightly late, but at least you'll get them all."
    },
    {
        "link": "https://readthedocs.org/projects/pygame/downloads/pdf/latest",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/22765525/pygame-economic-way-of-handling-game-loops",
        "document": "The only thing that you can do is to block events that you are not going to use:\n\nThis will only post events such as and onto the queue.\n\nIf there are no new key presses, there is nothing in the event queue, so the loop is not executed.\n\nAs sshashhank124 said in the comments, you can also slow the the main loop, by calling\n\nThis will cause pygame to sleep for some time so that the method tick will be called frames times per second."
    },
    {
        "link": "https://pygame.org/docs/tut/newbieguide.html",
        "document": "The most important thing is to feel confident using python. Learning something as potentially complicated as graphics programming will be a real chore if you're also unfamiliar with the language you're using. Write a few sizable non-graphical programs in python -- parse some text files, write a guessing game or a journal-entry program or something. Get comfortable with string and list manipulation -- know how to split, slice and combine strings and lists. Know how works -- try writing a program that is spread across several source files. Write your own functions, and practice manipulating numbers and characters; know how to convert between the two. Get to the point where the syntax for using lists and dictionaries is second-nature -- you don't want to have to run to the documentation every time you need to slice a list or sort a set of keys. Get comfortable using file paths -- this will come in handy later when you start loading assets and creating save files. Resist the temptation to ask for direct help online when you run into trouble. Instead, fire up the interpreter and play with the problem for a few hours, or use print statements and debugging tools to find out what's going wrong in your code. Get into the habit of looking things up in the official Python documentation, and Googling error messages to figure out what they mean.\n\nPete Shinners' wrapper may have cool alpha effects and fast blitting speeds, but I have to admit my favorite part of pygame is the lowly class. A rect is simply a rectangle -- defined only by the position of its top left corner, its width, and its height. Many pygame functions take rects as arguments, and they also take 'rectstyles', a sequence that has the same values as a rect. So if I need a rectangle that defines the area between 10, 20 and 40, 50, I can do any of the following: For example, suppose I'd like to get a list of all the sprites that contain a point (x, y) -- maybe the player clicked there, or maybe that's the current location of a bullet. It's simple if each sprite has a .rect member -- I just do: Rects have no other relation to surfaces or graphics functions, other than the fact that you can use them as arguments. You can also use them in places that have nothing to do with graphics, but still need to be defined as rectangles. Every project I discover a few new places to use rects where I never thought I'd need them.\n\nThe second method uses the SDL event queue. This queue is a list of events -- events are added to the list as they're detected, and they're deleted from the queue as they're read off. In the queue system, however, each keypress arrives in the queue as a completely separate event, so you'd need to remember that the key was down, and hadn't come up yet, while checking for the key. A little more complicated. The lesson is: choose the system that meets your requirements. If you don't have much going on in your loop -- say you're just sitting in a loop, waiting for input, use or another state function; the latency will be lower. On the other hand, if every keypress is crucial, but latency isn't as important -- say your user is typing something in an editbox, use the event queue. Some key presses may be slightly late, but at least you'll get them all."
    },
    {
        "link": "https://medium.com/@moraneus/exploring-game-development-with-pygame-a-beginners-guide-58115caf9553",
        "document": "If you’re interested in game development and looking for a place to start, Pygame is an excellent choice. It’s a Python library designed to make creating games straightforward by providing the ability to handle graphics, sounds, and input devices. Whether you’re a hobbyist looking to create your first game or an experienced developer aiming to prototype ideas quickly, Pygame offers the tools necessary for building engaging games.\n\nPygame is a set of Python modules designed for writing video games. It includes computer graphics and sound libraries designed to be used with the Python programming language. Pygame simplifies tasks like drawing images on the screen and playing sound effects, making it ideal for beginners. However, don’t let its simplicity fool you; Pygame is powerful enough to support complex projects and is widely used in the game development community.\n• Audio: Add background music and sound effects to increase the immersion of your games.\n• Input Handling: Respond to keyboard strokes, mouse movements, and other input actions.\n• Sprite Management: Use Pygame’s built-in Sprite classes to manage your game objects efficiently.\n\nLet’s break down a simple game script where a friendly dinosaur must jump over obstacles against a scrolling background. This example will help illustrate how to structure a game in Pygame.\n\nThe following code illustrates the basic structure of a Pygame program, handling initialization, game loop, event processing, game mechanics, drawing, and cleanup. It’s a great starting point for beginners to understand how to make interactive games using Pygame.\n\nLet’s break down this code to understand how it sets up and runs a simple Pygame application featuring a jumping dinosaur game.\n\nHere, we start by importing the library, which provides all the necessary functions to create and run games. The function initializes all the pygame modules that need initialization, and it must be called before any other pygame functions.\n\nThese lines configure the main window or screen for the game:\n• and set the dimensions of the game window.\n• is a Pygame display Surface representing the visible part of the window.\n• sets the caption text of the window.\n• and are RGB color definitions used later for drawing.\n• Dinosaur and obstacle dimensions and positions are defined here.\n• is the initial jump speed for the dinosaur.\n• applies gravity to the dinosaur when it jumps.\n• defines how fast the obstacle moves towards the dinosaur.\n• is used to manage how fast the game updates (frame rate).\n• The variable controls the game loop. The loop continues as long as is .\n\nThis block listens for events: if the window’s close button is clicked, or if the space bar is pressed to make the dinosaur jump.\n\nThese lines update the dinosaur’s vertical position, applying gravity to simulate falling and resetting the jump speed when the dinosaur hits the ground.\n\nThe obstacle’s horizontal position is updated, moving it left across the screen. If it goes off-screen, it’s repositioned to the right edge.\n\nThis checks if the dinosaur intersects with the obstacle. If so, it ends the game by setting to .\n\nThese commands clear the screen and redraw the dinosaur and obstacle in their new positions.\n• updates the full display Surface to the screen.\n• limits the game to 60 frames per second.\n\nThis ensures that Pygame shuts down cleanly when the game loop ends.\n\nIn this code example, I’ve incorporated several advanced techniques that significantly enhance the player’s experience. To bring the game to life, I introduced animated dinosaur sprites that make it appear as though the dinosaur is walking. Additionally, I used a variety of graphical obstacles and different background images that scroll to create a sense of movement, adding depth and interest to the game’s visual appeal. A scoreboard is prominently displayed, providing real-time feedback on player performance and increasing the competitive element of the game. To elevate the challenge, the game progressively becomes harder by increasing the speed of the obstacles as the player’s score climbs. These enhancements not only improve the aesthetic and interactive quality of the game but also make it more engaging and challenging for players.\n\nimport pygame\n\nimport random\n\nimport os\n\nfrom typing import List\n\n\n\n# Initialize Pygame\n\npygame.init()\n\n\n\n# Set up the game window\n\nSCREEN_WIDTH = 1200\n\nSCREEN_HEIGHT = 600\n\n\n\n# Dino params\n\nDINO_START_X = 50\n\nDINO_START_Y_OFFSET = 10\n\nDINO_JUMP_SPEED = -15\n\nDINO_GRAVITY = 0.8\n\n\n\n# Obstacle params\n\nINITIAL_OBSTACLE_SPEED = 5\n\nSPEED_INCREASE_FACTOR = 1.05\n\nOBSTACLE_SPAWN_DELAY_MIN = 50\n\nOBSTACLE_SPAWN_DELAY_MAX = 150\n\n\n\n# Background details\n\nBACKGROUND_TRANSITION_SPEED = 5\n\nWHITE = (255, 255, 255)\n\nBLACK = (0, 0, 0)\n\n\n\n\n\nclass Dinosaur(pygame.sprite.Sprite):\n\n \"\"\"A class to represent the dinosaur character.\"\"\"\n\n\n\n def __init__(self, images: List[pygame.Surface]):\n\n \"\"\"Initialize the dinosaur.\"\"\"\n\n super().__init__()\n\n self.images = images\n\n self.image = images[0] # Set the initial image\n\n self.rect = self.image.get_rect()\n\n self.rect.x = DINO_START_X\n\n self.rect.y = SCREEN_HEIGHT - self.rect.height - DINO_START_Y_OFFSET\n\n self.jump_speed = 0\n\n self.frame = 0\n\n self.frame_count = 0\n\n\n\n def update(self):\n\n \"\"\"Update the dinosaur's position and handle jumping.\"\"\"\n\n self.jump_speed += DINO_GRAVITY\n\n self.rect.y += self.jump_speed\n\n\n\n # Keep the dinosaur on the ground\n\n if self.rect.y > SCREEN_HEIGHT - self.rect.height - DINO_START_Y_OFFSET:\n\n self.rect.y = SCREEN_HEIGHT - self.rect.height - DINO_START_Y_OFFSET\n\n self.jump_speed = 0\n\n\n\n # Update the animation frame\n\n self.frame_count += 1\n\n if self.frame_count % 10 == 0:\n\n self.frame = (self.frame + 1) % len(self.images)\n\n self.image = self.images[self.frame]\n\n\n\n def jump(self):\n\n \"\"\"Make the dinosaur jump.\"\"\"\n\n if self.rect.y == SCREEN_HEIGHT - self.rect.height - DINO_START_Y_OFFSET:\n\n self.jump_speed = DINO_JUMP_SPEED\n\n\n\n\n\nclass Obstacle(pygame.sprite.Sprite):\n\n \"\"\"A class to represent an obstacle.\"\"\"\n\n\n\n def __init__(self, image: pygame.Surface, speed: int):\n\n \"\"\"Initialize the obstacle.\"\"\"\n\n super().__init__()\n\n self.image = image\n\n self.rect = self.image.get_rect()\n\n self.rect.x = SCREEN_WIDTH\n\n self.rect.y = SCREEN_HEIGHT - self.rect.height\n\n self.speed = speed\n\n self.passed = False\n\n\n\n def update(self):\n\n \"\"\"Update the obstacle's position.\"\"\"\n\n self.rect.x -= self.speed\n\n if self.rect.right < 0:\n\n self.kill()\n\n\n\n\n\nclass Background:\n\n \"\"\"A class to represent the scrolling background.\"\"\"\n\n\n\n def __init__(self, images: List[pygame.Surface]):\n\n \"\"\"Initialize the background.\"\"\"\n\n self.images = images\n\n self.current_image = random.choice(self.images)\n\n self.next_image = None\n\n self.x = 0\n\n self.transition_alpha = 0\n\n self.changed = False\n\n\n\n def update(self, score: int):\n\n \"\"\"Update the background and handle transitions.\"\"\"\n\n # Check if it's time to change the background\n\n if score > 0 and score % 10 == 0 and not self.changed:\n\n self.next_image = random.choice([image for image in self.images if image != self.current_image])\n\n self.transition_alpha = 0\n\n self.changed = True\n\n\n\n # Update the background transition\n\n if self.next_image is not None:\n\n self.transition_alpha += BACKGROUND_TRANSITION_SPEED\n\n if self.transition_alpha >= 255:\n\n self.current_image = self.next_image\n\n self.next_image = None\n\n self.changed = False\n\n\n\n # Scroll the background\n\n self.x -= 2\n\n if self.x <= -self.current_image.get_width():\n\n self.x = 0\n\n\n\n def draw(self, screen: pygame.Surface):\n\n \"\"\"Draw the background on the screen.\"\"\"\n\n screen.blit(self.current_image, (self.x, 0))\n\n screen.blit(self.current_image, (self.x + self.current_image.get_width(), 0))\n\n if self.next_image is not None:\n\n self.next_image.set_alpha(self.transition_alpha)\n\n screen.blit(self.next_image, (self.x, 0))\n\n screen.blit(self.next_image, (self.x + self.next_image.get_width(), 0))\n\n\n\n\n\nclass Game:\n\n \"\"\"A class to handle the game loop and manage game objects.\"\"\"\n\n\n\n def __init__(self):\n\n \"\"\"Initialize the game.\"\"\"\n\n self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n\n pygame.display.set_caption(\"Dino Game\")\n\n self.clock = pygame.time.Clock()\n\n self.font = pygame.font.Font(None, 36)\n\n self.score = 0\n\n self.obstacle_speed = INITIAL_OBSTACLE_SPEED\n\n self.obstacle_spawn_timer = 0\n\n\n\n # Load and scale the dinosaur images\n\n dino_files = [file for file in os.listdir(\"dino\") if file.endswith(\".png\")]\n\n dino_images = [\n\n pygame.transform.scale(\n\n pygame.image.load(os.path.join(\"dino\", file)), (40, 60)) for file in dino_files\n\n ]\n\n self.dinosaur = Dinosaur(dino_images)\n\n\n\n # Load obstacle images\n\n obstacle_files = [file for file in os.listdir(\"obstacles\") if file.endswith(\".png\")]\n\n self.obstacle_images = [pygame.image.load(os.path.join(\"obstacles\", file)) for file in obstacle_files]\n\n\n\n # Load background images\n\n background_files = [\n\n file for file in os.listdir(\"backgrounds\") if file.endswith((\".jpg\", \".png\"))\n\n ]\n\n background_images = [pygame.image.load(os.path.join(\"backgrounds\", file)) for file in background_files]\n\n self.background = Background(background_images)\n\n\n\n self.obstacles = pygame.sprite.Group()\n\n self.all_sprites = pygame.sprite.Group(self.dinosaur)\n\n\n\n def spawn_obstacles(self):\n\n \"\"\"Spawn obstacles at random intervals.\"\"\"\n\n if self.obstacle_spawn_timer <= 0 and self.obstacle_images:\n\n obstacle_image = random.choice(self.obstacle_images)\n\n obstacle_width, obstacle_height = random.randint(20, 50), random.randint(30, 90)\n\n obstacle_image = pygame.transform.scale(obstacle_image, (obstacle_width, obstacle_height))\n\n obstacle = Obstacle(obstacle_image, self.obstacle_speed)\n\n self.obstacles.add(obstacle)\n\n self.all_sprites.add(obstacle)\n\n self.obstacle_spawn_timer = random.randint(OBSTACLE_SPAWN_DELAY_MIN, OBSTACLE_SPAWN_DELAY_MAX)\n\n\n\n self.obstacle_spawn_timer -= 1\n\n\n\n def update_score(self):\n\n \"\"\"Update the score and increase obstacle speed.\"\"\"\n\n for obstacle in self.obstacles:\n\n if self.dinosaur.rect.right > obstacle.rect.right and not obstacle.passed:\n\n self.score += 1\n\n obstacle.passed = True\n\n\n\n # Update obstacle speed based on score\n\n if self.score > 0 and self.score % 10 == 0:\n\n self.obstacle_speed = INITIAL_OBSTACLE_SPEED * (SPEED_INCREASE_FACTOR ** (self.score // 10))\n\n\n\n def check_collisions(self) -> bool:\n\n \"\"\"Check for collisions between the dinosaur and obstacles.\"\"\"\n\n return bool(pygame.sprite.spritecollide(self.dinosaur, self.obstacles, dokill=False))\n\n\n\n def game_over_screen(self) -> bool:\n\n \"\"\"Display the game over screen and handle user input.\"\"\"\n\n game_over_text = self.font.render(\"GAME OVER\", True, BLACK)\n\n game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))\n\n\n\n continue_text = self.font.render(\"Press 'C' to Continue or 'Q' to Quit\", True, BLACK)\n\n continue_rect = continue_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))\n\n\n\n while True:\n\n for event in pygame.event.get():\n\n if event.type == pygame.QUIT:\n\n pygame.quit()\n\n quit()\n\n elif event.type == pygame.KEYDOWN:\n\n if event.key == pygame.K_c:\n\n self.reset_game()\n\n return True\n\n elif event.key == pygame.K_q:\n\n return False\n\n\n\n self.screen.fill(WHITE)\n\n self.screen.blit(game_over_text, game_over_rect)\n\n self.screen.blit(continue_text, continue_rect)\n\n pygame.display.flip()\n\n\n\n def reset_game(self):\n\n \"\"\"Reset the game to its initial state.\"\"\"\n\n self.score = 0\n\n self.obstacle_speed = INITIAL_OBSTACLE_SPEED\n\n self.obstacle_spawn_timer = 0\n\n\n\n self.dinosaur.rect.x = DINO_START_X\n\n self.dinosaur.rect.y = SCREEN_HEIGHT - self.dinosaur.rect.height - DINO_START_Y_OFFSET\n\n self.dinosaur.jump_speed = 0\n\n self.dinosaur.frame = 0\n\n self.dinosaur.frame_count = 0\n\n\n\n self.obstacles.empty()\n\n self.all_sprites.empty()\n\n self.all_sprites.add(self.dinosaur)\n\n\n\n self.background.current_image = random.choice(self.background.images)\n\n self.background.next_image = None\n\n self.background.x = 0\n\n self.background.transition_alpha = 0\n\n\n\n def run(self):\n\n \"\"\"Run the game loop.\"\"\"\n\n while True:\n\n for event in pygame.event.get():\n\n if event.type == pygame.QUIT:\n\n pygame.quit()\n\n quit()\n\n elif event.type == pygame.KEYDOWN:\n\n if event.key == pygame.K_SPACE:\n\n self.dinosaur.jump()\n\n\n\n self.screen.fill(WHITE)\n\n self.background.update(self.score)\n\n self.background.draw(self.screen)\n\n\n\n self.spawn_obstacles()\n\n self.all_sprites.update()\n\n self.update_score()\n\n\n\n if self.check_collisions():\n\n if not self.game_over_screen():\n\n break\n\n\n\n self.all_sprites.draw(self.screen)\n\n score_text = self.font.render(f\"Score: {self.score}\", True, BLACK)\n\n self.screen.blit(score_text, (10, 10))\n\n\n\n pygame.display.flip()\n\n self.clock.tick(60)\n\n\n\n pygame.quit()\n\n\n\n\n\n# Start the game\n\nif __name__ == \"__main__\":\n\n game = Game()\n\n game.run()\n\nThis section imports necessary libraries ( , , , and typing for annotations) and initializes Pygame. It sets up the game window dimensions (1200x600 pixels).\n\nDefines various constants used throughout the game such as starting position, jump mechanics for the dinosaur, obstacle behavior, and visual details like background transitions and colors.\n\nDefines a class inheriting from . This class manages the dinosaur's image, position, and jumping logic. The dinosaur's behavior, such as gravity effects and sprite animation, is handled within this class.\n\nDefines an class similar to the class but focused on obstacle behavior. It manages obstacle images, position, and movement across the screen, destroying itself if it moves past the screen (left edge).\n\nManages the game’s background. It supports scrolling and transitioning between different backgrounds based on the game’s score.\n\nThe class sets up the main game environment. It initializes the screen, loads images, and prepares sprite groups. The game's main components—such as the dinosaur, obstacles, and background—are instantiated here.\n\nContains the main game loop where continuous checks for events (like quitting the game or pressing keys) occur. This method handles game updates such as moving sprites, collision detection, and drawing elements on the screen.\n\nThese methods manage the game’s logic for detecting collisions between the dinosaur and obstacles, displaying a game over screen, and resetting the game to its initial state if the player chooses to continue.\n\nThis is the entry point of the script. It checks if the script is being run directly (not imported) and, if so, creates an instance of the class and starts the game loop.\n\nThe full code is available here.\n\nDeveloping “Dino Dash: A Pygame Adventure” demonstrates the versatility and power of Pygame as a tool for creating engaging and visually appealing video games. By leveraging Pygame’s capabilities to handle animations, manage game states, and process user inputs, developers can create rich interactive experiences that are both fun and challenging. This project not only showcases the practical application of Pygame in game development but also provides a platform for enthusiasts to explore and enhance their programming skills.\n\nFor those looking to dive into game development or seeking to enhance their programming portfolio, Pygame offers a straightforward yet powerful framework. The experience of building and iterating on “Dino Dash” underscores the importance of solid game design principles and the effective use of Pygame’s features to enhance gameplay dynamics. Whether you aim to create simple 2D games or more complex projects, Pygame serves as a robust starting point, and “Dino Dash” exemplifies what can be accomplished with creativity and technical knowledge in this accessible environment.\n\nIf you enjoyed this article and found it valuable, please consider giving it a clap to show your support. Feel free to explore my other articles, where I cover a wide range of topics related to Python programming and others. By following me, you’ll stay updated on my latest content and insights. I look forward to sharing more knowledge and connecting with you through future articles. Until then, keep coding, keep learning, and most importantly, enjoy the journey!"
    },
    {
        "link": "https://stackoverflow.com/questions/6395923/any-way-to-speed-up-python-and-pygame",
        "document": "I am writing a simple top down RPG in Pygame, and I have found that it is quite slow.... Although I am not expecting python or pygame to match the FPS of games made with compiled languages like C/C++ or even Byte Compiled ones like Java, but still the current FPS of pygame is like 15. I tried rendering 16-color Bitmaps instead of PNGs or 24 Bitmaps, which slightly boosted the speed, then in desperation, I switched everything to black and white monochrome bitmaps and that made the FPS go to 35. But not more. Now according to most game development books I have read, for a user to be completely satisfied with game graphics, the FPS of a 2d game should at least be 40, so is there ANY way of boosting the speed of pygame?\n\nAlso, enable doublebuffering. For example: You could also turn off alpha if you don't need it: Instead of flipping the entire screen every time, keep track of the changed areas and only update those. For example, something roughly like this (main loop): events = pygame.events.get() for event in events: # deal with events pygame.event.pump() my_sprites.do_stuff_every_loop() rects = my_sprites.draw() activerects = rects + oldrects activerects = filter(bool, activerects) pygame.display.update(activerects) oldrects = rects[:] for rect in rects: screen.blit(bgimg, rect, rect) You can also set only some allowed events, for more speedy event handling: Also, I would not bother with creating a buffer manually and would not use the HWACCEL flag, as I've experienced problems with it on some setups. Using this, I've achieved reasonably good FPS and smoothness for a small 2d-platformer.\n\nAll of these are great suggestions and work well, but you should also keep in mind two things: 1) Blitting surfaces onto surfaces is faster than drawing directly. So pre-drawing fixed images onto surfaces (outside the main game loop), then blitting the surface to the main screen will be more efficient. For exmample: # pre-draw image outside of main game loop image_rect = get_image(\"filename\").get_rect() image_surface = pygame.Surface((image_rect.width, image_rect.height)) image_surface.blit(get_image(\"filename\"), image_rect) ...... # inside main game loop - blit surface to surface (the main screen) screen.blit(image_surface, image_rect) 2) Make sure you aren't wasting resources by drawing stuff the user can't see. for example: if point.x >= 0 and point.x <= SCREEN_WIDTH and point.y >= 0 and point.y <= SCREEN_HEIGHT: # then draw your item These are some general concepts that help me keep FPS high.\n\nWhen using images it is important to convert them with the convert()-function of the image. I have read that convert() disables alpha which is normally quite slow. I also had speed problems until I used a colour depth of 16 bit and the convert function for my images. Now my FPS are around 150 even if I blit a big image to the screen. image = image.convert()#video system has to be initialed Also rotations and scaling takes a lot of time to calculate. A big, transformed image can be saved in another image if it is immutable. So the idea is to calculate once and reuse the outcome multiple times.\n\nFirst, always use 'convert()' because it disables alpha which makes bliting faster. Then only update the parts of the screen that need to be updated. global rects rects = [] rects.append(pygame.draw.line(screen, (0, 0, 0), (20, 20), (100, 400), 1)) pygame.display.update(rects) # pygame will only update those rects When moving a sprite you have to include in the list the rect from their last position.\n\nWhen loading images, if you absolutely require transparency or other alpha values, use the Surface.convert_alpha() method. I have been using it for a game I've been programming, and it has been a huge increase in performance. E.G: In your constructor, load your images using: As far as I can tell, any transformations you do to the image retains the performance this method calls. E.G: becomes redundant if you are using an image that has had ran on it.\n\nThere are a few things to consider for a well-performing Pygame application:\n• None Ensure that the image Surface has the same format as the display Surface. Use (or ) to create a Surface that has the same pixel format. This improves performance when the image is on the display, because the formats are compatible and does not need to perform an implicit transformation. e.g.:\n• None Do not load the images in the application loop. is a very time-consuming operation because the image file must be loaded from the device and the image format must be decoded. Load the images once before the application loop, but use the images in the application loop.\n• None If you have a static game map that consists of tiles, you can buy performance by paying with memory usage. Create a large with the complete map. the area which is currently visible on the screen: game_map = pygame.Surface((tile_size * columns, tile_size * rows)) for x in range(columns): for y in range(rows): tile_image = # image for this row and column game_map.blit(tile_image , (x * tile_size, y * tile_size))\n• None If the text is static, the text does not need to be rendered in each frame. Create the text surface once at the beginning of the program or in the constructor of a class, and the text surface in each frame.\n• None If the text is dynamic, it cannot even be pre-rendered. However, the most time-consuming is to create the / object. At the very least, you should avoid creating the font in every frame.\n\n In a typical application you don't need all permutations of fonts and font sizes. You just need a couple of different objects. Create a number of fonts at the beginning of the application and use them when rendering the text. For Instance. e.g.:"
    },
    {
        "link": "https://realpython.com/pygame-a-primer",
        "document": "When I started learning computer programming late in the last millennium, it was driven by my desire to write computer games. I tried to figure out how to write games in every language and on every platform I learned, including Python. That’s how I discovered and learned how to use it to write games and other graphical programs. At the time, I really wanted a primer on .\n\nBy the end of this article, you’ll be able to:\n\nThis primer assumes you have a basic understanding of writing Python programs, including user-defined functions, imports, loops, and conditionals. You should also be familiar with how to open files on your platform. A basic understanding of object-oriented Python is helpful as well. works with most versions of Python, but Python 3.6 is recommended and used throughout this article.\n\nYou can get all of the code in this article to follow along:\n\nAs and the SDL library are portable across different platforms and devices, they both need to define and work with abstractions for various hardware realities. Understanding those concepts and abstractions will help you design and develop your own games. The library is composed of a number of Python constructs, which include several different modules. These modules provide abstract access to specific hardware on your system, as well as uniform methods to work with that hardware. For example, allows uniform access to your video display, while allows abstract control of your joystick. After importing the library in the example above, the first thing you did was initialize PyGame using . This function calls the separate functions of all the included modules. Since these modules are abstractions for specific hardware, this initialization step is required so that you can work with the same code on Linux, Windows, and Mac. In addition to the modules, also includes several Python classes, which encapsulate non-hardware dependent concepts. One of these is the which, at its most basic, defines a rectangular area on which you can draw. objects are used in many contexts in . Later you’ll see how to load an image into a and display it on the screen. In , everything is viewed on a single user-created , which can be a window or a full screen. The display is created using , which returns a representing the visible part of the window. It is this that you pass into drawing functions like , and the contents of that are pushed to the display when you call . Your basic program drew a shape directly onto the display’s , but you can also work with images on the disk. The module allows you to load and save images in a variety of popular formats. Images are loaded into objects, which can then be manipulated and displayed in numerous ways. As mentioned above, objects are represented by rectangles, as are many other objects in , such as images and windows. Rectangles are so heavily used that there is a special class just to handle them. You’ll be using objects and images in your game to draw players and enemies, and to manage collisions between them. Okay, that’s enough theory. Let’s design and write a game!\n\nBefore you start writing any code, it’s always a good idea to have some design in place. Since this is a tutorial game, let’s design some basic gameplay for it as well:\n• The goal of the game is to avoid incoming obstacles:\n• The player starts on the left side of the screen.\n• The obstacles enter randomly from the right and move left in a straight line.\n• The player can move left, right, up, or down to avoid the obstacles.\n• The player cannot move off the screen.\n• The game ends either when the player is hit by an obstacle or when the user closes the window. When he was describing software projects, a former colleague of mine used to say, “You don’t know what you do until you know what you don’t do.” With that in mind, here are some things that won’t be covered in this tutorial: You’re free to try your hand at adding these and other features to your own program. After you import , you’ll also need to initialize it. This allows to connect its abstractions to your specific hardware: # Updated to conform to flake8 and black standards The library defines many things besides modules and classes. It also defines some local constants for things like keystrokes, mouse movements, and display attributes. You reference these constants using the syntax . By importing specific constants from , you can use the syntax instead. This will save you some keystrokes and improve overall readability. Now you need something to draw on! Create a screen to be the overall canvas: # Updated to conform to flake8 and black standards # Define constants for the screen width and height # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT You create the screen to use by calling and passing a tuple or list with the desired width and height. In this case, the window is 800x600, as defined by the constants and on lines 20 and 21. This returns a which represents the inside dimensions of the window. This is the portion of the window you can control, while the OS controls the window borders and title bar. If you run this program now, then you’ll see a window pop up briefly and then immediately disappear as the program exits. Don’t blink or you might miss it! In the next section, you’ll focus on the main game loop to ensure that your program exits only when given the correct input. Every game from Pong to Fortnite uses a game loop to control gameplay. The game loop does four very important things:\n• Updates the state of all game objects\n• Maintains the speed of the game Every cycle of the game loop is called a frame, and the quicker you can do things each cycle, the faster your game will run. Frames continue to occur until some condition to exit the game is met. In your design, there are two conditions that can end the game loop:\n• The player collides with an obstacle. (You’ll cover collision detection later.) The first thing the game loop does is process user input to allow the player to move around the screen. Therefore, you need some way to capture and process a variety of input. You do this using the event system. Key presses, mouse movements, and even joystick movements are some of the ways in which a user can provide input. All user input results in an event being generated. Events can happen at any time and often (but not always) originate outside the program. All events in are placed in the event queue, which can then be accessed and manipulated. Dealing with events is referred to as handling them, and the code to do so is called an event handler. Every event in has an event type associated with it. For your game, the event types you’ll focus on are keypresses and window closure. Keypress events have the event type , and the window closure event has the type . Different event types may also have other data associated with them. For example, the event type also has a variable called to indicate which key was pressed. You access the list of all active events in the queue by calling . You then loop through this list, inspect each event type, and respond accordingly: # Variable to keep the main loop running # Look at every event in the queue # Was it the Escape key? If so, stop the loop. # Did the user click the window close button? If so, stop the loop. Let’s take a closer look at this game loop:\n• Line 28 sets up a control variable for the game loop. To exit the loop and the game, you set . The game loop starts on line 29.\n• Line 31 starts the event handler, walking through every event currently in the event queue. If there are no events, then the list is empty, and the handler won’t do anything.\n• Lines 35 to 38 check if the current is a event. If it is, then the program checks which key was pressed by looking at the attribute. If the key is the key, indicated by , then it exits the game loop by setting .\n• Lines 41 and 42 do a similar check for the event type called . This event only occurs when the user clicks the window close button. The user may also use any other operating system action to close the window. When you add these lines to the previous code and run it, you’ll see a window with a blank or black screen: The window won’t disappear until you press the key, or otherwise trigger a event by closing the window. In the sample program, you drew on the screen using two commands: Now you’ll learn about a third way to draw to the screen: using a . Recall that a is a rectangular object on which you can draw, like a blank sheet of paper. The object is a , and you can create your own objects separate from the display screen. Let’s see how that works: # Create a surface and pass in a tuple containing its length and width # Give the surface a color to separate it from the background After the screen is filled with white on line 45, a new is created on line 48. This is 50 pixels wide, 50 pixels tall, and assigned to . At this point, you treat it just like the . So on line, 51 you fill it with black. You can also access its underlying using . This is stored as for later use. Just creating a new isn’t enough to see it on the screen. To do that, you need to blit the onto another . The term stands for Block Transfer, and is how you copy the contents of one to another. You can only from one to another, but since the screen is just another , that’s not a problem. Here’s how you draw on the screen: # This line says \"Draw surf onto the screen at the center\" The call on line 55 takes two arguments:\n• The location at which to draw it on the source The coordinates tell your program to place in the exact center of the screen, but it doesn’t quite look that way: The reason why the image looks off-center is that puts the top-left corner of at the location given. If you want to be centered, then you’ll have to do some math to shift it up and to the left. You can do this by subtracting the width and height of from the width and height of the screen, dividing each by 2 to locate the center, and then passing those numbers as arguments to : # Put the center of surf at the center of the display # Draw surf at the new coordinates Notice the call to after the call to . This updates the entire screen with everything that’s been drawn since the last flip. Without the call to , nothing is shown.\n\nIn your game design, the player starts on the left, and obstacles come in from the right. You can represent all the obstacles with objects to make drawing everything easier, but how do you know where to draw them? How do you know if an obstacle has collided with the player? What happens when the obstacle flies off the screen? What if you want to draw background images that also move? What if you want your images to be animated? You can handle all these situations and more with sprites. In programming terms, a sprite is a 2D representation of something on the screen. Essentially, it’s a picture. provides a class, which is designed to hold one or several graphical representations of any game object that you want to display on the screen. To use it, you create a new class that extends . This allows you to use its built-in methods. Here’s how you use objects with the current game to define the player. Insert this code after line 18: # The surface drawn on the screen is now an attribute of 'player' You first define by extending on line 22. Then uses to call the method of . For more info on why this is necessary, you can read Supercharge Your Classes With Python super(). Next, you define and initialize to hold the image to display, which is currently a white box. You also define and initialize , which you’ll use to draw the player later. To use this new class, you need to create a new object and change the drawing code as well. Expand the code block below to see it all together: # Updated to conform to flake8 and black standards # Define constants for the screen width and height # The surface drawn on the screen is now an attribute of 'player' # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT # Instantiate player. Right now, this is just a rectangle. # Variable to keep the main loop running # for loop through the event queue # If the Esc key is pressed, then exit the main loop # Check for QUIT event. If QUIT, then set running to false. # Draw the player on the screen Run this code. You’ll see a white rectangle at roughly the middle of the screen: What do you think would happen if you changed line 59 to ? Try it and see: # Draw the player on the screen When you pass a to , it uses the coordinates of the top left corner to draw the surface. You’ll use this later to make your player move! So far, you’ve learned how to set up and draw objects on the screen. Now, the real fun starts! You’ll make the player controllable using the keyboard. Earlier, you saw that returns a list of the events in the event queue, which you scan for event types. Well, that’s not the only way to read keypresses. also provides , which returns a dictionary containing all the current events in the queue. Put this in your game loop right after the event handling loop. This returns a dictionary containing the keys pressed at the beginning of every frame: # Get the set of keys pressed and check for user input Next, you write a method in to accepts that dictionary. This will define the behavior of the sprite based off the keys that are pressed. Here’s what that might look like: , , , and correspond to the arrow keys on the keyboard. If the dictionary entry for that key is , then that key is down, and you move the player in the proper direction. Here you use , which stands for move in place, to move the current . Then you can call every frame to move the player sprite in response to keypresses. Add this call right after the call to : # for loop through the event queue # If the Esc key is pressed, then exit the main loop # Check for QUIT event. If QUIT, then set running to false. # Get all the keys currently pressed Now you can move your player rectangle around the screen with the arrow keys: You may notice two small problems:\n• The player rectangle can move very fast if a key is held down. You’ll work on that later.\n• The player rectangle can move off the screen. Let’s solve that one now. To keep the player on the screen, you need to add some logic to detect if the is going to move off screen. To do that, you check whether the coordinates have moved beyond the screen’s boundary. If so, then you instruct the program to move it back to the edge: # Keep player on the screen Here, instead of using , you just change the corresponding coordinates of , , , or directly. Test this, and you’ll find the player rectangle can no longer move off the screen. What’s a game without enemies? You’ll use the techniques you’ve already learned to create a basic enemy class, then create a lot of them for your player to avoid. First, import the library: Then create a new sprite class called , following the same pattern you used for : # The surface you draw on the screen is now an attribute of 'enemy' # Remove the sprite when it passes the left edge of the screen There are four notable differences between and :\n• On lines 62 to 67, you update to be a random location along the right edge of the screen. The center of the rectangle is just off the screen. It’s located at some position between 20 and 100 pixels away from the right edge, and somewhere between the top and bottom edges.\n• On line 68, you define as a random number between 5 and 20. This specifies how fast this enemy moves towards the player.\n• On lines 73 to 76, you define . It takes no arguments since enemies move automatically. Instead, moves the enemy toward the left side of the screen at the defined when it was created.\n• On line 74, you check whether the enemy has moved off-screen. To make sure the is fully off the screen and won’t just disappear while it’s still visible, you check that the right side of the has gone past the left side of the screen. Once the enemy is off-screen, you call to prevent it from being processed further. So, what does do? To figure this out, you have to know about Sprite Groups.\n\nAnother super useful class that provides is the . This is an object that holds a group of objects. So why use it? Can’t you just track your objects in a list instead? Well, you can, but the advantage of using a lies in the methods it exposes. These methods help to detect whether any has collided with the , which makes updates much easier. Let’s see how to create sprite groups. You’ll create two different objects:\n• The first will hold every in the game.\n• The second will hold just the objects. Here’s what that looks like in code: # Create groups to hold enemy sprites and all sprites # - enemies is used for collision detection and position updates # - all_sprites is used for rendering # Variable to keep the main loop running When you call , the is removed from every to which it belongs. This removes the references to the as well, which allows Python’s garbage collector to reclaim the memory as necessary. Now that you have an group, you can change how objects are drawn. Instead of calling on just , you can iterate over everything in : # Flip everything to the display Now, anything put into will be drawn with every frame, whether it’s an enemy or the player. There’s just one problem… You don’t have any enemies! You could create a bunch of enemies at the beginning of the game, but the game would quickly become boring when they all left the screen a few seconds later. Instead, let’s explore how to keep a steady supply of enemies coming as the game progresses.\n\nThe design calls for enemies to appear at regular intervals. This means that at set intervals, you need to do two things:\n• Add it to and . You already have code that handles random events. The event loop is designed to look for random events occurring every frame and deal with them appropriately. Luckily, doesn’t restrict you to using only the event types it has defined. You can define your own events to handle as you see fit. Let’s see how to create a custom event that’s generated every few seconds. You can create a custom event by naming it: # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT # Instantiate player. Right now, this is just a rectangle. defines events internally as integers, so you need to define a new event with a unique integer. The last event reserves is called , so defining on line 83 ensures it’s unique. Next, you need to insert this new event into the event queue at regular intervals throughout the game. That’s where the module comes in. Line 84 fires the new event every 250 milliseconds, or four times per second. You call outside the game loop since you only need one timer, but it will fire throughout the entire game. Add the code to handle your new event: # Look at every event in the queue # Was it the Escape key? If so, stop the loop. # Did the user click the window close button? If so, stop the loop. # Create the new enemy and add it to sprite groups # Get the set of keys pressed and check for user input Whenever the event handler sees the new event on line 115, it creates an and adds it to and . Since is in , it will get drawn every frame. You also need to call on line 126, which updates everything in , to ensure they move properly: However, that’s not the only reason there’s a group for just .\n\nYour game design calls for the game to end whenever an enemy collides with the player. Checking for collisions is a basic technique of game programming, and usually requires some non-trivial math to determine whether two sprites will overlap each other. This is where a framework like comes in handy! Writing collision detection code is tedious, but has a LOT of collision detection methods available for you to use. For this tutorial, you’ll use a method called , which is read as “sprite collide any.” This method accepts a and a as parameters. It looks at every object in the and checks if its intersects with the of the . If so, then it returns . Otherwise, it returns . This is perfect for this game since you need to check if the single collides with one of a of . Here’s what that looks like in code: # Check if any enemies have collided with the player # If so, then remove the player and stop the loop Line 135 tests whether has collided with any of the objects in . If so, then is called to remove it from every group to which it belongs. Since the only objects being rendered are in , the will no longer be rendered. Once the player has been killed, you need to exit the game as well, so you set to break out of the game loop on line 138. At this point, you’ve got the basic elements of a game in place: Now, let’s dress it up a bit, make it more playable, and add some advanced capabilities to help it stand out.\n\nAlright, you have a game, but let’s be honest… It’s kind of ugly. The player and enemies are just white blocks on a black background. That was state-of-the-art when Pong was new, but it just doesn’t cut it anymore. Let’s replace all those boring white rectangles with some cooler images that will make the game feel like an actual game. Earlier, you learned that images on disk can be loaded into a with some help from the module. For this tutorial, we made a little jet for the player and some missiles for the enemies. You’re welcome to use this art, draw your own, or download some free game art assets to use. You can click the link below to download the art used in this tutorial: Sample Code: Click here to download the source code for the PyGame sample project used in this tutorial. Before you use images to represent the player and enemy sprites, you need to make some changes to their constructors. The code below replaces the code used previously: # Updated to conform to flake8 and black standards # Define constants for the screen width and height # Instead of a surface, use an image for a better-looking sprite Let’s unpack line 31 a bit. loads an image from the disk. You pass it a path to the file. It returns a , and the call optimizes the , making future calls faster. Line 32 uses to indicate the color will render as transparent. In this case, you choose white, because that’s the background color of the jet image. The RLEACCEL constant is an optional parameter that helps render more quickly on non-accelerated displays. This is added to the import statement on line 11. Nothing else needs to change. The image is still a , except now it has a picture painted on it. You still use it in the same way. Here’s what similar changes to the look like: # Instead of a surface, use an image for a better-looking sprite # The starting position is randomly generated, as is the speed Running the program now should show that this is the same game you had before, except now you’ve added some nice graphics skins with images. But why stop at just making the player and enemy sprites look nice? Let’s add a few clouds going past to give the impression of a jet flying through the sky. For background clouds, you use the same principles as you did for and :\n• Add an image of a cloud to it.\n• Create a method that moves the toward the left side of the screen.\n• Create a custom event and handler to create new objects at a set time interval.\n• Add the newly created objects to a new called .\n• Update and draw the in your game loop. Here’s what looks like: # Use an image for a better-looking sprite # Remove the cloud when it passes the left edge of the screen That should all look very familiar. It’s pretty much the same as . To have clouds appear at certain intervals, you’ll use event creation code similar to what you used to create new enemies. Put it right below the enemy creation event: # Create custom events for adding a new enemy and a cloud This says to wait 1000 milliseconds, or one second, before creating the next . Next, create a new to hold each newly created : # Create groups to hold enemy sprites, cloud sprites, and all sprites # - enemies is used for collision detection and position updates # - clouds is used for position updates # - all_sprites is used for rendering Next, add a handler for the new event in the event handler: # Look at every event in the queue # Was it the Escape key? If so, then stop the loop. # Did the user click the window close button? If so, stop the loop. # Create the new enemy and add it to sprite groups # Create the new cloud and add it to sprite groups Finally, make sure the are updated every frame: # Update the position of enemies and clouds Line 172 updates the original to fill the screen with a pleasant sky blue color. You can change this color to something else. Maybe you want an alien world with a purple sky, a toxic wasteland in neon green, or the surface of Mars in red! Note that each new and are added to as well as and . This is done because each group is used for a separate purpose:\n• Rendering is done using .\n• Position updates are done using and .\n• Collision detection is done using . You create multiple groups so that you can change the way sprites move or behave without impacting the movement or behavior of other sprites.\n\nWhile testing the game you may have noticed that the enemies move a little fast. If not, then that’s okay, as different machines will see different results at this point. The reason for this is that the game loop processes frames as fast as the processor and environment will allow. Since all the sprites move once per frame, they can move hundreds of times each second. The number of frames handled each second is called the frame rate, and getting this right is the difference between a playable game and a forgettable one. Normally, you want as high a frame rate as possible, but for this game, you need to slow it down a bit for the game to be playable. Fortunately, the module contains a which is designed exactly for this purpose. Using to establish a playable frame rate requires just two lines of code. The first creates a new before the game loop begins: The second calls to inform that the program has reached the end of the frame: # Flip everything to the display # Ensure program maintains a rate of 30 frames per second The argument passed to establishes the desired frame rate. To do this, calculates the number of milliseconds each frame should take, based on the desired frame rate. Then, it compares that number to the number of milliseconds that have passed since the last time was called. If not enough time has passed, then delays processing to ensure that it never exceeds the specified frame rate. Passing in a smaller frame rate will result in more time in each frame for calculations, while a larger frame rate provides smoother (and possibly faster) gameplay: Play around with this number to see what feels best for you!\n\nSo far, you’ve focused on gameplay and the visual aspects of your game. Now let’s explore giving your game some auditory flavor as well. provides to handle all sound-related activities. You’ll use this module’s classes and methods to provide background music and sound effects for various actions. The name refers to the fact that the module mixes various sounds into a cohesive whole. Using the sub-module, you can stream individual sound files in a variety of formats, such as MP3, Ogg, and Mod. You can also use to hold a single sound effect to be played, in either Ogg or uncompressed WAV formats. All playback happens in the background, so when you play a , the method returns immediately as the sound plays. Note: The documentation states that MP3 support is limited, and unsupported formats can cause system crashes. The sounds referenced in this article have been tested, and we recommend testing any sounds thoroughly before releasing your game. As with most things , using starts with an initialization step. Luckily, this is already handled by . You only need to call if you want to change the defaults: # Set up the clock for a decent framerate accepts a number of arguments, but the defaults work fine in most cases. Note that if you want to change the defaults, you need to call before calling . Otherwise, the defaults will be in effect regardless of your changes. After the system is initialized, you can get your sounds and background music setup: Lines 138 and 139 load a background sound clip and begin playing it. You can tell the sound clip to loop and never end by setting the named parameter . Lines 143 to 145 load three sounds you’ll use for various sound effects. The first two are rising and falling sounds, which are played when the player moves up or down. The last is the sound used whenever there is a collision. You can add other sounds as well, such as a sound for whenever an is created, or a final sound for when the game ends. So, how do you use the sound effects? You want to play each sound when a certain event occurs. For example, when the ship moves up, you want to play . Therefore, you add a call to whenever you handle that event. In the design, that means adding the following calls to for : # Instead of a surface, use an image for a better-looking sprite For a collision between the player and an enemy, you play the sound for when collisions are detected: # Check if any enemies have collided with the player # If so, then remove the player # Stop any moving sounds and play the collision sound Here, you stop any other sound effects first, because in a collision the player is no longer moving. Then you play the collision sound and continue execution from there. Finally, when the game is over, all sounds should stop. This is true whether the game ends due to a collision or the user exits manually. To do this, add the following lines at the end of the program after the loop: # All done! Stop and quit the mixer. Technically, these last few lines are not required, as the program ends right after this. However, if you decide later on to add an intro screen or an exit screen to your game, then there may be more code running after the game ends. That’s it! Test it again, and you should see something like this:"
    }
]