[
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/python3-if-if-else-nested-if-if-elif-statements",
        "document": "There are situations in real life when we need to do some specific task and based on some specific conditions, we decide what we should do next. Similarly, there comes a situation in programming where a specific task is to be performed if a specific condition is True. In such cases, conditional statements can be used. The following are the conditional statements provided by Python.\n\nLet us go through all of them.\n\nIf the simple code of block is to be performed if the condition holds true then the if statement is used. Here the condition mentioned holds then the code of the block runs otherwise not.\n\nFlowchart of if Statement in Python\n\nBelow is the flowchart by which we can understand how to use if statement in Python:\n\nIn this example, an statement checks if 10 is greater than 5. If true, it prints “10 greater than 5”; regardless, it then prints “Program ended” as the next statement, indicating the program flow.\n\nIndentation(White space) is used to delimit the block of code. As shown in the above example it is mandatory to use indentation in Python3 coding.\n\nif else Statement in Python\n\nIn conditional if Statement the additional block of code is merged as else statement which is performed when if condition is false.\n\nBelow is the flowchart by which we can understand how to use if-else statement in Python:\n\nIn this example, the code assigns the value 3 to variable x and uses an if..else statement to check if x is equal to 4. If true, it prints “Yes”; otherwise, it prints “No,” demonstrating a conditional branching structure.\n\nYou can also chain if..else statement with more than one condition. In this example, the code uses a nested if..else chain to check the value of the variable letter. It prints a corresponding message based on whether letter is “B,” “C,” “A,” or none of the specified values, illustrating a hierarchical conditional structure.\n\nif statement can also be checked inside other if statement. This conditional statement is called a nested if statement. This means that inner if condition will be checked only if outer if condition is true and by this, we can see multiple conditions to be satisfied.\n\nFlow chart of Nested If Statement In Python\n\nBelow is the flowchart by which we can understand how to use nested if statement in Python:\n\nIn this example, the code uses a nested if statement to check if the variable num is greater than 5. If true, it further checks if num is less than or equal to 15, printing “Bigger than 5” and “Between 5 and 15” accordingly, showcasing a hierarchical condition for refined control flow.\n\nThe if-elif statement is shortcut of if..else chain. While using if-elif statement at the end else block is added which is performed if none of the above if-elif statement is true.\n\nBelow is the flowchart by which we can understand how to use elif in Python:\n\nIn this example, the code uses an if-elif-else statement to evaluate the value of the variable letter. It prints a corresponding message based on whether letter is “B,” “C,” “A,” or none of the specified values, demonstrating a sequential evaluation of conditions for controlled branching.\n\nCan We Use Elif in Nested If?\n\nYes, you can use within nested statements in Python. This allows for more complex decision structures within a branch of another decision. For example:\n\nThe structure of the above code provides conditional checks within another conditional check, enhancing the decision-making capabilities of your code.\n\nAre You Allowed to Nest If Statements Inside Other If Statements in Python?\n\nYes, you are allowed to nest if statements inside other if statements in Python. This is a common practice used to make more complex conditional logic possible. Nested if statements can be as deep as you need, although deep nesting can make your code harder to read and maintain.\n\nCan We Use Multiple If Instead of Elif?\n\nYes, you can use multiple if statements instead of elif, but the behavior of your code will change. elif allows for mutually exclusive conditions; only one branch can execute. With multiple if statements, each if condition is checked independently of others, so multiple branches might execute. x = 10 y = 5 if x > 5: if y > 5: print(\"x and y are greater than 5\") elif y == 5: print(\"x is greater than 5 and y is 5\") else: print(\"x is greater than 5 and y is less than 5\") Using elif, the second condition would only be checked if the first condition failed.\n\nWhat is the Difference Between if-else and Nested If Statements in Python?\n\nWhat is the Maximum Number of Elif Clauses You Can Have in a Conditional?"
    },
    {
        "link": "https://datacamp.com/tutorial/elif-statements-python",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://docs.python.org/3/reference/compound_stmts.html",
        "document": "Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way. In general, compound statements span multiple lines, although in simple incarnations a whole compound statement may be contained in one line.\n\nThe , and statements implement traditional control flow constructs. specifies exception handlers and/or cleanup code for a group of statements, while the statement allows the execution of initialization and finalization code around a block of code. Function and class definitions are also syntactically compound statements.\n\nA compound statement consists of one or more ‘clauses.’ A clause consists of a header and a ‘suite.’ The clause headers of a particular compound statement are all at the same indentation level. Each clause header begins with a uniquely identifying keyword and ends with a colon. A suite is a group of statements controlled by a clause. A suite can be one or more semicolon-separated simple statements on the same line as the header, following the header’s colon, or it can be one or more indented statements on subsequent lines. Only the latter form of a suite can contain nested compound statements; the following is illegal, mostly because it wouldn’t be clear to which clause a following clause would belong:\n\nAlso note that the semicolon binds tighter than the colon in this context, so that in the following example, either all or none of the calls are executed:\n\nNote that statements always end in a possibly followed by a . Also note that optional continuation clauses always begin with a keyword that cannot start a statement, thus there are no ambiguities (the ‘dangling ’ problem is solved in Python by requiring nested statements to be indented).\n\nThe formatting of the grammar rules in the following sections places each clause on a separate line for clarity.\n\nThe statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object: for_stmt ::= \"for\" \"in\" \":\" [\"else\" \":\" ] The expression is evaluated once; it should yield an iterable object. An iterator is created for that iterable. The first item provided by the iterator is then assigned to the target list using the standard rules for assignments (see Assignment statements), and the suite is executed. This repeats for each item provided by the iterator. When the iterator is exhausted, the suite in the clause, if present, is executed, and the loop terminates. A statement executed in the first suite terminates the loop without executing the clause’s suite. A statement executed in the first suite skips the rest of the suite and continues with the next item, or with the clause if there is no next item. The for-loop makes assignments to the variables in the target list. This overwrites all previous assignments to those variables including those made in the suite of the for-loop: # this will not affect the for-loop # because i will be overwritten with the next Names in the target list are not deleted when the loop is finished, but if the sequence is empty, they will not have been assigned to at all by the loop. Hint: the built-in type represents immutable arithmetic sequences of integers. For instance, iterating successively yields 0, 1, and then 2. Changed in version 3.11: Starred elements are now allowed in the expression list.\n\nThe statement specifies exception handlers and/or cleanup code for a group of statements: try_stmt ::= | | try1_stmt ::= \"try\" \":\" (\"except\" [ [\"as\" ]] \":\" )+ [\"else\" \":\" ] [\"finally\" \":\" ] try2_stmt ::= \"try\" \":\" (\"except\" \"*\" [\"as\" ] \":\" )+ [\"else\" \":\" ] [\"finally\" \":\" ] try3_stmt ::= \"try\" \":\" \"finally\" \":\" Additional information on exceptions can be found in section Exceptions, and information on using the statement to generate exceptions may be found in section The raise statement. The clause(s) specify one or more exception handlers. When no exception occurs in the clause, no exception handler is executed. When an exception occurs in the suite, a search for an exception handler is started. This search inspects the clauses in turn until one is found that matches the exception. An expression-less clause, if present, must be last; it matches any exception. For an clause with an expression, the expression must evaluate to an exception type or a tuple of exception types. The raised exception matches an clause whose expression evaluates to the class or a non-virtual base class of the exception object, or to a tuple that contains such a class. If no clause matches the exception, the search for an exception handler continues in the surrounding code and on the invocation stack. If the evaluation of an expression in the header of an clause raises an exception, the original search for a handler is canceled and a search starts for the new exception in the surrounding code and on the call stack (it is treated as if the entire statement raised the exception). When a matching clause is found, the exception is assigned to the target specified after the keyword in that clause, if present, and the clause’s suite is executed. All clauses must have an executable block. When the end of this block is reached, execution continues normally after the entire statement. (This means that if two nested handlers exist for the same exception, and the exception occurs in the clause of the inner handler, the outer handler will not handle the exception.) When an exception has been assigned using , it is cleared at the end of the clause. This is as if This means the exception must be assigned to a different name to be able to refer to it after the clause. Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs. Before an clause’s suite is executed, the exception is stored in the module, where it can be accessed from within the body of the clause by calling . When leaving an exception handler, the exception stored in the module is reset to its previous value: The clause(s) are used for handling s. The exception type for matching is interpreted as in the case of , but in the case of exception groups we can have partial matches when the type matches some of the exceptions in the group. This means that multiple clauses can execute, each handling part of the exception group. Each clause executes at most once and handles an exception group of all matching exceptions. Each exception in the group is handled by at most one clause, the first that matches it. Any remaining exceptions that were not handled by any clause are re-raised at the end, along with all exceptions that were raised from within the clauses. If this list contains more than one exception to reraise, they are combined into an exception group. If the raised exception is not an exception group and its type matches one of the clauses, it is caught and wrapped by an exception group with an empty message string. An clause must have a matching expression; it cannot be . Furthermore, this expression cannot contain exception group types, because that would have ambiguous semantics. It is not possible to mix and in the same . , and cannot appear in an clause. The optional clause is executed if the control flow leaves the suite, no exception was raised, and no , , or statement was executed. Exceptions in the clause are not handled by the preceding clauses. If is present, it specifies a ‘cleanup’ handler. The clause is executed, including any and clauses. If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The clause is executed. If there is a saved exception it is re-raised at the end of the clause. If the clause raises another exception, the saved exception is set as the context of the new exception. If the clause executes a , or statement, the saved exception is discarded: The exception information is not available to the program during execution of the clause. When a , or statement is executed in the suite of a … statement, the clause is also executed ‘on the way out.’ The return value of a function is determined by the last statement executed. Since the clause always executes, a statement executed in the clause will always be the last one executed: Changed in version 3.8: Prior to Python 3.8, a statement was illegal in the clause due to a problem with the implementation.\n\nA function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function). This function object contains a reference to the current global namespace as the global namespace to be used when the function is called. The function definition does not execute the function body; this gets executed only when the function is called. A function definition may be wrapped by one or more decorator expressions. Decorator expressions are evaluated when the function is defined, in the scope that contains the function definition. The result must be a callable, which is invoked with the function object as the only argument. The returned value is bound to the function name instead of the function object. Multiple decorators are applied in nested fashion. For example, the following code except that the original function is not temporarily bound to the name . Changed in version 3.9: Functions may be decorated with any valid . Previously, the grammar was much more restrictive; see PEP 614 for details. A list of type parameters may be given in square brackets between the function’s name and the opening parenthesis for its parameter list. This indicates to static type checkers that the function is generic. At runtime, the type parameters can be retrieved from the function’s attribute. See Generic functions for more. Changed in version 3.12: Type parameter lists are new in Python 3.12. When one or more parameters have the form parameter expression, the function is said to have “default parameter values.” For a parameter with a default value, the corresponding argument may be omitted from a call, in which case the parameter’s default value is substituted. If a parameter has a default value, all following parameters up until the “ ” must also have a default value — this is a syntactic restriction that is not expressed by the grammar. Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter value is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default parameter value is in effect modified. This is generally not what was intended. A way around this is to use as the default, and explicitly test for it in the body of the function, e.g.: Function call semantics are described in more detail in section Calls. A function call always assigns values to all parameters mentioned in the parameter list, either from positional arguments, from keyword arguments, or from default values. If the form “ ” is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple. If the form “ ” is present, it is initialized to a new ordered mapping receiving any excess keyword arguments, defaulting to a new empty mapping of the same type. Parameters after “ ” or “ ” are keyword-only parameters and may only be passed by keyword arguments. Parameters before “ ” are positional-only parameters and may only be passed by positional arguments. Changed in version 3.8: The function parameter syntax may be used to indicate positional-only parameters. See PEP 570 for details. Parameters may have an annotation of the form “ ” following the parameter name. Any parameter may have an annotation, even those of the form or . (As a special case, parameters of the form may have an annotation “ ”.) Functions may have “return” annotation of the form “ ” after the parameter list. These annotations can be any valid Python expression. The presence of annotations does not change the semantics of a function. The annotation values are available as values of a dictionary keyed by the parameters’ names in the attribute of the function object. If the import from is used, annotations are preserved as strings at runtime which enables postponed evaluation. Otherwise, they are evaluated when the function definition is executed. In this case annotations may be evaluated in a different order than they appear in the source code. Changed in version 3.11: Parameters of the form “ ” may have an annotation “ ”. See PEP 646. It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions. This uses lambda expressions, described in section Lambdas. Note that the lambda expression is merely a shorthand for a simplified function definition; a function defined in a “ ” statement can be passed around or assigned to another name just like a function defined by a lambda expression. The “ ” form is actually more powerful since it allows the execution of multiple statements and annotations. Programmer’s note: Functions are first-class objects. A “ ” statement executed inside a function definition defines a local function that can be returned or passed around. Free variables used in the nested function can access the local variables of the function containing the def. See section Naming and binding for details. Support for forward references within annotations by preserving annotations in a string form at runtime instead of eager evaluation. Function and method decorators were introduced. Class decorators were introduced in PEP 3129.\n\nA class definition is an executable statement. The inheritance list usually gives a list of base classes (see Metaclasses for more advanced uses), so each item in the list should evaluate to a class object which allows subclassing. Classes without an inheritance list inherit, by default, from the base class ; hence, The class’s suite is then executed in a new execution frame (see Naming and binding), using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary. The class name is bound to this class object in the original local namespace. The order in which attributes are defined in the class body is preserved in the new class’s . Note that this is reliable only right after the class is created and only for classes that were defined using the definition syntax. Class creation can be customized heavily using metaclasses. Classes can also be decorated: just like when decorating functions, The evaluation rules for the decorator expressions are the same as for function decorators. The result is then bound to the class name. Changed in version 3.9: Classes may be decorated with any valid . Previously, the grammar was much more restrictive; see PEP 614 for details. A list of type parameters may be given in square brackets immediately after the class’s name. This indicates to static type checkers that the class is generic. At runtime, the type parameters can be retrieved from the class’s attribute. See Generic classes for more. Changed in version 3.12: Type parameter lists are new in Python 3.12. Programmer’s note: Variables defined in the class definition are class attributes; they are shared by instances. Instance attributes can be set in a method with . Both class and instance attributes are accessible through the notation “ ”, and an instance attribute hides a class attribute with the same name when accessed in this way. Class attributes can be used as defaults for instance attributes, but using mutable values there can lead to unexpected results. Descriptors can be used to create instance variables with different implementation details. The proposal that changed the declaration of metaclasses to the current syntax, and the semantics for how classes with metaclasses are constructed. The proposal that added class decorators. Function and method decorators were introduced in PEP 318.\n\nChanged in version 3.13: Support for default values was added (see PEP 696). Functions (including coroutines), classes and type aliases may contain a type parameter list: Semantically, this indicates that the function, class, or type alias is generic over a type variable. This information is primarily used by static type checkers, and at runtime, generic objects behave much like their non-generic counterparts. Type parameters are declared in square brackets ( ) immediately after the name of the function, class, or type alias. The type parameters are accessible within the scope of the generic object, but not elsewhere. Thus, after a declaration , the name is not available in the module scope. Below, the semantics of generic objects are described with more precision. The scope of type parameters is modeled with a special function (technically, an annotation scope) that wraps the creation of the generic object. Generic functions, classes, and type aliases have a attribute listing their type parameters. Type parameters come in three kinds:\n• None , introduced by a plain name (e.g., ). Semantically, this represents a single type to a type checker.\n• None , introduced by a name prefixed with a single asterisk (e.g., ). Semantically, this stands for a tuple of any number of types.\n• None , introduced by a name prefixed with two asterisks (e.g., ). Semantically, this stands for the parameters of a callable. declarations can define bounds and constraints with a colon ( ) followed by an expression. A single expression after the colon indicates a bound (e.g. ). Semantically, this means that the can only represent types that are a subtype of this bound. A parenthesized tuple of expressions after the colon indicates a set of constraints (e.g. ). Each member of the tuple should be a type (again, this is not enforced at runtime). Constrained type variables can only take on one of the types in the list of constraints. For s declared using the type parameter list syntax, the bound and constraints are not evaluated when the generic object is created, but only when the value is explicitly accessed through the attributes and . To accomplish this, the bounds or constraints are evaluated in a separate annotation scope. s and s cannot have bounds or constraints. All three flavors of type parameters can also have a default value, which is used when the type parameter is not explicitly provided. This is added by appending a single equals sign ( ) followed by an expression. Like the bounds and constraints of type variables, the default value is not evaluated when the object is created, but only when the type parameter’s attribute is accessed. To this end, the default value is evaluated in a separate annotation scope. If no default value is specified for a type parameter, the attribute is set to the special sentinel object . The following example indicates the full set of allowed type parameter declarations: Generic functions are declared as follows: This syntax is equivalent to: Here indicates an annotation scope, which is not actually bound to any name at runtime. (One other liberty is taken in the translation: the syntax does not go through attribute access on the module, but creates an instance of directly.) The annotations of generic functions are evaluated within the annotation scope used for declaring the type parameters, but the function’s defaults and decorators are not. The following example illustrates the scoping rules for these cases, as well as for additional flavors of type parameters: Except for the lazy evaluation of the bound, this is equivalent to: # In reality, BOUND_OF_T() is evaluated only on demand. The capitalized names like are not actually bound at runtime. Generic classes are declared as follows: This syntax is equivalent to: Here again (not a real keyword) indicates an annotation scope, and the name is not actually bound at runtime. Generic classes implicitly inherit from . The base classes and keyword arguments of generic classes are evaluated within the type scope for the type parameters, and decorators are evaluated outside that scope. This is illustrated by this example: The statement can also be used to create a generic type alias: Except for the lazy evaluation of the value, this is equivalent to: # In reality, the value is lazily evaluated Here, (not a real keyword) indicates an annotation scope. The capitalized names like are not actually bound at runtime."
    },
    {
        "link": "https://libguides.ntu.edu.sg/python/ifelifelse",
        "document": "We can use if statements when we want the code to do something when a condition is met.\n\nSequence of an if statement:"
    },
    {
        "link": "https://geeksforgeeks.org/python-3-input-function",
        "document": "In Python, we use the input() function to take input from the user. Whatever you enter as input, the input function converts it into a string. If you enter an integer value still input() function converts it into a string.\n\nIn this example, we are using input() function to input user data as a string in Python.\n\nIn this example, we are using the Python input() function to input user data as a string in Python, which takes input from the user and prints it.\n\nIn this example, we are taking input from the user and input user data as a string in Python with a prompt and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converting it into an integer adding 1 to the integer, and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converts it into float adds 1 to the float, and prints it.\n\nIn this example, we are taking input from the user in string format converting it into a list, and printing it.\n\nTake User Input for Tuples and Sets\n\nIn this example, we are taking input from the user in string format converting it into a tuple, and printing it.\n\nIn this example, we are taking the words separated by space to input user data as a string in Python, and we make a dictionary of the word as the key with their length as the value."
    },
    {
        "link": "https://geeksforgeeks.org/taking-input-from-console-in-python",
        "document": "What is Console in Python? Console (also called Shell) is basically a command line interpreter that takes input from the user i.e one command at a time and interprets it. If it is error free then it runs the command and gives required output otherwise shows the error message. A Python Console looks like this. Here we write a command and to execute the command just press enter key and your command will be interpreted. For coding in Python, you must know the basics of the console used in Python. The primary prompt of the python console is the three greater than symbols\n\nYou are free to write the next command on the shell only when these prompts have appeared after executing the first command. The Python Console accepts commands in Python that you write after the prompt. Accepting Input from Console User enters the values in the Console and that value is then used in the program as it was required. To take input from the user we make use of a built-in function input().\n\nWe can also typecast this input to integer, float, or string by specifying the input() function inside the type.\n\n1. Typecasting the input to Integer: There might be conditions when you might require integer input from the user/Console, the following code takes two input(integer/float) from the console and typecasts them to an integer then prints the sum.\n\n2. Typecasting the input to Float: To convert the input to float the following code will work out.\n\n3. Typecasting the input to String: All kinds of input can be converted to string type whether they are float or integer. We make use of keyword str for typecasting.\n\nwe can also take input string by just writing input() function by default it makes the input string"
    },
    {
        "link": "https://realpython.com/python-input-output",
        "document": "For a program to be useful, it often needs to communicate with the outside world. In Python, the function allows you to capture user input from the keyboard, while you can use the function to display output to the console.\n\nThese built-in functions allow for basic user interaction in Python scripts, enabling you to gather data and provide feedback. If you want to go beyond the basics, then you can even use them to develop applications that are not only functional but also user-friendly and responsive.\n\nBy the end of this tutorial, you’ll know how to:\n• Take user input from the keyboard with\n• Display output to the console with\n• Use to improve the user experience when collecting input on UNIX-like systems\n• Format output using the and keyword arguments of\n\nTo get the most out of this tutorial, you should have a basic understanding of Python syntax and familiarity with using the Python interpreter and running Python scripts.\n\nPrograms often need to obtain data from users, typically through keyboard input. In Python, one way to collect user input from the keyboard is by calling the function: The function pauses program execution to allow you to type in a line of input from the keyboard. Once you press the key, all characters typed are read and returned as a string, excluding the newline character generated by pressing . If you add text in between the parentheses, effectively passing a value to the optional argument, then displays the text you entered as a prompt: \"Please enter your name: \" Please enter your name: John Doe Adding a meaningful prompt will assist your user in understanding what they’re supposed to input, which makes for a better user experience. The function always reads the user’s input as a string. Even if you type characters that resemble numbers, Python will still treat them as a string: File , line , in : can only concatenate str (not \"int\") to str In the example above, you wanted to add to the number entered by the user. However, the expression on line 7 doesn’t work because is a string ( ) and is an integer. In Python, you can’t combine a string and an integer using the plus ( ) operator. You wanted to perform a mathematical operation using two integers, but because always returns a string, you need a way to read user input as a numeric type. So, you’ll need to convert the string to the appropriate type: In this updated code snippet, you use to convert the user input to an integer right after collecting it. Then, you assign the converted value to the name . That way, the calculation has two integers to add. The calculation succeeds and Python returns the correct sum. Note: When you convert user input to a numeric type using functions like in a real-world scenario, it’s crucial to handle potential exceptions to prevent your program from crashing due to invalid input. The function lets you collect information from your users. But once your program has calculated a result, how do you display it back to them? Up to this point, you’ve seen results displayed automatically as output in the interactive Python interpreter session. However, if you ran the same code from a file instead, then Python would still calculate the values, but you wouldn’t see the results. To display output in the console, you can use Python’s function, which lets you show text and data to your users.\n\nIn addition to obtaining data from the user, a program will often need to present data back to the user. In Python, you can display data to the console with the function. To display objects to the console, you pass them as a comma-separated list of arguments to . By default, the output that produces separates objects by a single space and appends a newline to the end of the output: You can specify any type of object as an argument to . If an object isn’t a string, then converts it to an appropriate string representation before displaying it: As you can see, you can display complex types like lists, dictionaries, and even functions to the console with .\n\nCombining Python Input and Output in a Practical Example Now that you know how to read input from users with and display output with , you can combine these tools to create a small two-line program that greets a user by their name. The program will start by prompting the user to enter their name and capture that input using . Then, you can use to output a personalized greeting that includes the entered name: \"Please enter your name: \" The script introduces a small interaction with your user. When the program runs, it temporarily pauses, awaiting input from the user. Once the user provides their name and presses the key, the program immediately responds with a warm greeting: Note that automatically adds spaces between arguments when concatenating multiple arguments into a single string. The small program in collects user input and responds with console output in only two lines of code:\n• Line 1 prompts the user with a helpful message. The function then collects the user’s response as a string, which you assign to the variable.\n• Line 2 assembles a custom greeting using hardcoded strings and the value stored in . The function combines the greeting with the user’s input and displays it to the console. This example brings together the and functions to accomplish a specific purpose, using the strengths of each function:\n• gathers user data, making the program interactive and adaptable to different users.\n• displays feedback based on that data, which allows the program to communicate its response to the user in a friendly, personalized way. In a real-world application, these basic tools can support more complex workflows. For example, after welcoming a user, your program might offer further options or prompt them for more specific input to guide them through a process. Expand the collapsible section below to continue practicing with a slightly more complex example: Create a guess-the-number game where a player only has one shot at getting the right answer. You can use the function from Python’s module to let your program pick a random number: Then, your program should prompt the player to enter a number using . You can then use conditional statements to take different actions, depending on whether the user guessed the correct number or not. Keep in mind that you’ll have to read the user input as an integer in order to successfully compare it to the randomly generated number. Give it a try and write the code for this small game. Once you have a working solution—or if you get really stuck—you can check the example solution in the collapsible section below. If you’ve successfully built the guess-the-number game and you want another challenge, then you can expand the collapsible section below for a second task: Write a text-based adventure game where the player can choose whether to attack or run using . Try to implement a game loop using indefinite iteration and allow your code to take different actions depending on conditional logic. Keep it small and don’t go overboard—unless you really want to, of course! You can check out an example solution for a minimal implementation of this game by expanding the collapsible section following this one. Collecting user input and displaying data back to the user comes in handy in many scenarios. Can you think of another practical use case? If you do, share your thoughts in the comments section below.\n\nIn the previous sections, you explored how the function allows your program to pause and wait for the user to provide information. However, depending on the operating system and shell that you’re working with, the standard may have some limitations that can affect user experience. Note: If you’re on Windows 10 or newer, then you can skip this section. Windows 10 shipped with console improvements that allow for improved keyboard editing and selection. This works natively on Command Prompt and PowerShell. In some configurations, specifically on UNIX-like systems and Windows versions before Windows 10, you’ll notice that you can’t use arrow keys for navigating through typed characters or to recall previously entered commands: This can become cumbersome in interactive programs where users might want to correct mistakes or quickly repeat commands. There’s a straightforward way to improve input functionality just by importing an additional module. The module that you can use depends on whether you’re on a UNIX-like system or on Windows, so make sure to select your operating system from the options below: If you’re on a Windows version above Windows 10, then you don’t need to do anything. Advanced input editing capabilities and history recall are natively supported in Command Prompt and PowerShell since Windows 10. You can try running the code that you’ll see further down without importing the module, and you should still have access to all of the mentioned features. However, if you’re working on a Windows version before Windows 10, then you need to install a third-party library to get access to this functionality. One such library is , which you can install with Python’s package manager, : After the installation is done, the library will provide similar functionality to the GNU Readline library available on UNIX-like systems. While it mimics the behavior of the module from Python’s standard library, is not a direct substitute as it may have differences due to underlying system variations. The file of the third-party project ensures that when you import in your Python code, your code will instead use the implementation. UNIX-like systems, such as macOS and Linux, usually come with the GNU Readline library preinstalled. Python’s module provides an interface to the GNU Readline library, which straightforwardly handles the aforementioned limitations of . Because is part of Python’s standard-library, you don’t even need to install anything. To activate the improved input functionality in your input interface, you only need to import : Try running the code snippet above, which drops you into an infinite loop that allows you to test input editing and history recall:\n• Use the and arrow keys to navigate within the input line.\n• Use and to move to the beginning and end of the input line, respectively.\n• Recall previous inputs using the and arrow keys. You can exit the loop that you set up in and end the example program by typing . Usually, when you call , it calls a lower-level input handling function to wait for user input from the standard input stream. When you import , it overrides the standard input processing by registering handlers for keyboard input. These handlers capture each key press, interpreting special keys like arrows differently. The readline module achieves this seamlessly because instead of changing , it intercepts calls to the lower-level read commands that relies on. When calls these commands, steps in and provides its enhanced behavior. Integrating enhanced input features can significantly improve the user experience, especially in interactive applications like command-line tools or games: This enhancement is particularly valuable in scenarios where users are expected to input commands frequently or make complex entries with frequent edits. It’s important to note that the features provided by and are natively supported only in console environments and may not work in all Integrated Development Environments (IDEs). IDEs often handle input differently from standard terminal environments. Additionally, some key bindings and functionalities may vary depending on the system configuration and the specific implementation of the module. By extending the capabilities of , your programs can offer a more robust and user-friendly interface, accommodating smoother data entry and manipulation processes. In the next section, you’ll continue to explore how you can refine output appearance and formatting using some advanced features of .\n\nThe function takes additional arguments that provide some control over the format of the output. Each of these is a special type of argument called a keyword argument. Keyword arguments have the form . You need to pass them at the end, after the list of objects that you want to display. Note: You can only achieve basic formatting of console output with . If you need more precise control over the appearance of your data, then you can use Python’s f-strings to format the object before passing it to . In this section, you’ll see how the following keyword arguments affect the console output that produces:\n• : This argument allows you to specify how to separate multiple objects when they are printed.\n• : Use this argument to set what Python prints at the end of a call.\n• : This allows you to redirect the output to any file-like object.\n• : Use this argument to flush the output stream, effectively bypassing any buffering. Adding the keyword argument causes Python to separate objects by instead of by the default single space: In these examples, you’ve used different strings, such as , , and to separate the objects that you’re asking to display. You can use the keyword to specify any arbitrary string as the separator: However, passing a string such as as the separator will rarely make a lot of sense. In practice, you’ll probably want to stick with passing a well-readable separator symbol like in the previous examples. To squish objects together without any space between them, you specify an empty string ( ) as the separator: Finally, you can add a linebreak in between each item by passing the newline character ( ) to : Separating objects with a newline character displays each of them on an individual line, which can be helpful when you need to inspect more complex objects. Sometimes, you may even want to separate them with two consecutive newline characters ( ) to group your output better and make it more readable. The keyword argument causes Python to terminate the output by instead of by the default newline: In this example, you’ve replaced the default newline end character with an exclamation mark. Notice how this breaks the usual neat way that calling drops you into a new empty line. Now you get to see an exclamation mark followed directly by Python’s input prompt ( ) because you told not to write a newline character. You can also pass an empty string to this parameter to side-step the default newline functionality. For example, assume that you’re displaying values in a loop: For such small values, you might want to display all values on one line, rather than on individual lines. You can accomplish this with : Note that your prompt slid back up into the output line again because you’re not using a newline as the output terminator. By calling without any arguments just after the loop, you can avoid that, too: When you don’t provide any values to , it outputs a newline character, effectively moving the cursor to the next line. Alternatively, you can achieve the same effect with a bit of logic wrapped in a conditional expression: Just like with , you can use any string as an argument to the keyword, but some strings will make more sense than others as output terminators. The function accepts two additional keyword arguments, and , both of which affect how the function handles the output stream. If you want to learn how to work with these two additional keyword arguments, then you can read the in-depth guide about Python’s function."
    },
    {
        "link": "https://w3schools.com/python/python_user_input.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/70797/user-input-and-command-line-arguments",
        "document": "To read user input you can try the module for easily creating a mini-command line interpreter (with help texts and autocompletion) and ( for Python 3+) for reading a line of text from the user.\n\nCommand line inputs are in . Try this in your script:\n\nThere are two modules for parsing command line options: (deprecated since Python 2.7, use instead) and . If you just want to input files to your script, behold the power of .\n\nThe Python library reference is your friend."
    },
    {
        "link": "https://docs.python.org/3/reference/expressions.html",
        "document": "This chapter explains the meaning of the elements of expressions in Python.\n\nSyntax Notes: In this and the following chapters, extended BNF notation will be used to describe syntax, not lexical analysis. When (one alternative of) a syntax rule has the form\n\nand no semantics are given, the semantics of this form of are the same as for .\n\nPrimaries represent the most tightly bound operations of the language. Their syntax is: An attribute reference is a primary followed by a period and a name: The primary must evaluate to an object of a type that supports attribute references, which most objects do. This object is then asked to produce the attribute whose name is the identifier. The type and value produced is determined by the object. Multiple evaluations of the same attribute reference may yield different objects. This production can be customized by overriding the method or the method. The method is called first and either returns a value or raises if the attribute is not available. If an is raised and the object has a method, that method is called as a fallback. The subscription of an instance of a container class will generally select an element from the container. The subscription of a generic class will generally return a GenericAlias object. When an object is subscripted, the interpreter will evaluate the primary and the expression list. The primary must evaluate to an object that supports subscription. An object may support subscription through defining one or both of and . When the primary is subscripted, the evaluated result of the expression list will be passed to one of these methods. For more details on when is called instead of , see __class_getitem__ versus __getitem__. If the expression list contains at least one comma, or if any of the expressions are starred, the expression list will evaluate to a containing the items of the expression list. Otherwise, the expression list will evaluate to the value of the list’s sole member. Changed in version 3.11: Expressions in an expression list may be starred. See PEP 646. For built-in objects, there are two types of objects that support subscription via :\n• None Mappings. If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key. An example of a builtin mapping class is the class.\n• None Sequences. If the primary is a sequence, the expression list must evaluate to an or a (as discussed in the following section). Examples of builtin sequence classes include the , and classes. The formal syntax makes no special provision for negative indices in sequences. However, built-in sequences all provide a method that interprets negative indices by adding the length of the sequence to the index so that, for example, selects the last item of . The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero). Since the support for negative indices and slicing occurs in the object’s method, subclasses overriding this method will need to explicitly add that support. A is a special kind of sequence whose items are characters. A character is not a separate data type but a string of exactly one character. A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions or as targets in assignment or statements. The syntax for a slicing: There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing. Rather than further complicating the syntax, this is disambiguated by defining that in this case the interpretation as a subscription takes priority over the interpretation as a slicing (this is the case if the slice list contains no proper slice). The semantics for a slicing are as follows. The primary is indexed (using the same method as normal subscription) with a key that is constructed from the slice list, as follows. If the slice list contains at least one comma, the key is a tuple containing the conversion of the slice items; otherwise, the conversion of the lone slice item is the key. The conversion of a slice item that is an expression is that expression. The conversion of a proper slice is a slice object (see section The standard type hierarchy) whose , and attributes are the values of the expressions given as lower bound, upper bound and stride, respectively, substituting for missing expressions. An optional trailing comma may be present after the positional and keyword arguments but does not affect the semantics. The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and all objects having a method are callable). All argument expressions are evaluated before the call is attempted. Please refer to section Function definitions for the syntax of formal parameter lists. If keyword arguments are present, they are first converted to positional arguments, as follows. First, a list of unfilled slots is created for the formal parameters. If there are N positional arguments, they are placed in the first N slots. Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on). If the slot is already filled, a exception is raised. Otherwise, the argument is placed in the slot, filling it (even if the expression is , it fills the slot). When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition. (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don’t specify an argument value for the corresponding slot; this should usually be avoided.) If there are any unfilled slots for which no default value is specified, a exception is raised. Otherwise, the list of filled slots is used as the argument list for the call. CPython implementation detail: An implementation may provide built-in functions whose positional parameters do not have names, even if they are ‘named’ for the purpose of documentation, and which therefore cannot be supplied by keyword. In CPython, this is the case for functions implemented in C that use to parse their arguments. If there are more positional arguments than there are formal parameter slots, a exception is raised, unless a formal parameter using the syntax is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). If any keyword argument does not correspond to a formal parameter name, a exception is raised, unless a formal parameter using the syntax is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. If the syntax appears in the function call, must evaluate to an iterable. Elements from these iterables are treated as if they were additional positional arguments. For the call , if y evaluates to a sequence y1, …, yM, this is equivalent to a call with M+4 positional arguments x1, x2, y1, …, yM, x3, x4. A consequence of this is that although the syntax may appear after explicit keyword arguments, it is processed before the keyword arguments (and any arguments – see below). So: It is unusual for both keyword arguments and the syntax to be used in the same call, so in practice this confusion does not often arise. If the syntax appears in the function call, must evaluate to a mapping, the contents of which are treated as additional keyword arguments. If a parameter matching a key has already been given a value (by an explicit keyword argument, or from another unpacking), a exception is raised. When is used, each key in this mapping must be a string. Each value from the mapping is assigned to the first formal parameter eligible for keyword assignment whose name is equal to the key. A key need not be a Python identifier (e.g. is acceptable, although it will not match any formal parameter that could be declared). If there is no match to a formal parameter the key-value pair is collected by the parameter, if there is one, or if there is not, a exception is raised. Formal parameters using the syntax or cannot be used as positional argument slots or as keyword argument names. Changed in version 3.5: Function calls accept any number of and unpackings, positional arguments may follow iterable unpackings ( ), and keyword arguments may follow dictionary unpackings ( ). Originally proposed by PEP 448. A call always returns some value, possibly , unless it raises an exception. How this value is computed depends on the type of the callable object. The code block for the function is executed, passing it the argument list. The first thing the code block will do is bind the formal parameters to the arguments; this is described in section Function definitions. When the code block executes a statement, this specifies the return value of the function call. If execution reaches the end of the code block without executing a statement, the return value is . The result is up to the interpreter; see Built-in Functions for the descriptions of built-in functions and methods. A new instance of that class is returned. The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument. The class must define a method; the effect is then the same as if that method was called.\n\nThe binary arithmetic operations have the conventional priority levels. Note that some of these operations also apply to certain non-numeric types. Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators: The (multiplication) operator yields the product of its arguments. The arguments must either both be numbers, or one argument must be an integer and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together. In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence. This operation can be customized using the special and methods. The (at) operator is intended to be used for matrix multiplication. No builtin Python types implement this operator. This operation can be customized using the special and methods. The (division) and (floor division) operators yield the quotient of their arguments. The numeric arguments are first converted to a common type. Division of integers yields a float, while floor division of integers results in an integer; the result is that of mathematical division with the ‘floor’ function applied to the result. Division by zero raises the exception. The division operation can be customized using the special and methods. The floor division operation can be customized using the special and methods. The (modulo) operator yields the remainder from the division of the first argument by the second. The numeric arguments are first converted to a common type. A zero right argument raises the exception. The arguments may be floating-point numbers, e.g., equals (since equals .) The modulo operator always yields a result with the same sign as its second operand (or zero); the absolute value of the result is strictly smaller than the absolute value of the second operand . The floor division and modulo operators are connected by the following identity: . Floor division and modulo are also connected with the built-in function : . . In addition to performing the modulo operation on numbers, the operator is also overloaded by string objects to perform old-style string formatting (also known as interpolation). The syntax for string formatting is described in the Python Library Reference, section printf-style String Formatting. The modulo operation can be customized using the special and methods. The floor division operator, the modulo operator, and the function are not defined for complex numbers. Instead, convert to a floating-point number using the function if appropriate. The (addition) operator yields the sum of its arguments. The arguments must either both be numbers or both be sequences of the same type. In the former case, the numbers are converted to a common type and then added together. In the latter case, the sequences are concatenated. This operation can be customized using the special and methods. The (subtraction) operator yields the difference of its arguments. The numeric arguments are first converted to a common type. This operation can be customized using the special and methods.\n\nUnlike C, all comparison operations in Python have the same priority, which is lower than that of any arithmetic, shifting or bitwise operation. Also unlike C, expressions like have the interpretation that is conventional in mathematics: comparison ::= ( )* comp_operator ::= \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\" | \"is\" [\"not\"] | [\"not\"] \"in\" Comparisons yield boolean values: or . Custom rich comparison methods may return non-boolean values. In this case Python will call on such value in boolean contexts. Comparisons can be chained arbitrarily, e.g., is equivalent to , except that is evaluated only once (but in both cases is not evaluated at all when is found to be false). Formally, if a, b, c, …, y, z are expressions and op1, op2, …, opN are comparison operators, then is equivalent to a op1 b and b op2 c and ... y opN z , except that each expression is evaluated at most once. Note that doesn’t imply any kind of comparison between a and c, so that, e.g., is perfectly legal (though perhaps not pretty). The operators , , , , , and compare the values of two objects. The objects do not need to have the same type. Chapter Objects, values and types states that objects have a value (in addition to type and identity). The value of an object is a rather abstract notion in Python: For example, there is no canonical access method for an object’s value. Also, there is no requirement that the value of an object should be constructed in a particular way, e.g. comprised of all its data attributes. Comparison operators implement a particular notion of what the value of an object is. One can think of them as defining the value of an object indirectly, by means of their comparison implementation. Because all types are (direct or indirect) subtypes of , they inherit the default comparison behavior from . Types can customize their comparison behavior by implementing rich comparison methods like , described in Basic customization. The default behavior for equality comparison ( and ) is based on the identity of the objects. Hence, equality comparison of instances with the same identity results in equality, and equality comparison of instances with different identities results in inequality. A motivation for this default behavior is the desire that all objects should be reflexive (i.e. implies ). A default order comparison ( , , , and ) is not provided; an attempt raises . A motivation for this default behavior is the lack of a similar invariant as for equality. The behavior of the default equality comparison, that instances with different identities are always unequal, may be in contrast to what types will need that have a sensible definition of object value and value-based equality. Such types will need to customize their comparison behavior, and in fact, a number of built-in types have done that. The following list describes the comparison behavior of the most important built-in types.\n• None Numbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard library types and can be compared within and across their types, with the restriction that complex numbers do not support order comparison. Within the limits of the types involved, they compare mathematically (algorithmically) correct without loss of precision. The not-a-number values and are special. Any ordered comparison of a number to a not-a-number value is false. A counter-intuitive implication is that not-a-number values are not equal to themselves. For example, if , , and are all false, while is true. This behavior is compliant with IEEE 754.\n• None and are singletons. PEP 8 advises that comparisons for singletons should always be done with or , never the equality operators.\n• None Binary sequences (instances of or ) can be compared within and across their types. They compare lexicographically using the numeric values of their elements.\n• None Strings (instances of ) compare lexicographically using the numerical Unicode code points (the result of the built-in function ) of their characters. Strings and binary sequences cannot be directly compared.\n• None Sequences (instances of , , or ) can be compared only within each of their types, with the restriction that ranges do not support order comparison. Equality comparison across these types results in inequality, and ordering comparison across these types raises . Sequences compare lexicographically using comparison of corresponding elements. The built-in containers typically assume identical objects are equal to themselves. That lets them bypass equality tests for identical objects to improve performance and to maintain their internal invariants. Lexicographical comparison between built-in collections works as follows:\n• None For two collections to compare equal, they must be of the same type, have the same length, and each pair of corresponding elements must compare equal (for example, is false because the type is not the same).\n• None Collections that support order comparison are ordered the same as their first unequal elements (for example, has the same value as ). If a corresponding element does not exist, the shorter collection is ordered first (for example, is true).\n• None Mappings (instances of ) compare equal if and only if they have equal pairs. Equality comparison of the keys and values enforces reflexivity.\n• None Sets (instances of or ) can be compared within and across their types. They define order comparison operators to mean subset and superset tests. Those relations do not define total orderings (for example, the two sets and are not equal, nor subsets of one another, nor supersets of one another). Accordingly, sets are not appropriate arguments for functions which depend on total ordering (for example, , , and produce undefined results given a list of sets as inputs). Comparison of sets enforces reflexivity of its elements.\n• None Most other built-in types have no comparison methods implemented, so they inherit the default comparison behavior. User-defined classes that customize their comparison behavior should follow some consistency rules, if possible:\n• None Equality comparison should be reflexive. In other words, identical objects should compare equal:\n• None Comparison should be symmetric. In other words, the following expressions should have the same result:\n• None Comparison should be transitive. The following (non-exhaustive) examples illustrate that:\n• None Inverse comparison should result in the boolean negation. In other words, the following expressions should have the same result: The last two expressions apply to totally ordered collections (e.g. to sequences, but not to sets or mappings). See also the decorator.\n• None The result should be consistent with equality. Objects that are equal should either have the same hash value, or be marked as unhashable. Python does not enforce these consistency rules. In fact, the not-a-number values are an example for not following these rules. The operators and test for membership. evaluates to if x is a member of s, and otherwise. returns the negation of . All built-in sequences and set types support this as well as dictionary, for which tests whether the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression is equivalent to any(x is e or x == e for e in y) . For the string and bytes types, is if and only if x is a substring of y. An equivalent test is . Empty strings are always considered to be a substring of any other string, so will return . For user-defined classes which define the method, returns if returns a true value, and otherwise. For user-defined classes which do not define but do define , is if some value , for which the expression is true, is produced while iterating over . If an exception is raised during the iteration, it is as if raised that exception. Lastly, the old-style iteration protocol is tried: if a class defines , is if and only if there is a non-negative integer index i such that , and no lower integer index raises the exception. (If any other exception is raised, it is as if raised that exception). The operator is defined to have the inverse truth value of . The operators and test for an object’s identity: is true if and only if x and y are the same object. An Object’s identity is determined using the function. yields the inverse truth value."
    },
    {
        "link": "https://docs.python.org/3/tutorial/floatingpoint.html",
        "document": "Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example, the decimal fraction has value 6/10 + 2/100 + 5/1000, and in the same way the binary fraction has value 1/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the first is written in base 10 fractional notation, and the second in base 2.\n\nUnfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is that, in general, the decimal floating-point numbers you enter are only approximated by the binary floating-point numbers actually stored in the machine.\n\nThe problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate that as a base 10 fraction:\n\nand so on. No matter how many digits you’re willing to write down, the result will never be exactly 1/3, but will be an increasingly better approximation of 1/3.\n\nIn the same way, no matter how many base 2 digits you’re willing to use, the decimal value 0.1 cannot be represented exactly as a base 2 fraction. In base 2, 1/10 is the infinitely repeating fraction\n\nStop at any finite number of bits, and you get an approximation. On most machines today, floats are approximated using a binary fraction with the numerator using the first 53 bits starting with the most significant bit and with the denominator as a power of two. In the case of 1/10, the binary fraction is which is close to but not exactly equal to the true value of 1/10.\n\nMany users are not aware of the approximation because of the way values are displayed. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. On most machines, if Python were to print the true decimal value of the binary approximation stored for 0.1, it would have to display:\n\nThat is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead:\n\nJust remember, even though the printed result looks like the exact value of 1/10, the actual stored value is the nearest representable binary fraction.\n\nInterestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers and and are all approximated by . Since all of these decimal values share the same approximation, any one of them could be displayed while still preserving the invariant .\n\nHistorically, the Python prompt and built-in function would choose the one with 17 significant digits, . Starting with Python 3.1, Python (on most systems) is now able to choose the shortest of these and simply display .\n\nNote that this is in the very nature of binary floating point: this is not a bug in Python, and it is not a bug in your code either. You’ll see the same kind of thing in all languages that support your hardware’s floating-point arithmetic (although some languages may not display the difference by default, or in all output modes).\n\nFor more pleasant output, you may wish to use string formatting to produce a limited number of significant digits:\n\nIt’s important to realize that this is, in a real sense, an illusion: you’re simply rounding the display of the true machine value.\n\nOne illusion may beget another. For example, since 0.1 is not exactly 1/10, summing three values of 0.1 may not yield exactly 0.3, either:\n\nAlso, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 cannot get any closer to the exact value of 3/10, then pre-rounding with function cannot help:\n\nThough the numbers cannot be made closer to their intended exact values, the function can be useful for comparing inexact values:\n\nAlternatively, the function can be used to compare rough approximations:\n\nBinary floating-point arithmetic holds many surprises like this. The problem with “0.1” is explained in precise detail below, in the “Representation Error” section. See Examples of Floating Point Problems for a pleasant summary of how binary floating point works and the kinds of problems commonly encountered in practice. Also see The Perils of Floating Point for a more complete account of other common surprises.\n\nAs that says near the end, “there are no easy answers.” Still, don’t be unduly wary of floating point! The errors in Python float operations are inherited from the floating-point hardware, and on most machines are on the order of no more than 1 part in 2**53 per operation. That’s more than adequate for most tasks, but you do need to keep in mind that it’s not decimal arithmetic and that every float operation can suffer a new rounding error.\n\nWhile pathological cases do exist, for most casual use of floating-point arithmetic you’ll see the result you expect in the end if you simply round the display of your final results to the number of decimal digits you expect. usually suffices, and for finer control see the method’s format specifiers in Format String Syntax.\n\nFor use cases which require exact decimal representation, try using the module which implements decimal arithmetic suitable for accounting applications and high-precision applications.\n\nAnother form of exact arithmetic is supported by the module which implements arithmetic based on rational numbers (so the numbers like 1/3 can be represented exactly).\n\nIf you are a heavy user of floating-point operations you should take a look at the NumPy package and many other packages for mathematical and statistical operations supplied by the SciPy project. See <https://scipy.org>.\n\nPython provides tools that may help on those rare occasions when you really do want to know the exact value of a float. The method expresses the value of a float as a fraction:\n\nSince the ratio is exact, it can be used to losslessly recreate the original value:\n\nThe method expresses a float in hexadecimal (base 16), again giving the exact value stored by your computer:\n\nThis precise hexadecimal representation can be used to reconstruct the float value exactly:\n\nSince the representation is exact, it is useful for reliably porting values across different versions of Python (platform independence) and exchanging data with other languages that support the same format (such as Java and C99).\n\nAnother helpful tool is the function which helps mitigate loss-of-precision during summation. It uses extended precision for intermediate rounding steps as values are added onto a running total. That can make a difference in overall accuracy so that the errors do not accumulate to the point where they affect the final total:\n\nThe goes further and tracks all of the “lost digits” as values are added onto a running total so that the result has only a single rounding. This is slower than but will be more accurate in uncommon cases where large magnitude inputs mostly cancel each other out leaving a final sum near zero:\n\nThis section explains the “0.1” example in detail, and shows how you can perform an exact analysis of cases like this yourself. Basic familiarity with binary floating-point representation is assumed. Representation error refers to the fact that some (most, actually) decimal fractions cannot be represented exactly as binary (base 2) fractions. This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many others) often won’t display the exact decimal number you expect. Why is that? 1/10 is not exactly representable as a binary fraction. Since at least 2000, almost all machines use IEEE 754 binary floating-point arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 “double precision” values. IEEE 754 binary64 values contain 53 bits of precision, so on input the computer strives to convert 0.1 to the closest fraction it can of the form J/2**N where J is an integer containing exactly 53 bits. Rewriting and recalling that J has exactly 53 bits (is but ), the best value for N is 56: That is, 56 is the only value for N that leaves J with exactly 53 bits. The best possible value for J is then that quotient rounded: Since the remainder is more than half of 10, the best approximation is obtained by rounding up: Therefore the best possible approximation to 1/10 in IEEE 754 double precision is: Dividing both the numerator and denominator by two reduces the fraction to: Note that since we rounded up, this is actually a little bit larger than 1/10; if we had not rounded up, the quotient would have been a little bit smaller than 1/10. But in no case can it be exactly 1/10! So the computer never “sees” 1/10: what it sees is the exact fraction given above, the best IEEE 754 double approximation it can get: If we multiply that fraction by 10**55, we can see the value out to 55 decimal digits: meaning that the exact number stored in the computer is equal to the decimal value 0.1000000000000000055511151231257827021181583404541015625. Instead of displaying the full decimal value, many languages (including older versions of Python), round the result to 17 significant digits: The and modules make these calculations easy:"
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://python-textbok.readthedocs.io/en/latest/Python_Basics.html",
        "document": "In this chapter, we introduce the basics of the Python programming language. At this point you should already have set up a development environment for writing and running your Python code. It will be assumed in the text that this is the case. If you are having trouble setting up Python, contact a teaching assistant or post a message to the course forum. Throughout this course, you are strongly encouraged to try what you have learnt by writing an actual program. You can only learn how to program by actually doing it yourself. Each chapter contains several exercises to help you practice. Solutions are found at the end of the chapter. Python recently underwent a major version change from 2 to 3. For consistency with other courses in the department, we will be using Python 3. Python 2 is still widely used, and although Python 3 is not fully backwards compatible the two versions are very similar – so should you ever encounter Python 2 code you should find it quite familiar. We will mention important differences between the two versions throughout this course. We will always refer to the latest version of Python 2, which at the time of writing was 2.7.\n\nEntering on the commandline without any parameters will launch the Python interpreter. This is a text console in which you can enter Python commands one by one – they will be interpreted on the fly. In these notes we will assume throughout that the command launches Python 3, but if you have both Python 2 and Python 3 installed on your computer, you may need to specify that you want to use Python 3 by using the command instead. Whenever you launch the interpreter, you will see some information printed before the prompt, which includes the version number – make sure that it starts with 3! Take note of the command that you need to use. Here is an example of an interpreter prompt: If you type a number, string or any variable into the interpreter, its value will automatically be echoed to the console: That means that you don’t have to use an explicit print command to display the value of a variable if you are using the interpreter – you can just enter the bare variable, like this: This won’t work if you are running a program from a file – if you were to enter the two lines above into a file and run it, you wouldn’t see any output at all. You would have to use the print function to output the value of : In most of the code examples in this module we have used explicit print statements, so that you will see the same output whether you use the examples in the interpreter or run them from files. The interpreter can be very useful when you want to test out a small piece of code before adding it to a larger program. It’s a quick and easy way to check how a function works or make sure that the syntax of a code fragment is correct. There are some other interactive interpreters for Python which have more advanced features than the built-in interpreter, for example functionality for inspecting the contents of objects or querying the documentation for imported modules, classes and functions:\n• None IPython, which was originally developed within the scientific community The interpreter is useful for testing code snippets and exploring functions and modules, but to save a program permanently we need to write it into a file. Python files are commonly given the suffix . Once you have written a program and saved it, you can run it by using the command with the file name as a parameter: This will cause Python to execute the program. Like any source code file, a Python file is just an ordinary text file. You can edit it with any text editor you like. It is a good idea to use a text editor which at least supports syntax highlighting – that is, it can display the words in your program in different colours, depending on the function they perform in your program. It is also useful to have indentation features such as the ability to indent or unindent blocks of code all at once, and automatic indentation (having the program guess the right level of indentation whenever you start typing a new line). Some programmers prefer to use an integrated development environment, or IDE. An IDE is a program which combines a text editor with additional functionality like looking up documentation, inspecting objects, compiling the code (in the case of a compiled language) and running the code. Some IDEs support multiple languages, and some are designed for a specific language. There are many IDEs, free and commercial, which can be used with Python. Python also comes with a simple built-in IDE called IDLE (you may need to install it from a separate package). How you install new Python packages depends a little on your operating system. Linux distributions have their own package managers, and you may choose to install packages using these managers so that they are integrated with the other packages on your system. However, some obscure Python packages may not be available as system packages, and the packages which are available are often not the latest versions. It is thus sometimes necessary to install packages directly from PyPI. The Python Package Index (PyPI) is a large repository of Python packages. You can install packages from this repository using a tool like easy_install or pip (which is intended to be a more modern replacement for easy_install). Both of these utilities are cross-platform. Here is how you install a package called with pip: This command will search PyPI for a package called sqlobject, download it and install it on your system. In this module we will see many examples of Python’s built-in functions and types and modules in the standard library – but this document is only a summary, and not an exhaustive list of all the features of the language. As you work on the exercises in this module, you should use the official Python documentation as a reference. For example, each module in the standard library has a section in the documentation which describes its application programming interface, or API – the functionality which is available to you when you use the module in your code. By looking up the API you will be able to see what functions the module provides, what input they require, what output they return, and so on. The documentation often includes helpful examples which show you how the module is meant to be used. The documentation is available on the web, but you can also install it on your computer – you can either download a copy of the documentation files in HTML format so that you can browse them locally, or use a tool like , which prints out the documentation on the commandline:\n\nIn most of today’s written languages, words by themselves do not make sense unless they are in certain order and surrounded by correct punctuation symbols. This is also the case with the Python programming language. The Python interpreter is able to interpret and run correctly structured Python programs. For example, the following Python code is correctly structured and will run: Many other languages require a lot more structure in their simplest programs, but in Python this single line, which prints a short message, is sufficient. It is not, however, a very informative example of Python’s syntax – so here is a slightly more complex program which does (almost) exactly the same thing: # Here is the main function. This type of program is often referred to as a skeleton program, because one can build upon it to create a more complex program. The first line of the skeleton program is a comment. A hash ( ) denotes the start of a comment. The interpreter will ignore everything that follows the hash until the end of the line. Comments will be discussed further in the later part of this unit. In the code above, the words and are keywords or reserved words, i.e. they have been kept for specific purposes and may not be used for any other purposes in the program. The following are keywords in Python: When we write a Python program, we will create many entities – variables which store values like numbers or strings, as well as functions and classes. These entities must given names by which they can be referred to uniquely – these names are known as identifiers. For example, in our skeleton code above, is the name of the function. This particular name has no special significance – we could also have called the function or . What is important is that we use the same name to refer to the function when we call it at the bottom of the program. Python has some rules that you must follow when forming an identifier:\n• None it may only contain letters (uppercase or lowercase), numbers or the underscore character ( ) (no spaces!).\n• None it may not start with a number. If we break any of these rules, our program will exit with a syntax error. However, not all identifiers which are syntactically correct are meaningful to human readers. There are a few guidelines that we should follow when naming our variables to make our code easier to understand (by other people, and by us!) – this is an important part of following a good coding style:\n• None be descriptive – a variable name should describe the contents of the variable; a function name should indicate what the function does; etc..\n• None don’t use abbreviations unnecessarily – they may be ambiguous and more difficult to read. Pick a naming convention, and stick to it. This is a commonly used naming convention in Python:\n• None names of classes should be in CamelCase (words capitalised and squashed together).\n• None names of variables which are intended to be constants should be in CAPITAL_LETTERS_WITH_UNDERSCORES.\n• None names of all other variables should be in lowercase_with_underscores. In some other languages, like Java, the standard is to use camelCase (with the initial letter lowercase), but this style is less popular in Python.\n• None names of class attributes and methods which are intended to be “private” and not accessed from outside the class should start with an underscore. Of course there are always exceptions – for example, many common mathematical symbols have very short names which are nonetheless widely understood. Here are a few examples of identifiers: Be careful not to redefine existing variables accidentally by reusing their names. This applies not only to your own variables, but to built-in Python functions like , or : these names are not keywords, and you will not get a syntax error if you reuse them, but you will encounter confusing results if you try to use the original functions later in your program. Redefining variables (accidentally and on purpose) will be discussed in greater detail in the section about scope. Write down why each of the entries in the left column will raise a syntax error if it is used as an identifier. In Python, statements are written as a list, in the way that a person would write a list of things to do. The computer starts off by following the first instruction, then the next, in the order that they appear in the program. It only stops executing the program after the last instruction is completed. We refer to the order in which the computer executes instructions as the flow of control. When the computer is executing a particular instruction, we can say that control is at that instruction. Many languages arrange code into blocks using curly braces ( and ) or and statements – these languages encourage us to indent blocks to make code easier to read, but indentation is not compulsory. Python uses indentation only to delimit blocks, so we must indent our code: # this instruction is inside the block, because it's indented # this if statement starts a new block # this is inside the block # this is outside the block! \"Print this no matter what.\" In many languages we need to use a special character to mark the end of each instruction – usually a semicolon. Python uses ends of lines to determine where instructions end (except in some special cases when the last symbol on the line lets Python know that the instruction will span multiple lines). We may optionally use semicolons – this is something we might want to do if we want to put more than one instruction on a line (but that is usually bad style): # These all individual instructions -- no semicolons required! # This instruction spans more than one line # This is legal, but we shouldn't do it Write down the two statements inside the block created by the function: The following Python program is not indented correctly. Re-write it so that it is correctly indented: Unlike some languages (such as Pascal), Python is case-sensitive. This means that the interpreter treats upper- and lowercase letters as different from one another. For example, is different from and is different from . Also remember that all reserved words (except , and ) are in lowercase. Many programs display text on the screen either to give some information or to ask for some information. For example, we might just want to tell the user what our program does: Perhaps we might want to ask the user for a number: The easiest way to output information is to display a string literal using the built-in function. A string literal is text enclosed in quotes. We can use either single quotes ( ) or double quotes ( ) – but the start quote and the end quote have to match! These are examples of string literals: We can tell the computer to print “Hello!” on the console with the following instruction: As you can see the function takes in a string as an argument. It prints the string, and also prints a newline character at the end – this is why the console’s cursor appears on a new line after we have printed something. To query the user for information, we use the function: There are several things to note. First, unlike the function, the function does not print a newline automatically – the text will be entered directly after the prompt. That is why we have added a trailing space after the colon. Second, the function always returns a string – we will have to convert it to a number ourselves. The string prompt is optional – we could just use the function without a parameter: in Python 2, there is a function called which does what does in Python 3: that is, it reads input from the user, and returns it as a string. In Python 2, the function called does something different: it reads input from the user and tries to evaluate it as a Python expression. There is no function like this in Python 3, but you can achieve the same result by using the function on the string returned by . is almost always a bad idea, and you should avoid using it – especially on arbitrary user input that you haven’t checked first. It can be very dangerous – the user could enter absolutely anything, including malicious code! Although the function prints to the console by default, we can also use it to write to a file. Here is a simple example: Quite a lot is happening in these two lines. In the statement (which we will look at in more detail in the chapter on errors and exceptions) the file is opened for writing and assigned to the variable . Inside the block, followed by a newline is written to the file. The character passed to indicates that the file should be opened for writing. As an alternative to , we can use a file’s method as follows: A method is a function attached to an object – methods will be explained in more detail in the chapter about classes. Unlike , the method does not add a newline to the string which is written. We can read data from a file by opening it for reading and using the file’s method: This reads the contents of the file into the variable . Note that this time we have passed to the function. This indicates that the file should be opened for reading. Python will raise an error if you attempt to open a file that has not been created yet for reading. Opening a file for writing will create the file if it does not exist yet. The statement automatically closes the file at the end of the block, even if an error occurs inside the block. In older versions of Python files had to be closed explicitly – this is no longer recommended. You should always use the statement. There are many kinds of information that a computer can process, like numbers and characters. In Python (and other programming languages), the kinds of information the language is able to handle are known as types. Many common types are built into Python – for example integers, floating-point numbers and strings. Users can also define their own types using classes. In many languages a distinction is made between built-in types (which are often called “primitive types” for this reason) and classes, but in Python they are indistinguishable. Everything in Python is an object (i.e. an instance of some class) – that even includes lists and functions. A type consists of two parts: a domain of possible values and a set of possible operations that can be performed on these values. For example, the domain of the integer type ( ) contains all integers, while common integer operations are addition, subtraction, multiplication and division. Python is a dynamically (and not statically) typed language. That means that we don’t have to specify a type for a variable when we create it – we can use the same variable to store values of different types. However, Python is also strongly (and not weakly) typed – at any given time, a variable has a definite type. If we try to perform operations on variables which have incompatible types (for example, if we try to add a number to a string), Python will exit with a type error instead of trying to guess what we mean. The function can be used to determine the type of an object. For example:\n\nAn integer ( type) is a whole number such as , , or . is not an integer because it has a decimal point. Numbers with decimal points are floating-point numbers. Even is a floating-point number and not an integer. Python can display an integer with the function, but only if it is the only argument: # We can add two numbers together We can’t combine a string and an integer directly, because Python is strongly typed: If we want to print a number and a string together, we will have to convert the number to a string somehow: # Then we can concatenate two strings with +. # String formatting does the conversion for us. Note that all these operations are integer operations. That is why the answer to is not , but . An integer operation results in an integer solution. In Python 2, the operator performed integer division if both the dividend and the divisor were integers, and floating-point division if at least one of them was a float. In Python 3, always performs floating-point division and always performs integer division – even if the dividend and divisor are floats! Some other languages (e.g. C, Java) store each integer in a small fixed amount of memory. This limits the size of the integer that may be stored. Common limits are , , and . Python has no fixed limit can stored surprisingly large integers such as as long as there is enough memory and processing power available on the machine where it is running. Another important thing to keep in mind is operator precedence. For example, does mean or ? Python has a specific and predictable way to determine the order in which it performs operations. For integer operations, the system will first handle brackets , then , then , and , and finally and . If an expression contains multiple operations which are at the same level of precedence, like , and , they will be performed in order, either from left to right (for left-associative operators) or from right to left (for right-associative operators). All these arithmetic operators are left-associative, except for , which is right-associative: # all arithmetic operators other than ** are left-associative, so # is evaluated left to right: # is evaluated right to left: The following table shows some more examples of precedence: Sometimes it’s a good idea to add brackets to arithmetic expressions even if they’re not compulsory, because it makes the code more understandable.\n• None Which of the following numbers are valid Python integers? , , , ,\n• None What are the results of the following operations and explain why: #. #. #. #. #.\n• None What happens when you evaluate in the Python console? Why does this happen?\n\nFloating-point numbers ( type) are numbers with a decimal point or an exponent (or both). Examples are , , , and . We can use scientific notation to denote very large or very small floating-point numbers, e.g. 3.8 x 1015. The first part of the number, 3.8, is the mantissa and 15 is the exponent. We can think of the exponent as the number of times we have to move the decimal point to the right to get to the actual value of the number. In Python, we can write the number 3.8 x 1015 as or . We can also write it as or . They are all the same value. A negative exponent indicates smaller numbers, e.g. is the same as . Negative exponents can be thought of as how many times we have to move the decimal point to the left. Negative mantissa indicates that the number itself is negative, e.g. equals and equals . The function will display floating-point numbers in decimal notation if they are greater than or equal to and less than , but for smaller and larger numbers it will use scientific notation: When displaying floats, we will usually specify how we would like them to be displayed, using string formatting: Note that any rounding only affects the display of the numbers. The precision of the number itself is not affected. Arithmetic operations for floating-point numbers are the same as those for integers: addition, subtraction, multiplication, division and modulus. They also use the same operators, except for division – the floating-point division operator is . Floating-point operations always produce a floating-point solution. The order of precedence for these operators is the same as those for integer operators. Often, we will have to decide which type of number to use in a program. Generally, we should use integers for counting and measuring discrete whole numbers. We should use floating-point numbers for measuring things that are continuous. We can combine integers and floating-point numbers in arithmetic expressions without having to convert them – this is something that Python will do for us automatically. If we perform an arithmetic operation on an integer and a floating-point number, the result will always be a floating-point number. We can use the integer division operator on floating-point numbers, and vice versa. The two division operators are at the same level in the order of precedence. Python floating-point numbers conform to a standardised format named . The standard represents each floating-point number using a small fixed amount of memory, so unlike Python’s integers, Python’s floating-point numbers have a limited range. The largest floating-point number that can be represented in Python is . Python includes three other types for dealing with numbers:\n• None (for decimal floating-point arithmetic; available in the module). Using these is beyond the scope of this module, but it’s worth knowing that they exist in case you have a use for them later.\n• None Which of the following are Python floating-point numbers? , , , , , ,\n• None What is the difference between integer and floating-point division? What is the operator used for integer division? What is the operator used for floating-point division?\n• None What are the results of the following operations? Explain why: #. #. #. #. #. #.\n• None What happens when you evaluate in the Python console?\n• None What happens when you evaluate ? What about ? And ?\n\nA string is a sequence of characters. You should already be familiar with string literals from working with them in the last section. In Python, strings (type ) are a special kind of type which is similar to sequence types. In many ways, strings behave in similar ways to lists (type ), which we will discuss in a later chapter, but they also have some functionality specific to text. Many other languages have a different variable type for individual characters – but in Python single characters are just strings with a length of 1. In Python 2, the type used the ASCII encoding. If we wanted to use strings containing Unicode (for example, characters from other alphabets or special punctuation) we had to use the type. In Python 3, the type uses Unicode. We will often need to print a message which is not a fixed string – perhaps we want to include some numbers or other values which are stored in variables. The recommended way to include these variables in our message is to use string formatting syntax: The symbols in the string which start with percent signs ( ) are placeholders, and the variables which are to be inserted into those positions are given after the string formatting operator, , in the same order in which they appear in the string. If there is only one variable, it doesn’t require any kind of wrapper, but if we have more than one we need to put them in a tuple (between round brackets). The placeholder symbols have different letters depending on the type of the variable – is a string, but is an integer. All the variables will be converted to strings before being combined with the rest of the message. An escape sequence (of characters) can be used to denote a special character which cannot be typed easily on a keyboard or one which has been reserved for other purposes. For example, we may want to insert a newline into our string: If our string is enclosed in single quotes, we will have to escape apostrophes, and we need to do the same for double quotes in a string enclosed in double quotes. An escape sequence starts with a backslash ( ): If we did not escape one of these quotes, Python would treat it as the end quote of our string – and shortly afterwards it would fail to parse the rest of the statement and give us a syntax error: We can also use escape sequences to output unicode characters. Sometimes we may need to define string literals which contain many backslashes – escaping all of them can be tedious. We can avoid this by using Python’s raw string notation. By adding an before the opening quote of the string, we indicate that the contents of the string are exactly what we have written, and that backslashes have no special meaning. For example: # This string ends in a backslash followed by an 'n' We most often use raw strings when we are passing strings to some other program which does its own processing of special sequences. We want to leave all such sequences untouched in Python, to allow the other program to handle them. In cases where we need to define a long literal spanning multiple lines, or containing many quotes, it may be simplest and most legible to enclose it in triple quotes (either single or double quotes, but of course they must match). Inside the triple quotes, all whitespace is treated literally – if we type a newline it will be reflected in our string. We also don’t have to escape any quotes. We must be careful not to include anything that we don’t mean to – any indentation will also go inside our string! These string literals will be identical: We have already introduced a string operation - concatenation ( ). It can be used to join two strings. There are many built-in functions which perform operations on strings. String objects also have many useful methods (i.e. functions which are attached to the objects, and accessed with the attribute reference operator, ): # Find the length of a string with the built-in len function Why does the last print statement output the original value of ? It’s because the method does not change the value of . It returns a modified copy of the value. If we wanted to change the value of permanently, we would have to assign the new value to the variable, like this: In Python, strings are immutable – that means that we can’t modify a string once it has been created. However, we can assign a new string value to an existing variable name.\n• None Given variables and , use string formatting to print out the values of and and their sum. For example, if and your statement should print .\n• None Re-write the following strings using single-quotes instead of double-quotes. Make use of escape sequences as needed: #. #. \"The title of the book was \\\"Good Omens\\\".\" #.\n• None Use escape sequences to write a string which represents the letters , and separated by tabs.\n• None Use escape sequences to write a string containing the following haiku (with newlines) inside single double-or-single quotes. Then do the same using triple quotes instead of the escape sequences:\n• None Given a variable containing a string, write a print statement that prints the name and the number of characters in it. For example, if , your statement should print .\n• None What does the following sequence of statements output: Why is the second line output not lowercase?"
    },
    {
        "link": "https://upgrad.com/tutorials/software-engineering/python-tutorial/operator-precedence-in-python",
        "document": "In Python, operator precedence refers to the order in which operators are evaluated in an expression. This means certain operations are performed before others when no parentheses are used to define the order explicitly.\n\nUnderstanding operator precedence in Python with examples is essential. The wrong evaluation order can lead to unexpected results in your code.\n\nFortunately, learning the precedence of arithmetic operators in Python will help you avoid these issues. You can use parentheses to control the order of operations, ensuring your calculations are accurate.\n\nKeep reading and learn how to make your code more predictable and error-free. Let’s dive in!\n\n“Enhance your Python skills further with our and from top universities — take the next step in your learning journey!”\n\nWhat is Operator Precedence in Python?\n\nOperator precedence in determines the order in which different operators are evaluated in an expression. For example, when you write an expression like 3 + 4 * 2, the multiplication (*) happens first, because it has higher precedence than addition (+).\n\nIn simple terms, operator precedence helps Python decide which operation to perform first when multiple operators are used in a single expression. This ensures your expressions are evaluated consistently and correctly.\n\nIf you don’t specify the order using parentheses, Python will follow the predefined rules of precedence, ensuring operations like multiplication, division, and subtraction happen before addition.\n\nTo help you understand operator precedence in Python with examples, here's a simple table showing the order in which Python evaluates operators.\n\nThe higher the operator is on the list, the higher its precedence.\n\nKnowing this precedence of arithmetic operators in Python allows you to predict how your expressions will be evaluated.\n\nIf you want to override the default order, just use parentheses () to make the evaluation clear.\n\nWhen dealing with operator precedence in Python with examples, it’s helpful to remember the PEMDAS rule. This acronym stands for Parentheses, Exponents, Multiplication and Division (from left to right), Addition and Subtraction (from left to right). This is the order Python follows when evaluating expressions.\n• Parentheses (): Anything inside parentheses is evaluated first, no matter what.\n• **Exponents ** : Then, exponentiation (**) happens next.\n• Multiplication (*) and Division (/): After that, multiplication and division are evaluated from left to right.\n• Addition (+) and Subtraction (-): Finally, addition and subtraction are performed from left to right.\n\nFor example, in the expression 2 + 3 * 4, Python first evaluates 3 * 4 (multiplication) and then adds 2 to the result, following the PEMDAS rule.\n\nIf you need to change the order, just use parentheses to make the logic explicit.\n\nAlso Read: List of Operators In SQL [With Examples]\n\nThe Associativity Rule in Python determines the order in which operators of the same precedence level are evaluated.\n\nThere are two types of associativity:\n• Left-to-Right (LTR) Associativity , such as addition, subtraction, multiplication, and comparison operators, follow left-to-right associativity. This means Python evaluates the leftmost operator first.For example, in the expression 5 - 3 - 2, Python evaluates it as (5 - 3) - 2, going from left to right.\n• Right-to-Left (RTL) Associativity : Some operators, like exponentiation (**), have right-to-left associativity. This means Python evaluates the rightmost operator first.For example, in 2 ** 3 ** 2, Python evaluates it as 2 ** (3 ** 2), meaning it performs 3 ** 2 first, and then raises 2 to the result.\n\nThese concepts will help you write more accurate and reliable code.\n\nIn Python, comparison operators are used to compare two values. These operators return either True or False based on the comparison.\n\nUnderstanding operator precedence in Python with examples is key, as comparison operators have their own precedence when used with other operators in expressions.\n\nLet's go through the comparison operators in Python:\n\nThis operator checks if two values are equal.\n\nHere, x becomes 7 (5 + 2), and y also evaluates to 7 (3 * 2 + 1), so x == y returns True.\n\nThis operator checks if two values are not equal.\n\nHere, a is 7 (10 - 3), and b is also 10 (5 * 2), so a != b evaluates to False.\n\nThis operator checks if the value on the left is greater than the value on the right.\n\nHere, x becomes 10 ((3 + 2) * 2), and y is also 10. The comparison x > y returns False because they are equal, so it will evaluate as False.\n\nThis operator checks if the value on the left is less than the value on the right.\n\nIn this case, the multiplication happens first (3 * 2 = 6), so x becomes 2 (8 - 6). Since 2 is indeed less than 6, the result is True.\n\n5. Greater than or equal to (>=)\n\nThis operator checks if the value on the left is greater than or equal to the value on the right.\n\nThe multiplication 4 * 3 = 12 happens first, so a becomes 18. Since a is equal to b, the result of a >= b is True.\n\n6. Less than or equal to (<=)\n\nThis operator checks if the value on the left is less than or equal to the value on the right.\n\nHere, a becomes 5.0 (15 / 3), and b becomes 8 (6 + 2). Since 5.0 is less than 8, the result is True.\n• None Comparison operators have a lower operator precedence than arithmetic operators, which means they are evaluated after operations like addition, subtraction, and multiplication.\n\nHowever, if you use parentheses, you can control the evaluation order.\n• None These operators are often used in like if, elif, and to check whether a condition is met.\n\nPractice these examples and learn how to control program flow by making decisions based on values.\n\n“Start your coding journey with our complimentary Python courses designed just for you — dive into , explore , and engage with !”\n\nLogical operators in Python are used to combine conditional statements, allowing you to evaluate multiple conditions at once. These operators return True or False based on the conditions.\n\nHere are the main logical operators in Python:\n\nThis operator returns True if both conditions are true.\n\nBoth conditions (x > 3 and y < 15) are True, so the result is True.\n\nThis operator returns True if at least one condition is true.\n\nSince one condition (y < 25) is True, the result is True.\n\nThis operator inverts the truth value of the condition. If the condition is True, it returns False and vice versa.\n\nSince x > 10 is False, not inverts it to True.\n• AND returns True only if both conditions are true.\n• OR returns True if at least one condition is true.\n• NOT inverts the result of the condition.\n\nKeep experimenting to strengthen your understanding!\n\nare used to perform mathematical operations on numbers. These operators allow you to perform basic calculations like addition, subtraction, multiplication, and more.\n\nLet’s look at precedence of arithmetic operators in Python:\n\nSubtracts the right-hand number from the left-hand number.\n\nDivides the left-hand number by the right-hand number, always returning a float.\n\nReturns the remainder of the division.\n\nRaises the left-hand number to the power of the right-hand number.\n\n3 ** 2 equals 9 (3 raised to the power of 2).\n\nDivides the left-hand number by the right-hand number and returns the largest integer less than or equal to the result.\n\n17 // 3 gives 5, which is the floor division result.\n• Division floor division returns the largest integer less than or equal to the result.\n• Modulus gives the remainder of the division.\n\nExperiment with more complex expressions to deepen your knowledge!\n\nare used to manipulate individual bits of integer values. These operators work on the binary representations of numbers, allowing you to perform operations at the bit level.\n\nHere are the key bitwise operators in Python:\n\nPerforms a bitwise AND operation. It returns 1 if both bits are 1; otherwise, it returns 0.\n\nHere, 1010 & 0100 gives 0000 in binary, which is 0 in decimal.\n\nPerforms a bitwise OR operation. It returns 1 if at least one bit is 1, otherwise, it returns 0.\n\nHere, 1010 | 0100 gives 1110 in binary, which is 14 in decimal.\n\nPerforms a bitwise XOR (exclusive OR) operation. It returns 1 if the bits are different, otherwise returns 0.\n\nHere, 1010 ^ 0100 gives 1110 in binary, which is 14 in decimal.\n\nPerforms a bitwise NOT operation, which inverts the bits. It flips 1 to 0 and 0 to 1.\n\nThe bitwise NOT of 10 (which is 1010 in binary) inverts all the bits, resulting in -11 due to the way negative numbers are represented in Python.\n\nShifts the bits of a number to the left by a specified number of positions, effectively multiplying the number by 2 for each position shifted.\n\nShifting 5 (which is 0101 in binary) one position to the left gives 1010, which is 10 in decimal.\n\nShifts the bits of a number to the right by a specified number of positions, effectively dividing the number by 2 for each position shifted.\n\nShifting 10 (which is 1010 in binary) one position to the right gives 0101, which is 5 in decimal.\n• AND returns 1 only when both bits are 1.\n• OR returns 1 if at least one bit is 1.\n• XOR returns 1 if the bits are different.\n• NOT inverts the bits, flipping 1 to 0 and vice versa.\n• Left and Right Shift operations shift the bits left or right, multiplying or dividing by 2 for each shift.\n\nKeep practicing with these operators to get comfortable with bitwise manipulation!\n\nAlso Read: Comprehensive Guide to Binary Code: Basics, Uses, and Practical Examples\n\nare used to assign values to variables. These operators not only assign values but also perform arithmetic or bitwise operations in a shorthand way.\n\nHere are the main assignment operators in Python:\n\nThe = operator is used to assign a value to a variable.\n\nHere, 10 is assigned to the variable x.\n\nThis operator adds the right operand to the left operand and assigns the result to the left operand.\n\nHere, 3 is added to x, and the result is assigned back to x, so x becomes 8.\n\nThis operator subtracts the right operand from the left operand and assigns the result to the left operand.\n\nHere, 4 is subtracted from x, and the result is assigned back to x, so x becomes 6.\n\nThis operator multiplies the left operand by the right operand and assigns the result to the left operand.\n\nHere, x is multiplied by 2, and the result is assigned back to x, so x becomes 12.\n\nThis operator divides the left operand by the right operand and assigns the result to the left operand.\n\nHere, 10 is divided by 2, and the result (5.0, since division always returns a float) is assigned to x.\n\nThis operator takes the modulus of the left operand by the right operand and assigns the result to the left operand.\n\nHere, the modulus of 10 by 3 is 1, and the result is assigned to x.\n\nThis operator raises the left operand to the power of the right operand and assigns the result to the left operand.\n\nHere, x is raised to the power of 3, so x becomes 8.\n\nThis operator performs floor division (divides and rounds down) on the left operand by the right operand and assigns the result to the left operand.\n\nHere, 15 // 4 gives 3 because floor division rounds down to the nearest integer.\n• Assignment Operators combine the assignment operation with other arithmetic operations, allowing for shorthand code.\n• None You can use * +=, -=, =, /=, and others to update the value of variables without repeating the variable name.\n\nExperiment with these operators in different scenarios to simplify your code and improve efficiency!\n\nHow upGrad can help you?\n\nWith upGrad, you can access global standard education facilities right here in India. upGrad also offers that come with certificates, making them an excellent opportunity if you're interested in data science and machine learning.\n\nBy enrolling in upGrad's Python courses, you can benefit from the knowledge and expertise of some of the best educators from around the world. These instructors understand the diverse challenges that Python programmers face and can provide guidance to help you navigate them effectively.\n\nSo, reach out to an today to learn more about how you can benefit from a Python course.\n\nHere are some of the best data science and machine learning courses offered by upGrad, designed to meet your learning needs:\n• None Professional Certificate Program in Business Analytics & Consulting in association with PwC India\n• None Doctor of Business Administration in Emerging Technologies with Specialization in Generative AI\n• None Difference Between List and Tuple in Python\n• None Difference between List, Tuple, Set, and Dictionary in Python\n\n1. What is operator precedence in Python?\n\nOperator precedence in Python determines the order in which operations are performed in an expression. Higher precedence operators are evaluated first.\n\nPython follows specific rules like PEMDAS (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction) to handle operator precedence in Python with examples.\n\nNo, operator precedence is fixed in Python. However, you can use parentheses () to explicitly define the order of operations.\n\n4. What happens if I don’t use parentheses in an expression?\n\nPython will follow the default operator precedence in Python. Without parentheses, operations will follow the fixed precedence rules, which may lead to unexpected results.\n\n5. Do logical operators have higher precedence than arithmetic operators?\n\nNo, logical operators have lower precedence than arithmetic operators. Arithmetic operators like +, -, *, / are evaluated before logical operators like and, or.\n\n6. What is the precedence of comparison operators in Python?\n\nComparison operators (like ==, !=, >, <) have lower precedence than arithmetic operators but higher precedence than logical operators.\n\n7. How do bitwise operators work in terms of precedence?\n\nBitwise operators (like &, |, ^, <<, >>) have lower precedence than arithmetic operators but higher than comparison and logical operators.\n\n8. Can I mix arithmetic and logical operators in an expression?\n\nYes, but be mindful of operator precedence in Python. Arithmetic operations will be performed first unless parentheses are used to alter the order.\n\n9. What is the difference between and and or in Python?\n\nThe and operator returns True only if both conditions are true, while the or operator returns True if at least one condition is true.\n\n10. Does the order of operations matter in Python?\n\nYes, understanding operator precedence is essential in Python to ensure expressions are evaluated as intended. Parentheses can be used to control the order explicitly.\n\n11. How do I check operator precedence in Python?\n\nYou can refer to Python’s official documentation or use a precedence table to check how different operators are evaluated in Python."
    }
]