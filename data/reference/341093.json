[
    {
        "link": "https://cppcheck.sourceforge.io/manual.pdf",
        "document": ""
    },
    {
        "link": "https://cppcheck.sourceforge.io/manual.html",
        "document": "Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code, and generate as few false positives (wrongly reported warnings) as possible. Cppcheck is designed to analyze your C/C++ code even if it has non-standard syntax, as is common in for example embedded projects.\n• Cppcheck checks non-standard code that contains various compiler extensions, inline assembly code, etc.\n• Cppcheck should be compilable by any compiler that supports C++11 or later.\n• Cppcheck is cross platform and is used in various posix/windows/etc environments.\n\nThe checks in Cppcheck are not perfect. There are bugs that should be found, that Cppcheck fails to detect.\n\nThe kinds of bugs that you can find with static analysis are:\n\nThere are many bugs that you can not find with static analysis. Static analysis tools do not have human knowledge about what your program is intended to do. If the output from your program is valid but unexpected then in most cases this is not detected by static analysis tools. For instance, if your small program writes “Helo” on the screen instead of “Hello” it is unlikely that any tool will complain about that.\n\nStatic analysis should be used as a complement in your quality assurance. It does not replace any of;\n\nIt is not required but creating a new project file is a good first step. There are a few options you can tweak to get good results.\n\nIn the project settings dialog, the first option you see is “Import project”. It is recommended that you use this feature if you can. Cppcheck can import:\n• Compile database, which can be generated from CMake/qbs/etc build files\n\nWhen you have filled out the project settings and clicked on OK, the Cppcheck analysis will start.\n\nHere is some simple code:\n\nIf you save that into file1.c and execute:\n\nThe output from Cppcheck will then be:\n\nNormally a program has many source files. Cppcheck can check all source files in a directory:\n\nIf “path” is a folder, then Cppcheck will recursively check all source files in this folder:\n\nWith Cppcheck you can check files manually by specifying files/paths to check and settings. Or you can use a build environment, such as CMake or Visual Studio.\n\nWe don’t know which approach (project file or manual configuration) will give you the best results. It is recommended that you try both. It is possible that you will get different results so that to find the largest amount of bugs you need to use both approaches. Later chapters will describe this in more detail.\n\nWith you can set a file filter and only those files matching the filter will be checked.\n\nFor example: if you want to check only those files and folders starting from a subfolder src/ that start with “test” you have to type:\n\nCppcheck first collects all files in src/ and will apply the filter after that. So the filter must start with the given start folder.\n\nTo exclude a file or folder, there are two options. The first option is to only provide the paths and files you want to check:\n\nAll files under src/a and src/b are then checked.\n\nThe second option is to use -i, which specifies the files/paths to ignore. With this command no files in src/c are checked:\n\nThis option is only valid when supplying an input directory. To ignore multiple directories supply the -i flag for each directory individually. The following command ignores both the src/b and src/c directories:\n\nBy default Cppcheck uses an internal C/C++ parser. However there is an experimental option to use the Clang parser instead.\n\nTechnically, Cppcheck will execute with its option. The Clang output is then imported and converted into the normal Cppcheck format. And then normal Cppcheck analysis is performed on that.\n\nYou can also pass a custom Clang executable to the option by using for example . You can also pass it with a path. On Windows it will append the extension unless you use a path.\n\nThe possible severities for messages are:\n\nwhen code is executed there is either undefined behavior or other error, such as a memory leak or resource leak\n\nwhen code is executed there might be undefined behavior\n\nstylistic issues, such as unused functions, redundant code, constness, operator precedence, possible mistakes.\n\nrun time performance suggestions based on common knowledge, though it is not certain any measurable speed difference will be achieved by fixing these messages.\n\nportability warnings. Implementation defined behavior. 64-bit portability. Some undefined behavior that probably works “as you want”, etc.\n\nconfiguration problems, which does not relate to the syntactical correctness, but the used Cppcheck configuration could be improved.\n\nCppcheck instantiates the templates in your code.\n\nIf your templates are recursive this can lead to slow analysis that uses a lot of memory. Cppcheck will write information messages when there are potential problems.\n\nAs you can see Cppcheck has instantiated until was reached and then it bails out.\n\nTo limit template recursion you can:\n• configure Cppcheck, which can be done in the GUI project file dialog\n\nYou can pass when checking this code.\n\nUsing a Cppcheck build folder is not mandatory but it is recommended.\n• It speeds up the analysis as it makes incremental analysis possible. Only changed files are analyzed when you recheck.\n• Whole program analysis also when multiple threads are used.\n\nOn the command line you configure that through . Example:\n\nIn the GUI it is configured in the project settings.\n\nYou can import some project files and build configurations into Cppcheck.\n\nYou can import and use Cppcheck GUI project files in the command line tool:\n\nThe Cppcheck GUI has a few options that are not available in the command line directly. To use these options you can import a GUI project file. The command line tool usage is kept intentionally simple and the options are therefore limited.\n\nTo ignore certain folders in the project you can use . This will skip the analysis of source files in the folder.\n\nThe file is created in the current folder. Now run Cppcheck like this:\n\nTo ignore certain folders you can use . This will skip analysis of source files in the folder.\n\nYou can run Cppcheck on individual project files (*.vcxproj) or on a whole solution (*.sln)\n\nBoth options will analyze all available configurations in the project(s). Limiting on a single configuration:\n\nIn the you have the option to only analyze a single debug configuration. If you want to use this option on the command line, then create a project with this activated and then import the GUI project file on the command line.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nIf you can generate a compile database, then it is possible to import that in Cppcheck.\n\nIn Linux you can use for instance the (build ear) utility to generate a compile database from arbitrary build tools:\n\nIf you use then Cppcheck will automatically use the preprocessor settings in the imported project file and likely you don’t have to configure anything extra.\n\nIf you don’t use then a bit of manual preprocessor configuration might be required. However Cppcheck has automatic configuration of defines.\n\nCppcheck automatically test different combinations of preprocessor defines to achieve as high coverage in the analysis as possible.\n\nHere is a file that has 3 bugs (when x,y,z are assigned).\n\nThe flag tells Cppcheck that a name is defined. There will be no Cppcheck analysis without this define. The flag tells Cppcheck that a name is not defined. There will be no Cppcheck analysis with this define. The flag and is used to control how many combinations are checked. When is used, Cppcheck will only check 1 configuration unless these are used.\n\nTo add an include path, use , followed by the path.\n\nCppcheck’s preprocessor basically handles includes like any other preprocessor. However, while other preprocessors stop working when they encounter a missing header, Cppcheck will just print an information message and continues parsing the code.\n\nThe purpose of this behaviour is that Cppcheck is meant to work without necessarily seeing the entire code. Actually, it is recommended to not give all include paths. While it is useful for Cppcheck to see the declaration of a class when checking the implementation of its members, passing standard library headers is discouraged, because the analysis will not work fully and lead to a longer checking time. For such cases, .cfg files are the preferred way to provide information about the implementation of functions and types to Cppcheck, see below for more information.\n\nYou should use a platform configuration that matches your target environment.\n\nBy default Cppcheck uses native platform configuration that works well if your code is compiled and executed locally.\n\nCppcheck has builtin configurations for Unix and Windows targets. You can easily use these with the command line flag.\n\nYou can also create your own custom platform configuration in a XML file. Here is an example:\n\nUse on the command line to specify a C/C++ standard.\n\nCppcheck assumes that the code is compatible with the latest C/C++ standard, but it is possible to override this.\n\nThe available options are:\n\nIt’s a good idea to use a Cppcheck build dir. On the command line use . In the GUI, the build dir is configured in the project options.\n\nRechecking code will be much faster. Cppcheck does not analyse unchanged code. The old warnings are loaded from the build dir and reported again.\n\nWhole program analysis does not work when multiple threads are used; unless you use a cppcheck build dir. For instance, the unusedFunction warnings require whole program analysis.\n\nIf you want to filter out certain errors from being generated, then it is possible to suppress these.\n\nIf you encounter a false positive, then please report it to the Cppcheck team so that it can be fixed.\n\nThe format for an error suppression is one of:\n\nThe is the id that you want to suppress. The id of a warning is shown in brackets in the normal cppcheck text output. The suppression may contain * to match any sequence of tokens.\n\nThe filename may include the wildcard characters * or ?, which matches any sequence of characters or any single character respectively. It is recommended to use forward-slash as path separator on all operating systems. The filename must match the filename in the reported warning exactly. For instance, if the warning contains a relative path, then the suppression must match that relative path.\n\nThe command line option is used to specify suppressions on the command line. Example:\n\nYou can create a suppressions file for example as follows:\n\nNote that you may add empty lines and comments in the suppressions file. Comments must start with or and be at the start of the line, or after the suppression line.\n\nThe usage of the suppressions file is as follows:\n\nYou can specify suppressions in a XML file, for example as follows:\n\nThe XML format is extensible and may be extended with further attributes in the future.\n\nThe usage of the suppressions file is as follows:\n\nSuppressions can also be added directly in the code by adding comments that contain special keywords. Note that adding comments sacrifices the readability of the code somewhat.\n\nThis code will normally generate an error message:\n\nYou can suppress a warning with:\n\nSuppressing multiple ids in one comment by using []:\n\nSuppressing warnings where macro is used:\n\nSuppressing multiple ids where macro is used:\n\nThe comment can be put before the code or at the same line as the code.\n\nOr at the same line as the code:\n\nIn this example there are 2 lines with code and 1 suppression comment. The suppression comment only applies to 1 line: .\n\nAs a special case for backwards compatibility, if you have a on its own line and a suppression comment after that, then that will suppress warnings for both the current and next line. This example will suppress warnings both for and for :\n\nFor a line of code there might be several warnings you want to suppress.\n\nThere are several options;\n\nUsing 1 suppression comment before the code:\n\nSuppression comment on the same line as the code:\n\nYou can specify that the inline suppression only applies to a specific symbol:\n\nYou can write comments about a suppression as follows:\n\nCppcheck can generate output in XML format. Use to enable this format.\n\nA sample command to check a file and output errors in the XML format:\n\nEach error is reported in a element. Attributes:\n\nid of error, and which are valid symbolnames\n\nthis attribute is only used when the error message is inconclusive\n\nCWE ID for the problem; note that this attribute is only used when the CWE ID for the message is known\n\nAll locations related to an error are listed with elements. The primary location is listed first.\n\nfilename, both relative and absolute paths are possible\n\nname of the source file (optional)\n\nIf you want to reformat the output so that it looks different, then you can use templates.\n\nTo get Visual Studio compatible output you can use –template=vs:\n\nThis output will look like this:\n\nTo get gcc compatible output you can use –template=gcc:\n\nThe output will look like this:\n\nYou can write your own pattern. For instance, to get warning messages that are formatted like traditional gcc, then the following format can be used:\n\nThe output will then look like this:\n\nThe output will look like this:\n\nMany warnings have multiple locations. Example code:\n\nThere is a possible null pointer dereference at line 3. Cppcheck can show how it came to that conclusion by showing extra location information. You need to use both –template and –template-location at the command line, for example:\n\nThe output from Cppcheck is:\n\nThe first line in the warning is formatted by the –template format.\n\nThe other lines in the warning are formatted by the –template-location format.\n\nThe available specifiers for –template are:\n\nWrite all locations. Each location is written in [{file}:{line}] format and the locations are separated by ->. For instance it might look like: [multiline.c:8] -> [multiline.c:9] -> [multiline.c:3]\n\nIf warning is inconclusive, then the given text is written. The given text can be any text that does not contain }. Example: {inconclusive:inconclusive,}\n\nThe remark text if a remark comment has been provided\n\nThe available specifiers for are:\n\nJustifications for warnings in the report\n\nYou can add remark comments in the source code that justify why there is a warning/violation.\n• can either be added above the source code that generates the warning, or after the code on the same line.\n\nIn Cppcheck text output the remarks are not shown by default, you can use option to show remarks:\n\nIn xml output the comment text is provided in a “remark” attribute:\n\nAddons are scripts that analyse Cppcheck dump files to check compatibility with secure coding standards and to locate issues.\n\nCppcheck is distributed with a few addons which are listed below.\n\nmisra.py is used to verify compliance with MISRA C 2012, a proprietary set of guidelines to avoid questionable code, developed for embedded systems.\n\nThe misra rule texts should be downloaded from MISRA: https://gitlab.com/MISRA/MISRA-C/MISRA-C-2012/tools\n\nUse the option to specify the rules text file that has been downloaded from MISRA.\n\ny2038.py checks Linux systems for year 2038 problem safety. This required modified environment. See complete description here.\n\nthreadsafety.py analyses Cppcheck dump files to locate thread safety issues like static local objects used by multiple threads.\n\nAddons could be run through Cppcheck command line utility as follows:\n\nThis will launch all Cppcheck checks and additionally calls specific checks provided by selected addon.\n\nSome addons need extra arguments. You can configure how you want to execute an addon in a json file. For example put this in misra.json:\n\nAnd then the configuration can be executed on the Cppcheck command line:\n\nBy default Cppcheck would search addon at the standard path which was specified during the installation process. You also can set this path directly, for example:\n\nThis allows you to create and manage multiple configuration files for different projects.\n\nWhen external libraries are used, such as WinAPI, POSIX, gtk, Qt, etc, Cppcheck has no information about functions, types, or macros contained in those libraries. Cppcheck then fails to detect various problems in the code, or might even abort the analysis. But this can be fixed by using the appropriate configuration files.\n\nCppcheck already contains configurations for several libraries. They can be loaded as described below. Note that the configuration for the standard libraries of C and C++, std.cfg, is always loaded by cppcheck. If you create or update a configuration file for a popular library, we would appreciate if you supplied it to the cppcheck project.\n\nTo use a .cfg file shipped with cppcheck, pass the option. The table below shows the currently existing libraries: | .cfg file | Library | Comment | | ————- | ————- | ————- | | avr.cfg | | | bento4.cfg | Bento4 | | boost.cfg | Boost| | bsd.cfg | BSD | | cairo.cfg | cairo | | cppcheck-lib.cfg | Cppcheck | Used in selfcheck of the Cppcheck code base | cppunit.cfg | CppUnit | | dpdk.cfg | | | embedded_sql.cfg | | | emscripten.cfg | | | ginac.cfg | | | gnu.cfg | GNU | | googletest.cfg | GoogleTest | | gtk.cfg | GTK | | icu.cfg | | | kde.cfg | KDE | | libcerror.cfg | libcerror | | libcurl.cfg | libcurl | | libsigc++.cfg | libsigc++ | | lua.cfg | | | mfc.cfg | MFC | | microsoft_atl.cfg | ATL | | microsoft_sal.cfg | SAL annotations | | microsoft_unittest.cfg | CppUnitTest | | motif.cfg | | | nspr.cfg | | | ntl.cfg | | | opencv2.cfg | OpenCV | | opengl.cfg | OpenGL | | openmp.cfg | OpenMP | | openssl.cfg | OpenSSL | | pcre.cfg | PCRE | | posix.cfg | POSIX | | python.cfg | | | qt.cfg | Qt | | ruby.cfg | | | sdl.cfg | | | sfml.cfg | | | sqlite3.cfg | SQLite | | std.cfg | C/C++ standard library | Loaded by default | tinyxml2.cfg | TinyXML-2 | | vcl.cfg | | | windows.cfg | Win32 API | | wxsqlite3.cfg | | | wxsvg.cfg | | | wxwidgets.cfg | wxWidgets | | zephyr.cfg | | | zlib.cfg | zlib |\n\nYou can create and use your own .cfg files for your projects. Use to get hints about what you should configure.\n\nYou can use the in the to edit configuration files. It is available in the menu.\n\nThe .cfg file format is documented in the (https://cppcheck.sourceforge.io/reference-cfg-format.pdf) document.\n\nYou can convert the XML output from Cppcheck into a HTML report. You’ll need Python and the pygments module (http://pygments.org/) for this to work. In the Cppcheck source tree there is a folder htmlreport that contains a script that transforms a Cppcheck XML file into HTML output.\n\nThis command generates the help screen:\n\nThe “reduced” check level performs a limited data flow analysis. If developers want to run cppcheck directly during development and require faster results than “normal” provides then this reduced checking can be an option.\n\nThe “normal” check level is chosen by default. Our aim is that this checking level will provide an effective checking in “reasonable” time.\n\nThe “normal” check level should be useful during active development: * checking files while you edit them. * block changes to the repo * etc\n\nWhen you can wait longer for the results you can enable the “exhaustive” checking, by using the option .\n\nExhaustive checking level should be useful for scenarios where you can wait for results. For instance: * nightly builds * etc\n\nFor performance reasons it might be a good idea to limit preprocessor configurations to check.\n\nThe command line option adjusts the max count for number of if in a function.\n\nWhen that limit is exceeded there is a limitation of data flow in that function. It is not drastic: * Analysis of other functions are not affected. * It’s only for some specific data flow analysis, we have data flow analysis that is always executed. * All checks are always executed. There can still be plenty of warnings in the limited function.\n\nThere is data flow analysis that slows down exponentially when number of if increase. And the limit is intended to avoid that analysis time explodes.\n\nIn the GUI there are various options to limit analysis.\n\nIn the GUI: * Open the project dialog. * In the “Analysis” tab there are several options.\n\nIf you want to use these limitations on the command line also you can import the GUI project file with –project.\n\nThis is analysis that is more noisy than normal analysis. Most warnings will be false positives (cppcheck will wrongly claim that there are bugs). The design goal is to not have more than roughly 5 - 10 false positives in each file.\n\nIt is not intended to be used in normal CI or regular static analysis by developers. The noise makes it useless for that.\n\nIt is intended to be used when you are looking for bugs and you really can accept noise. For example: * You have developed a brand new feature and want to ensure that there are no bugs. * Maybe as part of release testing your product you can run bug hunting on modified files. * Etc\n\nTechnically, analysis that is “sound” will detect all bugs. Analysis that is “soundy” has the goal to detect most bugs and it tries to keep the noise at an reasonable level.\n\nA license that is connected to your computer. You can check any code you want.\n\nA license that allows you to run cppcheck on a limited number of lines of code. It can only be used for certain licensed paths in a repository."
    },
    {
        "link": "https://cppcheck.sourceforge.io",
        "document": "Cppcheck is a static analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to have very few false positives. Cppcheck is designed to be able to analyze your C/C++ code even if it has non-standard syntax (common in embedded projects).\n\nCppcheck is available both as open-source (this page) and as Cppcheck Premium with extended functionality and support. Please visit www.cppcheck.com for more information and purchase options for the commercial version.\n\nCppcheck can also be installed from various package managers; however, you might get an outdated version then.\n\nUnique code analysis that detect various kinds of bugs in your code.\n\nBoth command line interface and graphical user interface are available.\n\nUsing several static analysis tools can be a good idea. There are unique features in each tool. This has been established in many studies.\n\nSo what is unique in Cppcheck.\n\nCppcheck uses unsound flow sensitive analysis. Several other analyzers use path sensitive analysis based on abstract interpretation, that is also great however that has both advantages and disadvantages. In theory by definition, it is better with path sensitive analysis than flow sensitive analysis. But in practice, it means Cppcheck will detect bugs that the other tools do not detect.\n\nIn Cppcheck the data flow analysis is not only \"forward\" but \"bi-directional\". Most analyzers will diagnose this:\n\nMost tools can determine that the array index will be 1000 and there will be overflow.\n\nCppcheck will also diagnose this:\n\nThe most common types of security vulnerabilities in 2017 (CVE count) was:\n\nCVEs that was found using Cppcheck:\n• CVE-2017-1000249 : file : stack based buffer overflow\n\n This was found by Thomas Jarosch using Cppcheck. The cause is a mistake in a condition.\n• CVE-2013-6462 : 23 year old stack overflow in X.org that was found with Cppcheck.\n\n This has been described in a few articles (link).\n• CVE-2012-1147 : readfilemap.c in expat before 2.1.0 allows context-dependent attackers to cause a denial of service (file descriptor consumption) via a large number of crafted XML files..\n\nThese CVEs are shown when you google \"cppcheck CVE\". Feel free to compare the search results with other static analysis tools.\n\nSecurity experts recommend that static analysis is used. And using several tools is the best approach from a security perspective.\n\nFor a list of all checks in Cppcheck see: http://sourceforge.net/p/cppcheck/wiki/ListOfChecks.\n\nCppcheck is integrated with many popular development tools. For instance:\n• Mercurial (Linux) - pre-commit hook - Check for new errors on commit (requires interactive terminal)\n\nUsing a battery of tools is better than using one tool. Each tool has unique code analysis and therefore we recommend that you also use other tools.\n\nCppcheck focus on bugs instead of stylistic issues. Therefore a tool that focus on stylistic issues could be a good addition.\n\nCppcheck tries very hard to avoid false positives. Sometimes people want to detect all bugs even if there will be many false warnings, for instance when they are working on a release and want to verify that there are no bugs. A tool that is much more noisy than Cppcheck might be a good addition.\n\nEven tools that have the same design goals as Cppcheck will probably be good additions. Static analysis is such a big field, Cppcheck only covers a small fraction of it. No tool covers the whole field. The day when all manual testing will be obsolete because of some tool is very far away.\n\nYou can read the manual.\n• Use Trac to report bugs and feature requests\n• Ask questions at the IRC channel #cppcheck\n\nThe Cppcheck project is a hobby project with limited resources. You can help us by donating CPU (1 core or as many as you like). It is simple:\n\nThe script will analyse debian source code and upload the results to a cppcheck server. We need these results both to improve Cppcheck and to detect regressions.\n\nYou can stop the script whenever you like with Ctrl C.\n\nYou are welcome to contribute. Help is needed.\n\nA presentation that might be interesting: Contribute to open source static analysis"
    },
    {
        "link": "https://github.com/danmar/cppcheck/blob/main/man/manual.md",
        "document": "Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code, and generate as few false positives (wrongly reported warnings) as possible. Cppcheck is designed to analyze your C/C++ code even if it has non-standard syntax, as is common in for example embedded projects.\n• Cppcheck checks non-standard code that contains various compiler extensions, inline assembly code, etc.\n• Cppcheck should be compilable by any compiler that supports C++11 or later.\n• Cppcheck is cross platform and is used in various posix/windows/etc environments.\n\nThe checks in Cppcheck are not perfect. There are bugs that should be found, that Cppcheck fails to detect.\n\nThe kinds of bugs that you can find with static analysis are:\n\nThere are many bugs that you can not find with static analysis. Static analysis tools do not have human knowledge about what your program is intended to do. If the output from your program is valid but unexpected then in most cases this is not detected by static analysis tools. For instance, if your small program writes \"Helo\" on the screen instead of \"Hello\" it is unlikely that any tool will complain about that.\n\nStatic analysis should be used as a complement in your quality assurance. It does not replace any of;\n\nIt is not required but creating a new project file is a good first step. There are a few options you can tweak to get good results.\n\nIn the project settings dialog, the first option you see is \"Import project\". It is recommended that you use this feature if you can. Cppcheck can import:\n• Compile database, which can be generated from CMake/qbs/etc build files\n\nWhen you have filled out the project settings and clicked on OK, the Cppcheck analysis will start.\n\nHere is some simple code:\n\nIf you save that into file1.c and execute:\n\nThe output from Cppcheck will then be:\n\nNormally a program has many source files. Cppcheck can check all source files in a directory:\n\nIf \"path\" is a folder, then Cppcheck will recursively check all source files in this folder:\n\nWith Cppcheck you can check files manually by specifying files/paths to check and settings. Or you can use a build environment, such as CMake or Visual Studio.\n\nWe don't know which approach (project file or manual configuration) will give you the best results. It is recommended that you try both. It is possible that you will get different results so that to find the largest amount of bugs you need to use both approaches. Later chapters will describe this in more detail.\n\nWith you can set a file filter and only those files matching the filter will be checked.\n\nFor example: if you want to check only those files and folders starting from a subfolder src/ that start with \"test\" you have to type:\n\nCppcheck first collects all files in src/ and will apply the filter after that. So the filter must start with the given start folder.\n\nTo exclude a file or folder, there are two options. The first option is to only provide the paths and files you want to check:\n\nAll files under src/a and src/b are then checked.\n\nThe second option is to use -i, which specifies the files/paths to ignore. With this command no files in src/c are checked:\n\nThis option is only valid when supplying an input directory. To ignore multiple directories supply the -i flag for each directory individually. The following command ignores both the src/b and src/c directories:\n\nBy default Cppcheck uses an internal C/C++ parser. However there is an experimental option to use the Clang parser instead.\n\nTechnically, Cppcheck will execute with its option. The Clang output is then imported and converted into the normal Cppcheck format. And then normal Cppcheck analysis is performed on that.\n\nYou can also pass a custom Clang executable to the option by using for example . You can also pass it with a path. On Windows it will append the extension unless you use a path.\n\nThe possible severities for messages are:\n\nwhen code is executed there is either undefined behavior or other error, such as a memory leak or resource leak\n\nwhen code is executed there might be undefined behavior\n\nstylistic issues, such as unused functions, redundant code, constness, operator precedence, possible mistakes.\n\nrun time performance suggestions based on common knowledge, though it is not certain any measurable speed difference will be achieved by fixing these messages.\n\nportability warnings. Implementation defined behavior. 64-bit portability. Some undefined behavior that probably works \"as you want\", etc.\n\nconfiguration problems, which does not relate to the syntactical correctness, but the used Cppcheck configuration could be improved.\n\nCppcheck instantiates the templates in your code.\n\nIf your templates are recursive this can lead to slow analysis that uses a lot of memory. Cppcheck will write information messages when there are potential problems.\n\nAs you can see Cppcheck has instantiated until was reached and then it bails out.\n\nTo limit template recursion you can:\n• configure Cppcheck, which can be done in the GUI project file dialog\n\nYou can pass when checking this code.\n\nUsing a Cppcheck build folder is not mandatory but it is recommended.\n• It speeds up the analysis as it makes incremental analysis possible. Only changed files are analyzed when you recheck.\n• Whole program analysis also when multiple threads are used.\n\nOn the command line you configure that through . Example:\n\nIn the GUI it is configured in the project settings.\n\nYou can import some project files and build configurations into Cppcheck.\n\nYou can import and use Cppcheck GUI project files in the command line tool:\n\nThe Cppcheck GUI has a few options that are not available in the command line directly. To use these options you can import a GUI project file. The command line tool usage is kept intentionally simple and the options are therefore limited.\n\nTo ignore certain folders in the project you can use . This will skip the analysis of source files in the folder.\n\nThe file is created in the current folder. Now run Cppcheck like this:\n\nTo ignore certain folders you can use . This will skip analysis of source files in the folder.\n\nYou can run Cppcheck on individual project files (*.vcxproj) or on a whole solution (*.sln)\n\nBoth options will analyze all available configurations in the project(s). Limiting on a single configuration:\n\nIn the you have the option to only analyze a single debug configuration. If you want to use this option on the command line, then create a project with this activated and then import the GUI project file on the command line.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nIf you can generate a compile database, then it is possible to import that in Cppcheck.\n\nIn Linux you can use for instance the (build ear) utility to generate a compile database from arbitrary build tools:\n\nIf you use then Cppcheck will automatically use the preprocessor settings in the imported project file and likely you don't have to configure anything extra.\n\nIf you don't use then a bit of manual preprocessor configuration might be required. However Cppcheck has automatic configuration of defines.\n\nCppcheck automatically test different combinations of preprocessor defines to achieve as high coverage in the analysis as possible.\n\nHere is a file that has 3 bugs (when x,y,z are assigned).\n\nThe flag tells Cppcheck that a name is defined. There will be no Cppcheck analysis without this define. The flag tells Cppcheck that a name is not defined. There will be no Cppcheck analysis with this define. The flag and is used to control how many combinations are checked. When is used, Cppcheck will only check 1 configuration unless these are used.\n\nTo add an include path, use , followed by the path.\n\nCppcheck's preprocessor basically handles includes like any other preprocessor. However, while other preprocessors stop working when they encounter a missing header, Cppcheck will just print an information message and continues parsing the code.\n\nThe purpose of this behaviour is that Cppcheck is meant to work without necessarily seeing the entire code. Actually, it is recommended to not give all include paths. While it is useful for Cppcheck to see the declaration of a class when checking the implementation of its members, passing standard library headers is discouraged, because the analysis will not work fully and lead to a longer checking time. For such cases, .cfg files are the preferred way to provide information about the implementation of functions and types to Cppcheck, see below for more information.\n\nYou should use a platform configuration that matches your target environment.\n\nBy default Cppcheck uses native platform configuration that works well if your code is compiled and executed locally.\n\nCppcheck has builtin configurations for Unix and Windows targets. You can easily use these with the command line flag.\n\nYou can also create your own custom platform configuration in a XML file. Here is an example:\n\nUse on the command line to specify a C/C++ standard.\n\nCppcheck assumes that the code is compatible with the latest C/C++ standard, but it is possible to override this.\n\nThe available options are:\n\nIt's a good idea to use a Cppcheck build dir. On the command line use . In the GUI, the build dir is configured in the project options.\n\nRechecking code will be much faster. Cppcheck does not analyse unchanged code. The old warnings are loaded from the build dir and reported again.\n\nWhole program analysis does not work when multiple threads are used; unless you use a cppcheck build dir. For instance, the unusedFunction warnings require whole program analysis.\n\nIf you want to filter out certain errors from being generated, then it is possible to suppress these.\n\nIf you encounter a false positive, then please report it to the Cppcheck team so that it can be fixed.\n\nThe format for an error suppression is one of:\n\nThe is the id that you want to suppress. The id of a warning is shown in brackets in the normal cppcheck text output. The suppression may contain * to match any sequence of tokens.\n\nThe filename may include the wildcard characters * or ?, which matches any sequence of characters or any single character respectively. It is recommended to use forward-slash as path separator on all operating systems. The filename must match the filename in the reported warning exactly. For instance, if the warning contains a relative path, then the suppression must match that relative path.\n\nThe command line option is used to specify suppressions on the command line. Example:\n\nYou can create a suppressions file for example as follows:\n\nNote that you may add empty lines and comments in the suppressions file. Comments must start with or and be at the start of the line, or after the suppression line.\n\nThe usage of the suppressions file is as follows:\n\nYou can specify suppressions in a XML file, for example as follows:\n\nThe XML format is extensible and may be extended with further attributes in the future.\n\nThe usage of the suppressions file is as follows:\n\nSuppressions can also be added directly in the code by adding comments that contain special keywords. Note that adding comments sacrifices the readability of the code somewhat.\n\nThis code will normally generate an error message:\n\nYou can suppress a warning with:\n\nSuppressing multiple ids in one comment by using []:\n\nSuppressing warnings where macro is used:\n\nSuppressing multiple ids where macro is used:\n\nComment before code or on same line\n\nThe comment can be put before the code or at the same line as the code.\n\nOr at the same line as the code:\n\nIn this example there are 2 lines with code and 1 suppression comment. The suppression comment only applies to 1 line: .\n\nAs a special case for backwards compatibility, if you have a on its own line and a suppression comment after that, then that will suppress warnings for both the current and next line. This example will suppress warnings both for and for :\n\nFor a line of code there might be several warnings you want to suppress.\n\nThere are several options;\n\nUsing 1 suppression comment before the code:\n\nSuppression comment on the same line as the code:\n\nYou can specify that the inline suppression only applies to a specific symbol:\n\nYou can write comments about a suppression as follows:\n\nCppcheck can generate output in XML format. Use to enable this format.\n\nA sample command to check a file and output errors in the XML format:\n\nEach error is reported in a element. Attributes:\n\nid of error, and which are valid symbolnames\n\nthis attribute is only used when the error message is inconclusive\n\nCWE ID for the problem; note that this attribute is only used when the CWE ID for the message is known\n\nAll locations related to an error are listed with elements. The primary location is listed first.\n\nfilename, both relative and absolute paths are possible\n\nname of the source file (optional)\n\nIf you want to reformat the output so that it looks different, then you can use templates.\n\nTo get Visual Studio compatible output you can use --template=vs:\n\nThis output will look like this:\n\nTo get gcc compatible output you can use --template=gcc:\n\nThe output will look like this:\n\nYou can write your own pattern. For instance:\n\nThe output will then look like this:\n\nThe output will look like this:\n\nMany warnings have multiple locations. Example code:\n\nThere is a possible null pointer dereference at line 3. Cppcheck can show how it came to that conclusion by showing extra location information. You need to use both --template and --template-location at the command line, for example:\n\nThe output from Cppcheck is:\n\nThe first line in the warning is formatted by the --template format.\n\nThe other lines in the warning are formatted by the --template-location format.\n\nThe available specifiers for --template are:\n\nWrite all locations. Each location is written in [{file}:{line}] format and the locations are separated by ->. For instance it might look like: [multiline.c:8] -> [multiline.c:9] -> [multiline.c:3]\n\nIf warning is inconclusive, then the given text is written. The given text can be any text that does not contain }. Example: {inconclusive:inconclusive,}\n\nThe remark text if a remark comment has been provided\n\nThe available specifiers for are:\n\nYou can add remark comments in the source code that justify why there is a warning/violation.\n• can either be added above the source code that generates the warning, or after the code on the same line.\n\nIn Cppcheck text output the remarks are not shown by default, you can use option to show remarks:\n\nIn xml output the comment text is provided in a \"remark\" attribute:\n\nAddons are scripts that analyse Cppcheck dump files to check compatibility with secure coding standards and to locate issues.\n\nCppcheck is distributed with a few addons which are listed below.\n\nmisra.py is used to verify compliance with MISRA C 2012, a proprietary set of guidelines to avoid questionable code, developed for embedded systems.\n\nThe misra rule texts should be downloaded from MISRA\n\nUse the option to specify the rules text file that has been downloaded from MISRA.\n\ny2038.py checks Linux systems for year 2038 problem safety. This required modified environment. See complete description here.\n\nthreadsafety.py analyses Cppcheck dump files to locate thread safety issues like static local objects used by multiple threads.\n\nAddons could be run through Cppcheck command line utility as follows:\n\nThis will launch all Cppcheck checks and additionally calls specific checks provided by selected addon.\n\nSome addons need extra arguments. You can configure how you want to execute an addon in a json file. For example put this in misra.json:\n\nAnd then the configuration can be executed on the Cppcheck command line:\n\nBy default Cppcheck would search addon at the standard path which was specified during the installation process. You also can set this path directly, for example:\n\nThis allows you to create and manage multiple configuration files for different projects.\n\nWhen external libraries are used, such as WinAPI, POSIX, gtk, Qt, etc, Cppcheck has no information about functions, types, or macros contained in those libraries. Cppcheck then fails to detect various problems in the code, or might even abort the analysis. But this can be fixed by using the appropriate configuration files.\n\nCppcheck already contains configurations for several libraries. They can be loaded as described below. Note that the configuration for the standard libraries of C and C++, std.cfg, is always loaded by cppcheck. If you create or update a configuration file for a popular library, we would appreciate if you supplied it to the cppcheck project.\n\nTo use a .cfg file shipped with cppcheck, pass the option. The table below shows the currently existing libraries:\n\nYou can create and use your own .cfg files for your projects. Use to get hints about what you should configure.\n\nYou can use the in the to edit configuration files. It is available in the menu.\n\nThe .cfg file format is documented in the (https://cppcheck.sourceforge.io/reference-cfg-format.pdf) document.\n\nYou can convert the XML output from Cppcheck into a HTML report. You'll need Python and the pygments module (http://pygments.org/) for this to work. In the Cppcheck source tree there is a folder htmlreport that contains a script that transforms a Cppcheck XML file into HTML output.\n\nThis command generates the help screen:\n\nThe \"reduced\" check level performs a limited data flow analysis. If developers want to run cppcheck directly during development and require faster results than \"normal\" provides then this reduced checking can be an option.\n\nThe \"normal\" check level is chosen by default. Our aim is that this checking level will provide an effective checking in \"reasonable\" time.\n\nThe \"normal\" check level should be useful during active development:\n• checking files while you edit them.\n• block changes to the repo\n\nWhen you can wait longer for the results you can enable the \"exhaustive\" checking, by using the option .\n\nExhaustive checking level should be useful for scenarios where you can wait for results. For instance:\n\nFor performance reasons it might be a good idea to limit preprocessor configurations to check.\n\nThe command line option adjusts the max count for number of if in a function.\n\nWhen that limit is exceeded there is a limitation of data flow in that function. It is not drastic:\n• Analysis of other functions are not affected.\n• It's only for some specific data flow analysis, we have data flow analysis that is always executed.\n• All checks are always executed. There can still be plenty of warnings in the limited function.\n\nThere is data flow analysis that slows down exponentially when number of if increase. And the limit is intended to avoid that analysis time explodes.\n\nIn the GUI there are various options to limit analysis.\n• In the \"Analysis\" tab there are several options.\n\nIf you want to use these limitations on the command line also you can import the GUI project file with --project."
    },
    {
        "link": "https://stackoverflow.com/questions/10611011/cannot-generate-xml-output-from-cppcheck",
        "document": "That part is obviously shell syntax, and is only meant to work from the context of a shell interpreter. So what to do when NOT running from a shell, just a plain “command with arguments” type of interface (like , , and such)?\n\nIt should be needless to say that the obvious workaround, wrapping the whole thing in , is a horrible antipattern: Quoting and escaping is hard to do correctly, most programmers won't even try, resulting in brittle code and a potential security hole. That would be an unreasonable complication for specifying an output file, and a clear sign that you're doing something wrong.\n\nA wrapper script lets you solve the problem the right way\n\n… but that would be a file, and that may be a complication in itself. Luckily, that script can be written in an inline form like this:\n\nThis is now in the form of a plain argument list, and therefore works in all shells, as well as non-shells like ."
    },
    {
        "link": "https://cppcheck.sourceforge.io/manual.pdf",
        "document": ""
    },
    {
        "link": "https://cppcheck.sourceforge.io/manual.html",
        "document": "Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code, and generate as few false positives (wrongly reported warnings) as possible. Cppcheck is designed to analyze your C/C++ code even if it has non-standard syntax, as is common in for example embedded projects.\n• Cppcheck checks non-standard code that contains various compiler extensions, inline assembly code, etc.\n• Cppcheck should be compilable by any compiler that supports C++11 or later.\n• Cppcheck is cross platform and is used in various posix/windows/etc environments.\n\nThe checks in Cppcheck are not perfect. There are bugs that should be found, that Cppcheck fails to detect.\n\nThe kinds of bugs that you can find with static analysis are:\n\nThere are many bugs that you can not find with static analysis. Static analysis tools do not have human knowledge about what your program is intended to do. If the output from your program is valid but unexpected then in most cases this is not detected by static analysis tools. For instance, if your small program writes “Helo” on the screen instead of “Hello” it is unlikely that any tool will complain about that.\n\nStatic analysis should be used as a complement in your quality assurance. It does not replace any of;\n\nIt is not required but creating a new project file is a good first step. There are a few options you can tweak to get good results.\n\nIn the project settings dialog, the first option you see is “Import project”. It is recommended that you use this feature if you can. Cppcheck can import:\n• Compile database, which can be generated from CMake/qbs/etc build files\n\nWhen you have filled out the project settings and clicked on OK, the Cppcheck analysis will start.\n\nHere is some simple code:\n\nIf you save that into file1.c and execute:\n\nThe output from Cppcheck will then be:\n\nNormally a program has many source files. Cppcheck can check all source files in a directory:\n\nIf “path” is a folder, then Cppcheck will recursively check all source files in this folder:\n\nWith Cppcheck you can check files manually by specifying files/paths to check and settings. Or you can use a build environment, such as CMake or Visual Studio.\n\nWe don’t know which approach (project file or manual configuration) will give you the best results. It is recommended that you try both. It is possible that you will get different results so that to find the largest amount of bugs you need to use both approaches. Later chapters will describe this in more detail.\n\nWith you can set a file filter and only those files matching the filter will be checked.\n\nFor example: if you want to check only those files and folders starting from a subfolder src/ that start with “test” you have to type:\n\nCppcheck first collects all files in src/ and will apply the filter after that. So the filter must start with the given start folder.\n\nTo exclude a file or folder, there are two options. The first option is to only provide the paths and files you want to check:\n\nAll files under src/a and src/b are then checked.\n\nThe second option is to use -i, which specifies the files/paths to ignore. With this command no files in src/c are checked:\n\nThis option is only valid when supplying an input directory. To ignore multiple directories supply the -i flag for each directory individually. The following command ignores both the src/b and src/c directories:\n\nBy default Cppcheck uses an internal C/C++ parser. However there is an experimental option to use the Clang parser instead.\n\nTechnically, Cppcheck will execute with its option. The Clang output is then imported and converted into the normal Cppcheck format. And then normal Cppcheck analysis is performed on that.\n\nYou can also pass a custom Clang executable to the option by using for example . You can also pass it with a path. On Windows it will append the extension unless you use a path.\n\nThe possible severities for messages are:\n\nwhen code is executed there is either undefined behavior or other error, such as a memory leak or resource leak\n\nwhen code is executed there might be undefined behavior\n\nstylistic issues, such as unused functions, redundant code, constness, operator precedence, possible mistakes.\n\nrun time performance suggestions based on common knowledge, though it is not certain any measurable speed difference will be achieved by fixing these messages.\n\nportability warnings. Implementation defined behavior. 64-bit portability. Some undefined behavior that probably works “as you want”, etc.\n\nconfiguration problems, which does not relate to the syntactical correctness, but the used Cppcheck configuration could be improved.\n\nCppcheck instantiates the templates in your code.\n\nIf your templates are recursive this can lead to slow analysis that uses a lot of memory. Cppcheck will write information messages when there are potential problems.\n\nAs you can see Cppcheck has instantiated until was reached and then it bails out.\n\nTo limit template recursion you can:\n• configure Cppcheck, which can be done in the GUI project file dialog\n\nYou can pass when checking this code.\n\nUsing a Cppcheck build folder is not mandatory but it is recommended.\n• It speeds up the analysis as it makes incremental analysis possible. Only changed files are analyzed when you recheck.\n• Whole program analysis also when multiple threads are used.\n\nOn the command line you configure that through . Example:\n\nIn the GUI it is configured in the project settings.\n\nYou can import some project files and build configurations into Cppcheck.\n\nYou can import and use Cppcheck GUI project files in the command line tool:\n\nThe Cppcheck GUI has a few options that are not available in the command line directly. To use these options you can import a GUI project file. The command line tool usage is kept intentionally simple and the options are therefore limited.\n\nTo ignore certain folders in the project you can use . This will skip the analysis of source files in the folder.\n\nThe file is created in the current folder. Now run Cppcheck like this:\n\nTo ignore certain folders you can use . This will skip analysis of source files in the folder.\n\nYou can run Cppcheck on individual project files (*.vcxproj) or on a whole solution (*.sln)\n\nBoth options will analyze all available configurations in the project(s). Limiting on a single configuration:\n\nIn the you have the option to only analyze a single debug configuration. If you want to use this option on the command line, then create a project with this activated and then import the GUI project file on the command line.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nIf you can generate a compile database, then it is possible to import that in Cppcheck.\n\nIn Linux you can use for instance the (build ear) utility to generate a compile database from arbitrary build tools:\n\nIf you use then Cppcheck will automatically use the preprocessor settings in the imported project file and likely you don’t have to configure anything extra.\n\nIf you don’t use then a bit of manual preprocessor configuration might be required. However Cppcheck has automatic configuration of defines.\n\nCppcheck automatically test different combinations of preprocessor defines to achieve as high coverage in the analysis as possible.\n\nHere is a file that has 3 bugs (when x,y,z are assigned).\n\nThe flag tells Cppcheck that a name is defined. There will be no Cppcheck analysis without this define. The flag tells Cppcheck that a name is not defined. There will be no Cppcheck analysis with this define. The flag and is used to control how many combinations are checked. When is used, Cppcheck will only check 1 configuration unless these are used.\n\nTo add an include path, use , followed by the path.\n\nCppcheck’s preprocessor basically handles includes like any other preprocessor. However, while other preprocessors stop working when they encounter a missing header, Cppcheck will just print an information message and continues parsing the code.\n\nThe purpose of this behaviour is that Cppcheck is meant to work without necessarily seeing the entire code. Actually, it is recommended to not give all include paths. While it is useful for Cppcheck to see the declaration of a class when checking the implementation of its members, passing standard library headers is discouraged, because the analysis will not work fully and lead to a longer checking time. For such cases, .cfg files are the preferred way to provide information about the implementation of functions and types to Cppcheck, see below for more information.\n\nYou should use a platform configuration that matches your target environment.\n\nBy default Cppcheck uses native platform configuration that works well if your code is compiled and executed locally.\n\nCppcheck has builtin configurations for Unix and Windows targets. You can easily use these with the command line flag.\n\nYou can also create your own custom platform configuration in a XML file. Here is an example:\n\nUse on the command line to specify a C/C++ standard.\n\nCppcheck assumes that the code is compatible with the latest C/C++ standard, but it is possible to override this.\n\nThe available options are:\n\nIt’s a good idea to use a Cppcheck build dir. On the command line use . In the GUI, the build dir is configured in the project options.\n\nRechecking code will be much faster. Cppcheck does not analyse unchanged code. The old warnings are loaded from the build dir and reported again.\n\nWhole program analysis does not work when multiple threads are used; unless you use a cppcheck build dir. For instance, the unusedFunction warnings require whole program analysis.\n\nIf you want to filter out certain errors from being generated, then it is possible to suppress these.\n\nIf you encounter a false positive, then please report it to the Cppcheck team so that it can be fixed.\n\nThe format for an error suppression is one of:\n\nThe is the id that you want to suppress. The id of a warning is shown in brackets in the normal cppcheck text output. The suppression may contain * to match any sequence of tokens.\n\nThe filename may include the wildcard characters * or ?, which matches any sequence of characters or any single character respectively. It is recommended to use forward-slash as path separator on all operating systems. The filename must match the filename in the reported warning exactly. For instance, if the warning contains a relative path, then the suppression must match that relative path.\n\nThe command line option is used to specify suppressions on the command line. Example:\n\nYou can create a suppressions file for example as follows:\n\nNote that you may add empty lines and comments in the suppressions file. Comments must start with or and be at the start of the line, or after the suppression line.\n\nThe usage of the suppressions file is as follows:\n\nYou can specify suppressions in a XML file, for example as follows:\n\nThe XML format is extensible and may be extended with further attributes in the future.\n\nThe usage of the suppressions file is as follows:\n\nSuppressions can also be added directly in the code by adding comments that contain special keywords. Note that adding comments sacrifices the readability of the code somewhat.\n\nThis code will normally generate an error message:\n\nYou can suppress a warning with:\n\nSuppressing multiple ids in one comment by using []:\n\nSuppressing warnings where macro is used:\n\nSuppressing multiple ids where macro is used:\n\nThe comment can be put before the code or at the same line as the code.\n\nOr at the same line as the code:\n\nIn this example there are 2 lines with code and 1 suppression comment. The suppression comment only applies to 1 line: .\n\nAs a special case for backwards compatibility, if you have a on its own line and a suppression comment after that, then that will suppress warnings for both the current and next line. This example will suppress warnings both for and for :\n\nFor a line of code there might be several warnings you want to suppress.\n\nThere are several options;\n\nUsing 1 suppression comment before the code:\n\nSuppression comment on the same line as the code:\n\nYou can specify that the inline suppression only applies to a specific symbol:\n\nYou can write comments about a suppression as follows:\n\nCppcheck can generate output in XML format. Use to enable this format.\n\nA sample command to check a file and output errors in the XML format:\n\nEach error is reported in a element. Attributes:\n\nid of error, and which are valid symbolnames\n\nthis attribute is only used when the error message is inconclusive\n\nCWE ID for the problem; note that this attribute is only used when the CWE ID for the message is known\n\nAll locations related to an error are listed with elements. The primary location is listed first.\n\nfilename, both relative and absolute paths are possible\n\nname of the source file (optional)\n\nIf you want to reformat the output so that it looks different, then you can use templates.\n\nTo get Visual Studio compatible output you can use –template=vs:\n\nThis output will look like this:\n\nTo get gcc compatible output you can use –template=gcc:\n\nThe output will look like this:\n\nYou can write your own pattern. For instance, to get warning messages that are formatted like traditional gcc, then the following format can be used:\n\nThe output will then look like this:\n\nThe output will look like this:\n\nMany warnings have multiple locations. Example code:\n\nThere is a possible null pointer dereference at line 3. Cppcheck can show how it came to that conclusion by showing extra location information. You need to use both –template and –template-location at the command line, for example:\n\nThe output from Cppcheck is:\n\nThe first line in the warning is formatted by the –template format.\n\nThe other lines in the warning are formatted by the –template-location format.\n\nThe available specifiers for –template are:\n\nWrite all locations. Each location is written in [{file}:{line}] format and the locations are separated by ->. For instance it might look like: [multiline.c:8] -> [multiline.c:9] -> [multiline.c:3]\n\nIf warning is inconclusive, then the given text is written. The given text can be any text that does not contain }. Example: {inconclusive:inconclusive,}\n\nThe remark text if a remark comment has been provided\n\nThe available specifiers for are:\n\nJustifications for warnings in the report\n\nYou can add remark comments in the source code that justify why there is a warning/violation.\n• can either be added above the source code that generates the warning, or after the code on the same line.\n\nIn Cppcheck text output the remarks are not shown by default, you can use option to show remarks:\n\nIn xml output the comment text is provided in a “remark” attribute:\n\nAddons are scripts that analyse Cppcheck dump files to check compatibility with secure coding standards and to locate issues.\n\nCppcheck is distributed with a few addons which are listed below.\n\nmisra.py is used to verify compliance with MISRA C 2012, a proprietary set of guidelines to avoid questionable code, developed for embedded systems.\n\nThe misra rule texts should be downloaded from MISRA: https://gitlab.com/MISRA/MISRA-C/MISRA-C-2012/tools\n\nUse the option to specify the rules text file that has been downloaded from MISRA.\n\ny2038.py checks Linux systems for year 2038 problem safety. This required modified environment. See complete description here.\n\nthreadsafety.py analyses Cppcheck dump files to locate thread safety issues like static local objects used by multiple threads.\n\nAddons could be run through Cppcheck command line utility as follows:\n\nThis will launch all Cppcheck checks and additionally calls specific checks provided by selected addon.\n\nSome addons need extra arguments. You can configure how you want to execute an addon in a json file. For example put this in misra.json:\n\nAnd then the configuration can be executed on the Cppcheck command line:\n\nBy default Cppcheck would search addon at the standard path which was specified during the installation process. You also can set this path directly, for example:\n\nThis allows you to create and manage multiple configuration files for different projects.\n\nWhen external libraries are used, such as WinAPI, POSIX, gtk, Qt, etc, Cppcheck has no information about functions, types, or macros contained in those libraries. Cppcheck then fails to detect various problems in the code, or might even abort the analysis. But this can be fixed by using the appropriate configuration files.\n\nCppcheck already contains configurations for several libraries. They can be loaded as described below. Note that the configuration for the standard libraries of C and C++, std.cfg, is always loaded by cppcheck. If you create or update a configuration file for a popular library, we would appreciate if you supplied it to the cppcheck project.\n\nTo use a .cfg file shipped with cppcheck, pass the option. The table below shows the currently existing libraries: | .cfg file | Library | Comment | | ————- | ————- | ————- | | avr.cfg | | | bento4.cfg | Bento4 | | boost.cfg | Boost| | bsd.cfg | BSD | | cairo.cfg | cairo | | cppcheck-lib.cfg | Cppcheck | Used in selfcheck of the Cppcheck code base | cppunit.cfg | CppUnit | | dpdk.cfg | | | embedded_sql.cfg | | | emscripten.cfg | | | ginac.cfg | | | gnu.cfg | GNU | | googletest.cfg | GoogleTest | | gtk.cfg | GTK | | icu.cfg | | | kde.cfg | KDE | | libcerror.cfg | libcerror | | libcurl.cfg | libcurl | | libsigc++.cfg | libsigc++ | | lua.cfg | | | mfc.cfg | MFC | | microsoft_atl.cfg | ATL | | microsoft_sal.cfg | SAL annotations | | microsoft_unittest.cfg | CppUnitTest | | motif.cfg | | | nspr.cfg | | | ntl.cfg | | | opencv2.cfg | OpenCV | | opengl.cfg | OpenGL | | openmp.cfg | OpenMP | | openssl.cfg | OpenSSL | | pcre.cfg | PCRE | | posix.cfg | POSIX | | python.cfg | | | qt.cfg | Qt | | ruby.cfg | | | sdl.cfg | | | sfml.cfg | | | sqlite3.cfg | SQLite | | std.cfg | C/C++ standard library | Loaded by default | tinyxml2.cfg | TinyXML-2 | | vcl.cfg | | | windows.cfg | Win32 API | | wxsqlite3.cfg | | | wxsvg.cfg | | | wxwidgets.cfg | wxWidgets | | zephyr.cfg | | | zlib.cfg | zlib |\n\nYou can create and use your own .cfg files for your projects. Use to get hints about what you should configure.\n\nYou can use the in the to edit configuration files. It is available in the menu.\n\nThe .cfg file format is documented in the (https://cppcheck.sourceforge.io/reference-cfg-format.pdf) document.\n\nYou can convert the XML output from Cppcheck into a HTML report. You’ll need Python and the pygments module (http://pygments.org/) for this to work. In the Cppcheck source tree there is a folder htmlreport that contains a script that transforms a Cppcheck XML file into HTML output.\n\nThis command generates the help screen:\n\nThe “reduced” check level performs a limited data flow analysis. If developers want to run cppcheck directly during development and require faster results than “normal” provides then this reduced checking can be an option.\n\nThe “normal” check level is chosen by default. Our aim is that this checking level will provide an effective checking in “reasonable” time.\n\nThe “normal” check level should be useful during active development: * checking files while you edit them. * block changes to the repo * etc\n\nWhen you can wait longer for the results you can enable the “exhaustive” checking, by using the option .\n\nExhaustive checking level should be useful for scenarios where you can wait for results. For instance: * nightly builds * etc\n\nFor performance reasons it might be a good idea to limit preprocessor configurations to check.\n\nThe command line option adjusts the max count for number of if in a function.\n\nWhen that limit is exceeded there is a limitation of data flow in that function. It is not drastic: * Analysis of other functions are not affected. * It’s only for some specific data flow analysis, we have data flow analysis that is always executed. * All checks are always executed. There can still be plenty of warnings in the limited function.\n\nThere is data flow analysis that slows down exponentially when number of if increase. And the limit is intended to avoid that analysis time explodes.\n\nIn the GUI there are various options to limit analysis.\n\nIn the GUI: * Open the project dialog. * In the “Analysis” tab there are several options.\n\nIf you want to use these limitations on the command line also you can import the GUI project file with –project.\n\nThis is analysis that is more noisy than normal analysis. Most warnings will be false positives (cppcheck will wrongly claim that there are bugs). The design goal is to not have more than roughly 5 - 10 false positives in each file.\n\nIt is not intended to be used in normal CI or regular static analysis by developers. The noise makes it useless for that.\n\nIt is intended to be used when you are looking for bugs and you really can accept noise. For example: * You have developed a brand new feature and want to ensure that there are no bugs. * Maybe as part of release testing your product you can run bug hunting on modified files. * Etc\n\nTechnically, analysis that is “sound” will detect all bugs. Analysis that is “soundy” has the goal to detect most bugs and it tries to keep the noise at an reasonable level.\n\nA license that is connected to your computer. You can check any code you want.\n\nA license that allows you to run cppcheck on a limited number of lines of code. It can only be used for certain licensed paths in a repository."
    },
    {
        "link": "https://github.com/danmar/cppcheck/blob/main/man/manual.md",
        "document": "Cppcheck is an analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code, and generate as few false positives (wrongly reported warnings) as possible. Cppcheck is designed to analyze your C/C++ code even if it has non-standard syntax, as is common in for example embedded projects.\n• Cppcheck checks non-standard code that contains various compiler extensions, inline assembly code, etc.\n• Cppcheck should be compilable by any compiler that supports C++11 or later.\n• Cppcheck is cross platform and is used in various posix/windows/etc environments.\n\nThe checks in Cppcheck are not perfect. There are bugs that should be found, that Cppcheck fails to detect.\n\nThe kinds of bugs that you can find with static analysis are:\n\nThere are many bugs that you can not find with static analysis. Static analysis tools do not have human knowledge about what your program is intended to do. If the output from your program is valid but unexpected then in most cases this is not detected by static analysis tools. For instance, if your small program writes \"Helo\" on the screen instead of \"Hello\" it is unlikely that any tool will complain about that.\n\nStatic analysis should be used as a complement in your quality assurance. It does not replace any of;\n\nIt is not required but creating a new project file is a good first step. There are a few options you can tweak to get good results.\n\nIn the project settings dialog, the first option you see is \"Import project\". It is recommended that you use this feature if you can. Cppcheck can import:\n• Compile database, which can be generated from CMake/qbs/etc build files\n\nWhen you have filled out the project settings and clicked on OK, the Cppcheck analysis will start.\n\nHere is some simple code:\n\nIf you save that into file1.c and execute:\n\nThe output from Cppcheck will then be:\n\nNormally a program has many source files. Cppcheck can check all source files in a directory:\n\nIf \"path\" is a folder, then Cppcheck will recursively check all source files in this folder:\n\nWith Cppcheck you can check files manually by specifying files/paths to check and settings. Or you can use a build environment, such as CMake or Visual Studio.\n\nWe don't know which approach (project file or manual configuration) will give you the best results. It is recommended that you try both. It is possible that you will get different results so that to find the largest amount of bugs you need to use both approaches. Later chapters will describe this in more detail.\n\nWith you can set a file filter and only those files matching the filter will be checked.\n\nFor example: if you want to check only those files and folders starting from a subfolder src/ that start with \"test\" you have to type:\n\nCppcheck first collects all files in src/ and will apply the filter after that. So the filter must start with the given start folder.\n\nTo exclude a file or folder, there are two options. The first option is to only provide the paths and files you want to check:\n\nAll files under src/a and src/b are then checked.\n\nThe second option is to use -i, which specifies the files/paths to ignore. With this command no files in src/c are checked:\n\nThis option is only valid when supplying an input directory. To ignore multiple directories supply the -i flag for each directory individually. The following command ignores both the src/b and src/c directories:\n\nBy default Cppcheck uses an internal C/C++ parser. However there is an experimental option to use the Clang parser instead.\n\nTechnically, Cppcheck will execute with its option. The Clang output is then imported and converted into the normal Cppcheck format. And then normal Cppcheck analysis is performed on that.\n\nYou can also pass a custom Clang executable to the option by using for example . You can also pass it with a path. On Windows it will append the extension unless you use a path.\n\nThe possible severities for messages are:\n\nwhen code is executed there is either undefined behavior or other error, such as a memory leak or resource leak\n\nwhen code is executed there might be undefined behavior\n\nstylistic issues, such as unused functions, redundant code, constness, operator precedence, possible mistakes.\n\nrun time performance suggestions based on common knowledge, though it is not certain any measurable speed difference will be achieved by fixing these messages.\n\nportability warnings. Implementation defined behavior. 64-bit portability. Some undefined behavior that probably works \"as you want\", etc.\n\nconfiguration problems, which does not relate to the syntactical correctness, but the used Cppcheck configuration could be improved.\n\nCppcheck instantiates the templates in your code.\n\nIf your templates are recursive this can lead to slow analysis that uses a lot of memory. Cppcheck will write information messages when there are potential problems.\n\nAs you can see Cppcheck has instantiated until was reached and then it bails out.\n\nTo limit template recursion you can:\n• configure Cppcheck, which can be done in the GUI project file dialog\n\nYou can pass when checking this code.\n\nUsing a Cppcheck build folder is not mandatory but it is recommended.\n• It speeds up the analysis as it makes incremental analysis possible. Only changed files are analyzed when you recheck.\n• Whole program analysis also when multiple threads are used.\n\nOn the command line you configure that through . Example:\n\nIn the GUI it is configured in the project settings.\n\nYou can import some project files and build configurations into Cppcheck.\n\nYou can import and use Cppcheck GUI project files in the command line tool:\n\nThe Cppcheck GUI has a few options that are not available in the command line directly. To use these options you can import a GUI project file. The command line tool usage is kept intentionally simple and the options are therefore limited.\n\nTo ignore certain folders in the project you can use . This will skip the analysis of source files in the folder.\n\nThe file is created in the current folder. Now run Cppcheck like this:\n\nTo ignore certain folders you can use . This will skip analysis of source files in the folder.\n\nYou can run Cppcheck on individual project files (*.vcxproj) or on a whole solution (*.sln)\n\nBoth options will analyze all available configurations in the project(s). Limiting on a single configuration:\n\nIn the you have the option to only analyze a single debug configuration. If you want to use this option on the command line, then create a project with this activated and then import the GUI project file on the command line.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nTo ignore certain folders in the project you can use . This will skip analysis of source files in the folder.\n\nIf you can generate a compile database, then it is possible to import that in Cppcheck.\n\nIn Linux you can use for instance the (build ear) utility to generate a compile database from arbitrary build tools:\n\nIf you use then Cppcheck will automatically use the preprocessor settings in the imported project file and likely you don't have to configure anything extra.\n\nIf you don't use then a bit of manual preprocessor configuration might be required. However Cppcheck has automatic configuration of defines.\n\nCppcheck automatically test different combinations of preprocessor defines to achieve as high coverage in the analysis as possible.\n\nHere is a file that has 3 bugs (when x,y,z are assigned).\n\nThe flag tells Cppcheck that a name is defined. There will be no Cppcheck analysis without this define. The flag tells Cppcheck that a name is not defined. There will be no Cppcheck analysis with this define. The flag and is used to control how many combinations are checked. When is used, Cppcheck will only check 1 configuration unless these are used.\n\nTo add an include path, use , followed by the path.\n\nCppcheck's preprocessor basically handles includes like any other preprocessor. However, while other preprocessors stop working when they encounter a missing header, Cppcheck will just print an information message and continues parsing the code.\n\nThe purpose of this behaviour is that Cppcheck is meant to work without necessarily seeing the entire code. Actually, it is recommended to not give all include paths. While it is useful for Cppcheck to see the declaration of a class when checking the implementation of its members, passing standard library headers is discouraged, because the analysis will not work fully and lead to a longer checking time. For such cases, .cfg files are the preferred way to provide information about the implementation of functions and types to Cppcheck, see below for more information.\n\nYou should use a platform configuration that matches your target environment.\n\nBy default Cppcheck uses native platform configuration that works well if your code is compiled and executed locally.\n\nCppcheck has builtin configurations for Unix and Windows targets. You can easily use these with the command line flag.\n\nYou can also create your own custom platform configuration in a XML file. Here is an example:\n\nUse on the command line to specify a C/C++ standard.\n\nCppcheck assumes that the code is compatible with the latest C/C++ standard, but it is possible to override this.\n\nThe available options are:\n\nIt's a good idea to use a Cppcheck build dir. On the command line use . In the GUI, the build dir is configured in the project options.\n\nRechecking code will be much faster. Cppcheck does not analyse unchanged code. The old warnings are loaded from the build dir and reported again.\n\nWhole program analysis does not work when multiple threads are used; unless you use a cppcheck build dir. For instance, the unusedFunction warnings require whole program analysis.\n\nIf you want to filter out certain errors from being generated, then it is possible to suppress these.\n\nIf you encounter a false positive, then please report it to the Cppcheck team so that it can be fixed.\n\nThe format for an error suppression is one of:\n\nThe is the id that you want to suppress. The id of a warning is shown in brackets in the normal cppcheck text output. The suppression may contain * to match any sequence of tokens.\n\nThe filename may include the wildcard characters * or ?, which matches any sequence of characters or any single character respectively. It is recommended to use forward-slash as path separator on all operating systems. The filename must match the filename in the reported warning exactly. For instance, if the warning contains a relative path, then the suppression must match that relative path.\n\nThe command line option is used to specify suppressions on the command line. Example:\n\nYou can create a suppressions file for example as follows:\n\nNote that you may add empty lines and comments in the suppressions file. Comments must start with or and be at the start of the line, or after the suppression line.\n\nThe usage of the suppressions file is as follows:\n\nYou can specify suppressions in a XML file, for example as follows:\n\nThe XML format is extensible and may be extended with further attributes in the future.\n\nThe usage of the suppressions file is as follows:\n\nSuppressions can also be added directly in the code by adding comments that contain special keywords. Note that adding comments sacrifices the readability of the code somewhat.\n\nThis code will normally generate an error message:\n\nYou can suppress a warning with:\n\nSuppressing multiple ids in one comment by using []:\n\nSuppressing warnings where macro is used:\n\nSuppressing multiple ids where macro is used:\n\nComment before code or on same line\n\nThe comment can be put before the code or at the same line as the code.\n\nOr at the same line as the code:\n\nIn this example there are 2 lines with code and 1 suppression comment. The suppression comment only applies to 1 line: .\n\nAs a special case for backwards compatibility, if you have a on its own line and a suppression comment after that, then that will suppress warnings for both the current and next line. This example will suppress warnings both for and for :\n\nFor a line of code there might be several warnings you want to suppress.\n\nThere are several options;\n\nUsing 1 suppression comment before the code:\n\nSuppression comment on the same line as the code:\n\nYou can specify that the inline suppression only applies to a specific symbol:\n\nYou can write comments about a suppression as follows:\n\nCppcheck can generate output in XML format. Use to enable this format.\n\nA sample command to check a file and output errors in the XML format:\n\nEach error is reported in a element. Attributes:\n\nid of error, and which are valid symbolnames\n\nthis attribute is only used when the error message is inconclusive\n\nCWE ID for the problem; note that this attribute is only used when the CWE ID for the message is known\n\nAll locations related to an error are listed with elements. The primary location is listed first.\n\nfilename, both relative and absolute paths are possible\n\nname of the source file (optional)\n\nIf you want to reformat the output so that it looks different, then you can use templates.\n\nTo get Visual Studio compatible output you can use --template=vs:\n\nThis output will look like this:\n\nTo get gcc compatible output you can use --template=gcc:\n\nThe output will look like this:\n\nYou can write your own pattern. For instance:\n\nThe output will then look like this:\n\nThe output will look like this:\n\nMany warnings have multiple locations. Example code:\n\nThere is a possible null pointer dereference at line 3. Cppcheck can show how it came to that conclusion by showing extra location information. You need to use both --template and --template-location at the command line, for example:\n\nThe output from Cppcheck is:\n\nThe first line in the warning is formatted by the --template format.\n\nThe other lines in the warning are formatted by the --template-location format.\n\nThe available specifiers for --template are:\n\nWrite all locations. Each location is written in [{file}:{line}] format and the locations are separated by ->. For instance it might look like: [multiline.c:8] -> [multiline.c:9] -> [multiline.c:3]\n\nIf warning is inconclusive, then the given text is written. The given text can be any text that does not contain }. Example: {inconclusive:inconclusive,}\n\nThe remark text if a remark comment has been provided\n\nThe available specifiers for are:\n\nYou can add remark comments in the source code that justify why there is a warning/violation.\n• can either be added above the source code that generates the warning, or after the code on the same line.\n\nIn Cppcheck text output the remarks are not shown by default, you can use option to show remarks:\n\nIn xml output the comment text is provided in a \"remark\" attribute:\n\nAddons are scripts that analyse Cppcheck dump files to check compatibility with secure coding standards and to locate issues.\n\nCppcheck is distributed with a few addons which are listed below.\n\nmisra.py is used to verify compliance with MISRA C 2012, a proprietary set of guidelines to avoid questionable code, developed for embedded systems.\n\nThe misra rule texts should be downloaded from MISRA\n\nUse the option to specify the rules text file that has been downloaded from MISRA.\n\ny2038.py checks Linux systems for year 2038 problem safety. This required modified environment. See complete description here.\n\nthreadsafety.py analyses Cppcheck dump files to locate thread safety issues like static local objects used by multiple threads.\n\nAddons could be run through Cppcheck command line utility as follows:\n\nThis will launch all Cppcheck checks and additionally calls specific checks provided by selected addon.\n\nSome addons need extra arguments. You can configure how you want to execute an addon in a json file. For example put this in misra.json:\n\nAnd then the configuration can be executed on the Cppcheck command line:\n\nBy default Cppcheck would search addon at the standard path which was specified during the installation process. You also can set this path directly, for example:\n\nThis allows you to create and manage multiple configuration files for different projects.\n\nWhen external libraries are used, such as WinAPI, POSIX, gtk, Qt, etc, Cppcheck has no information about functions, types, or macros contained in those libraries. Cppcheck then fails to detect various problems in the code, or might even abort the analysis. But this can be fixed by using the appropriate configuration files.\n\nCppcheck already contains configurations for several libraries. They can be loaded as described below. Note that the configuration for the standard libraries of C and C++, std.cfg, is always loaded by cppcheck. If you create or update a configuration file for a popular library, we would appreciate if you supplied it to the cppcheck project.\n\nTo use a .cfg file shipped with cppcheck, pass the option. The table below shows the currently existing libraries:\n\nYou can create and use your own .cfg files for your projects. Use to get hints about what you should configure.\n\nYou can use the in the to edit configuration files. It is available in the menu.\n\nThe .cfg file format is documented in the (https://cppcheck.sourceforge.io/reference-cfg-format.pdf) document.\n\nYou can convert the XML output from Cppcheck into a HTML report. You'll need Python and the pygments module (http://pygments.org/) for this to work. In the Cppcheck source tree there is a folder htmlreport that contains a script that transforms a Cppcheck XML file into HTML output.\n\nThis command generates the help screen:\n\nThe \"reduced\" check level performs a limited data flow analysis. If developers want to run cppcheck directly during development and require faster results than \"normal\" provides then this reduced checking can be an option.\n\nThe \"normal\" check level is chosen by default. Our aim is that this checking level will provide an effective checking in \"reasonable\" time.\n\nThe \"normal\" check level should be useful during active development:\n• checking files while you edit them.\n• block changes to the repo\n\nWhen you can wait longer for the results you can enable the \"exhaustive\" checking, by using the option .\n\nExhaustive checking level should be useful for scenarios where you can wait for results. For instance:\n\nFor performance reasons it might be a good idea to limit preprocessor configurations to check.\n\nThe command line option adjusts the max count for number of if in a function.\n\nWhen that limit is exceeded there is a limitation of data flow in that function. It is not drastic:\n• Analysis of other functions are not affected.\n• It's only for some specific data flow analysis, we have data flow analysis that is always executed.\n• All checks are always executed. There can still be plenty of warnings in the limited function.\n\nThere is data flow analysis that slows down exponentially when number of if increase. And the limit is intended to avoid that analysis time explodes.\n\nIn the GUI there are various options to limit analysis.\n• In the \"Analysis\" tab there are several options.\n\nIf you want to use these limitations on the command line also you can import the GUI project file with --project."
    },
    {
        "link": "https://sourceforge.net/p/cppcheck/wiki/Home",
        "document": "Cppcheck is an analysis tool for C/C++ code. Unlike C/C++ compilers and many other analysis tools, it doesn't detect syntax errors. Cppcheck only detects the types of bugs that the compilers normally fail to detect. The goal is no false positives.\n\nWe recommend that you enable as many warnings as possible in your compiler.\n\n - If you use Visual C++: you should use warning level 4.\n\n - If you use GCC: take a look at Warning options - using GCC\n\n - If you use Clang: take a look at Options to Control Error and Warning Messages\n\n - If you use another compiler: look in the manual.\n\nSupported platforms:\n\n - You can check non-standard code that includes various compiler extensions, inline assembly code, etc.\n\n - Cppcheck is supposed to be compilable by any C++ compiler which handles the latest C++ standard.\n\n - Cppcheck is supposed to work on any platform that has sufficient cpu and memory.\n\nCppcheck is far from finished, it is continuously improved to make it more accurate.\n\nCppcheck is rarely wrong about reported errors. But there are many bugs that it doesn't detect.\n\nYou will find more bugs in your software by testing your software carefully, than by using Cppcheck.\n\n You will find more bugs in your software by instrumenting your software (with for example http://valgrind.org/), than by using Cppcheck.\n\n It is unlikely that you will find all the bugs in your software through testing and instrumenting. Cppcheck can detect some of the bugs that you have missed.\n\nThe Cppcheck manual is available as HTML and PDF.\n\nArticles about writing rules.\n\n Part 1 - Getting started\n\n Part 2 - Data representation\n\n Part 3 - Introduction to C++ rules\n\nThis article talks about the internal data in Cppcheck.\n\nThis article discuss the philosphy of Cppcheck - how we try to avoid false warnings.\n\nCppcheck can be used from many popular development tools.\n• Eclipse - Plugin / Tutorial to integrate Cppcheck in your IDE\n• Mercurial (linux) - pre-commit hook - Check for new errors on commit (requires interactive terminal)\n• CppDepend - Integrated. Note: CppDepend is free to use for open source projects.\n\nCppcheck has many different kinds of checks. A full list is available.\n\nTo suggest a new checker, please use Trac.\n\nIRC channel:\n\n channel: #cppcheck\n\n server: irc://irc.libera.chat\n\n The IRC channel can be access with a web browser: https://web.libera.chat/\n\nUse Trac to report any problems: Trac\n\n''Defects'' are for severe bugs such as:\n\n - False positives\n\n - Cppcheck hangs/crashes\n\n - Fail to compile\n\n''Enhancements'' are for issues such as:\n\n - Fail to detect bug\n\n - Change the output of Cppcheck\n\n - Suggestion for a new check\n\nYou are welcome to contribute. Help is needed.\n\n - Testing - Pick a project and test it's source with latest version. Write tickets to Trac about issues you find from Cppcheck. If you test open source projects and write bug reports to them, check the issues in Found bugs section, and write links to the bug reports you have created e.g. to our Forum, so we can keep a track about them.\n\n - Developing - Pick a ticket from Trac, write a test case for it (and write a comment to the ticket that test case has been created). Or pick a test case that fails and try to fix it. Make a patch and submit it to Trac either inline if it is small, or attach it as a file.\n\n - Marketing - Write articles, reviews or tell your friends about us. The more users we have, the more people we have testing and the better we can become.\n\n - Design - Invent new good checks and create tickets to Trac about them.\n\n - Integration - Write a plugin to your favorite IDE or create a package for your distribution or operating system.\n\n - Technical Writer - Write better documentation for the bugs we find. Currently only a few bugs have any documentation at all.\n\nLatest version can be found in the cppcheck git repository.\n\nTo get the source code using git:\n\nTo get the source code using subversion:\n\nYou can also download the latest sources in a zip archive from the github website.\n\nHere are some of the found bugs that have been fixed:"
    },
    {
        "link": "https://cppcheck.sourceforge.io",
        "document": "Cppcheck is a static analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to have very few false positives. Cppcheck is designed to be able to analyze your C/C++ code even if it has non-standard syntax (common in embedded projects).\n\nCppcheck is available both as open-source (this page) and as Cppcheck Premium with extended functionality and support. Please visit www.cppcheck.com for more information and purchase options for the commercial version.\n\nCppcheck can also be installed from various package managers; however, you might get an outdated version then.\n\nUnique code analysis that detect various kinds of bugs in your code.\n\nBoth command line interface and graphical user interface are available.\n\nUsing several static analysis tools can be a good idea. There are unique features in each tool. This has been established in many studies.\n\nSo what is unique in Cppcheck.\n\nCppcheck uses unsound flow sensitive analysis. Several other analyzers use path sensitive analysis based on abstract interpretation, that is also great however that has both advantages and disadvantages. In theory by definition, it is better with path sensitive analysis than flow sensitive analysis. But in practice, it means Cppcheck will detect bugs that the other tools do not detect.\n\nIn Cppcheck the data flow analysis is not only \"forward\" but \"bi-directional\". Most analyzers will diagnose this:\n\nMost tools can determine that the array index will be 1000 and there will be overflow.\n\nCppcheck will also diagnose this:\n\nThe most common types of security vulnerabilities in 2017 (CVE count) was:\n\nCVEs that was found using Cppcheck:\n• CVE-2017-1000249 : file : stack based buffer overflow\n\n This was found by Thomas Jarosch using Cppcheck. The cause is a mistake in a condition.\n• CVE-2013-6462 : 23 year old stack overflow in X.org that was found with Cppcheck.\n\n This has been described in a few articles (link).\n• CVE-2012-1147 : readfilemap.c in expat before 2.1.0 allows context-dependent attackers to cause a denial of service (file descriptor consumption) via a large number of crafted XML files..\n\nThese CVEs are shown when you google \"cppcheck CVE\". Feel free to compare the search results with other static analysis tools.\n\nSecurity experts recommend that static analysis is used. And using several tools is the best approach from a security perspective.\n\nFor a list of all checks in Cppcheck see: http://sourceforge.net/p/cppcheck/wiki/ListOfChecks.\n\nCppcheck is integrated with many popular development tools. For instance:\n• Mercurial (Linux) - pre-commit hook - Check for new errors on commit (requires interactive terminal)\n\nUsing a battery of tools is better than using one tool. Each tool has unique code analysis and therefore we recommend that you also use other tools.\n\nCppcheck focus on bugs instead of stylistic issues. Therefore a tool that focus on stylistic issues could be a good addition.\n\nCppcheck tries very hard to avoid false positives. Sometimes people want to detect all bugs even if there will be many false warnings, for instance when they are working on a release and want to verify that there are no bugs. A tool that is much more noisy than Cppcheck might be a good addition.\n\nEven tools that have the same design goals as Cppcheck will probably be good additions. Static analysis is such a big field, Cppcheck only covers a small fraction of it. No tool covers the whole field. The day when all manual testing will be obsolete because of some tool is very far away.\n\nYou can read the manual.\n• Use Trac to report bugs and feature requests\n• Ask questions at the IRC channel #cppcheck\n\nThe Cppcheck project is a hobby project with limited resources. You can help us by donating CPU (1 core or as many as you like). It is simple:\n\nThe script will analyse debian source code and upload the results to a cppcheck server. We need these results both to improve Cppcheck and to detect regressions.\n\nYou can stop the script whenever you like with Ctrl C.\n\nYou are welcome to contribute. Help is needed.\n\nA presentation that might be interesting: Contribute to open source static analysis"
    }
]