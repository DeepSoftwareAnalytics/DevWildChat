[
    {
        "link": "https://digitalocean.com/community/tutorials/r-melt-and-cast-function",
        "document": "Hello, readers! In this article, we would be having a look at an important concept of R programming - Reshaping data using R melt() and cast() functions, in detail.\n\nThe R melt() and cast() functions help us to reshape the data within a data frame into any customized shape.\n\nWorking with the R melt() and cast() functions\n\nLet’s understand both the functions in detail. Here we go!\n\nThe in R programming is an in-built function. It enables us to reshape and elongate the data frames in a user-defined manner. It organizes the data values in a long data frame format.\n\nHave a look at the below syntax!\n\nWe pass the data frame to the reshaped to the function along with na.rm = FALSE as the default value which means the NA values won’t be ignored.\n\nFurther, we pass the new variable/column name to value.name parameter to store the elongated values obtained from the function into it.\n\nThe ID parameter is set to the column names of the data frame with respect to which the reshaping would happen.\n\nIn this example, we would be making use of libraries ‘MASS, reshape2, and reshape’. Having created the data frame, we apply the melt() function on the data frame with respect to the column A and B.\n\nAs seen above, after applying melt() function, the data frame gets converted to an elongated data frame. In order to regain the nearly original and natural shape of the data frame, is used.\n\nThe cast() function accepts an aggregated function and a formula as a parameter (here, formula is the manner in which the data is to be represented after reshaping) and casts the elongated or molted data frame into a nearly aggregated form of data frame.\n\nWe can provide the cast() function with any aggregate function available such as mean, sum, etc.\n\nAs seen above, we have passed mean as the aggregate function to cast() and have set variable equivalent to A variable as the format of representation.\n\nBy this, we have come to the end of this topic. Feel free to comment below, in case you come across any question."
    },
    {
        "link": "https://ademos.people.uic.edu/Chapter8.html",
        "document": ""
    },
    {
        "link": "https://cran.r-project.org/web/packages/reshape2/reshape2.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/melt-function-in-r",
        "document": "In this article, we will discuss what is Melt Function and how it works in R Programming Language.\n\nIn data analysis and manipulation, restructuring data is often necessary to facilitate further analysis or visualization. The melt() function in R, provided by the reshape2 or tidyr package, is a powerful tool for reshaping data frames from a wide format to a long format. This article explores the melt() function in detail, discussing its syntax, parameters, and examples to demonstrate its usage.\n\nThe basic syntax of the melt() function is as follows:\n• data: The data frame to be melted.\n• id.vars: Names of columns that should remain as identifiers.\n• measure.vars: Names of columns to be melted.\n• variable.name: The name of the variable column (default is \"variable\").\n• value.name: The name of the value column (default is \"value\").\n\nConsider a data frame df containing information about students' test scores in different subjects:\n\nNow, let's melt the data frame to convert it from a wide format to a long format:\n\nIn the melted data frame, each row represents a unique combination of student, subject, and score, making it easier to analyze or visualize the data.\n\nThe melt() function in R is a valuable tool for reshaping data frames from a wide format to a long format. By specifying the appropriate parameters, you can control which columns remain unchanged and which columns are melted, resulting in a more structured and tidy data format suitable for various analytical tasks."
    },
    {
        "link": "https://rdocumentation.org/packages/reshape2/versions/1.4.4/topics/melt",
        "document": "This the generic melt function. See the following functions for the details about different data structures:"
    },
    {
        "link": "https://stackoverflow.com/questions/48389050/how-to-convert-a-matrix-into-a-data-table-in-r",
        "document": "I have this data which is basically a matrix but is in data.table format:\n\nHow do I make the matrix into a database type in data.table?\n\nI have thought about a very stupid way to make a list of companies:\n\nAnd obviously I can at most get the data in date 200101. To get 200102, I write a for loop. Then, merge both 200101 and 200102 into dtB according to the colnames.\n\nIs there a clever way to do this in data.table? Many thanks"
    },
    {
        "link": "https://datacamp.com/tutorial/data-reshaping-in-r",
        "document": "Get started on the path to exploring and visualizing your own data with the tidyverse, a powerful and popular collection of data science tools within R."
    },
    {
        "link": "https://stackoverflow.com/questions/9617348/reshape-three-column-data-frame-to-matrix-long-to-wide-format",
        "document": "There are many ways to do this. This answer starts with what is quickly becoming the standard method, but also includes older methods and various other methods from answers to similar questions scattered around this site.\n\nThe new cool new way to do this is with from . It returns a data frame, which is probably what most readers of this answer will want. For a heatmap, though, you would need to convert this to a true matrix.\n\nThe old cool new way to do this is with from . It similarly returns a data frame.\n\nOne of the first steps toward the tidyverse was the reshape2 package.\n\nTo get a matrix use :\n\nOr to get a data frame, use , as here: Reshape data for values in one column.\n\nIn between reshape2 and the tidyverse came , with the function, as shown here: https://stackoverflow.com/a/7020101/210673\n\nThis is kinda old school but is a nice demonstration of matrix indexing, which can be really useful in certain situations.\n\nThere's also within the package, as seen here: R - convert BIG table into matrix by column names\n\nYou can also use the base R function , as suggested here: Convert table into matrix by column names, though you have to do a little manipulation afterwards to remove an extra columns and get the names right (not shown)."
    },
    {
        "link": "https://geeksforgeeks.org/reshaping-data-frame-from-wide-to-long-format-in-r",
        "document": "Reshaping a data frame from wide to long format in R Programming Language is a common operation when dealing with data analysis and visualization. The process involves converting data that is spread across multiple columns (wide format) into a format where each row represents a single observation (long format). This article covers various methods to accomplish this task using functions like reshape2, tidyr, and pivot_longer.\n\nBefore diving into reshaping methods, let's create a sample data frame in a wide format.\n\nThis data frame contains student IDs, names, and scores for three tests (Test1, Test2, and Test3).\n\nThe melt function from the reshape2 package can be used to reshape data from wide to long format.\n\nThe pivot_longer function from the tidyr package provides a modern and efficient way to reshape data from wide to long format.\n\nReshaping a data frame from wide to long format in R is a crucial step in data preprocessing and analysis. This article demonstrated three methods to accomplish this task: using the melt function from the reshape2 package, the pivot_longer function from the tidyr package, and the reshape function from base R. Depending on your preference and specific requirements, you can choose the most suitable method for reshaping your data."
    },
    {
        "link": "https://cran.r-project.org/package=data.table/vignettes/datatable-reshape.html",
        "document": "Translations of this document are available in\n\nThis vignette discusses the default usage of reshaping functions (wide to long) and (long to wide) for data.tables as well as the new extended functionalities of melting and casting on multiple columns available from .\n\nWe will load the data sets directly within sections.\n\nThe and functions for s are for reshaping wide-to-long and long-to-wide, respectively; the implementations are specifically designed with large in-memory data (e.g. 10Gb) in mind.\n\nIn this vignette, we will\n• First briefly look at the default ing and ing of s to convert them from wide to long format and vice versa\n• Look at scenarios where the current functionalities become cumbersome and inefficient\n• Finally look at the new improvements to both and methods for s to handle multiple columns simultaneously.\n\nThe extended functionalities are in line with ’s philosophy of performing operations efficiently and in a straightforward manner.\n\nSuppose we have a (artificial data) as shown below:\n\n- Convert to long form where each is a separate observation.\n\nWe could accomplish this using by specifying and arguments as follows:\n• specify the set of columns we would like to collapse (or combine) together.\n• We can also specify column positions instead of names.\n• By default, column is of type . Set argument to if you’d like to return a vector instead.\n• By default, the molten columns are automatically named and .\n\n- Name the and columns to and respectively\n• By default, when one of or is missing, the rest of the columns are automatically assigned to the missing argument.\n• When neither nor are specified, as mentioned under , all non- , , columns will be assigned to . In addition, a warning message is issued highlighting the columns that are automatically considered to be .\n\nIn the previous section, we saw how to get from wide form to long form. Let’s see the reverse operation in this section.\n\n- How can we get back to the original data table from ?\n\nThat is, we’d like to collect all child observations corresponding to each together under the same row. We can accomplish it using as follows:\n• uses formula interface. The variables on the LHS of formula represents the id vars and RHS the measure vars.\n• denotes the column to be filled in with while casting to wide format.\n• also tries to preserve attributes in result wherever possible.\n\n- Starting from , how can we get the number of children in each family?\n\nYou can also pass a function to aggregate by in with the argument . This is particularly essential when the formula provided does not identify single observation for each cell.\n\nCheck for other useful arguments and additional examples.\n\nSo far we’ve seen features of and that are implemented efficiently for s, using internal machinery (fast radix ordering, binary search etc.).\n\nHowever, there are situations we might run into where the desired operation is not expressed in a straightforward manner. For example, consider the shown below:\n\nAnd you’d like to combine ( ) all the columns together, and columns together. Using the current functionality, we can do something like this:\n• What we wanted to do was to combine all the and type columns together respectively. Instead, we are combining everything together, and then splitting them again. I think it’s easy to see that it’s quite roundabout (and inefficient). As an analogy, imagine you’ve a closet with four shelves of clothes and you’d like to put together the clothes from shelves 1 and 2 together (in 1), and 3 and 4 together (in 3). What we are doing is more or less to combine all the clothes together, and then split them back on to shelves 1 and 3!\n• The columns to may be of different types. By ing them all together, the columns will be coerced in result.\n• We are generating an additional column by splitting the column into two columns, whose purpose is quite cryptic. We do it because we need it for casting in the next step.\n• Finally, we cast the data set. But the issue is it’s a much more computationally involved operation than melt. Specifically, it requires computing the order of the variables in formula, and that’s costly.\n\nIn fact, is capable of performing this operation in a very straightforward manner. It is an extremely useful and often underrated function. You should definitely give it a try!\n\nSince we’d like for s to perform this operation straightforward and efficient using the same interface, we went ahead and implemented an additional functionality, where we can to multiple columns simultaneously.\n\nThe idea is quite simple. We pass a list of columns to , where each element of the list contains the columns that should be combined together.\n• We can remove the column if necessary.\n• The functionality is implemented entirely in C, and is therefore both fast and memory efficient in addition to being straightforward.\n\nUsually in these problems, the columns we’d like to melt can be distinguished by a common pattern. We can use the function , implemented for convenience, to provide regular expressions for the columns to be combined together. The above operation can be rewritten as:\n\n- Using to specify via separator or pattern\n\nIf, as in the data above, the input columns to melt have regular names, then we can use , which allows specifying the columns to melt via a separator or a regex. For example consider the iris data,\n\nThe iris data has four numeric columns with a regular structure: first the flower part, then a period, then the measurement dimension. To specify that we want to melt those four columns, we can use with which means to use on all column names; the columns which result in the maximum number of groups after splitting will be used as :\n\nThe first two arguments to in the code above ( and ) are used to name the output columns; the number of arguments must equal the max number of groups after splitting with .\n\nIf we want two value columns, one for each part, we can use the special keyword, which means to output a value column for each unique name found in that group:\n\nUsing the code above we get one value column per flower part. If we instead want a value column for each measurement dimension, we can do:\n\nGoing back to the example of the data with families and children, we can see a more complex usage of , involving a function which is used to convert the string values to integers:\n\nIn the code above we used which results in melting only the columns which contain that string (six column names split into two groups each). The argument means the second group will result in an output column named with values defined by plugging the character strings from that group into the function .\n\nFinally we consider an example (borrowed from tidyr package) where we need to define the groups using a regular expression rather than a separator.\n\nWhen using the argument, it must be a Perl-compatible regular expression containing the same number of capture groups (parenthesized sub-expressions) as the number other arguments (group names). The code below shows how to use a more complex regex with five groups, two numeric output columns, and an anonymous type conversion function,\n\nOkay great! We can now melt into multiple columns simultaneously. Now given the data set as shown above, how can we get back to the same format as the original data we started with?\n\nIf we use the current functionality of , then we’d have to cast twice and bind the results together. But that’s once again verbose, not straightforward and is also inefficient.\n\nWe can now provide multiple columns to for s directly so that the operations are taken care of internally and efficiently.\n• Attributes are preserved in result wherever possible.\n• Everything is taken care of internally, and efficiently. In addition to being fast, it is also very memory efficient.\n\nYou can also provide multiple functions to to for data.tables. Check the examples in which illustrates this functionality."
    }
]