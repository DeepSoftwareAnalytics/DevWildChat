[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html",
        "document": ". Returns a of objects that are the immediate sources, not the sources of these immediate sources, of image data for this\n\nSets a rectangular region of the image to the contents of the specified , which is assumed to be in the same coordinate space as the ."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/awt/image/BufferedImage.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://tutorialspoint.com/java_dip/java_buffered_image.htm",
        "document": "Java class is a subclass of Image class. It is used to handle and manipulate the image data. A is made of ColorModel of image data. All objects have an upper left corner coordinate of (0, 0).\n\nThis class supports three types of constructors.\n\nThe first constructor constructs a new with a specified ColorModel and Raster.\n\nThe second constructor constructs a of one of the predefined image types.\n\nThe third constructor constructs a of one of the predefined image types: TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED.\n\nThe following example demonstrates the use of java class that draw some text on the screen using Graphics Object −\n\nWhen you execute the given code, the following output is seen −"
    },
    {
        "link": "https://geeksforgeeks.org/image-processing-in-java-read-and-write",
        "document": "Java implements a particular type of object called a BufferedImage for images in Java. A BufferedImage can be read from several distinct image types (i.e., BMP, HEIC, etc.). Not all of these are backed by ImageIO itself, but there are plugins to extend ImageIO and other libraries such as Apache Imaging and JDeli.\n\nIn Java itself, all the complexity of various image types is hidden, and we only work on BufferedImage. Java provides immediate access to the image pixels and color information and allows conversions and image processing.\n\nClasses Required to Perform the Read and Write Operations:\n\n1. java.io.File: To read and write an image file, we must import the File class. This class represents file and directory path names in general.\n\n2. java.io.IOException: To handle errors, we use the IOException class.\n\n3. java.awt.image.BufferedImage: To hold the image, we create the BufferedImage object; we use BufferedImage class. This object is used to store an image in RAM.\n\n4. javax.imageio.ImageIO: To perform the image read-write operation, we will import the ImageIO class. This class has static methods to read and write an image."
    },
    {
        "link": "https://stackoverflow.com/questions/17161335/how-to-manipulate-bufferedimage",
        "document": "has a class named from which you can get an array of that contains values for all pixels. Then, you manipulate this array and call and voila you have applied an effect to the image.\n\nI was wondering if the same can be done in with some appropriate mechanism. I found that does indeed have a method to get pixels as :\n\nHow do I modify these pixels and show the appropriate changes in ?\n\nI guess I will need to obtain a for the image and use\n\nbut I am still unsure."
    },
    {
        "link": "https://stackoverflow.com/questions/53547194/draw-in-jpanel-with-java-swing-graphics-g",
        "document": "Never, ever call directly, no external source has any reason to do so. Also, what do you thing would happen if you passed it ?\n\nYou should start by having a look at Performing Custom Painting and Painting in AWT and Swing to get a better understand of how paint in Swing works.\n\nThe Swing API basically uses a delegate model, where the system delegates responsibility of the paint of each component to the component. This is achieved by the system calling the components method, which in-turn calls (among a few others) .\n\nSwing also uses a passive rendering approaching, meaning that painting occurs at the discretion of the paint system. You component is notified of the need when its paint method is called. This may occur at any time.\n\nIn order for a component to be painted, it must first be added to container which is realised on the screen (has a native peer), in most cases, this means that the component hierarchy needs to resolve to some kind of window based class, like .\n\nSo, the answer to your question is:\n• Read the above documentation (and get a better understanding of how the API works)\n• Add your to a container which can be resolved to a window based class\n\nTo me, this makes no sense. There is no reasonable reason why needs a reference to . is, in of itself, a \"view\". If anything, the only thing you \"should\" be passing to (assuming you're trying to use a MVC) is a controller"
    },
    {
        "link": "https://stackoverflow.com/questions/26522125/best-practice-for-paintcomponent",
        "document": "Start by taking a look at Painting in AWT and Swing and Performing Custom Painting\n\nSwing uses a passive rendering engine, that is, it only paints when it feels that it has to. Painting can happen for any number of reasons, many of which you don't control, but you can make a request to the repaint manager via the method.\n\nWould suggest that something is wrong, shouldn't, under normal circumstances, be repeatedly called. This can, of course, happen if you are doing animation and need to update the graphics.\n\nSo is there a way to stop that from happening or is it fine to leave rendering as it is\n\nConsider providing a runnable example which demonstrates your problem. This will result in less confusion and better responses.\n\nWithout some idea of what you are doing, there's no way to know what to suggest..."
    },
    {
        "link": "https://coderanch.com/t/676991/java/approach-repainting-custom-objects-JPanel",
        "document": "this forum made possible by our volunteer staff, including ..."
    },
    {
        "link": "https://www3.ntu.edu.sg/home/ehchua/programming/java/J4b_CustomGraphics.html",
        "document": "This chapter shows you how you can paint your own custom drawing (such as graphs, charts, drawings and, in particular, computer game avatars) because you cannot find standard GUI components that meets your requirements. I shall stress that you should try to reuse the standard GUI components as far as possible and leave custom graphics as the last resort. Nonetheless, custom graphics is crucial in game programming.\n\nA graphics context provides the capabilities of drawing on the screen. The graphics context maintains states such as the color and font used in drawing, as well as interacting with the underlying operating system to perform the drawing. In Java, custom painting is done via the class, which manages a graphics context, and provides a set of device-independent methods for drawing texts, figures and images on the screen on different platforms.\n\nThe is an class, as the actual act of drawing is system-dependent and device-dependent. Each operating platform will provide a subclass of to perform the actual drawing under the platform, but conform to the specification defined in .\n\nThe class provides methods for drawing three types of graphical objects:\n• Text strings: via the method. Take note that prints to the system console, not to the graphics screen.\n• Vector-graphic primitives and shapes: via methods and , where could be , , , , , , or .\n\nThese drawing methods is illustrated below. The methods draw the outlines; while methods fill the internal. Shapes with negative and will not be painted. The will be discussed later.\n\nThe graphic context maintains states (or attributes) such as the current painting color, the current font for drawing text strings, and the current painting rectangular area (called clip). You can use the methods , , , , , to get or set the color, font, and clip area. Any painting outside the clip area is ignored.\n\nIn Java Windowing Subsystem (like most of the 2D Graphics systems), the origin is located at the top-left corner.\n\nEACH component/container has its own coordinate system, ranging for to as illustrated.\n\nYou can use method and to retrieve the width and height of a component/container. You can use or to get the top-left corner of this component's origin relative to its parent.\n\nUnder Swing, custom painting is usually performed by extending (i.e., sub-classing) a as the drawing canvas and override the method to perform your own drawing with the drawing methods provided by the class. The Java Windowing Subsystem invokes (calls back) to render the by providing the current graphics context , which can be used to invoke the drawing methods. The extended is often programmed as an inner class of a application to facilitate access of private variables/methods. Although we typically draw on the , you can in fact draw on any (such as , ).\n\nThe custom painting code template is as follows:\n• Custom painting is performed by extending a (called ) and overrides the method to do your own drawing with the drawing methods provided by the class.\n• is designed as an inner class of this application, so as to facilitate access of the private variables/methods.\n• Java Windowing Subsystem invokes (calls back) to render the , with the current graphics context in , whenever there is a need to refresh the display (e.g., during the initial launch, restore, resize, etc). You can use the drawing methods ( and ) on the current graphics context to perform custom painting on the .\n• The size of the is set via the . The does not set its size, but packs the components contained via .\n• In the , the constructor is called in the event-dispatch thread via static method (instead of running in the main thread), to ensure thread-safety and avoid deadlock, as recommended by the Swing developers.\n\nInstead of a named-inner class called in the previous example, you can also use an anonymous inner class for the drawing canvas, if the painting code is short. For example,\n\nYou can retrieve the context of a via the method. This is, however, not commonly used. For example,\n\nUnder AWT, you can perform custom painting by extending , and override the method, in a application. Similarly, you can explicitly invoke to update the graphics.\n\nAt times, we need to explicitly refresh the display (e.g., in game and animation). We shall NOT invoke directly. Instead, we invoke the 's method. The Windowing Subsystem will in turn call back the with the current context and execute it in the event-dispatching thread for thread safety. You can a particular (such as a ) or the entire . The children contained within the will also be repainted.\n\nThe class provides 13 standard colors as named-constants. They are: , , , , , , , , , , , , and . (In JDK 1.1, these constant names are in lowercase, e.g., red. This violates the Java naming convention for constants. In JDK 1.2, the uppercase names are added. The lowercase names were not removed for backward compatibility.)\n\nYou can use the to print the RGB values of these color (e.g., ):\n\nYou can also use the RGB values or RGBA value (A for alpha to specify transparency/opaque) to construct your own color via constructors:\n\nTo retrieve the individual components, you can use , , , , etc.\n\nTo set the background and foreground (text) color of a component/container , you can invoke:\n\nTo set the color of the context (for drawing lines, shapes, and texts), use :\n\nThis example uses the to set the background color of the .\n\nThe class represents a specific font face, which can be used for rendering texts. You can use the following constructor to construct a instance:\n\nYou can use the method to set the current font for the context for rendering texts. For example,\n\nFont's Family Name vs. Font Name\n\nA font could have many faces (or style), e.g., plain, bold or italic. All these faces have similar typographic design. The font face name, or font name for short, is the name of a particular font face, like \"Arial\", \"Arial Bold\", \"Arial Italic\", \"Arial Bold Italic\". The font family name is the name of the font family that determines the typographic design across several faces, like \"Arial\". For example,\n\nJDK supports these logical font family names: \" \", \" \", \" \", \" \", or \" \". JDK 1.6 provides these constants: , , , , .\n\nPhysical font names are actual font libraries such as \"Arial\", \"Times New Roman\" in the system.\n\nYou can use 's to list all the font family names; and to construct all instances (with font size of 1 pt). For example,\n\nYou can use 's to derive a new instance from this with varying size, style and others.\n\nThe class can be used to measure the exact width and height of the string for a particular font face, so that you can position the string as you desire (such as at the center of the screen).\n\nTo create a , use methods of the class, as follows:\n\nThe most commonly-used function for is to measure the width of a given displayed in a certain font.\n\nTo centralize a string on the drawing canvas (e.g., JPanel):\n\nExample 1: Moving an Object via Key/Button Action\n\nThis example illustrates how to re-paint the screen in response to a or .\n\nThe display consists of two in a , arranged in . The top panel is used for custom painting; the bottom panel holds two arranged in . Clicking the \"Move Right\" or \"Move Left\" buttons moves the line. The listens to the \"Left-arrow\" and \"Right-arrow\" keys, and responses by moving the line left or right.\n• To do custom painting, you have to decide which superclass to use. It is recommended that you use a (or a more specialized Swing component such as or ). In this example, we extend the to do our custom painting, in an inner class, as follows:\n• The method is overridden to provide the custom drawing codes. We use the method to draw a line from to .\n• The method cannot be called directly from your code, because it requires a object as argument.\n• is a so-called \"call-back\" method. The Windowing subsystem invokes this method and provides a pre-configured object to represent its state (e.g., current color, font, clip area and etc). There are two kinds of painting: system-triggered painting and application-triggered painting. In a system-trigger painting, the system request a component to render its content when the component is first made visible on the screen, or the component is resized, or the component is damaged that needs to be repaint. In an application-triggered painting, the application invokes a request. Under both cases, the Windowing subsystem will call-back the to render the contents of the component with a proper object as argument.\n• In this example, the application requests for a in the and handlers, which triggers the with an appropriate object as the argument.\n• To be precise, when you invoke the method to repaint a , the Windowing subsystem calls-back method. The method then calls-back three methods: , and .\n• In the overridden method, we call to paint the background of the . If this call is omitted, you must either paint the background yourself (via a call) or use to make the transparent. This will inform Swing system to paint those behind the transparent component.\n• We choose the as the source of the . shall be \"in focus\" when the key is pressed. The method (of \" \" ) is invoked to request for the keyboard focus.\n\n[TODO]: may need to revise.\n\nModifying the program to move a ball in response to up/down/left/right buttons, as well as the 4 arrow and \"wasd\" keys , as shown:\n\nIn game programming, we have moving game objects called sprites. Each sprite is usually modeled in its own class, with its own properties, and it can paint itself.\n\nThis class models a sprite, with its own properties, and it can paint itself via the method provided given a context. A rectangle is used here.\n\nInstead of repainting the entire display, we only repaint the affected areas (clips), for efficiency, via the method. In and , we save the states, move the object, repaint the saved clip-area with the background color, and repaint the new clip-area occupied by the sprite. Repainting is done by asking the sprite to paint itself at the new location, and erase from the old location.\n\nThe class represents an icon, which is a fixed-size picture, typically small-size and used to decorate components. To create an :\n\nis fixed-in-sized and cannot be resized in display. You can use 's to resize a source image in display.\n\nThe coordinates involved is shown in the above diagram. The receives notification about the as it is loaded. In most purposes, you can set it to or .\n\nThe method requires an instance, which can be obtained via 's method; or via method (read \"Reading Images into your program\"). For example,\n\nThis example places absolute numbers in the draw methods, which is hard to maintain and reuse. You should define name-constants such as , , etc, and compute the numbers based on these constants.\n\nCreating an animation (such as a bouncing ball) requires repeatedly running an updating task at a regular interval. Swing provides a class which can be used to fire to its registered at regular interval.\n\nThe class has one constructor:\n\nYou are required to override the method of the to specify your task's behavior. The fires an to the after the (initial) delay, and then at regular interval after delay.\n\nYou can start and stop the via the 's and methods. For example,\n\nYou can use method to set the to fire only once, after the delay. You can set the initial delay via and regular delay via .\n\nA can fire the to more than one s. You can register more s via the method.\n\nThe runs on the event-dispatching thread, just like all the event handlers. You can be relieved of the multi-threading issues.\n\nJDK 1.3 introduced another timer class called , which is more general, but is sufficient (and easier) to run animation in Swing application.\n\ndoes not provide very accurate timing due to the overhead of event-handling. It probably cannot be used for real-time application such as displaying a clock.\n\nAnimation usually involves multi-threading, so that the GUI refreshing operations does not interfere with the programming logic. Multi-threading is an advanced topics. Read \"Multithreading & Concurrent Programming\"\n\nIn the previous example, we use , which run the updating task at regular interval on the event-dispatching thread. In this example, we shall create a new thread to run the update.\n\nTo create a new thread, define a (anonymous and inner) subclass of and override the method to specify the behavior of the task. Create an instance and start the instance via the method, which calls back the defined earlier.\n\nTo ensure the new thread does not starve the other threads, in particular the event-dispatching thread, the thread shall yield control via the method, which also provides the necessary delay.\n• To update the display regularly, we explicitly invoke the method of the , which will callback the of all the components contained in this .\n• The display refreshing code is run in its own thread, so as to avoid the infamous unresponsive user interface problem. It is programmed as an anonymous inner class, extends class , by overriding the method to provide the programmed operations (i.e., ). The method is use to start the thread, which will callback the .\n• Inside the overridden , the is programmed inside an infinite loop, followed by a method, which suspends the thread for the given milliseconds. This operation provides the necessary delay and also yield control to other thread to perform their intended operations.\n\nReference: \"Painting in AWT and Swing\" @ http://www.oracle.com/technetwork/java/painting-140037.html. I summarize some of the important points here.\n\nThe original AWT components are heavyweight components. \"Heavyweight\" means that the component has it's own opaque native window. Heavyweight components, such as , are mapped to the platform-specific components. It relies on the windowing subsystem in each native platform to take care of details such as damage detection, clip calculation, and z-ordering. On the other hand, the newer Swing s (such as ) are lightweight components. A \"lightweight\" component does not own its screen resources but reuses the native window of its closest heavyweight ancestor. Swing s do not rely on the native platform and are written purely in Java, . The top-level containers, such as , and , which are not subclass of , remain heavyweight. It is because the lightweight Swing s need to attach to a heavyweight ancestor.\n\nPainting is carried out via a \"call-back\" mechanism. A program shall put its painting codes in a overridden method ( for AWT components or for Swing component), and the windowing subsystem will call back this method when it's time to paint.\n\nThere are two types of paint (or repaint) requests:\n• System-triggered: e.g., the component is first made visible, the component is resized, etc. The windowing subsystem will schedule or on the event-dispatching thread.\n• Application-triggered: application has modified the appearance of the component and requested to repaint the component. However, Application shall not invoke or directly. Instead, it shall invoke a special method called , which will in turn invoke or . Multiple requests may be collapsed into a single call.\n\nInstead of issuing to paint the entire component, for efficiency, you can selectively repaint a rectangular clip area. You can also specify a maximum time limit for painting to take place.\n\nA lightweight needs a heavyweight somewhere up the containment hierarchy in order to have a place to paint, as only heavyweight components have their own opaque window. When this heavyweight ancestor is asked to paint its window, it must also paint all of its lightweight descendants. This is handled by 's method, which calls on any of its visible, lightweight children which intersect with the rectangle to be painted. Hence, it is crucial for all subclasses (lightweight or heavyweight) that override to place a call in the method. This call invoke 's ( ) method, which in turn invoke on all its descendants. If the call is missing, some of the lightweight descendants will be shown up.\n\nLightweight components does not own its opaque window and \"borrow\" the screen real estate of its heavyweight ancestor. As a result, they could be made transparent, by leaving their background pixels unpainted to allow the underlying component to show through.\n\nTo improve performance of opaque components, Swing adds a property called to all s. If is set to , the component agrees to paint all of the pixels contained within its rectangular bounds. In order words, the windowing subsystem does not have to do anything within these bounds such as painting its ancestors. It is set to , the component makes no guarantees about painting all the bits within its rectangular bounds, and the windowing subsystem has more work to do.\n\nSwing further factor the method into three methods, which are invoked in the following order:\n\nSwing programs should override instead of .\n\nMost of the standard Swing components (in particular, ) have their look and feel implemented by separate look-and-feel objects (called \"UI delegates\") for Swing's Pluggable look and feel feature. This means that most or all of the painting for the standard components is delegated to the UI delegate and this occurs in the following way:\n• If the property is non- , invokes .\n• If the component's property is , fills the component's background with the background color and invokes .\n• renders the content of the component.\n\nThis means that subclasses of Swing components which have a UI delegate (such as ), should invoke within their overridden , so that fills the background (of the superclass such as ) provided is .\n\nTry removing the from a Swing program that does animation (e.g., bouncing ball). The background will not be painted, and the previous screen may not be cleared. You can also paint the background yourself by filling a Rectangle with background color.\n\nFurthermore, if you set the to (via ) for the subclass of , the does not fill the background.\n• \"The Swing Tutorial\" @ http://docs.oracle.com/javase/tutorial/uiswing/, in particular, the section on \"Performing Custom Graphics\"."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/step2.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nNext, we will add a custom drawing surface to the frame. For this we will create a subclass of (a generic lightweight container) which will supply the code for rendering our custom painting.\n\nClick the Launch button to run SwingPaintDemo2 using Java™ Web Start (download JDK 7 or later). Alternatively, to compile and run the example yourself, consult the example index.\n\nThe first change you will notice is that we are now importing a number of additional classes, such as , , and . Since some of the older AWT classes are still used in modern Swing applications, it is normal to see the package in a few of the import statements. We have also defined a custom subclass, called , which comprises the majority of the new code.\n\nThe class definition has a constructor that sets a black border around its edges. This is a subtle detail that might be difficult to see at first (if it is, just comment out the invocation of and then recompile.) also overrides , which returns the desired width and height of the panel (in this case 250 is the width, 200 is the height.) Because of this, the class no longer needs to specify the size of the frame in pixels. It simply adds the panel to the frame and then invokes .\n\nThe method is where all of your custom painting takes place. This method is defined by and then overridden by your subclasses to provide their custom behavior. Its sole parameter, a object, exposes a number of methods for drawing 2D shapes and obtaining information about the application's graphics environment. In most cases the object that is actually received by this method will be an instance of (a subclass), which provides support for sophisticated 2D graphics rendering.\n\nMost of the standard Swing components have their look and feel implemented by separate \"UI Delegate\" objects. The invocation of passes the graphics context off to the component's UI delegate, which paints the panel's background. For a closer look at this process, see the section entitled \"Painting and the UI Delegate\" in the aforementioned SDN article.\n• Now that you have drawn some custom text to the screen, try minimizing and restoring the application as you did before.\n• Obscure a part of the text with another window, then move that window out of the way to re-expose the custom text. In both cases, the painting subsystem will determine that the component is damaged and will ensure that your method is invoked."
    }
]