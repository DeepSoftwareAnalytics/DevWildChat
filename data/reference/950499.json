[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes",
        "document": "This code example retrieves a list of running processes. First, the GetProcessList function takes a snapshot of currently executing processes in the system. To do that, it uses the CreateToolhelp32Snapshot function, and then it walks through the list recorded in the snapshot by using Process32First and Process32Next. For each process in turn, GetProcessList calls the ListProcessModules function, which is described in Traversing the module list, and the ListProcessThreads function, which is described in Traversing the thread list.\n\nA simple error-reporting function, printError, displays the reason for any failures (which typically result from security restrictions). For example, OpenProcess fails for the Idle and CSRSS processes because their access restrictions prevent user-level code from opening them.\n\nTo follow along with the code example, use Visual Studio to create a new project from the C++ Console App project template, and add the code below to it."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/_proc_snap",
        "document": "To develop Process Snapshotting, you need these headers:\n\nFor programming guidance for this technology, see:"
    },
    {
        "link": "https://stackoverflow.com/questions/50390124/getting-process-information-of-every-process",
        "document": "I am trying to create a program that any normal user can run on windows and generate a process list of all processes, including the executable location. I have used CreateToolhelp32Snapshot() to get all process names, pid, ppid. But having issues getting the image path. Everything I do results in pretty much Access Denied.\n\nI have tried ZwQueryInformationProcess, GetProcessImageFileName, etc. and also using OpenProcess to get the handle to each process. I can get the handle by using PROCESS_QUERY_LIMITED_INFORMATION, but any other option doesn't work. I am lost and have been at this for a few days. Can anyone point me in the right direction?"
    },
    {
        "link": "https://medium.com/@R3dLevy/offensive-development-with-c-c-getting-started-with-win32-api-and-pratical-examples-81e51c74a4e5",
        "document": "We introduce the basics of Win32 API and some implementations, crucial for those interested in offensive security. We will explore fundamental concepts, necessary tools, and provide practical examples using the “MessageBox” function\n\n1. Understand what the Windows API is, its use cases, and how it interacts with the OS subsystems\n\n2. Learn how to implement the Windows API in C++ to pop a message or list all processes.\n\nPrograms often need to access or modify Windows subsystems or hardware but are restricted to maintain machine stability. To solve this problem, Microsoft released the Win32 API.\n\nThe Win32 API is a set of functions and procedures that abstract many tasks performed daily to interface between user-mode applications and the kernel on the Windows OS.\n\nFor example, the Win32API function called “WriteProcessMemory” writes data into a specific region of the memory’s process.\n\nThere is mainly two set of functions, user mode functions and kernel functions. The first set has limited acces and sometimes Hooked/monitor by Antivirus or EDR.\n\nBelow is a visual representation of how a user application can use API calls to modify kernel components.\n\nUnderstanding the difference between user mode and kernel mode is essential when working with the Windows API:\n• User Mode: applications have limited access to system resources and hardware. This mode provides a controlled environment where most applications run, preventing them from performing operations that could harm the system or other applications.\n• Kernel Mode: code has unrestricted access to all system resources, including hardware. This mode is where the core of the operating system runs, along with device drivers and other low-level components. Operations requiring direct interaction with hardware or critical system components are executed in kernel mode.\n\nWhy C++ & C#?\n\nC++ and C# are powerful languages for system programming and application development.\n\nC++ is widely used for its efficiency and ability to directly manipulate hardware resources, making it an excellent choice for low-level programming and offensive security tasks.\n\nC#, on the other hand, offers a higher level of abstraction and ease of use, making it suitable for rapid development and creating complex applications with less code.\n\nWe will use both languages depending on the example to demonstrate their respective strengths.\n• Microsoft Visual Studio: A comprehensive development environment for C++ and other languages.\n• Windows 11: The latest version of Windows OS, which includes all necessary tools and updates for modern API development.\n\nOne of the simplest Windows API functions is “MessageBox”, which displays a dialog box containing a message. This function is part of the User32 library in the Win32 API.\n\nThe Microsoft Docs provide this C++ definition :\n\n“MessageBoxA” is the ASCII implementation of the function.\n\nHere’s a basic example of implementation in C++:\n\nThis code will display a message box with the text “Hello, Windows API!” and an “OK” button.\n• “NULL”: Handle to the owner window (no owner in this case).\n• ”Hello, Windows API! by R3dLevy”: The message to display.\n• ”Hello”: The title of the message box.\n• MB_OK: Indicates that the message box will contain an OK button.\n\nTo dive deeper, let’s look at more API calls for process enumeration. This is particularly useful in offensive security for understanding and interacting with processes running on a system.\n\nWe will use 3 functions for this example :\n• CreateToolhelp32Snapshot: Takes a snapshot of the specified processes, heaps, modules, and threads used by the processes.\n• Module32First: Retrieves information about the first module associated with a process\n• Module32Next: Retrieves information about the next module associated with a process or thread.\n\nHere is a brief overview:\n\nListing all process in the debug terminal of visual studio:\n• CreateToolhelp32Snapshot: Takes a snapshot of the processes, heaps, modules, or threads.\n• <> “TH32CS_SNAPPROCESS”: Includes all processes in the snapshot.\n• <> 0: Takes a snapshot of all processes in the system.\n• Process32First and Process32Next: Used to iterate over the list of processes in the snapshot.\n\nThis post covered the basics of Windows API, including user mode and kernel mode distinctions, and provided examples of using the “MessageBox” function and enumerating processes with “CreateToolhelp32Snapshot”.\n\nFuture posts will delve deeper into more advanced topics such as memory management and process manipulation. Specifically, the next post will focus on process injection.\n\nAll the examples can be found on my github repos : https://github.com/R3dLevy/TheOffensiveDevelopmentProject\n• For more detailed information on Windows API calls, you can refer to this resource"
    },
    {
        "link": "https://stackoverflow.com/questions/13999136/listing-windows-processes-and-modules",
        "document": "So I've been messing around with Windows API lately, and I've encountered an issue that I need a little assistance with. Actually, to be precise, there are two issues.\n\nI will first show the code and then explain the difficulties that I am experiencing:\n\nSo, the first issue has to do with the following:\n\nSometimes I get an INVALID_HANDLE error, and I don't really know why. The Process handle is not invalid, nor is any other parameter passed to the function. If somebody could explain to me or at least point me in some direction (which is more preferred solution, since I am more interested to learn :D) it would do me good.\n\nSecond is that for some reason, when I enumerate process' modules and GetModuleFileName() it also includes the location of the current process.\n\nI would get the following when I write to the file:\n\nIt literally does that for every process that I can extract modules from. Any help would be much appreciated!"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/unordered_set",
        "document": "is an associative container that contains a set of unique objects of type . Search, insertion, and removal have average constant-time complexity.\n\nInternally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.\n\nContainer elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.\n• References and pointers to data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated.\n• After container move assignment, unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the past-the-end iterator) to moved-from container remain valid, but refer to elements that are now in .\n\nAn iterator type whose category, value, difference, pointer and\n\nreference types are the same as . This iterator\n\ncan be used to iterate through a single bucket but not across buckets An iterator type whose category, value, difference, pointer and\n\nreference types are the same as . This iterator\n\ncan be used to iterate through a single bucket but not across buckets\n\nThe member types and may be aliases to the same type. This means defining a pair of function overloads using the two types as parameter types may violate the One Definition Rule. Since is convertible to , a single function with a as parameter type will work instead.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/unordered_set-in-cpp-stl",
        "document": "In C++, unordered_set is an unordered associative container that stores unique elements. Unlike set, it stores its elements using hashing. This provides average constant-time O(1) search, insert, and delete operations but the elements are not sorted in any particular order.\n\nExplanation: In the above program, we created an unordered set us with values: {1, 2, 3, 4, 5}\n\nUnordered set is defined as std::unordered_set class template inside the <unordered_set> header file.\n• us: Name assigned to the unordered set.\n\nThe unordered set can be declared and initialized in several ways as shown in the below example:\n• unordered_set<int> us2 = {1, 2, 3, 4, 5} creates the unordered set using the initialization list.\n\nHere are some common operations performed on an unordered set:\n\nNew elements can be inserted into unordered set using insert() method. We cannot specify the position to insert the element as it is automatically decided by its hashed value.\n\nWe can’t access elements of an unordered set by index like in an array or vector. We have to increment or decrement iterator obtained from begin() or end() methods respectively to access the element by position. This can also be done with the help of next() or advance() function.\n\nExplanation: In the above code, iterator it accesses the third element by advancing begin() by 2 positions using next().\n\nIn unordered set, the value of the elements cannot be changed after it is inserted.\n\nUnordered set provides fast search by value operation using the find() member function. This function returns iterator to the element if found, otherwise returns end() iterator.\n\nUnordered set can be traverse either range-based for loop or using begin() and end() iterator in a loop.\n\nOther method is to use the range based for loop that we have used in previous examples.\n\nElements can be removed from the unordered set using erase() method. We can erase elements either by value or by position.\n\nExplanation: In the above example, the element with value 5 is deleted using us.erase(5). Then, the first element is deleted by position using us.erase(us.begin()).\n\nThe below table lists the time complexity of above operations on unordered set:\n\nUnordered set is used in many situations for different purposes. The following examples’ aim is to help you master unordered set beyond the basics:\n\nIn C++, unordered_set provides the built-in implementation of hash table data structure. Each element is hashed on the basis of its value. This hash value determines where to store it in hash table. Each key in an unordered set is unique, and if an attempt is made to insert a duplicate element, it will be ignored. As it uses hashing, insertion, deletion and search operations take O(1) amortized time.\n\nFollowing is the primary differences between unordered_set and set in C++:\n• None Unordered set stores elements in any order and insertion, deletion, and access operations are O(1) time due to the use of hashing\n• None stores elements in a sorted order and operations such as insertions, deletions, and accessing operations are takes logarithmic O(log n)\n\nHere’s the list of all member functions of std::unordered_set:\n\nInsert a new element in the unordered set. Return an iterator pointing to the first element in the unordered set. Return an iterator pointing to beyond the element in the unordered set Count occurrences of a particular element in an unordered set. Search for an element in the unordered set. Removes all of the elements from an unordered set and empties it. Return a const iterator pointing to the first element in the unordered set. Return a const iterator pointing to beyond the element in the unordered set. Returns the total number of elements present in a specific bucket in an unordered set. Remove either a single element or a range of elements ranging from start(inclusive) to end(exclusive). Return the number of elements in the unordered set. Insert an element in an unordered set. Returns maximum number of elements that an unordered set can hold. Check if an unordered set is empty or not. Returns range that includes all elements equal to a given value. This hash function is a unary function that takes a single argument only and returns a unique value of type size_t based on it. Used to request a capacity change of unordered set. Returns the total number of buckets present in an unordered set. Returns the current load factor in the unordered set. Set the number of buckets in the container of unordered set to a given size or more. Returns the current maximum load factor of the unordered set. Inserts a new element in the unordered set only if the value to be inserted is unique, with a given hint. Returns a boolean value according to the comparison. It returns the key equivalence comparison predicate used by the unordered set. Return the maximum number of buckets that unordered set can hold."
    },
    {
        "link": "https://cplusplus.com/reference/unordered_set/unordered_set",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/unordered-set-class?view=msvc-170",
        "document": "The class template describes an object that controls a varying-length sequence of elements of type . The sequence is weakly ordered by a hash function, which partitions the sequence into an ordered set of subsequences called buckets. Within each bucket, a comparison function determines whether any pair of elements has equivalent ordering. Each element serves as both a sort key and a value. The sequence is represented in a way that permits lookup, insertion, and removal of an arbitrary element with a number of operations that can be independent of the number of elements in the sequence (constant time), at least when all buckets are of roughly equal length. In the worst case, when all of the elements are in one bucket, the number of operations is proportional to the number of elements in the sequence (linear time). Inserting an element invalidates no iterators, and removing an element invalidates only those iterators that point at the removed element.\n\nThe object orders the sequence it controls by calling two stored objects, a comparison function object of type and a hash function object of type . You access the first stored object by calling the member function ; and you access the second stored object by calling the member function . Specifically, for all values and of type , the call returns true only if the two argument values have equivalent ordering; the call yields a distribution of values of type . Unlike class template Class, an object of type ensures that is always false for any two elements of the controlled sequence. (Keys are unique.)\n\nThe object also stores a maximum load factor, which specifies the maximum desired average number of elements per bucket. If inserting an element causes to exceed the maximum load factor, the container increases the number of buckets and rebuilds the hash table as needed.\n\nThe actual order of elements in the controlled sequence depends on the hash function, the comparison function, the order of insertion, the maximum load factor, and the current number of buckets. You can't in general predict the order of elements in the controlled sequence. You can always be assured, however, that any subset of elements that have equivalent ordering are adjacent in the controlled sequence.\n\nThe object allocates and frees storage for the sequence it controls through a stored allocator object of type . Such an allocator object must have the same external interface as an object of type . The stored allocator object isn't copied when the container object is assigned.\n\nThe type of an allocator for managing storage.\n\nThe type is a synonym for the template parameter .\n\nDesignates the beginning of the controlled sequence or a bucket.\n\nThe first two member functions return a forward iterator that points at the first element of the sequence (or just beyond the end of an empty sequence). The last two member functions return a forward iterator that points at the first element of bucket (or just beyond the end of an empty bucket).\n\nGets the bucket number for a key value.\n\n\n\n The key value to map.\n\nThe member function returns the bucket number currently corresponding to the key value .\n\nGets the number of buckets.\n\nThe member function returns the current number of buckets.\n\nGets the size of a bucket\n\nThe member functions returns the size of bucket number .\n\nReturns a iterator that addresses the first element in the range.\n\nA forward-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, ).\n\nWith the return value of , the elements in the range can't be modified.\n\nYou can use this member function in place of the member function to guarantee that the return value is . Typically, it's used in conjunction with the type deduction keyword, as shown in the following example. In the example, consider to be a modifiable (non- ) container of any kind that supports and .\n\nReturns a iterator that addresses the location just beyond the last element in a range.\n\nA forward-access iterator that points just beyond the end of the range.\n\nis used to test whether an iterator has passed the end of its range.\n\nYou can use this member function in place of the member function to guarantee that the return value is . Typically, it's used in conjunction with the type deduction keyword, as shown in the following example. In the example, consider to be a modifiable (non- ) container of any kind that supports and .\n\nThe value returned by shouldn't be dereferenced.\n\nThe member function calls , . For more information, see , , and .\n\nThe type of a constant iterator for the controlled sequence.\n\nThe type describes an object that can serve as a constant forward iterator for the controlled sequence. It's described here as a synonym for the implementation-defined type .\n\nThe type of a constant bucket iterator for the controlled sequence.\n\nThe type describes an object that can serve as a constant forward iterator for a bucket. It's described here as a synonym for the implementation-defined type .\n\nThe type of a constant pointer to an element.\n\nThe type describes an object that can serve as a constant pointer to an element of the controlled sequence.\n\nThe type of a constant reference to an element.\n\nThe type describes an object that can serve as a constant reference to an element of the controlled sequence.\n\nChecks if there's an element with the specified key in the .\n\n\n\n The type of the key.\n\n\n\n The element's key value to look for.\n\nif the element is found in the container; otherwise.\n\nis new in C++20. To use it, specify the /std:c++20 or later compiler option.\n\nonly participates in overload resolution if is transparent.\n\nFinds the number of elements matching a specified key.\n\n\n\n Key value to search for.\n\nThe member function returns the number of elements in the range delimited by .\n\nThe type of a signed distance between two elements.\n\nThe signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence. It's described here as a synonym for the implementation-defined type .\n\nInserts an element constructed in place (no copy or move operations are performed).\n\n\n\n The arguments forwarded to construct an element to be inserted into the unless it already contains an element whose value is equivalently ordered.\n\nA whose component returns true if an insertion was made and false if the already contained an element whose key had an equivalent value in the ordering, and whose iterator component returns the address where a new element was inserted or where the element was already located.\n\nTo access the iterator component of a pair returned by this member function, use , and to dereference it, use . To access the component of a pair returned by this member function, use .\n\nNo iterators or references are invalidated by this function.\n\nDuring the insertion, if an exception is thrown but doesn't occur in the container's hash function, the container isn't modified. If the exception is thrown in the hash function, the result is undefined.\n\nFor a code example, see .\n\nInserts an element constructed in place (no copy or move operations are performed), with a placement hint.\n\n\n\n The arguments forwarded to construct an element to be inserted into the unless the already contains that element or, more generally, unless it already contains an element whose key is equivalently ordered.\n\n\n\n A hint about the place to start searching for the correct point of insertion.\n\nAn iterator to the newly inserted element.\n\nIf the insertion failed because the element already exists, returns an iterator to the existing element.\n\nNo iterators or references are invalidated by this function.\n\nDuring the insertion, if an exception is thrown but doesn't occur in the container's hash function, the container isn't modified. If the exception is thrown in the hash function, the result is undefined.\n\nFor a code example, see .\n\nTests whether no elements are present.\n\nThe member function returns true for an empty controlled sequence.\n\nDesignates the end of the controlled sequence.\n\nThe first two member functions return a forward iterator that points just beyond the end of the sequence. The last two member functions return a forward iterator that points just beyond the end of bucket .\n\n\n\n Key value to search for.\n\nThe member function returns a pair of iterators such that delimits just those elements of the controlled sequence that have equivalent ordering with . If no such elements exist, both iterators are .\n\nRemoves an element or a range of elements in a from specified positions or removes elements that match a specified key.\n\n\n\n Position of the element to be removed.\n\n\n\n Position of the first element to be removed.\n\n\n\n Position just beyond the last element to be removed.\n\n\n\n The key value of the elements to be removed.\n\nFor the first two member functions, a bidirectional iterator that designates the first element remaining beyond any elements removed, or an element that is the end of the if no such element exists.\n\nFor the third member function, returns the number of elements that have been removed from the .\n\nFor a code example, see set::erase.\n\nFinds an element that matches a specified key.\n\n\n\n Key value to search for.\n\nThe type of the hash function.\n\nThe type is a synonym for the template parameter .\n\nInserts an element or a range of elements into an .\n\n\n\n The value of an element to be inserted into the unless it already contains an element whose key is equivalently ordered.\n\n\n\n The place to start searching for the correct point of insertion.\n\n\n\n Template parameter that specifies the argument type that the can use to construct an element of , and perfect-forwards as an argument.\n\n\n\n The position of the first element to be copied.\n\n\n\n The position just beyond the last element to be copied.\n\n\n\n Template function argument that meets the requirements of an input iterator that points to elements of a type that can be used to construct objects.\n\n\n\n The from which to copy the elements.\n\nThe single-element member functions, (1) and (2), return a whose component is true if an insertion was made, and false if the already contained an element whose key had an equivalent value in the ordering. The iterator component of the return-value pair points to the newly inserted element if the component is , or to the existing element if the component is .\n\nThe single-element-with-hint member functions, (3) and (4), return an iterator that points to the position where the new element was inserted into the or, if an element with an equivalent key already exists, to the existing element.\n\nNo iterators, pointers, or references are invalidated by this function.\n\nDuring the insertion of just one element, if an exception is thrown but doesn't occur in the container's hash function, the container's state isn't modified. If the exception is thrown in the hash function, the result is undefined. During the insertion of multiple elements, if an exception is thrown, the container is left in an unspecified but valid state.\n\nTo access the iterator component of a that's returned by the single-element member functions, use ; to dereference the iterator within the returned pair, use , giving you an element. To access the component, use . For an example, see the sample code later in this article.\n\nThe of a container is a typedef that belongs to the container, and, for set, is type .\n\nThe range member function (5) inserts the sequence of element values into an that corresponds to each element addressed by an iterator in the range ; therefore, doesn't get inserted. The container member function refers to the position just after the last element in the container—for example, the statement attempts to insert all elements of into . Only elements that have unique values in the range are inserted; duplicates are ignored. To observe which elements are rejected, use the single-element versions of .\n\nThe initializer list member function (6) uses an to copy elements into the .\n\nFor insertion of an element constructed in place—that is, no copy or move operations are performed—see and .\n\nFor a code example, see .\n\nA type that provides a constant forward iterator that can read elements in an unordered_set.\n\nSee the example for for an example of how to declare and use an iterator.\n\nThe type of the comparison function.\n\nThe type is a synonym for the template parameter .\n\nThe type of an ordering key.\n\nThe type is a synonym for the template parameter .\n\nThe member function returns unordered_set::size unordered_set::bucket_count , the average number of elements per bucket.\n\nThe type describes an object that can serve as a forward iterator for a bucket. It's described here as a synonym for the implementation-defined type .\n\nGets the maximum number of buckets.\n\nThe member function returns the maximum number of buckets currently permitted.\n\nGets or sets the maximum elements per bucket.\n\nThe first member function returns the stored maximum load factor. The second member function replaces the stored maximum load factor with .\n\nGets the maximum size of the controlled sequence.\n\nThe member function returns the length of the longest sequence that the object can control.\n\n\n\n The being copied into the .\n\nAfter erasing any existing elements in an , either copies or moves the contents of into the .\n\nThe type of a pointer to an element.\n\nThe type describes an object that can serve as a pointer to an element of the controlled sequence.\n\nThe type of a reference to an element.\n\nThe type describes an object that can serve as a reference to an element of the controlled sequence.\n\nThe member function alters the number of buckets to be at least and rebuilds the hash table as needed.\n\nThe member function returns the length of the controlled sequence.\n\nThe type of an unsigned distance between two elements.\n\nThe unsigned integer type describes an object that can represent the length of any controlled sequence. It's described here as a synonym for the implementation-defined type .\n\nSwaps the contents of two containers.\n\n\n\n The container to swap with.\n\nThe member function swaps the controlled sequences between and . If , it does so in constant time, it throws an exception only as a result of copying the stored traits object of type , and it invalidates no references, pointers, or iterators that designate elements in the two controlled sequences. Otherwise, it performs a number of element assignments and constructor calls proportional to the number of elements in the two controlled sequences.\n\n\n\n The containing the elements to copy.\n\nThe first constructor specifies a copy of the sequence controlled by . The second constructor specifies an empty controlled sequence. The third constructor specifies a copy of the sequence by moving The fourth through eighth constructors use an to specify the elements to copy. The ninth constructor inserts the sequence of element values .\n\nAll constructors also initialize several stored values. For the copy constructor, the values are obtained from . Otherwise:\n\nThe minimum number of buckets is the argument , if present; otherwise it's a default value described here as the implementation-defined value .\n\nThe hash function object is the argument , if present; otherwise it's .\n\nThe comparison function object is the argument , if present; otherwise it's .\n\nThe allocator object is the argument , if present; otherwise, it's .\n\nThe type of an element.\n\nThe type describes an element of the controlled sequence."
    },
    {
        "link": "https://codesignal.com/learn/courses/hashing-maps-and-collections-in-cpp/lessons/stdunorderedset-a-comprehensive-guide",
        "document": "Welcome to our session, in which we will explore the inner workings of C++'s structure. Our aim is to gain a comprehensive understanding of how sets operate in C++, learn how to apply these structures practically, and get detailed insights into their time and space complexities. In programming, we often use a when managing a collection of unique items. in C++ is part of the Standard Template Library (STL) and offers benefits such as efficient membership checks and automatic duplicate removal. Let's dive into this distinct structure and its practical applications. Ready? Let's embark on this learning journey!\n\nAn is an integral part of C++'s STL, designed to store unique elements in an unordered manner. Unlike arrays or vectors, the does not maintain any specific order for the elements inserted. This flexibility ensures that every stored element is unique, providing developers with a powerful tool for managing collections of non-repeating data. An excels in implementations where uniqueness is vital, optimizing scenarios that involve checking for existing items or storing distinct data. Let's consider an example with C++: In this example, despite attempting to add \"Alice\" twice, the includes \"Alice\" only once when printed. Note that does not maintain the order of elements, illustrating its unordered nature.\n\nUnder the hood, uses a hash table to organize its elements. It employs an array and a hash function to generate a hash code, which simplifies both the storage and retrieval operations. The hash function converts elements like \"David\" or \"Alice\" into integers that determine the index where each element is stored, allowing for efficient storage and retrieval. In cases where two elements generate the same hash code (a situation known as a 'collision'), the resolves this using a technique like 'chaining', where multiple elements are stored in the same hash bucket. However, this can slightly degrade performance, pushing the time complexity closer to in the worst case. In C++, the operations , , and on an rely on the hash code of the elements. Here's an example demonstrating the use of these functions: In this snippet, we add numbers from 0 to 99 to the and verify if each number is present. The hashing mechanism ensures swift lookups, enhancing our code execution performance. The function in provides a way to determine if an element was successfully added to the set or if it was already present. It returns a , where the component is an iterator pointing to the position of the element in the set, and the component is a boolean. The value is if the insertion was successful, meaning the element was not present and was added; it is if the element already existed in the set, hence no new addition took place.\n\nA key factor influencing the performance of an is its time and space complexity. The index of an element is computed directly via the hash function, providing average constant time complexity ( ) for adding, finding, or removing an element from an . The space complexity of std::unordered_set is , which means that it grows linearly with the number of elements stored. This includes the storage for elements themselves, as well as the extra memory overhead required for the hash table's buckets and any linked structures used to resolve collisions. The function operates in average time, but in cases where many elements share the same hash bucket (due to poor hash distribution), performance could degrade to for that particular bucket. Proper choice of a hash function can help mitigate such issues, ensuring more uniform distribution. In the code above, adding, searching, and removing elements from remains efficient, demonstrating the effectiveness of its operations.\n\nThe is invaluable when working with large datasets. It provides quick handling for operations such as adding, checking the presence of, and removing items. It's commonly used in scenarios requiring fast membership checks, like database indexing or managing unique records. For instance, suppose we're tracking unique visited web pages. Using an , we can quickly add new pages and efficiently check if a specific page has been visited: As we add URLs to the , checking for a previously visited page becomes efficient and immediate.\n\nIn wrapping up our exploration of C++'s , we've highlighted its unique characteristics, delved into its operational mechanics, and acquainted ourselves with its time and space efficiencies. An essential takeaway from this session is understanding the implementation and significance of hash functions, which are pivotal in optimizing data structures like . Next, we'll tackle hands-on exercises crafted to solidify your grasp of . These exercises are designed to imbue you with a practical perspective on its applications. Ready to dive into some coding challenges? Let's get started!"
    },
    {
        "link": "https://stackoverflow.com/questions/25895835/best-practices-for-concurrent-c-applications",
        "document": "I have some questions regarding software design aspects for designing concurrent C++ applications. I have some hihger-level question (I know the basics like 'what is a lock/mutex/condition variable' etc).\n\nAssume that some function operates on some object . It is necessary during these operations to hold a lock (which might be a member variable of ). Now assume that calls a subfunction while it holds the lock. Now operates on an object which is already locked. However, what if I also want to call from somewhere else without holding the lock? Should lock or should it not? I see 3 possibilites:\n• I could pass a to indicating whether ot not locking is required. This seems to introduce a lot of boilerplate code though.\n• I could use a recursive lock and just always lock in . Recursive locks seem to be problematic though, see here.\n• I could assume that every caller of holds the lock already. I would have to document this and perhaps enforce this (at least in debugging mode). Is it reasonable to have functions make assumptions regarding which locks are / are not held by the calling thread? More generally, how do I decide from a design perspective which function should lock and which should assume that it is already locked?\n\nDo you have a recommendation for this?\n\nSo far I am using a method returning a which I supply to an RAII . I think that if I were to use C++11 it would be more idiot proof to return a directly and to overload the move constructor. But this is not possible in C++03. Still, is there a differnt strategy? Is it generally recommended to expose a mutex or should this rather be avoided?\n\nAssume that I have a Document consisting of multiple Pages. This document might be accessed in the following ways:\n• Threads rerender Pages which become visible / have changed / etc.\n\nThe obvious way would be a big lock for the Document which every thread has to hold while accessing the document. This has the distinct disadvantage that the rendering threads are essentially working consecutively even if they access different pages. I have two solutions in mind:\n• Use a read-write mutex. Upon modifying the document the thread has to have write access while the rerendering threads only need read access.\n• Use a lock for each Page plus one for the Document. Rerendering threads hold the Page lock. The user thread acquires the Page lock when changing a Page and in addition the Document lock when it changes the structure of the Document. It might be necessary to hold multiple Page locks if the user wants to for instance swap two Pages. In this case I believe there has to be a fixed locking order.\n\nHow do these approaches compare regarding code complexity / execution time? What would you recommend?\n\nConsider again the scenario from the last point. Assume that there is some affinity regarding tasks and threads. More to the point, some functions are required to be called solely from a particular thread (if you must know I am using gtk and it is required that any interaction with gtk has to be performed from a single thread.). The approach seems to be to add a callback to be processed by the correct thread. However, what happens if I require a lock to be held during the entire operation? Should I pass the (held) lock across threads (this seems like an anti-pattern to me)?\n\nTo hunt down bugs I would like to have a single threaded mode. Assume that I have a Scheduler which gets passed a class instance with a method. Normally the Scheduler acts as a Threadpool. It would notify some idle thread and pass it the instance to be processed. I had the naive idea to make the Scheduler just call the method itself. This does not work however since the calling function might hold locks which the needs to lock as well leading to a deadlock. Is there some simple way to avoid this situation? I am tempted to pass a to the lock indicating whether or not the lock is merely a dummy and should do absolutely nothing. But this could just introduce multi-threaded problems (violated invariants) into a single threaded environment... Is there some simple way to get a Scheduler to switch to single threaded mode?\n\nThose are quite some problems and it took me a while to write everything down :) I would very much appreciate your help though. Recommendations for literature would also be welcome."
    },
    {
        "link": "https://medium.com/@alex.omegapy/concurrency-in-c-mitigating-risks-5891fba59842",
        "document": "In computer science, concurrency or multithreading is a powerful tool that can be used to improve the performance and responsiveness of applications, it is especially beneficial to applications needing to handle large amounts of computation or I/O tasks. Concurrency is an approach that allows multiple threads to be executed concurrently on multi-core processors, reducing the program execution time. C++, starting at the C++ 11 release, provides native support for threads such as ‘std::thread’, as well as concurrency control features such as ‘std::mutex’, ‘std::lock_guard’, and ‘unique_lock’.\n\nHowever, concurrency, in C++, also introduces vulnerabilities if not properly managed. An incorrect implementation of concurrency can result in serious issues such as data races, deadlocks, and undefined behavior. Thus, it is imperative to understand how to properly implement and manage threats to avoid potentially serious consequences. This can be done by adhering to best practices such as the one recommended by SEI CERT C++ Coding Standard, Rule 10 Concurrency (CON) (CMU — Software Engineering Institute, n.d.).\n\nBelow is a list of common concurrency vulnerabilities and the corresponding SEI CERT C++ Coding Standard rules that address them.\n\nIt occurs when two or more threads access shared data simultaneously, and at least one thread modifies the data. This can lead to inconsistent or unexpected results.\n\nAccessing shared data in a safe manner by preventing data races is compliant with the SEI CERT C++ Coding Standard CON51-CPP: “Ensure actively held locks are released on exceptional conditions” (CMU — Software Engineering Institute, n.d.).\n\nIt happens when two or more threads are waiting indefinitely for resources held by each other, preventing any of them from proceeding.\n\nLocking mutexes in a predefined order to avoid deadlocks is compliant with CON53-CPP: “Avoid deadlock by locking in a predefined order” (CMU — Software Engineering Institute, n.d.).\n\nDestroying a mutex while it is still locked can lead to undefined behavior and potential resource leaks.\n\nNot destroyed mutexes while locked is compliant with CON50-CPP: “Do not destroy a mutex while it is locked” (CMU — Software Engineering Institute, n.d.).\n\nNot wrapping condition variable waits in a loop can lead to spurious wake-ups and incorrect program behavior. \n\nWrapping wait calls in a loop is compliant with CON54-CPP: “Wrap functions that can spuriously wake up in a loop” (CMU — Software Engineering Institute, n.d.).\n\nExample 4: Condition variable without loop (CON54-CPP) — Code with vulnerability\n\nDo not attend to lock a non-recursive mutex that is already locked by the same thread, this can result in undefined behavior and potential deadlocks.\n\nNot trying to lock already locked non-recursive mutexes is compliant with CON56-CPP: “Do not speculatively lock a non-recursive mutex that is already owned by the calling thread” (CMU — Software Engineering Institute, n.d.).\n\nAccessing bit fields concurrently can result in data race conditions.\n\nWhen accessing bit-fields preventing data races from multiple threads is compliant with CON52-CPP: “Prevent data races when accessing bit-fields from multiple threads” (CMU — Software Engineering Institute, n.d.).\n\nSolution: Use separate storage units or protect with mutex\n\nWhen using condition variables is essential to ensure thread safety and preserve liveness. Liveness is the process of the threads making continuous progress and does not end up in situations where they are unable to proceed. For example, being indefinitely blocked or waiting for resources that never will become available.\n\nPreserving thread safety and liveness is compliant with CON55-CPP: “Preserve thread safety and liveness when using condition variables” (CMU — Software Engineering Institute, n.d.).\n\nBelow is a table summary of the risk assessment of the C++ concurrency coding rules from the SEI CERT C++ Coding Standard.\n\nNote: From “Rule 10. Concurrency (CON). SEI CERT C++ Coding Standard” by CMU — Software Engineering Institute (n.d.).\n• Rule: The specific rule from the SEI CERT C++ Coding Standard.\n• Likelihood: The probability of the rule violation leading to a vulnerability.\n• Remediation Cost: The effort required to fix the violation.\n\nTo summarize, in computer science, concurrency is a powerful tool that can be used to improve the performance and responsiveness of applications. However, in C++, concurrency can introduce vulnerabilities if not properly managed, and it may result in serious issues such as data races, deadlocks, and undefined behavior. Thus, it is imperative to adhere to best practices such as the one recommended by SEI CERT C++ Coding Standard."
    },
    {
        "link": "https://stackoverflow.com/questions/12507937/multiple-threads-and-mutexes",
        "document": "I see three problems here. There's a question your infinite loop, another about your intention in having multiple threads, and there's a future maintainability \"gotcha\" lurking.\n\nIs that right? You read some stuff from a socket, and start an infinite loop without ever closing the socket? I can only assume that you do some more reading in the loop, but in which case you are waiting for an external event while holding the mutex. In general that's a bad pattern limiting your concurrency. A possibly pattern is to have one thread reading the data and then passing the read data to other threads which do the processing.\n\nNext, you have two different sets of resources each protected by their own mutex. You then intend to have a set of Threads for each resource. But each thread has the pattern\n\nThere's virtually no opportunity for two threads to work in parallel. I question whether your have need for multiple threads for each resource.\n\nLast there's a potential maintenance issue. I'm just pointing this out for future reference, I don't think you need to do anything right now. You have two functions, intended for use by two threads, but in the end they are just functions that can be called by anyone. If later maintenance results in those functions (or refactored subsets of the functions) then you could get two threads\n\nand the other\n\nNot an easy problem to avoid, but at the very least one can aid the maintainer by careful naming choices and refactoring."
    },
    {
        "link": "https://linkedin.com/pulse/mastering-multithreading-concurrency-c-comprehensive-deep-bajwa",
        "document": "Multithreading and concurrency stand as fundamental pillars in the domain of modern software development. These concepts play a pivotal role in optimizing application performance. Within the robust confines of the C++ programming language, multithreading and concurrency are not just features to explore but essential components that empower developers to craft highly efficient and responsive software. In this comprehensive article, we embark on an extensive journey into the realm of multithreading and concurrency in C++, starting with the basics and venturing into advanced topics.\n\nAt its core, multithreading is the art of executing multiple threads concurrently within a single program. Threads, akin to nimble and lightweight processes, coexist within the same memory space. This arrangement allows them to communicate and collaborate seamlessly, performing tasks simultaneously. Multithreading, particularly on multi-core processors, can yield remarkable gains in application performance.\n\nC++ equips programmers with a toolkit for managing threads. This toolkit encompasses essential functions such as thread creation, joining, detaching, and termination. Proficiency in utilizing these functions is imperative for mastering multithreading.\n\nWhen multiple threads engage in simultaneous access and modification of shared data, the peril of data races looms, resulting in undefined behavior. The salvation lies in synchronization mechanisms such as mutexes and locks.\n\nMutexes, the sentinels of multithreading, stand as guardians protecting shared data. C++ extends its benevolence with std::mutex, std::unique_lock, and std::lock_guard to streamline the management of mutexes and locks efficiently. Behold a vivid example:\n\nCondition variables (`std::condition_variable`) offer threads the ability to pause gracefully until specific conditions are met. They emerge as invaluable allies, particularly in scenarios where one thread produces data, while another thread consumes it.\n\nAn essential distinction lies in understanding the difference between parallelism (the simultaneous execution of threads on multiple cores) and concurrency (the efficient orchestration of multiple tasks). This comprehension is pivotal for optimizing application performance.\n\nThread pools usher in the age of efficiency by simplifying the management and reuse of a fixed number of threads for tasks. They mitigate the overhead of thread creation and destruction. C++ provides libraries such as <thread> and <future> to embrace the world of thread pools.\n\nMultithreading and concurrency in C++ are formidable tools for crafting high-performance applications. While they present challenges like data races and synchronization, a comprehensive understanding of these concepts, coupled with the tools and techniques furnished by C++, empowers you to unleash the full potential of multithreading. The result is software that not only exemplifies efficiency but also responsiveness. Continuous practice and experimentation are your steadfast companions on the journey to mastering this indispensable facet of C++ programming."
    },
    {
        "link": "https://articles.emptycrate.com/2009/06/10/optimizing_massively_multithreaded_c_applications__watch_for_hidden_mutexes.html",
        "document": "If your application does not scale as your threads increase, you should check the code to make sure there are no hidden mutexes limiting your concurrency.\n\nHow is your logging system implemented? Does writing a log message grab a mutex lock? Is the lock held for potentially a long time? If you provide a significant amount of logging from many different threads it is possible they are getting bound on the logger and limiting your concurrency. One possible fix is to implement a log message queue and have a separate thread that handles expensive logging operations such as transmitting the log message over the network or writing it to a file.\n\nDo you have any global system objects? In the case of the application I was optimizing I needed to raise OS privilege level during certain operations. The system object that raised privileges had a mutex to prevent more than one thread from raising privileges at once. In this particular case, I spent more time in a raised level than not, and was effectively limiting my concurrency to… 1 (2 or 3 at best). The solution in this case was to just run the application as root, and bypass the issue. Alternatively, I could have used a non-exclusive lock and implemented a count of the number of threads needing privileges. Only when the count reached 0 would have I dropped back down to an unprivileged state.\n\nAny data that is shared between threads must be protected with mutexes. If we don’t protect it we risk serious problems with multiple threads trying to update a value at once or one thread trying to read a value while another one is updating it. Effectively managing shared data can be a real headache to get right. Worse, for the point of this discussion, shared data introduces points of contention between threads. Often, copying the data for per-thread usage may be your best bet.\n\nOne can better manage data that must be shared by using reader / writer mutexes. While simultaneously reading and writing a variable more complex than a machine-sized integer is dangerous, almost any data type can be read from multiple readers simultaneously. The boost shared_mutex is one such implementation of a reader / writer mutex. For any operation that must read the shared data, you acquire a shared_lock. For any operation that must update the data, you acquire an unique_lock. An unique_lock prevents any other lock from being acquired, but multiple threads can own shared_lock."
    }
]