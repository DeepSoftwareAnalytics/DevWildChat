[
    {
        "link": "https://mybatis.org/mybatis-3/dynamic-sql.html",
        "document": "One of the most powerful features of MyBatis has always been its Dynamic SQL capabilities. If you have any experience with JDBC or any similar framework, you understand how painful it is to conditionally concatenate strings of SQL together, making sure not to forget spaces or to omit a comma at the end of a list of columns. Dynamic SQL can be downright painful to deal with.\n\nWhile working with Dynamic SQL will never be a party, MyBatis certainly improves the situation with a powerful Dynamic SQL language that can be used within any mapped SQL statement.\n\nThe Dynamic SQL elements should be familiar to anyone who has used JSTL or any similar XML based text processors. In previous versions of MyBatis, there were a lot of elements to know and understand. MyBatis 3 greatly improves upon this, and now there are less than half of those elements to work with. MyBatis employs powerful OGNL based expressions to eliminate most of the other elements:\n\nThe most common thing to do in dynamic SQL is conditionally include a part of a where clause. For example: <select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <if test=\"title != null\"> AND title like #{title} </if> </select> This statement would provide an optional text search type of functionality. If you passed in no title, then all active Blogs would be returned. But if you do pass in a title, it will look for a title like that (for the keen eyed, yes in this case your parameter value would need to include any masking or wildcard characters). What if we wanted to optionally search by title and author? First, I’d change the name of the statement to make more sense. Then simply add another condition. <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </select>\n\nSometimes we don’t want all of the conditionals to apply, instead we want to choose only one case among many options. Similar to a switch statement in Java, MyBatis offers a choose element. Let’s use the example above, but now let’s search only on title if one is provided, then only by author if one is provided. If neither is provided, let’s only return featured blogs (perhaps a strategically list selected by administrators, instead of returning a huge meaningless list of random blogs). <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <choose> <when test=\"title != null\"> AND title like #{title} </when> <when test=\"author != null and author.name != null\"> AND author_name like #{author.name} </when> <otherwise> AND featured = 1 </otherwise> </choose> </select>\n\nThe previous examples have been conveniently dancing around a notorious dynamic SQL challenge. Consider what would happen if we return to our “if” example, but this time we make “ACTIVE = 1” a dynamic condition as well. <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE <if test=\"state != null\"> state = #{state} </if> <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </select> What happens if none of the conditions are met? You would end up with SQL that looked like this: This would fail. What if only the second condition was met? You would end up with SQL that looked like this: SELECT * FROM BLOG WHERE AND title like ‘someTitle’ This would also fail. This problem is not easily solved with conditionals, and if you’ve ever had to write it, then you likely never want to do so again. MyBatis has a simple answer that will likely work in 90% of the cases. And in cases where it doesn’t, you can customize it so that it does. With one simple change, everything works fine: <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG <where> <if test=\"state != null\"> state = #{state} </if> <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </where> </select> The where element knows to only insert “WHERE” if there is any content returned by the containing tags. Furthermore, if that content begins with “AND” or “OR”, it knows to strip it off. If the where element does not behave exactly as you like, you can customize it by defining your own trim element. For example, the trim equivalent to the where element is: The prefixOverrides attribute takes a pipe delimited list of text to override, where whitespace relevant. The result is the removal of anything specified in the prefixOverrides attribute, and the insertion of anything in the prefix attribute. There is a similar solution for dynamic update statements called set. The set element can be used to dynamically include columns to update, and leave out others. For example: <update id=\"updateAuthorIfNecessary\"> update Author <set> <if test=\"username != null\">username=#{username},</if> <if test=\"password != null\">password=#{password},</if> <if test=\"email != null\">email=#{email},</if> <if test=\"bio != null\">bio=#{bio}</if> </set> where id=#{id} </update> Here, the set element will dynamically prepend the SET keyword, and also eliminate any extraneous commas that might trail the value assignments after the conditions are applied. Alternatively, you can achieve the same effect by using trim element: Notice that in this case we’re overriding a suffix, while we’re still appending a prefix.\n\nAnother common necessity for dynamic SQL is the need to iterate over a collection, often to build an IN condition. For example: <select id=\"selectPostIn\" resultType=\"domain.blog.Post\"> SELECT * FROM POST P <where> <foreach item=\"item\" index=\"index\" collection=\"list\" open=\"ID in (\" separator=\",\" close=\")\" nullable=\"true\"> #{item} </foreach> </where> </select> The foreach element is very powerful, and allows you to specify a collection, declare item and index variables that can be used inside the body of the element. It also allows you to specify opening and closing strings, and add a separator to place in between iterations. The element is smart in that it won’t accidentally append extra separators. NOTE You can pass any Iterable object (for example List, Set, etc.), as well as any Map or Array object to foreach as collection parameter. When using an Iterable or Array, index will be the number of current iteration and value item will be the element retrieved in this iteration. When using a Map (or Collection of Map.Entry objects), index will be the key object and item will be the value object. This wraps up the discussion regarding the XML configuration file and XML mapping files. The next section will discuss the Java API in detail, so that you can get the most out of the mappings that you’ve created.\n\nStarting from version 3.2 MyBatis supports pluggable scripting languages, so you can plug a language driver and use that language to write your dynamic SQL queries. You can plug a language by implementing the following interface: Once you have your custom language driver you can set it to be the default by configuring it in the mybatis-config.xml file: Instead of changing the default, you can specify the language for an specific statement by adding the attribute as follows: Or, in the case you are using mappers, using the annotation: NOTE You can use Apache Velocity as your dynamic language. Have a look at the MyBatis-Velocity project for the details. All the xml tags you have seen in the previous sections are provided by the default MyBatis language that is provided by the driver which is aliased as ."
    },
    {
        "link": "https://stackoverflow.com/questions/7491291/how-can-i-use-like-in-sql-queries-with-mybatis-safely-and-db-agnostic",
        "document": "In MyBatis, you mark the places where parameters should be inserted into your SQL like so:\n\nThis syntax activates proper escaping etc to avoid, among other things, SQL injection attacks. If you have trusted input and want to skip escaping, you can insert the parameters verbatim:\n\nNow, I want to do a LIKE search on unsafe input, so what I want to do is this:\n\nUnfortunately, however, important DB servers don't support the syntax for concatenation:\n\nMSSQL - Breaks the standard by using the '+' operator instead of '||'. MySQL - Badly breaks the standard by redefining || to mean OR.\n\nSo, I could do either\n\nand be confined to, in this case, MySQL, or I could do\n\nand would have to sanitize input myself.\n\nIs there a more elegant solution?"
    },
    {
        "link": "https://mybatis.org/mybatis-3/configuration.html",
        "document": "The MyBatis configuration contains settings and properties that have a dramatic effect on how MyBatis behaves. The high level structure of the document is as follows:\n\nThese are externalizable, substitutable properties that can be configured in a typical Java Properties file instance, or passed in through sub-elements of the properties element. For example: The properties can then be used throughout the configuration files to substitute values that need to be dynamically configured. For example: The username and password in this example will be replaced by the values set in the properties elements. The driver and url properties would be replaced with values contained from the config.properties file. This provides a lot of options for configuration. Properties can also be passed into the SqlSessionFactoryBuilder.build() methods. For example: If a property exists in more than one of these places, MyBatis loads them in the following order:\n• Properties specified in the body of the properties element are read first,\n• Properties loaded from the classpath resource or url attributes of the properties element are read second, and override any duplicate properties already specified,\n• Properties passed as a method parameter are read last, and override any duplicate properties that may have been loaded from the properties body and the resource/url attributes. Thus, the highest priority properties are those passed in as a method parameter, followed by resource/url attributes and finally the properties specified in the body of the properties element. Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow: <dataSource type=\"POOLED\"> <!-- ... --> <property name=\"username\" value=\"${username:ut_user}\"/> <!-- If 'username' property not present, username become 'ut_user' --> </dataSource> This feature is disabled by default. If you specify a default value into placeholder, you should enable this feature by adding a special property as follow: NOTE This will conflict with the character in property keys (e.g. ) or the ternary operator of OGNL expressions (e.g. ) on a SQL definition. If you use either and want default property values, you must change the default value separator by adding this special property: <properties resource=\"org/mybatis/example/config.properties\"> <!-- ... --> <property name=\"org.apache.ibatis.parsing.PropertyParser.default-value-separator\" value=\"?:\"/> <!-- Change default value of separator --> </properties>\n\nThese are extremely important tweaks that modify the way that MyBatis behaves at runtime. The following table describes the settings, their meanings and their default values. Globally enables or disables any caches configured in any mapper under this configuration. Globally enables or disables lazy loading. When enabled, all relations will be lazily loaded. This value can be superseded for a specific relation by using the attribute on it. When enabled, any method call will load all the lazy properties of the object. Otherwise, each property is loaded on demand (see also ). Deprecated. This option has no effect. Uses the column label instead of the column name. Different drivers behave differently in this respect. Refer to the driver documentation, or test out both modes to determine how your driver behaves. Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work (e.g. Derby). Specifies if and how MyBatis should automatically map columns to fields/properties. NONE disables auto-mapping. PARTIAL will only auto-map results with no nested result mappings defined inside. FULL will auto-map result mappings of any complexity (containing nested or otherwise). Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target.\n• : Output warning log (The log level of must be set to ) Note that there could be false-positives when is set to . Configures the default executor. SIMPLE executor does nothing special. REUSE executor reuses prepared statements. BATCH executor reuses statements and batches updates. Sets the number of seconds the driver will wait for a response from the database. Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting. Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2) Allows using RowBounds on nested statements. If allow, set the false. Allows using ResultHandler on nested statements. If allow, set the false. MyBatis uses local cache to prevent circular references and speed up repeated nested queries. By default (SESSION) all queries executed during a session are cached. If localCacheScope=STATEMENT local session will be used just for statement execution, no data will be shared between two different calls to the same SqlSession. Specifies the JDBC type for null values when no specific JDBC type was provided for the parameter. Some drivers require specifying the column JDBC type but others work with generic values like NULL, VARCHAR or OTHER. JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER Specifies the language used by default for dynamic SQL generation. Specifies the used by default for Enum. (Since: 3.4.5) Specifies if setters or map's put method will be called when a retrieved value is null. It is useful when you rely on Map.keySet() or null value initialization. Note primitives such as (int,boolean,etc.) will not be set to null. MyBatis, by default, returns when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collection and association). Since: 3.4.2 Specifies the prefix string that MyBatis will add to the logger names. Specifies which logging implementation MyBatis should use. If this setting is not present logging implementation will be autodiscovered. Specifies the proxy tool that MyBatis will use for creating lazy loading capable objects. Allow referencing statement parameters by their actual names declared in the method signature. To use this feature, your project must be compiled in Java 8 with option. (Since: 3.4.1) Specifies the class that provides an instance of . The returned Configuration instance is used to load lazy properties of deserialized objects. This class must have a method with a signature . (Since: 3.2.3) Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5) Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the (or ) attribute on sql provider annotation(e.g. ), when these attribute was omitted. Specifies the default value of ‘nullable’ attribute on ‘foreach’ tag. (Since 3.5.9) When applying constructor auto-mapping, argument name is used to search the column to map instead of relying on the column order. (Since 3.5.10) An example of the settings element fully configured is as follows:\n\nA type alias is simply a shorter name for a Java type. It's only relevant to the XML configuration and simply exists to reduce redundant typing of fully qualified classnames. For example: With this configuration, can now be used anywhere that could be. You can also specify a package where MyBatis will search for beans. For example: Each bean found in , if no annotation is found, will be registered as an alias using uncapitalized non-qualified class name of the bean. That is will be registered as . If the annotation is found its value will be used as an alias. See the example below: There are many built-in type aliases for common Java types. They are all case insensitive, note the special handling of primitives due to the overloaded names.\n\nWhenever MyBatis sets a parameter on a PreparedStatement or retrieves a value from a ResultSet, a TypeHandler is used to retrieve the value in a means appropriate to the Java type. The following table describes the default TypeHandlers. NOTE Since version 3.4.5, MyBatis supports JSR-310 (Date and Time API) by default. any string compatible type, as the code is stored (not index). Any compatible or , as the position is stored (not the code itself). You can override the type handlers or create your own to deal with unsupported or non-standard types. To do so, implement the interface or extend the convenience class and optionally map it to a JDBC type. For example: Using such a TypeHandler would override the existing type handler for Java String properties and VARCHAR parameters and results. Note that MyBatis does not introspect upon the database metadata to determine the type, so you must specify that it’s a VARCHAR field in the parameter and result mappings to hook in the correct type handler. This is due to the fact that MyBatis is unaware of the data type until the statement is executed. MyBatis will know the Java type that you want to handle with this TypeHandler by introspecting its generic type, but you can override this behavior by two means:\n• Adding a attribute to the typeHandler element (for example: )\n• Adding a annotation to your TypeHandler class specifying the list of java types to associate it with. This annotation will be ignored if the attribute as also been specified. The associated JDBC type can be specified by two means:\n• Adding a attribute to the typeHandler element (for example: ).\n• Adding a annotation to your TypeHandler class specifying the list of JDBC types to associate it with. This annotation will be ignored if the attribute as also been specified. When deciding which TypeHandler to use in a , the Java type is known (from the result type), but the JDBC type is unknown. MyBatis therefore uses the combination to choose a TypeHandler. This means that using a annotation restricts the scope of a TypeHandler and makes it unavailable for use in s unless explicitly set. To make a TypeHandler available for use in a , set on the annotation. Since Mybatis 3.4.0 however, if a single TypeHandler is registered to handle a Java type, it will be used by default in s using this Java type (i.e. even without ). And finally you can let MyBatis search for your TypeHandlers: Note that when using the autodiscovery feature JDBC types can only be specified with annotations. You can create a generic TypeHandler that is able to handle more than one class. For that purpose add a constructor that receives the class as a parameter and MyBatis will pass the actual class when constructing the TypeHandler. //GenericTypeHandler.java public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> { private Class<E> type; public GenericTypeHandler(Class<E> type) { if (type == null) throw new IllegalArgumentException(\"Type argument cannot be null\"); this.type = type; } ... and are generic TypeHandlers. We will learn about them in the following section.\n\nIf you want to map an , you'll need to use either or . For example, let's say that we need to store the rounding mode that should be used with some number if it needs to be rounded. By default, MyBatis uses to convert the values to their names. Note is special in the sense that unlike other handlers, it does not handle just one specific class, but any class that extends However, we may not want to store names. Our DBA may insist on an integer code instead. That's just as easy: add to the in your config file, and now each will be mapped to an integer using its ordinal value. But what if you want to map the same to a string in one place and to integer in another? The auto-mapper will automatically use , so if we want to go back to using plain old ordinary , we have to tell it, by explicitly setting the type handler to use for those SQL statements. <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"> <mapper namespace=\"org.apache.ibatis.submitted.rounding.Mapper\"> <resultMap type=\"org.apache.ibatis.submitted.rounding.User\" id=\"usermap\"> <id column=\"id\" property=\"id\"/> <result column=\"name\" property=\"name\"/> <result column=\"funkyNumber\" property=\"funkyNumber\"/> <result column=\"roundingMode\" property=\"roundingMode\"/> </resultMap> <select id=\"getUser\" resultMap=\"usermap\"> select * from users </select> <insert id=\"insert\"> insert into users (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode} ) </insert> <resultMap type=\"org.apache.ibatis.submitted.rounding.User\" id=\"usermap2\"> <id column=\"id\" property=\"id\"/> <result column=\"name\" property=\"name\"/> <result column=\"funkyNumber\" property=\"funkyNumber\"/> <result column=\"roundingMode\" property=\"roundingMode\" typeHandler=\"org.apache.ibatis.type.EnumTypeHandler\"/> </resultMap> <select id=\"getUser2\" resultMap=\"usermap2\"> select * from users2 </select> <insert id=\"insert2\"> insert into users2 (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler} ) </insert> </mapper> Note that this forces us to use a instead of a in our select statements.\n\nMyBatis allows you to intercept calls to at certain points within the execution of a mapped statement. By default, MyBatis allows plug-ins to intercept method calls of: The details of these classes methods can be discovered by looking at the full method signature of each, and the source code which is available with each MyBatis release. You should understand the behaviour of the method you’re overriding, assuming you’re doing something more than just monitoring calls. If you attempt to modify or override the behaviour of a given method, you’re likely to break the core of MyBatis. These are low level classes and methods, so use plug-ins with caution. Using plug-ins is pretty simple given the power they provide. Simply implement the Interceptor interface, being sure to specify the signatures you want to intercept. // ExamplePlugin.java @Intercepts({@Signature( type= Executor.class, method = \"update\", args = {MappedStatement.class,Object.class})}) public class ExamplePlugin implements Interceptor { private Properties properties = new Properties(); @Override public Object intercept(Invocation invocation) throws Throwable { // implement pre-processing if needed Object returnObject = invocation.proceed(); // implement post-processing if needed return returnObject; } @Override public void setProperties(Properties properties) { this.properties = properties; } } The plug-in above will intercept all calls to the “update” method on the Executor instance, which is an internal object responsible for the low-level execution of mapped statements. In addition to modifying core MyBatis behaviour with plugins, you can also override the class entirely. Simply extend it and override any methods inside, and pass it into the call to the method. Again though, this could have a severe impact on the behaviour of MyBatis, so use caution.\n\nMyBatis can be configured with multiple environments. This helps you to apply your SQL Maps to multiple databases for any number of reasons. For example, you might have a different configuration for your Development, Test and Production environments. Or, you may have multiple production databases that share the same schema, and you’d like to use the same SQL maps for both. There are many use cases. One important thing to remember though: While you can configure multiple environments, you can only choose ONE per SqlSessionFactory instance. So if you want to connect to two databases, you need to create two instances of SqlSessionFactory, one for each. For three databases, you’d need three instances, and so on. It’s really easy to remember: To specify which environment to build, you simply pass it to the SqlSessionFactoryBuilder as an optional parameter. The two signatures that accept the environment are: If the environment is omitted, then the default environment is loaded, as follows: The environments element defines how the environment is configured.\n• The Environment ID for each environment defined (e.g. id=“development”). The default environment and the environment IDs are self explanatory. Name them whatever you like, just make sure the default matches one of them. There are two TransactionManager types (i.e. type=“[JDBC|MANAGED]”) that are included with MyBatis:\n• JDBC – This configuration simply makes use of the JDBC commit and rollback facilities directly. It relies on the connection retrieved from the dataSource to manage the scope of the transaction. By default, it enables auto-commit when closing the connection for compatibility with some drivers. However, for some drivers, enabling auto-commit is not only unnecessary, but also is an expensive operation. So, since version 3.5.10, you can skip this step by setting the “skipSetAutoCommitOnClose” property to true. For example:\n• MANAGED – This configuration simply does almost nothing. It never commits, or rolls back a connection. Instead, it lets the container manage the full lifecycle of the transaction (e.g. a JEE Application Server context). By default it does close the connection. However, some containers don’t expect this, and thus if you need to stop it from closing the connection, set the “closeConnection” property to false. For example: NOTE If you are planning to use MyBatis with Spring there is no need to configure any TransactionManager because the Spring module will set its own one overriding any previously set configuration. Neither of these TransactionManager types require any properties. However, they are both Type Aliases, so in other words, instead of using them, you could put your own fully qualified class name or Type Alias that refers to your own implementation of the TransactionFactory interface. Any properties configured in the XML will be passed to the setProperties() method after instantiation. Your implementation would also need to create a Transaction implementation, which is also a very simple interface: Using these two interfaces, you can completely customize how MyBatis deals with Transactions. The dataSource element configures the source of JDBC Connection objects using the standard JDBC DataSource interface. Most MyBatis applications will configure a dataSource as in the example. However, it’s not required. Realize though, that to facilitate Lazy Loading, this dataSource is required. There are three built-in dataSource types (i.e. type=“[UNPOOLED|POOLED|JNDI]”): UNPOOLED – This implementation of DataSource simply opens and closes a connection each time it is requested. While it’s a bit slower, this is a good choice for simple applications that do not require the performance of immediately available connections. Different databases are also different in this performance area, so for some it may be less important to pool and this configuration will be ideal. The UNPOOLED DataSource has the following properties to configure:\n• – This is the fully qualified Java class of the JDBC driver (NOT of the DataSource class if your driver includes one).\n• – This is the JDBC URL for your database instance.\n• – The database username to log in with.\n• - The database password to log in with.\n• – The default network timeout value in milliseconds to wait for the database operation to complete. See the API documentation of for details. Optionally, you can pass properties to the database driver as well. To do this, prefix the properties with , for example: This will pass the property , with the value , to your database driver via the method. POOLED – This implementation of DataSource pools JDBC Connection objects to avoid the initial connection and authentication time required to create a new Connection instance. This is a popular approach for concurrent web applications to achieve the fastest response. In addition to the (UNPOOLED) properties above, there are many more properties that can be used to configure the POOLED datasource:\n• – This is the number of active (i.e. in use) connections that can exist at any given time. Default: 10\n• – The number of idle connections that can exist at any given time.\n• – This is the amount of time that a Connection can be “checked out” of the pool before it will be forcefully returned. Default: 20000ms (i.e. 20 seconds)\n• – This is a low level setting that gives the pool a chance to print a log status and re-attempt the acquisition of a connection in the case that it’s taking unusually long (to avoid failing silently forever if the pool is misconfigured). Default: 20000ms (i.e. 20 seconds)\n• – This is a low level setting about tolerance of bad connections got for any thread. If a thread got a bad connection, it may still have another chance to re-attempt to get another connection which is valid. But the retrying times should not more than the sum of and . Default: 3 (Since: 3.4.5)\n• – The Ping Query is sent to the database to validate that a connection is in good working order and is ready to accept requests. The default is “NO PING QUERY SET”, which will cause most database drivers to fail with a decent error message.\n• – This enables or disables the ping query. If enabled, you must also set the poolPingQuery property with a valid SQL statement (preferably a very fast one). Default: false.\n• – This configures how often the poolPingQuery will be used. This can be set to match the typical timeout for a database connection, to avoid unnecessary pings. Default: 0 (i.e. all connections are pinged every time – but only if poolPingEnabled is true of course). JNDI – This implementation of DataSource is intended for use with containers such as EJB or Application Servers that may configure the DataSource centrally or externally and place a reference to it in a JNDI context. This DataSource configuration only requires two properties:\n• – This property is used for the Context lookup from the InitialContext (i.e. initialContext.lookup(initial_context)). This property is optional, and if omitted, then the data_source property will be looked up against the InitialContext directly.\n• – This is the context path where the reference to the instance of the DataSource can be found. It will be looked up against the context returned by the initial_context lookup, or against the InitialContext directly if no initial_context is supplied. Similar to the other DataSource configurations, it’s possible to send properties directly to the InitialContext by prefixing those properties with , for example: This would send the property with the value of to the constructor of the InitialContext upon instantiation. You can plug any 3rd party DataSource by implementing the interface : can be used as super class to build new datasource adapters. For example this is the code needed to plug C3P0: To set it up, add a property for each setter method you want MyBatis to call. Follows below a sample configuration which connects to a PostgreSQL database:\n\nMyBatis is able to execute different statements depending on your database vendor. The multi-db vendor support is based on the mapped statements attribute. MyBatis will load all statements with no attribute or with a that matches the current one. In case the same statement is found with and without the the latter will be discarded. To enable the multi vendor support add a to mybatis-config.xml file as follows: The DB_VENDOR implementation databaseIdProvider sets as databaseId the String returned by . Given that usually that string is too long and that different versions of the same product may return different values, you may want to convert it to a shorter one by adding properties like follows: When properties are provided, the DB_VENDOR databaseIdProvider will search the property value corresponding to the first key found in the returned database product name or “null” if there is not a matching property. In this case, if returns “Oracle (DataDirect)” the databaseId will be set to “oracle”. You can build your own DatabaseIdProvider by implementing the interface and registering it in mybatis-config.xml:"
    },
    {
        "link": "https://stackoverflow.com/questions/3428742/how-to-use-annotations-with-ibatis-mybatis-for-an-in-query",
        "document": "We'd like to use only annotations with MyBatis; we're really trying to avoid xml. We're trying to use an \"IN\" clause:\n\nMyBatis doesn't seem able to pick out the array of ints and put those into the resulting query. It seems to \"fail softly\" and we get no results back.\n\nIt looks like we could accomplish this using XML mappings, but we'd really like to avoid that. Is there a correct annotation syntax for this?"
    },
    {
        "link": "https://mybatis.org/mybatis-3/java-api.html",
        "document": "Now that you know how to configure MyBatis and create mappings, you're ready for the good stuff. The MyBatis Java API is where you get to reap the rewards of your efforts. As you'll see, compared to JDBC, MyBatis greatly simplifies your code and keeps it clean, easy to understand and maintain. MyBatis 3 has introduced a number of significant improvements to make working with SQL Maps even better.\n\nThe rest of the examples in this section will assume you're following this directory structure.\n\nRemember, these are preferences, not requirements, but others will thank you for using a common directory structure.\n\nBefore we dive in to the Java API itself, it's important to understand the best practices surrounding directory structures. MyBatis is very flexible, and you can do almost anything with your files. But as with any framework, there's a preferred way.\n\nThe primary Java interface for working with MyBatis is the SqlSession. Through this interface you can execute commands, get mappers and manage transactions. We'll talk more about SqlSession itself shortly, but first we have to learn how to acquire an instance of SqlSession. SqlSessions are created by a SqlSessionFactory instance. The SqlSessionFactory contains methods for creating instances of SqlSessions all different ways. The SqlSessionFactory itself is created by the SqlSessionFactoryBuilder that can create the SqlSessionFactory from XML, annotations or hand coded Java configuration.\n\nNOTE When using MyBatis with a dependency injection framework like Spring or Guice, SqlSessions are created and injected by the DI framework so you don't need to use the SqlSessionFactoryBuilder or SqlSessionFactory and can go directly to the SqlSession section. Please refer to the MyBatis-Spring or MyBatis-Guice manuals for further info.\n\nThe SqlSessionFactoryBuilder has five build() methods, each which allows you to build a SqlSessionFactory from a different source. The first four methods are the most common, as they take an InputStream instance that refers to an XML document, or more specifically, the mybatis-config.xml file discussed above. The optional parameters are environment and properties. Environment determines which environment to load, including the datasource and transaction manager. For example: If you call a build method that takes the environment parameter, then MyBatis will use the configuration for that environment. Of course, if you specify an invalid environment, you will receive an error. If you call one of the build methods that does not take the environment parameter, then the default environment is used (which is specified as default=“development” in the example above). If you call a method that takes a properties instance, then MyBatis will load those properties and make them available to your configuration. Those properties can be used in place of most values in the configuration using the syntax: ${propName} Recall that properties can also be referenced from the mybatis-config.xml file, or specified directly within it. Therefore it's important to understand the priority. We mentioned it earlier in this document, but here it is again for easy reference: If a property exists in more than one of these places, MyBatis loads them in the following order.\n• Properties specified in the body of the properties element are read first,\n• Properties loaded from the classpath resource or url attributes of the properties element are read second, and override any duplicate properties already specified,\n• Properties passed as a method parameter are read last, and override any duplicate properties that may have been loaded from the properties body and the resource/url attributes. Thus, the highest priority properties are those passed in as a method parameter, followed by resource/url attributes and finally the properties specified in the body of the properties element. So to summarize, the first four methods are largely the same, but with overrides to allow you to optionally specify the environment and/or properties. Here is an example of building a SqlSessionFactory from an mybatis-config.xml file. Notice that we're making use of the Resources utility class, which lives in the org.apache.ibatis.io package. The Resources class, as its name implies, helps you load resources from the classpath, filesystem or even a web URL. A quick look at the class source code or inspection through your IDE will reveal its fairly obvious set of useful methods. Here's a quick list: The final build method takes an instance of Configuration. The Configuration class contains everything you could possibly need to know about a SqlSessionFactory instance. The Configuration class is useful for introspecting on the configuration, including finding and manipulating SQL maps (not recommended once the application is accepting requests). The configuration class has every configuration switch that you've learned about already, only exposed as a Java API. Here's a simple example of how to manually a Configuration instance and pass it to the build() method to create a SqlSessionFactory. DataSource dataSource = BaseDataTest.createBlogDataSource(); TransactionFactory transactionFactory = new JdbcTransactionFactory(); Environment environment = new Environment(\"development\", transactionFactory, dataSource); Configuration configuration = new Configuration(environment); configuration.setLazyLoadingEnabled(true); configuration.setEnhancementEnabled(true); configuration.getTypeAliasRegistry().registerAlias(Blog.class); configuration.getTypeAliasRegistry().registerAlias(Post.class); configuration.getTypeAliasRegistry().registerAlias(Author.class); configuration.addMapper(BoundBlogMapper.class); configuration.addMapper(BoundAuthorMapper.class); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(configuration); Now you have a SqlSessionFactory that can be used to create SqlSession instances.\n\nSqlSessionFactory has six methods that are used to create SqlSession instances. In general, the decisions you'll be making when selecting one of these methods are:\n• Transaction: Do you want to use a transaction scope for the session, or use auto-commit (usually means no transaction with most databases and/or JDBC drivers)?\n• Connection: Do you want MyBatis to acquire a Connection from the configured DataSource for you, or do you want to provide your own?\n• Execution: Do you want MyBatis to reuse PreparedStatements and/or batch updates (including inserts and deletes)? The set of overloaded openSession() method signatures allow you to choose any combination of these options that makes sense. The default openSession() method that takes no parameters will create a SqlSession with the following characteristics:\n• A object will be acquired from the DataSource instance configured by the active environment.\n• The transaction isolation level will be the default used by the driver or data source.\n• No PreparedStatements will be reused, and no updates will be batched. Most of the methods are pretty self explanatory. To enable auto-commit, pass a value of to the optional parameter. To provide your own connection, pass an instance of to the parameter. Note that there's no override to set both the and , because MyBatis will use whatever setting the provided connection object is currently using. MyBatis uses a Java enumeration wrapper for transaction isolation levels, called , but otherwise they work as expected and have the 5 levels supported by JDBC ( , , , , ). The one parameter that might be new to you is . This enumeration defines 3 values:\n• : This type of executor does nothing special. It creates a new PreparedStatement for each execution of a statement.\n• : This type of executor will reuse PreparedStatements.\n• : This executor will batch all update statements and demarcate them as necessary if SELECTs are executed between them, to ensure an easy-to-understand behavior. NOTE There's one more method on the SqlSessionFactory that we didn't mention, and that is getConfiguration(). This method will return an instance of Configuration that you can use to introspect upon the MyBatis configuration at runtime. NOTE If you've used a previous version of MyBatis, you'll recall that sessions, transactions and batches were all something separate. This is no longer the case. All three are neatly contained within the scope of a session. You need not deal with transactions or batches separately to get the full benefit of them.\n\nAs mentioned above, the SqlSession instance is the most powerful class in MyBatis. It is where you'll find all of the methods to execute statements, commit or rollback transactions and acquire mapper instances. There are over twenty methods on the SqlSession class, so let's break them up into more digestible groupings. These methods are used to execute SELECT, INSERT, UPDATE and DELETE statements that are defined in your SQL Mapping XML files. They are pretty self explanatory, each takes the ID of the statement and the Parameter Object, which can be a primitive (auto-boxed or wrapper), a JavaBean, a POJO or a Map. The difference between and is only in that must return exactly one object or (none). If any more than one, an exception will be thrown. If you don't know how many objects are expected, use . If you want to check for the existence of an object, you're better off returning a count (0 or 1). The is a special case in that it is designed to convert a list of results into a based on one of the properties in the resulting objects. Because not all statements require a parameter, these methods are overloaded with versions that do not require the parameter object. The value returned by the , and methods indicate the number of rows affected by the statement. A offers the same results as a List, except it fetches data lazily using an . try (Cursor<MyEntity> entities = session.selectCursor(statement, param)) { for (MyEntity entity : entities) { // process one entity } } Finally, there are three advanced versions of the methods that allow you to restrict the range of rows to return, or provide custom result handling logic, usually for very large data sets. The parameter causes MyBatis to skip the number of records specified, as well as limit the number of results returned to some number. The class has a constructor to take both the and , and is otherwise immutable. Different drivers are able to achieve different levels of efficiency in this regard. For the best performance, use result set types of or (in other words: not ). The parameter allows you to handle each row however you like. You can add it to a , create a , , or throw each result away and instead keep only rolled up totals of calculations. You can do pretty much anything with the , and it's what MyBatis uses internally itself to build result set lists. Since 3.4.6, passed to a statement is used on every output parameter of the stored procedure if there is any. The interface is very simple. The parameter gives you access to the result object itself, a count of the number of result objects created, and a method that you can use to stop MyBatis from loading any more results. Using a has two limitations that you should be aware of:\n• Data gotten from a method called with a will not be cached.\n• When using advanced s MyBatis will probably require several rows to build an object. If a is used you may be given an object whose associations or collections are not yet filled. There is method for flushing (executing) batch update statements that are stored in a JDBC driver class at any time. This method can be used when the is . There are four methods for controlling the scope of a transaction. Of course, these have no effect if you've chosen to use auto-commit or if you're using an external transaction manager. However, if you're using the JDBC transaction manager, managed by the instance, then the four methods that will come in handy are: By default MyBatis does not actually commit unless it detects that the database has been changed by a call to , , or with enabled. If you've somehow made changes without calling these methods, then you can pass into the and methods to guarantee that they will be committed (note, you still can't force a session in auto-commit mode, or one that is using an external transaction manager). Most of the time you won't have to call , as MyBatis will do that for you if you don't call commit. However, if you need more fine-grained control over a session where multiple commits and rollbacks are possible, you have the rollback option there to make that possible. NOTE MyBatis-Spring and MyBatis-Guice provide declarative transaction handling. So if you are using MyBatis with Spring or Guice please refer to their specific manuals. MyBatis uses two caches: a local cache and a second level cache. Each time a new session is created MyBatis creates a local cache and attaches it to the session. Any query executed within the session will be stored in the local cache so further executions of the same query with the same input parameters will not hit the database. The local cache is cleared upon , , and . By default local cache data is used for the whole session duration. This cache is needed to resolve circular references and to speed up repeated nested queries, so it can never be completely disabled but you can configure the local cache to be used just for the duration of a statement execution by setting . Note that when the is set to , MyBatis returns references to the same objects which are stored in the local cache. Any modification of the returned objects (lists etc.) influences the local cache contents and subsequently the values which are returned from the cache in the lifetime of the session. Therefore, as best practice, do not to modify the objects returned by MyBatis. You can clear the local cache at any time by calling: The most important thing you must ensure is to close any session that you open. The best way to ensure this is to use the following unit of work pattern: try (SqlSession session = sqlSessionFactory.openSession()) { // following 3 lines are pseudocode for \"doing some work\" session.insert(...); session.update(...); session.delete(...); session.commit(); } NOTE Just like , you can get the instance of that the is using by calling the method. While the various , , and methods above are powerful, they are also very verbose, not type safe and not as helpful to your IDE or unit tests as they could be. We've already seen an example of using s in the Getting Started section above. Therefore, a more common way to execute mapped statements is to use classes. A class is simply an interface with method definitions that match up against the methods. The following example class demonstrates some method signatures and how they map to the . In a nutshell, each method signature should match that of the method that it's associated to, but without the parameter ID. Instead, the method name must match the mapped statement ID. In addition, the return type must match that of the expected result type for single results or an array or collection for multiple results or . All of the usual types are supported, including: Primitives, , POJOs and . NOTE Mapper interfaces do not need to implement any interface or extend any class. As long as the method signature can be used to uniquely identify a corresponding mapped statement. NOTE Mapper interfaces can extend other interfaces. Be sure that you have the statements in the appropriate namespace when using XML binding to interfaces. Also, the only limitation is that you cannot have the same method signature in two interfaces in a hierarchy (a bad idea anyway). You can pass multiple parameters to a mapper method. If you do, they will be named by the literal “param” followed by their position in the parameter list by default, for example: , etc. If you wish to change the name of the parameters (multiple only), then you can use the annotation on the parameter. You can also pass a instance to the method to limit query results. Since the very beginning, MyBatis has been an XML driven framework. The configuration is XML based, and the Mapped Statements are defined in XML. With MyBatis 3, there are new options available. MyBatis 3 builds on top of a comprehensive and powerful Java based Configuration API. This Configuration API is the foundation for the XML based MyBatis configuration, as well as the new annotation-based configuration. Annotations offer a simple way to implement simple mapped statements without introducing a lot of overhead. NOTE Java annotations are unfortunately limited in their expressiveness and flexibility. Despite a lot of time spent in investigation, design and trials, the most powerful MyBatis mappings simply cannot be built with annotations – without getting ridiculous that is. C# Attributes (for example) do not suffer from these limitations, and thus MyBatis.NET will enjoy a much richer alternative to XML. That said, the Java annotation-based configuration is not without its benefits. The annotations are as follows: Configures the cache for the given namespace (i.e. class). Attributes: , , , , , , . Specifies the property value or placeholder(can replace by configuration properties that defined at the ). Attributes: , . (Available on MyBatis 3.4.2+) References the cache of another namespace to use. Note that caches declared in an XML mapper file are considered a separate namespace, even if they share the same FQCN. Attributes: and . If you use this annotation, you should be specified either or attribute. For the attribute specify a java type indicating the namespace(the namespace name become a FQCN of specified java type), and for the attribute(this attribute is available since 3.4.2) specify a name indicating the namespace. Collects a group of results to be passed to a result object constructor. Attributes: , which is an array of s. A single constructor argument that is part of a ConstructorArgs collection. Attributes: , , , , , , . The id attribute is a boolean value that identifies the property to be used for comparisons, similar to the XML element. Since 3.5.4, it can be used as repeatable annotation. A group of value cases that can be used to determine the result mapping to perform. Attributes: , , , , . The cases attribute is an array of s. A single case of a value and its corresponding mappings. Attributes: , , . The results attribute is an array of Results, thus this Annotation is similar to an actual , specified by the annotation below. A list of Result mappings that contain details of how a particular result column is mapped to a property or field. Attributes: , . The value attribute is an array of annotations. The id attribute is the name of the result mapping. A single result mapping between a column and a property or field. Attributes: , , , , , , , . The id attribute is a boolean value that indicates that the property should be used for comparisons (similar to in the XML mappings). The one attribute is for single associations, similar to , and the many attribute is for collections, similar to . They are named as they are to avoid class naming conflicts. Since 3.5.4, it can be used as repeatable annotation. A mapping to a single property value of a complex type. Attributes: , which is the fully qualified name of a mapped statement (i.e. mapper method) that can load an instance of the appropriate type. , which supersedes the global configuration parameter for this mapping. (available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result. (available since 3.5.5), which is column prefix for grouping select columns at nested result map. You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references. A mapping to a collection property of a complex type. Attributes: , which is the fully qualified name of a mapped statement (i.e. mapper method) that can load a collection of instances of the appropriate types. , which supersedes the global configuration parameter for this mapping. (available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result. (available since 3.5.5), which is column prefix for grouping select columns at nested result map. You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references. This is used on methods which return type is a Map. It is used to convert a List of result objects as a Map based on a property of those objects. Attributes: , which is a property used as the key of the map. This annotation provides access to the wide range of switches and configuration options that are normally present on the mapped statement as attributes. Rather than complicate each statement annotation, the annotation provides a consistent and clear way to access these. Attributes: , , , , , , , , , and . It's important to understand that with Java Annotations, there is no way to specify as a value. Therefore, once you engage the annotation, your statement is subject to all of the default values. Pay attention to what the default values are to avoid unexpected behavior. The (Available since 3.5.5), in case there is a configured , the MyBatis use the with no attribute or with a that matches the current one. If found with and without the the latter will be discarded.\n\n\n\nNote that is only required in certain databases (like Oracle and PostgreSQL). See the discussion about and above in the discussion of the insert statement for more information about allowable values in these attributes. Each of these annotations represents the actual SQL that is to be executed. They each take an array of strings (or a single string will do). If an array of strings is passed, they are concatenated with a single space between each to separate them. This helps avoid the “missing space” problem when building SQL in Java code. However, you're also welcome to concatenate together a single string if you like. Attributes: , which is the array of Strings to form the single SQL statement. The (Available since 3.5.5), in case there is a configured , the MyBatis use a statement with no attribute or with a that matches the current one. If found with and without the the latter will be discarded. Allows for creation of dynamic SQL. These alternative SQL annotations allow you to specify a class and a method name that will return the SQL to run at execution time (Since 3.4.6, you can specify the instead of as a method return type). Upon executing the mapped statement, MyBatis will instantiate the class, and execute the method, as specified by the provider. You can pass objects that passed to arguments of a mapper method, “Mapper interface type”, “Mapper method” and “Database ID” via the (available since MyBatis 3.4.5 or later) as method argument. (In MyBatis 3.4 or later, it's allow multiple parameters) Attributes: , , and . The and attribute is a class (The attribute is alias for , you must be specify either one. But both attributes can be omit when specify the as global configuration). The is the name of the method on that class (Since 3.5.1, you can omit attribute, the MyBatis will resolve a target method via the interface. If not resolve by it, the MyBatis use the reserved fallback method that named ). The (Available since 3.5.5), in case there is a configured , the MyBatis will use a provider method with no attribute or with a that matches the current one. If found with and without the the latter will be discarded. Following this section is a discussion about the class, which can help build dynamic SQL in a cleaner, easier to read way. If your mapper method takes multiple parameters, this annotation can be applied to a mapper method parameter to give each of them a name. Otherwise, multiple parameters will be named by their position prefixed with “param” (not including any parameters). For example , etc. is the default. With , the parameter would be named . This annotation duplicates the functionality for methods annotated with , , , or . It is ignored for other methods. If you specify a annotation, then MyBatis will ignore any generated key properties set via the annotation, or configuration properties. Attributes: an array of strings which is the SQL statement to execute, which is the property of the parameter object that will be updated with the new value, which must be either or to denote if the SQL statement should be executed before or after the insert, which is the Java type of the , and is a type of the statement that is any one of , or that is mapped to , and respectively. The default is . The (Available since 3.5.5), in case there is a configured , the MyBatis will use a statement with no attribute or with a that matches the current one. If found with and without the the latter will be discarded. This annotation is used to provide the id of a element in an XML mapper to a or annotation. This allows annotated selects to reuse resultmaps that are defined in XML. This annotation will override any or annotation if both are specified on an annotated select. This annotation is used when using a result handler. In that case, the return type is void so MyBatis must have a way to determine the type of object to construct for each row. If there is an XML result map, use the @ResultMap annotation. If the result type is specified in XML on the element, then no other annotation is necessary. In other cases, use this annotation. For example, if a @Select annotated method will use a result handler, the return type must be void and this annotation (or @ResultMap) is required. This annotation is ignored unless the method return type is void. If this annotation is used, it can be called the via method defined at a Mapper interface.(MyBatis 3.3 or above) This example shows using the @SelectKey annotation to retrieve a value from a sequence before an insert: @Insert(\"insert into table3 (id, name) values(#{nameId}, #{name})\") @SelectKey(statement=\"call next value for TestSequence\", keyProperty=\"nameId\", before=true, resultType=int.class) int insertTable3(Name name); This example shows using the @SelectKey annotation to retrieve an identity value after an insert: @Insert(\"insert into table2 (name) values(#{name})\") @SelectKey(statement=\"call identity()\", keyProperty=\"nameId\", before=false, resultType=int.class) int insertTable2(Name name); This example shows using the annotation to call the : These examples show how to name a ResultMap by specifying id attribute of @Results annotation. @Results(id = \"userResult\", value = { @Result(property = \"id\", column = \"uid\", id = true), @Result(property = \"firstName\", column = \"first_name\"), @Result(property = \"lastName\", column = \"last_name\") }) @Select(\"select * from users where id = #{id}\") User getUserById(Integer id); @Results(id = \"companyResults\") @ConstructorArgs({ @Arg(column = \"cid\", javaType = Integer.class, id = true), @Arg(column = \"name\", javaType = String.class) }) @Select(\"select * from company where id = #{id}\") Company getCompanyById(Integer id); This example shows solo parameter using the SelectProvider annotation: @SelectProvider(type = UserSqlBuilder.class, method = \"buildGetUsersByName\") List<User> getUsersByName(String name); class UserSqlBuilder { public static String buildGetUsersByName(final String name) { return new SQL(){{ SELECT(\"*\"); FROM(\"users\"); if (name != null) { WHERE(\"name like #{value} || '%'\"); } ORDER_BY(\"id\"); }}.toString(); } } This example shows multiple parameters using the Sql Provider annotation: @SelectProvider(type = UserSqlBuilder.class, method = \"buildGetUsersByName\") List<User> getUsersByName( @Param(\"name\") String name, @Param(\"orderByColumn\") String orderByColumn); class UserSqlBuilder { // If not use @Param, you should be define same arguments with mapper method public static String buildGetUsersByName( final String name, final String orderByColumn) { return new SQL(){{ SELECT(\"*\"); FROM(\"users\"); WHERE(\"name like #{name} || '%'\"); ORDER_BY(orderByColumn); }}.toString(); } // If use @Param, you can define only arguments to be used public static String buildGetUsersByName(@Param(\"orderByColumn\") final String orderByColumn) { return new SQL(){{ SELECT(\"*\"); FROM(\"users\"); WHERE(\"name like #{name} || '%'\"); ORDER_BY(orderByColumn); }}.toString(); } } This example shows usage that share an sql provider class to all mapper methods using global configuration(Available since 3.5.6): Configuration configuration = new Configuration(); configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // Specify an sql provider class for sharing on all mapper methods // ... // Can omit the type/value attribute on sql provider annotation // If omit it, the MyBatis apply the class that specified on defaultSqlProviderType. public interface UserMapper { @SelectProvider // Same with @SelectProvider(TemplateFilePathProvider.class) User findUser(int id); @InsertProvider // Same with @InsertProvider(TemplateFilePathProvider.class) void createUser(User user); @UpdateProvider // Same with @UpdateProvider(TemplateFilePathProvider.class) void updateUser(User user); @DeleteProvider // Same with @DeleteProvider(TemplateFilePathProvider.class) void deleteUser(int id); } This example shows usage the default implementation of (available since MyBatis 3.5.1 or later): @SelectProvider(UserSqlProvider.class) List<User> getUsersByName(String name); // Implements the ProviderMethodResolver on your provider class class UserSqlProvider implements ProviderMethodResolver { // In default implementation, it will resolve a method that method name is matched with mapper method public static String getUsersByName(final String name) { return new SQL(){{ SELECT(\"*\"); FROM(\"users\"); if (name != null) { WHERE(\"name like #{value} || '%'\"); } ORDER_BY(\"id\"); }}.toString(); } } This example shows usage the attribute on the statement annotation(Available since 3.5.5): @Select(value = \"SELECT SYS_GUID() FROM dual\", databaseId = \"oracle\") // Use this statement if DatabaseIdProvider provide \"oracle\" @Select(value = \"SELECT uuid_generate_v4()\", databaseId = \"postgres\") // Use this statement if DatabaseIdProvider provide \"postgres\" @Select(\"SELECT RANDOM_UUID()\") // Use this statement if the DatabaseIdProvider not configured or not matches databaseId String generateId();"
    },
    {
        "link": "https://stackoverflow.com/questions/7491291/how-can-i-use-like-in-sql-queries-with-mybatis-safely-and-db-agnostic",
        "document": "In MyBatis, you mark the places where parameters should be inserted into your SQL like so:\n\nThis syntax activates proper escaping etc to avoid, among other things, SQL injection attacks. If you have trusted input and want to skip escaping, you can insert the parameters verbatim:\n\nNow, I want to do a LIKE search on unsafe input, so what I want to do is this:\n\nUnfortunately, however, important DB servers don't support the syntax for concatenation:\n\nMSSQL - Breaks the standard by using the '+' operator instead of '||'. MySQL - Badly breaks the standard by redefining || to mean OR.\n\nSo, I could do either\n\nand be confined to, in this case, MySQL, or I could do\n\nand would have to sanitize input myself.\n\nIs there a more elegant solution?"
    },
    {
        "link": "https://stackoverflow.com/questions/56606291/i-encountered-some-difficulties-in-using-mybatis-and-the-problem-of-fuzzy-query",
        "document": "Thank you for checking my question.\n\nStatements in mybatis have no results when making fuzzy queries, while command line execution in the database can query the results\n\nWhen I replace the fields passed in by a fuzzy query with certain content, I can query and prove that mybatis supports passing parameters after the where condition."
    },
    {
        "link": "https://mybatis.org/mybatis-dynamic-sql/docs/complexQueries.html",
        "document": "Enhancements in version 1.1.2 make it easier to code complex queries. The Select DSL is implemented as a set of related objects. As the select statement is built, intermediate objects of various types are returned from the various methods that implement the DSL. The select statement can be completed by calling the method many of the intermediate objects. Prior to version 1.1.2, it was necessary to call on the last intermediate object. This restriction has been removed, and it is now possible to call on any intermediate object. This, along with several other enhancements, has simplified the coding of complex queries.\n\nFor example, suppose you want to code a complex search on a Person table. The search parameters are id, first name, and last name. The rules are:\n• If an id is entered, use the id and ignore the other search parameters\n• If an id is not entered, then do a fuzzy search based on the other parameters\n\nThis can be implemented with code like the following…\n• Note the use of the keyword here. If you are using an older version of Java, the actual type is\n• Here we are calling with no parameters. This sets up the builder to accept conditions further along in the code. If no conditions are added, then the where clause will not be rendered\n• This statement implements the rules of the search. If an ID is entered , use it. Otherwise, do a fuzzy search based on first name and last name.\n• The method on this line will mark the condition as unrenderable if the filter is not satisfied.\n• The statement on this line allows you to change the parameter value before it is placed in the parameter Map. In this case we are adding SQL wildcards to the start and end of the search String - but only if the search String is not null. If the search String is null, the lambda will not be called and the condition will not render\n• This line shows the use of a method reference instead of a lambda on the . Method references allow you to more clearly express intent. Note also the use of the function which is a built-in function that applies a non-null filter\n• It is a good idea to limit the number of rows returned from a search. The library now supports syntax for limiting rows\n• Note that we are calling the method from the intermediate object retrieved in step 1. It is no longer necessary to call on the last object returned from a select builder"
    },
    {
        "link": "https://topic.alibabacloud.com/a/various-fuzzy-queries-of-mybatis_8_8_31758089.html",
        "document": "I used it in my work. I want to write three statements. The fourth is case-insensitive query.\n\nSelect * From tablename where name like Concat ('%', # {text}), '% ');\n\nSelect * From tablename where name like '% $ {text} % ';\n\nSelect * From tablename where name like # {text };\n\nJava. Lang. illegalargumentexception:ModifyIs ambiguous in mapped statements collection (try using the full name including the namespace, or rename one of the entries)\n\n At org. Apache. ibatis. session. Configuration $ strictmap. Get (configuration. Java: 466)\n\n At org. Apache. ibatis. session. configuration. getmappedstatement (configuration. Java: 349)\n\n At org. Apache. ibatis. Binding. mappermethod. setupcommandtype (mappermethod. Java: 137)\n\n At org. Apache. ibatis. Binding. mappermethod. <init> (mappermethod. Java: 46)\n\n At org. Apache. ibatis. Binding. mapperproxy. Invoke (mapperproxy. Java: 34)\n\n At $ proxy10.modify (unknown source)\n\nThe cause of this exception may be that the <mapper> namespace attribute in the Mapper. xml configuration file is incorrectly configured, and the corresponding ing interface is not found based on the namespace value (full name class name.\n\nFor example: <mapper namespace = \"com. XXX. XXX. Mapper. tew.apper\">"
    },
    {
        "link": "https://labex.io/tutorials/java-mybatis-database-integration-project-300374",
        "document": "In this project, you will learn how to use MyBatis, a popular Java persistence framework, to interact with a MySQL database. Specifically, you will learn how to use input parameters in SQL queries and retrieve course information based on the teacher's name.\n\nIn this project, you will learn:\n• Implement the interface to define a method for retrieving courses based on the teacher's name\n• Write the SQL query in the file to perform a fuzzy search on the column and sort the results in descending order by course number\n• Test the implementation in the class to ensure the desired functionality\n\nAfter completing this project, you will be able to:\n• Use MyBatis to interact with a MySQL database\n• Perform a fuzzy search on a database column and sort the results\n• Test the functionality of a MyBatis mapper using a JUnit test case"
    }
]