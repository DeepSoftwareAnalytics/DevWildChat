[
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware?view=aspnetcore-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/blazor/security?view=aspnetcore-9.0",
        "document": "This article describes ASP.NET Core's support for the configuration and management of security in Blazor apps.\n\nBlazor uses the existing ASP.NET Core authentication mechanisms to establish the user's identity. The exact mechanism depends on how the Blazor app is hosted, server-side or client-side.\n\nSecurity scenarios differ between authorization code running server-side and client-side in Blazor apps. For authorization code that runs on the server, authorization checks are able to enforce access rules for areas of the app and components. Because client-side code execution can be tampered with, authorization code executing on the client can't be trusted to absolutely enforce access rules or control the display of client-side content.\n\nRazor Pages authorization conventions don't apply to routable Razor components. If a non-routable Razor component is embedded in a page of a Razor Pages app, the page's authorization conventions indirectly affect the Razor component along with the rest of the page's content.\n\nDon't store app secrets, connection strings, credentials, passwords, personal identification numbers (PINs), private .NET/C# code, or private keys/tokens in client-side code, which is always insecure. Client-side Blazor code should access secure services and databases through a secure web API that you control.\n\nIn test/staging and production environments, server-side Blazor code and web APIs should use secure authentication flows that avoid maintaining credentials within project code or configuration files. Outside of local development testing, we recommend avoiding the use of environment variables to store sensitive data, as environment variables aren't the most secure approach. For local development testing, the Secret Manager tool is recommended for securing sensitive data. For more information, see the following resources:\n\nFor client-side and server-side local development and testing, use the Secret Manager tool to secure sensitive credentials.\n\nFor Microsoft Azure services, we recommend using managed identities. Managed identities securely authenticate to Azure services without storing credentials in app code. For more information, see the following resources:\n• What are managed identities for Azure resources? (Microsoft Entra documentation)\n• Azure services documentation\n• How to use managed identities for App Service and Azure Functions\n\nServer-side Blazor apps are configured for security in the same manner as ASP.NET Core apps. For more information, see the articles under ASP.NET Core security topics.\n\nThe authentication context is only established when the app starts, which is when the app first connects to the WebSocket over a SignalR connection with the client. Authentication can be based on a cookie or some other bearer token, but authentication is managed via the SignalR hub and entirely within the circuit. The authentication context is maintained for the lifetime of the circuit. Apps periodically revalidate the user's authentication state every 30 minutes.\n\nIf the app must capture users for custom services or react to updates to the user, see ASP.NET Core server-side and Blazor Web App additional security scenarios.\n\nBlazor differs from a traditional server-rendered web apps that make new HTTP requests with cookies on every page navigation. Authentication is checked during navigation events. However, cookies aren't involved. Cookies are only sent when making an HTTP request to a server, which isn't what happens when the user navigates in a Blazor app. During navigation, the user's authentication state is checked within the Blazor circuit, which you can update at any time on the server using the abstraction.\n\nThe built-in or custom AuthenticationStateProvider service obtains authentication state data from ASP.NET Core's HttpContext.User. This is how authentication state integrates with existing ASP.NET Core authentication mechanisms.\n\nFor more information on server-side authentication, see ASP.NET Core Blazor authentication and authorization.\n\nServer-side Blazor apps live in server memory, and multiple app sessions are hosted within the same process. For each app session, Blazor starts a circuit with its own dependency injection container scope, thus scoped services are unique per Blazor session.\n\nYou can use stateful singleton services in Blazor apps if they're specifically designed for it. For example, use of a singleton memory cache is acceptable because a memory cache requires a key to access a given entry. Assuming users don't have control over the cache keys that are used with the cache, state stored in the cache doesn't leak across circuits.\n\nFor general guidance on state management, see ASP.NET Core Blazor state management.\n\nIn test/staging and production environments, server-side Blazor code and web APIs should use secure authentication flows that avoid maintaining credentials within project code or configuration files. Outside of local development testing, we recommend avoiding the use of environment variables to store sensitive data, as environment variables aren't the most secure approach. For local development testing, the Secret Manager tool is recommended for securing sensitive data. For more information, see the following resources:\n\nFor client-side and server-side local development and testing, use the Secret Manager tool to secure sensitive credentials.\n\nCreate a new server-side Blazor app by following the guidance in Tooling for ASP.NET Core Blazor.\n\nTo store additional claims from external providers, see Persist additional claims and tokens from external providers in ASP.NET Core.\n\nSpecify the issuer explicitly when deploying to Azure App Service on Linux with Identity Server. For more information, see Use Identity to secure a Web API backend for SPAs.\n\nDon't attempt to resolve AuthenticationStateProvider within a custom scope because it results in the creation of a new instance of the AuthenticationStateProvider that isn't correctly initialized.\n\nTo access the AuthenticationStateProvider within a service scoped to a component, inject the AuthenticationStateProvider into the component and pass it to the service as a parameter. This approach ensures that the correct, initialized instance of the AuthenticationStateProvider is used for each user app instance.\n\nRegister the service as scoped. In a server-side Blazor app, scoped services have a lifetime equal to the duration of the client connection circuit.\n\nIn the following component:\n• The AuthenticationStateProvider is injected and passed to .\n• is resolved with OwningComponentBase.ScopedServices and GetRequiredService, which returns the correct, initialized instance of that exists for the lifetime of the user's circuit.\n\nFor more information, see the guidance on OwningComponentBase in ASP.NET Core Blazor dependency injection.\n\nTo avoid showing unauthorized content, for example content in an component, while prerendering with a custom , adopt one of the following approaches:\n• None Implement IHostEnvironmentAuthenticationStateProvider for the custom AuthenticationStateProvider to support prerendering: For an example implementation of IHostEnvironmentAuthenticationStateProvider, see the Blazor framework's ServerAuthenticationStateProvider implementation in (reference source). Documentation links to .NET reference source usually load the repository's default branch, which represents the current development for the next release of .NET. To select a tag for a specific release, use the Switch branches or tags dropdown list. For more information, see How to select a version tag of ASP.NET Core source code (dotnet/AspNetCore.Docs #26205).\n• Authenticate the user on the server before the app starts: To adopt this approach, the app must respond to a user's initial request with the Identity-based sign-in page or view and prevent any requests to Blazor endpoints until they're authenticated. For more information, see Create an ASP.NET Core app with user data protected by authorization. After authentication, unauthorized content in prerendered Razor components is only shown when the user is truly unauthorized to view the content.\n\nIn spite of the word \"state\" in the name, AuthenticationStateProvider isn't for storing general user state. AuthenticationStateProvider only indicates the user's authentication state to the app, whether they are signed into the app and who they are signed in as.\n\nAuthentication uses the same ASP.NET Core Identity authentication as Razor Pages and MVC apps. The user state stored for ASP.NET Core Identity flows to Blazor without adding additional code to the app. Follow the guidance in the ASP.NET Core Identity articles and tutorials for the Identity features to take effect in the Blazor parts of the app.\n\nFor guidance on general state management outside of ASP.NET Core Identity, see ASP.NET Core Blazor state management.\n• None ServerAuthenticationStateProvider (reference source): An AuthenticationStateProvider used by the Blazor framework to obtain authentication state from the server.\n• None RevalidatingServerAuthenticationStateProvider (reference source): A base class for AuthenticationStateProvider services used by the Blazor framework to receive an authentication state from the host environment and revalidate it at regular intervals. The default 30 minute revalidation interval can be adjusted in ( ). The following example shortens the interval to 20 minutes:\n\nServer-side Blazor persists user authentication state for the lifetime of the circuit, including across browser tabs. To proactively sign off a user across browser tabs when the user signs out on one tab, you must implement a RevalidatingServerAuthenticationStateProvider (reference source) with a short RevalidationInterval.\n\nIn client-side Blazor apps, client-side authentication checks can be bypassed because all client-side code can be modified by users. The same is true for all client-side app technologies, including JavaScript SPA frameworks and native apps for any operating system.\n• For guidance on adding packages to .NET apps, see the articles under Install and manage packages at Package consumption workflow (NuGet documentation). Confirm correct package versions at NuGet.org.\n• None The Microsoft.AspNetCore.Components.Authorization namespace to the app's file.\n\nTo handle authentication, use the built-in or custom AuthenticationStateProvider service.\n\nFor more information on client-side authentication, see Secure ASP.NET Core Blazor WebAssembly.\n\nWhen a Blazor Web App adopts server-side rendering (SSR) and client-side rendering (CSR) for components or an entire app that specifies the Interactive Auto render mode, authorization to access components and data is applied in two places. The component restricts access to itself (and any data that it obtains) when rendered on the server by virtue of an authorization attribute in the component's definition file ( ). When the component is rendered on the client, access to data is restricted via the server web API endpoints that are called from the client. Care must be taken when securing data access in both locations to prevent improper data access. Consider the following scenario where secure weather data is displayed by a component. The following example can be examined and demonstrated in a running sample app with either the sample (.NET 9 or later) or the sample (.NET 8 or later) in the Blazor samples GitHub repository ( ) (how to download). public sealed class WeatherForecast(DateOnly date, int temperatureC, string summary) { public DateOnly Date { get; set; } = date; public int TemperatureC { get; set; } = temperatureC; public string? Summary { get; set; } = summary; public int TemperatureF => 32 + (int)(TemperatureC / 0.5556); } The client project's service implements . The method calls a web API in the server project at the endpoint for weather data:\n• Uses the Persistent Component State service (PersistentComponentState) to persist weather forecast data when the component transitions from static to interactive SSR on the server. @page \"/weather\" @using Microsoft.AspNetCore.Authorization @using BlazorWebAppEntra.Client.Weather @attribute [Authorize] @implements IDisposable @inject PersistentComponentState ApplicationState @inject IWeatherForecaster WeatherForecaster <PageTitle>Weather</PageTitle> <h1>Weather</h1> <p>This component demonstrates showing data.</p> @if (forecasts == null) { <p><em>Loading...</em></p> } else { <table class=\"table\"> <thead> <tr> <th>Date</th> <th aria-label=\"Temperature in Celsius\">Temp. (C)</th> <th aria-label=\"Temperature in Fahrenheit\">Temp. (F)</th> <th>Summary</th> </tr> </thead> <tbody> @foreach (var forecast in forecasts) { <tr> <td>@forecast.Date.ToShortDateString()</td> <td>@forecast.TemperatureC</td> <td>@forecast.TemperatureF</td> <td>@forecast.Summary</td> </tr> } </tbody> </table> } @code { private IEnumerable<WeatherForecast>? forecasts; private PersistingComponentStateSubscription persistingSubscription; protected override async Task OnInitializedAsync() { persistingSubscription = ApplicationState.RegisterOnPersisting(PersistData); if (!ApplicationState.TryTakeFromJson<IEnumerable<WeatherForecast>>( nameof(forecasts), out var restoredData)) { forecasts = await WeatherForecaster.GetWeatherForecastAsync(); } else { forecasts = restoredData!; } } private Task PersistData() { ApplicationState.PersistAsJson(nameof(forecasts), forecasts); return Task.CompletedTask; } void IDisposable.Dispose() => persistingSubscription.Dispose(); } The server project implements as , which generates and returns mock weather data via its method: Using the preceding approach, there are two systems in place to supply secure weather data to the user:\n• When the component is rendered on the server, the service's method is used directly to obtain the weather data. The security of the data is enforced by the component's attribute. In summary, the security of the weather data is enforced by the component.\n• When the component is rendered on the client, the service is used to make a web API call to the secure endpoint that applies the RequireAuthorization extension method. If the user has the authority to access weather data, the endpoint uses the service to call . The data is returned to the client. In summary, the security of the weather data is enforced by the server app's web API endpoint. The preceding approach works well when the security requirements of the web API match the security requirements of the component. For example, the same authorization policy can be applied to both the web API endpoint and the component. Complex scenarios require additional planning and implementation. For example, a server web API that has multiple callers with different access permissions either requires a more sophisticated authorization policy, one or more additional policies, or additional endpoints with different access requirements. As you build security into apps that adopt Interactive Auto rendering, be mindful that the security implemented for the server's web API endpoints doesn't secure the server's service implementation that's used when a component is rendered on the server and accesses data through the service. Carefully weigh the difference between accessing data on the server during SSR versus accessing the data on a client web API request during CSR. Strategically apply security to avoid improper access to data. Examples in the Blazor samples GitHub repository ( ) (how to download) that demonstrate the approach described in this section:\n\nYou don't typically use AuthenticationStateProvider directly. Use the component or approaches described later in this article. The main drawback to using AuthenticationStateProvider directly is that the component isn't notified automatically if the underlying authentication state data changes.\n\nTo implement a custom AuthenticationStateProvider, see ASP.NET Core Blazor authentication state, which includes guidance on implementing user authentication state change notifications.\n\nThe AuthenticationStateProvider service can provide the current user's ClaimsPrincipal data, as shown in the following example.\n\nIf is and because the user is a ClaimsPrincipal, claims can be enumerated and membership in roles evaluated.\n\nFor more information on dependency injection (DI) and services, see ASP.NET Core Blazor dependency injection and Dependency injection in ASP.NET Core. For information on how to implement a custom AuthenticationStateProvider, see ASP.NET Core Blazor authentication state.\n\nIf authentication state data is required for procedural logic, such as when performing an action triggered by the user, obtain the authentication state data by defining a cascading parameter of type AuthenticationState , as the following example demonstrates.\n\nIf is , claims can be enumerated and membership in roles evaluated.\n\nIn a server-side Blazor app, services for options and authorization are already present, so no further steps are required.\n\nAfter a user is authenticated, authorization rules are applied to control what the user can do.\n\nAccess is typically granted or denied based on whether:\n\nEach of these concepts is the same as in an ASP.NET Core MVC or Razor Pages app. For more information on ASP.NET Core security, see the articles under ASP.NET Core Security and Identity.\n\nThe AuthorizeView component selectively displays UI content depending on whether the user is authorized. This approach is useful when you only need to display data for the user and don't need to use the user's identity in procedural logic.\n\nThe component exposes a variable of type AuthenticationState ( in Razor syntax), which you can use to access information about the signed-in user:\n\nYou can also supply different content for display if the user isn't authorized with a combination of the Authorized and NotAuthorized parameters:\n\nAlthough the AuthorizeView component controls the visibility of elements based on the user’s authorization status, it doesn't enforce security on the event handler itself. In the preceding example, the method is only associated with a button visible to authorized users, but nothing prevents invoking this method from other places. To ensure method-level security, implement additional authorization logic within the handler itself or in the relevant API.\n\nThe content of Authorized and NotAuthorized can include arbitrary items, such as other interactive components.\n\nAuthorization conditions, such as roles or policies that control UI options or access, are covered in the Authorization section.\n\nIf authorization conditions aren't specified, AuthorizeView uses a default policy:\n\nThe AuthorizeView component can be used in the component ( ) to display a component (NavLink), but note that this approach only removes the list item from the rendered output. It doesn't prevent the user from navigating to the component. Implement authorization separately in the destination component.\n\nFor role-based authorization, use the Roles parameter. In the following example, the user must have a role claim for either the or roles:\n\nTo require a user have both and role claims, nest AuthorizeView components:\n\nThe preceding code establishes a for the inner AuthorizeView component to prevent an AuthenticationState context collision. The AuthenticationState context is accessed in the outer AuthorizeView with the standard approach for accessing the context ( ). The context is accessed in the inner AuthorizeView with the named context ( ).\n\nFor more information, including configuration guidance, see Role-based authorization in ASP.NET Core.\n\nFor policy-based authorization, use the Policy parameter with a single policy name:\n\nTo handle the case where the user should satisfy one of several policies, create a policy that confirms that the user satisfies other policies.\n\nTo handle the case where the user must satisfy several policies simultaneously, take either of the following approaches:\n• None Create a policy for AuthorizeView that confirms that the user satisfies several other policies.\n\nClaims-based authorization is a special case of policy-based authorization. For example, you can define a policy that requires users to have a certain claim. For more information, see Policy-based authorization in ASP.NET Core.\n\nIf neither Roles nor Policy is specified, AuthorizeView uses the default policy:\n\nBecause .NET string comparisons are case-sensitive, matching role and policy names is also case-sensitive. For example, (uppercase ) is not treated as the same role as (lowercase ).\n\nPascal case is typically used for role and policy names (for example, ), but the use of Pascal case isn't a strict requirement. Different casing schemes, such as camel case, kebab case, and snake case, are permitted. Using spaces in role and policy names is unusual but permitted by the framework. For example, is an unusual role or policy name format in .NET apps, but it's a valid role or policy name.\n\nBlazor allows for authentication state to be determined asynchronously. The primary scenario for this approach is in client-side Blazor apps that make a request to an external endpoint for authentication.\n\nWhile authentication is in progress, AuthorizeView displays no content. To display content while authentication occurs, assign content to the Authorizing parameter:\n\nThis approach isn't normally applicable to server-side Blazor apps. Server-side Blazor apps know the authentication state as soon as the state is established. Authorizing content can be provided in an app's AuthorizeView component, but the content is never displayed.\n\nThe attribute is available in Razor components:\n\nThe attribute also supports role-based or policy-based authorization. For role-based authorization, use the Roles parameter:\n\nFor policy-based authorization, use the Policy parameter:\n\nIf neither Roles nor Policy is specified, uses the default policy:\n\nWhen the user isn't authorized and if the app doesn't customize unauthorized content with the component, the framework automatically displays the following fallback message:\n\nThe Router component, in conjunction with the AuthorizeRouteView component, allows the app to specify custom content if:\n• The user fails an condition applied to the component. The markup of the element is displayed. The attribute is covered in the attribute section.\n• Asynchronous authorization is in progress, which usually means that the process of authenticating the user is in progress. The markup of the element is displayed.\n\nIf NotAuthorized content isn't specified, the AuthorizeRouteView uses the following fallback message:\n\nAn app created from the Blazor WebAssembly project template with authentication enabled includes a component, which is positioned in the content of the Router component. When a user isn't authenticated ( ), the component redirects the browser to the endpoint for authentication. The user is returned to the requested URL after authenticating with the identity provider.\n\nIf the app is required to check authorization rules as part of procedural logic, use a cascaded parameter of type AuthenticationState to obtain the user's ClaimsPrincipal. AuthenticationState can be combined with other services, such as , to evaluate policies.\n\nIn the following example:\n• The executes code for users in the 'Admin' role.\n• The executes code for users satisfying the 'content-editor' policy.\n\nA server-side Blazor app includes the appropriate namespaces when created from the project template. In a client-side Blazor app, confirm the presence of the Microsoft.AspNetCore.Authorization and Microsoft.AspNetCore.Components.Authorization namespaces either in the component or in the app's file:\n• None Authorization requires a cascading parameter of type . Consider using to supply this.\n• None value is received for\n\nIt's likely that the project wasn't created using a server-side Blazor template with authentication enabled.\n\nIn .NET 7 or earlier, wrap a around some part of the UI tree, for example around the Blazor router:\n\nIn .NET 8 or later, don't use the CascadingAuthenticationState component:\n\nInstead, add cascading authentication state services to the service collection in the file:\n\nThe CascadingAuthenticationState component (.NET 7 or earlier) or services provided by AddCascadingAuthenticationState (.NET 8 or later) supplies the AuthenticationState cascading parameter, which in turn it receives from the underlying AuthenticationStateProvider dependency injection service.\n\nMicrosoft uses the GDPR definition for 'personal data' (GDPR 4.1) when documentation discusses Personally Identifiable Information (PII).\n\nPII refers any information relating to an identified or identifiable natural person. An identifiable natural person is one who can be identified, directly or indirectly, with any of the following:"
    },
    {
        "link": "https://stackoverflow.com/questions/71994794/howto-implement-asp-net-core-blazor-server-app-and-a-web-api-app-in-the-same-pro",
        "document": "You should be able to combine these without any issues:\n\nThe service configuration supports registring all dependencies anyway. And between and , there are quite a lot of shared ones anyway.\n\nThe only thing that can be tricky is the pipeline configuration since you need to make sure that both API requests and Blazor requests are handled by the correct handlers.\n\nThe good thing is that is usually means a fixed set of routes. Since your controller actions have specific routes, having the first will make sure that those specific routes will be handled properly by your controllers.\n\nAll other requests, those that don’t match any controller action, will then go to the next route handler in the pipeline. So is next which will host the SignalR hub for Blazor. That’s also a very specific route which is provided here.\n\nSo finally, all remaining requests will land at . This is a fallback-handler which means that it will handle any route. This allows Blazor to have a single entry-point for which it will then use client-side routing. As long as this fallback call is the last in the pipeline, it should not be able to interfere with any other route handler.\n\nWith that combined configuration, both your API and your Blazor should work just fine.\n\nIf you do have a situation which is more complicated, then you can use app.MapWhen to branch off the pipeline. There is an example in the documentation if you are interested in this functionality. But as I said, for your situation, you shouldn’t need it."
    },
    {
        "link": "https://stackoverflow.com/questions/71146117/how-to-configure-middleware-to-blazor-app",
        "document": "This is the new structure in . You need to add all previous logic to\n\nTo add your middleware, add: and\n\nMake sure the entire namespace of the Middleware is added to your usings at the top of your file, or in global usings.\n\nEDIT: I didn't see that this a web assembly Blazor application. @Henk Holterman is correct, you cannot use middleware on a client only application. You will need to add the middleware to your Server."
    },
    {
        "link": "https://docs.simpleinjector.org/en/latest/aspnetintegration.html",
        "document": "With the introduction to ASP.NET Core, Microsoft created one unified model that integrates both MVC and Web API. They call this framework ASP.NET Core MVC. Simple Injector offers the following NuGet package for integration with ASP.NET Core MVC:\n\nThis is the package to use if you want all functionality from the Simple Injector integration and are not worried about the number of dependencies it pulls in. If you need more fine-grained control over the number of (Microsoft) packages that get included in your application, you should read about the available integration packages.\n\nTo install from the NuGet package manager console:\n\nThe following code snippet shows how to use the integration package to apply Simple Injector to your ASP.NET Core 6 (and up) web application’s program.cs: // Sets up the basic configuration that for integrating Simple Injector with // ASP.NET Core by setting the DefaultScopedLifestyle, and setting up auto // allows request-scoped framework services to be resolved. // Ensure activation of a specific framework type to be created by // Simple Injector instead of the built-in configuration system. // All calls are optional. You can enable what you need. For instance, // ViewComponents, PageModels, and TagHelpers are not needed when you // Optionally, allow application components to depend on the non-generic // Add your custom Simple Injector-created middleware to the pipeline. NOTE: Please note that when integrating Simple Injector in ASP.NET Core, you do not replace ASP.NET’s built-in container, as advised by the Microsoft documentation. The practice with Simple Injector is to use Simple Injector to build up object graphs of your application components and let the built-in container build framework and third-party components, as shown in the previous code snippet. To understand the rationale around this, please read this article. TIP: By using AddSimpleInjector, you allow the Simple Injector Container to be automatically disposed when the application shuts down. To override this behavior, please read this.\n\nPrior to ASP.NET Core 6, startup code had to be written in the class, which was created by the default Visual Studio template for ASP.NET Core. The following code snippet shows how to use the integration package to apply Simple Injector to that ‘old’ class. // Sets up the basic configuration that for integrating Simple Injector with // ASP.NET Core by setting the DefaultScopedLifestyle, and setting up auto // allows request-scoped framework services to be resolved. // Ensure activation of a specific framework type to be created by // Simple Injector instead of the built-in configuration system. // All calls are optional. You can enable what you need. For instance, // ViewComponents, PageModels, and TagHelpers are not needed when you // Optionally, allow application components to depend on the non-generic // Add your custom Simple Injector-created middleware to the pipeline.\n\nThe SimpleInjector.Integration.AspNetCore.Mvc NuGet package is the umbrella package that pulls in all integration functionality. The downside is that it also pulls in many ASP.NET Core packages that you might not need, or might not want. In case you need more fine-grained control over the number of Microsoft packages that get included in your application, you can decide to use one of the other available ASP.NET Core integration packages. With ASP.NET Core, Microsoft follows an onion-layered model where more features can be utilized by including extra packages. Simple Injector’s integration packages follow this onion-layered model by adding a package per relevant onion layer. The following table lists the relevant integration packages sorted from most complete to most basic integration: The previous code example demonstrates the use of these extension methods. This package contains the following dependencies: This package contains the following dependencies: This page’ss initial code example demonstrates the use of this extension method. This package contains the following dependencies: Adds request scoping and middleware integration ASP.NET Core. The features of this package are described on this page. This package contains the following dependencies: Adds Hosted Service integration and integration on top of IHost. The features of this package are discussed in the .NET Generic Host Integration Guide. This package contains the following dependencies: Adds integration with .NET Core’s configuration system (i.e. IServiceCollection) by allowing framework-configured services to be injected into Simple Injector-managed components. It, furthermore, simplifies integration with .NET Core’s logging infrastructure. The features of this package are discussed in the ServiceCollection Integration Guide. This package contains the following dependencies:\n\nThe previous program.cs and integration examples already showed how a custom middleware class can be used in the ASP.NET Core pipeline. The Simple Injector ASP.NET Core integration packages add an UseMiddleware extension method that allows adding custom middleware. The following listing shows how a class is added to the pipeline. // In ASP.NET Core, middleware is applied in the order of registration. // (opposite to how decorators are applied in Simple Injector). This means // that the following two custom middleware components are wrapped inside // the authorization middleware, which is typically what you'd want. The type supplied to UseMiddleware<T> should implement the interface from the namespace. IMPORTANT: Besides implementing the interface, ASP.NET Core supports the notion of convention-based middleware—i.e. middleware that doesn’t implement the interface. Simple Injector, however, does not support convention-based middleware because it doesn’t follow Simple Injector’s best practices. To integrate with Simple Injector, you need to implement ASP.NET Core’s interface on your middleware classes. This UseMiddleware overload ensures two particular things:\n• None Adds a middleware type to the application’s request pipeline. The middleware will be resolved from the supplied the Simple Injector container.\n• None The middleware type will be added to the container for verification. This means that you should call container.Verify() after the calls to UseMiddleware to ensure that your middleware components are verified. The following code snippet shows how such class might look like: // Example of some custom user-defined middleware component. Notice how the class contains dependencies. When the middleware is added to the pipeline using the previously shown UseMiddleware overload, it will be resolved from Simple Injector on each request, and its dependencies will be injected.\n\nBesides injecting dependencies into a controller’s constructor, ASP.NET Core MVC allows injecting dependencies directly into action methods using method injection. This is done by marking a corresponding action method argument with the attribute. While the use of works for services registered in ASP.NET Core’s built-in configuration system (i.e. ), the Simple Injector integration package, however, does not integrate with out of the box. This is by design and adheres to our design guidelines, as explained below. IMPORTANT: Simple Injector’s ASP.NET Core integration packages do not allow any Simple Injector-registered dependencies to be injected into ASP.NET Core MVC controller action methods using the attribute. The use of method injection, as the attribute allows, has a few considerate downsides that should be prevented. Compared to constructor injection, the use of method injection in action methods hides the relationship between the controller and its dependencies from the container. This allows a controller to be created by Simple Injector (or ASP.NET Core’s built-in container for that matter), while the invocation of an individual action might fail, because of the absence of a dependency or a misconfiguration in the dependency’s object graph. This can cause configuration errors to stay undetected longer than strictly required. Especially when using Simple Injector, it blinds its diagnostic abilities which allow you to verify the correctness at application start-up or as part of a unit test. You might be tempted to apply method injection to prevent the controller’s constructor from becoming too large. But big constructors are actually an indication that the controller itself is too big. It is a common code smell named Constructor over-injection. This is typically an indication that the class violates the Single Responsibility Principle meaning that the class is too complex and will be hard to maintain. A typical solution to this problem is to split up the class into multiple smaller classes. At first this might seem problematic for controller classes, because they can act as gateway to the business layer and the API signature follows the naming of controllers and their actions. Do note, however, that this one-to-one mapping between controller names and the route of your application is not a requirement. ASP.NET Core has a very flexible routing system that allows you to completely change how routes map to controller names and even action names. This allows you to split controllers into very small chunks with a very limited number of constructor dependencies and without the need to fall back to method injection using . Simple Injector promotes best practices, and because of downsides described above, we consider the use of the attribute not to be a best practice. This is why we choose not to provide out-of-the-box support for injecting Simple Injector registered dependencies into controller actions. In case you still feel method injection is the best option for you, you can plug in a custom implementation returning a custom that resolves instances from Simple Injector.\n\nIn order to allow framework services to be cross wired, Simple Injector’s basic ServiceCollection Integration manages the framework’s instances within its own Scope. This means that, with the basic integration, every Simple Injector Scope gets its own new . This behavior, however, is overridden by Simple Injector’s ASP.NET Core integration. It ensures that, within the context of a single web request, the request’s original implementation is used. Not reusing that would cause scoped framework components to lose request information, which is supplied by the ASP.NET Core framework at the beginning of the request. This behavior is typically preferable, because it would otherwise force you to add quite some infrastructural code to get this data back. On the other hand, it does mean, that even if you start a nested Scope within a web request, you are still getting the same cross-wired scoped framework services. For instance, in case you inject a cross-wired (registered through ), you get the same instance, even within that nested scope—this might not be the behavior you want, and this behavior can be overridden. Especially when building a Blazor Server application, overriding the default can be important. Blazor Server applications tend to reuse the same for the same user as long as they stay on the same page (because the SignalR pipeline is kept open). This reuse can have rather problematic consequences, especially because the user can cause server requests to happen in parallel (by clicking a button multiple times within a short time span). This causes problems, because , for instance, is not thread safe. This is also a case where you might want to override the default behavior. The following code snippet demonstrates how this behavior can be overridden: NOTE: This AddAspNetCore overload is new in v5.1 of the SimpleInjector.Integration.AspNetCore integration package. The AddAspNetCore method contains an overload that accepts an ServiceScopeReuseBehavior enum. This enum has the following options:\n• None OnePerRequest: Within the context of a web request (or SignalR connection), Simple Injector will reuse the same instance, irregardless of how many Simple Injector Scope instances are created. Outside the context of a (web) request (i.e. returns ), this behavior falls back to the Unchanged behavior as discussed below.\n• None OnePerNestedScope: Within the context of a web request (or SignalR connection), Simple Injector will use the request’s within its root scope. Within a nested scope or outside the context of a (web) request, this behavior falls back to Unchanged.\n• None Unchanged: This leaves the original configured SimpleInjectorAddOptions.ServiceProviderAccessor as-is. If ServiceProviderAccessor is not replaced, the default value, as returned by AddSimpleInjector, ensures the creation of a new .NET Core instance, for every Simple Injector Scope. The is scoped to that Simple Injector Scope. The ASP.NET Core’s request will NEVER be used. Instead Simple Injector creates a new one for the request (and one for each nested scope). This disallows accessing ASP.NET Core services that depend on or return request-specific data. Setting the ServiceScopeReuseBehavior to Unchanged in a web application might force you to provide request-specific data to services using ASP.NET Middleware."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/tutorials/signalr?view=aspnetcore-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/signalr/hubs?view=aspnetcore-9.0",
        "document": "Use hubs in SignalR for ASP.NET Core"
    },
    {
        "link": "https://stackoverflow.com/questions/28948517/how-do-i-generate-api-documentation-for-signalr",
        "document": "Here's a Nuget package which can help you.\n\nFirst you need to decorate your SignalR hubs with attributes from SignalRSwaggerGen.Attributes namespace:\n\nThen you add SignalRSwaggerGen to Swagger generator:\n\nFor more information please refer to Github documentation."
    },
    {
        "link": "https://medium.com/@sayyedulawwab/building-a-real-time-chat-service-with-net-core-and-signalrintroduction-f65943dba9f0",
        "document": "In today’s world, real-time communication is an essential feature of modern applications. Whether it’s chatting on platforms like Messenger, WhatsApp, or Microsoft Teams, real-time messaging has become integral to our lives. These platforms not only support messaging but also provide advanced features like audio and video calling, sparking my curiosity about implementing real-time communication functionalities.\n\nThis article focuses on creating a backend service for a real-time chat application. The app allows users to sign up, create chat rooms, and share the room ID or URL with others for group conversations. While I used ReactJS (primarily generated by ChatGPT) to test the backend, the emphasis here is on the backend development.\n\nSignalR is a library that simplifies adding real-time web functionality to applications. It primarily uses WebSockets for communication but can fallback to older transport protocols when necessary. SignalR supports “server push” capabilities, enabling the server to call client-side methods, unlike traditional HTTP’s request-response model.\n\nSignalR applications can scale to thousands of clients with built-in or third-party providers like Redis or SQL Server.\n\nSignalR automatically selects the best transport method based on the client’s capabilities, falling back to older protocols like Long Polling when necessary. This ensures reliability across different environments. SignalR selects the transport method as follows:\n• Cross-domain connection: Uses WebSocket if the client and server support it; otherwise, falls back to Long Polling.\n• Same-domain connection: Uses WebSocket if supported; otherwise, tries Server-Sent Events, then Forever Frame, and finally Long Polling.\n• Persistent Connections: Low-level API for managing messaging, suitable for direct control over protocols.\n• Hubs: High-level API for seamless two-way communication, allowing clients and servers to call methods on each other directly.\n\nTo begin, ensure the following prerequisites are installed:\n\nThese services can be set up locally which I have done, but Docker Compose is an excellent option for managing dependencies efficiently.\n\nIn this project, I used both SQL Server and MongoDB for different parts of the application. SQL Server is used to manage relational data such as user information, rooms, and members. For these entities, I designed the models as follows:\n• User: Stores user information such as name, email, and password.\n• Room: Stores chat rooms and related data, with an optional password for securing rooms.\n• Member: Represents users as members of rooms, with a role and the date they joined.\n\nHere’s an example of the User entity, stored in SQL Server:\n\nHere’s an example of the Room entity, stored in SQL Server:\n\nHere’s an example of the Member entity, stored in SQL Server:\n\nFor the SQL Server entities, additional configuration was implemented using Entity Framework Core to ensure optimal performance and integrity. Below are the configurations for the key entities: User, Room, and Member.\n\nIn this configuration, the User entity is mapped to the table. The is set as the primary key with auto-increment, and the field is indexed to ensure uniqueness. The field defaults to the current UTC date.\n\nThe Room entity is configured similarly, with properties like and configured to ensure appropriate length and default value.\n\nThe Member entity configuration ensures that each member’s and combination is unique, preventing duplicate entries. The field defaults to the current UTC date, and navigation properties to and are set up with appropriate foreign key relationships.\n\nThese configurations enable Entity Framework Core to map the SQL Server entities accurately and ensure referential integrity between users, rooms, and members.\n\nOn the other hand, MongoDB is used for managing non-relational data like conversations and messages. These are dynamic and more suitable for a NoSQL database, where data such as messages and conversations can change frequently and require quick retrieval.\n• Conversation: Represents a conversation, which can either be a private conversation or a group chat.\n\nHere’s an example of the Conversation entity, stored in MongoDB:\n\nHere’s an example of the Message entity, stored in MongoDB:\n\nThis approach allows for an efficient combination of the strengths of both relational and NoSQL databases, providing flexibility and performance for different use cases in the chat application.\n\nRegister: Allows users to sign up.\n\nThe JWT token is required for protected routes.\n\nCreateRoom: Creates a chat room with a name and password.\n\nJoinRoom: Adds users to an existing room. Here password is optional\n• For one-on-one chats, use a roomId and a list of participants.\n\nTo integrate SignalR into the application:\n\nThe class is the SignalR hub that manages real-time communication in the chat application. It enables authentication using JWT tokens and provides key features such as joining chat rooms, sending messages, and notifying about user activities like typing or disconnecting.\n• The hub validates the user’s JWT token when they connect.\n• Tokens are passed as a query parameter ( ) during the WebSocket handshake.\n• Users send messages to a specific chat room, with caching and persistence of messages.\n• Notifications, like typing status, are broadcast to the room.\n• Removes the user from groups and clears their cached connection data when they disconnect.\n\nThe frontend of the application is built using ReactJS, providing an interface to interact with the backend. While the main focus of this article is on the backend, I will provide a high-level overview of the frontend components and how they interact with the backend.\n• Login/Register: Allows users to log in and register using the authentication endpoints.\n• CreateRoom: Allows users to create a new chat room by calling the API.\n• JoinRoom: Lets users join an existing room by providing the room ID.\n• ChatRoom: Where the real-time messaging happens. It connects to the SignalR hub and sends/receives messages.\n\nThe React component interacts with the by leveraging SignalR's JavaScript client. It manages the user's connection, messaging, and activity notifications.\n• Initializes a connection to the using the user's JWT token.\n• Invokes the method on the hub to join the chat room.\n• Listens for incoming messages and updates the UI.\n• Sends a message to the hub using the method.\n• Notifies other users in the chat room when the user is typing.\n• Ease of Real-Time Implementation with SignalR\n\nSignalR simplifies adding real-time functionality to applications by leveraging WebSockets and providing fallback options for older browsers or constrained environments. Its flexibility makes it an excellent choice for building chat applications.\n• Scalable and Secure Backend Design\n\nThe implementation demonstrated how to use JWT authentication for secure user access, SignalR Hubs for real-time communication, and Redis for caching to support scalability.\n• Practical API Design\n\nBy structuring endpoints for user authentication, room management, and messaging, the backend provides a clean interface that can be easily consumed by frontend applications.\n• Integration of Frontend with Backend\n\nUsing ReactJS as the frontend demonstrates how SignalR seamlessly connects the user interface with the backend for real-time updates and messaging.\n• Add real-time read receipts, message reactions, and notifications for an improved chat experience.\n• Explore additional backplane options like SQL Server or Redis for distributed messaging.\n• Use database indexing to improve query performance for chat history.\n• Enhance the frontend with a modern design and responsive UI for better usability.\n\nThis article covered the foundational steps to build a real-time chat application using .NET Core and SignalR, showcasing its capability to handle real-time messaging effectively. While the current implementation is functional, there are exciting opportunities for enhancements, as outlined in the Future Enhancements section. Your thoughts and feedback are highly appreciated and can contribute to refining this solution further — feel free to reach out or share your thoughts in the comments."
    },
    {
        "link": "https://krishan-samarawickrama.medium.com/building-a-real-time-application-with-asp-net-core-signalr-a-comprehensive-guide-874e975377c8",
        "document": "In the digital age, real-time applications have become a cornerstone of modern software development. These applications allow users to receive information as it happens, without any significant delay. From chat applications to live sports updates, real-time technology is transforming the way we interact with the digital world.\n\nOne of the key technologies enabling the development of real-time applications is SignalR, a library that simplifies the process of adding real-time web functionality to applications. This article will focus on ASP.NET Core SignalR, a powerful framework for building real-time applications.\n\nASP.NET Core SignalR is an open-source library that simplifies the process of adding real-time web functionality to your applications. Real-time web functionality is the ability to have server-side code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.\n\nSignalR provides an abstraction over various techniques used for building real-time web applications, such as WebSockets, Server-Sent Events, and Long Polling. It automatically selects the best available transport based on the client and server capabilities.\n\nASP.NET Core SignalR comes with several features that make it a preferred choice for building real-time applications:\n• Automatic Transport Selection: SignalR automatically chooses the best transport mechanism (WebSockets, Server-Sent Events, or Long Polling) based on the capabilities of the client and server.\n• Connection Management: SignalR handles connection management automatically, allowing you to focus on your application logic.\n• High-Level API: SignalR provides a high-level API for server-to-client communication. You can call methods on the client from the server and vice versa.\n• Support for Binary and Text Data: SignalR supports both binary and text data, not just text.\n• Scalability: SignalR is designed to scale out to multiple servers, making it suitable for large applications.\n\nHow ASP.NET Core SignalR Differs from Other Real-Time Frameworks\n\nUnlike other real-time frameworks, ASP.NET Core SignalR is not just a wrapper around WebSocket. It provides a higher-level API for managing connections, broadcasting messages, and handling groups. It also falls back to other techniques when WebSocket is not available, ensuring your application works across different environments.\n\nNow, let’s dive into the practical part of this guide. We will build a simple chat application using ASP.NET Core SignalR.\n\nFirst, create a new ASP.NET Core Web Application project in Visual Studio. Name it “SignalRChat”.\n\nNext, install the SignalR library via NuGet. You can do this by running the following command in the Package Manager Console:\n\nA “Hub” in SignalR is a high-level pipeline that allows the client and server to call methods on each other. Create a new class named “ChatHub” in the Hubs folder and replace the existing code with the following:\n\nOn the client side, you’ll need to add a reference to the SignalR library. You can do this by adding the following script tag to your HTML file:\n\nThen, establish a connection to the hub and define a method to send messages:\n\nAnd that’s it! You’ve built a simple real-time chat application using ASP.NET Core SignalR.\n\nASP.NET Core SignalR can be used to build a variety of real-time applications. Here are a few examples:\n• Chat Applications: As demonstrated in this guide, SignalR is perfect for building real-time chat applications.\n• Live Updates: SignalR can be used to push live updates to clients. This can be useful in applications like stock trading, live sports updates, etc.\n• Collaborative Apps: Applications that require multiple users to interact in real-time, like Google Docs, can be built using SignalR.\n• Gaming: Real-time games that require high-frequency updates can benefit from SignalR.\n\nASP.NET Core SignalR is a powerful library for building real-time applications. It provides an abstraction over various real-time techniques, automatically selects the best transport based on client and server capabilities, and provides a high-level API for server-to-client communication.\n\nThis guide has provided a step-by-step process to build a simple real-time chat application using ASP.NET Core SignalR. However, the possibilities with SignalR are endless. I encourage you to experiment with this powerful library and see what amazing real-time applications you can build!\n\nRemember, the key to mastering any technology is practice. So, start building, start experimenting, and most importantly, have fun while doing it!"
    }
]