[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img",
        "document": "Defines text that can replace the image in the page. Note: Browsers do not always display images. There are a number of situations in which a browser might not display images, such as:\n• Non-visual browsers (such as those used by people with visual impairments)\n• The user chooses not to display images (saving bandwidth, privacy reasons)\n• The image is invalid or an unsupported type In these cases, the browser may replace the image with the text in the element's attribute. For these reasons and others, provide a useful value for whenever possible. Setting this attribute to an empty string ( ) indicates that this image is not a key part of the content (it's decoration or a tracking pixel), and that non-visual browsers may omit it from rendering. Visual browsers will also hide the broken image icon if the attribute is empty and the image failed to display. This attribute is also used when copying and pasting the image to text, or saving a linked image to a bookmark.\n\nspecifies that you want the browser to send an header along with the image request. On the server-side this is used to trigger sending an or header in the response, to register an image-based attribution source or attribution trigger, respectively. Which response header should be sent back depends on the value of the header that triggered the registration. The corresponding source or trigger event is set off once the browser receives the response containing the image file. Note: See the Attribution Reporting API for more details. There are two versions of this attribute that you can set:\n• Boolean, i.e. just the name. This specifies that you want the header sent to the same server as the attribute points to. This is fine when you are handling the attribution source or trigger registration on the same server. When registering an attribution trigger this property is optional, and a boolean value will be used if it is omitted.\n• Value containing one or more URLs, for example: This is useful in cases where the requested resource is not on a server you control, or you just want to handle registering the attribution source on a different server. In this case, you can specify one or more URLs as the value of . When the resource request occurs the header will be sent to the URL(s) specified in in addition to the resource origin. These URLs can then respond with a or header as appropriate to complete registration. Note: Specifying multiple URLs means that multiple attribution sources can be registered on the same feature. You might for example have different campaigns that you are trying to measure the success of, which involve generating different reports on different data.\n\nIndicates if the fetching of the image must be done using a CORS request. Image data from a CORS-enabled image returned from a CORS request can be reused in the element without being marked \"tainted\". If the attribute is not specified, then a non-CORS request is sent (without the request header), and the browser marks the image as tainted and restricts access to its image data, preventing its usage in elements. If the attribute is specified, then a CORS request is sent (with the request header); but if the server does not opt into allowing cross-origin access to the image data by the origin site (by not sending any response header, or by not including the site's origin in any response header it does send), then the browser blocks the image from loading, and logs a CORS error to the devtools console. A CORS request is sent with credentials omitted (that is, no cookies, X.509 certificates, or request header). The CORS request is sent with any credentials included (that is, cookies, X.509 certificates, and the request header). If the server does not opt into sharing credentials with the origin site (by sending back the response header), then the browser marks the image as tainted and restricts access to its image data. If the attribute has an invalid value, browsers handle it as if the value was used. See CORS settings attributes for additional information.\n\nThis attribute provides a hint to the browser as to whether it should perform image decoding along with rendering the other DOM content in a single presentation step that looks more \"correct\" ( ), or render and present the other DOM content first and then decode the image and present it later ( ). In practice, means that the next paint does not wait for the image to decode. It is often difficult to perceive any noticeable effect when using on static elements. They'll likely be initially rendered as empty images while the image files are fetched (either from the network or from the cache) and then handled independently anyway, so the \"syncing\" of content updates is less apparent. However, the blocking of rendering while decoding happens, while often quite small, can be measured — even if it is difficult to observe with the human eye. See What does the image decoding attribute actually do? for a more detailed analysis (tunetheweb.com, 2023). Using different types can result in more noticeable differences when dynamically inserting elements into the DOM via JavaScript — see for more details. Decode the image synchronously along with rendering the other DOM content, and present everything together. Decode the image asynchronously, after rendering and presenting the other DOM content. No preference for the decoding mode; the browser decides what is best for the user. This is the default value.\n\nIndicates how the browser should load the image: Loads the image immediately, regardless of whether or not the image is currently within the visible viewport (this is the default value). Defers loading the image until it reaches a calculated distance from the viewport, as defined by the browser. The intent is to avoid the network and storage bandwidth needed to handle the image until it's reasonably certain that it will be needed. This generally improves the performance of the content in most typical use cases. Note: Loading is only deferred when JavaScript is enabled. This is an anti-tracking measure, because if a user agent supported lazy loading when scripting is disabled, it would still be possible for a site to track a user's approximate scroll position throughout a session, by strategically placing images in a page's markup such that a server can track how many images are requested and when. Note: Images with set to will never be loaded if they do not intersect a visible part of an element, even if loading them would change that as unloaded images have a and of . Putting and on lazy-loaded images fixes this issue and is a best practice, recommended by the specification. Doing so also helps prevent layout shifts.\n\nOne or more strings separated by commas, indicating a set of source sizes. Each source size consists of:\n• A media condition. This must be omitted for the last item in the list. Media Conditions describe properties of the viewport, not of the image. For example, proposes to use a source of 1000px width, if the viewport is not higher than 500px. Because a source size descriptor is used to specify the width to use for the image during layout of the page, the media condition is typically (but not necessarily) based on the width information. Source size values specify the intended display size of the image. User agents use the current source size to select one of the sources supplied by the attribute, when those sources are described using width ( ) descriptors. The selected source size affects the intrinsic size of the image (the image's display size if no CSS styling is applied). If the attribute is absent, or contains no values with a width descriptor, then the attribute has no effect. A source size value can be any non-negative length. It must not use CSS functions other than the math functions. Units are interpreted in the same way as media queries, meaning that all relative length units are relative to the document root rather than the element, so an value is relative to the root font size, rather than the font size of the image. Percentage values are not allowed. Additionally, you can use the value to replace the whole list of sizes or the first entry in the list. It is only valid when combined with , and resolves to the concrete size of the image.\n\nOne or more strings separated by commas, indicating possible image sources for the user agent to use. Each string is composed of:\n• Optionally, whitespace followed by one of:\n• A width descriptor (a positive integer directly followed by ). The width descriptor is divided by the source size given in the attribute to calculate the effective pixel density. If no descriptor is specified, the source is assigned the default descriptor of . It is incorrect to mix width descriptors and pixel density descriptors in the same attribute. Duplicate descriptors (for instance, two sources in the same which are both described with ) are also invalid. If the attribute uses width descriptors, the attribute must also be present, or the itself will be ignored. The user agent selects any of the available sources at its discretion. This provides them with significant leeway to tailor their selection based on things like user preferences or bandwidth conditions. See our Responsive images tutorial for an example."
    },
    {
        "link": "https://w3schools.com/tags/tag_img.asp",
        "document": "More \"Try it Yourself\" examples below.\n\nThe tag is used to embed an image in an HTML page.\n\nImages are not technically inserted into a web page; images are linked to web pages. The tag creates a holding space for the referenced image.\n\nThe tag has two required attributes:\n• src - Specifies the path to the image\n• alt - Specifies an alternate text for the image, if the image for some reason cannot be displayed\n\nNote: Also, always specify the width and height of an image. If width and height are not specified, the page might flicker while the image loads.\n\nTip: To link an image to another document, simply nest the tag inside an <a> tag (see example below).\n\nThe tag also supports the Global Attributes in HTML.\n\nThe tag also supports the Event Attributes in HTML.\n\nMost browsers will display the element with the following default values:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture",
        "document": "The HTML element contains zero or more elements and one element to offer alternative versions of an image for different display/device scenarios. The browser will consider each child element and choose the best match among them. If no matches are found—or the browser doesn't support the element—the URL of the element's attribute is selected. The selected image is then presented in the space occupied by the element.\n\n<!--Change the browser window width to see the image change.--> <picture> <source srcset=\"/shared-assets/images/examples/surfer.jpg\" media=\"(orientation: portrait)\" /> <img src=\"/shared-assets/images/examples/painted-hand.jpg\" alt=\"\" /> </picture> To decide which URL to load, the user agent examines each 's , , and attributes to select a compatible image that best matches the current layout and capabilities of the display device.\n• It describes the size and other attributes of the image and its presentation.\n• It provides a fallback in case none of the offered elements are able to provide a usable image.\n• Art direction. Cropping or modifying images for different conditions (for example, loading a simpler version of an image which has too many details, on smaller displays).\n• Offering alternative image formats, for cases where certain formats are not supported. Note: For example, newer formats like AVIF or WEBP have many advantages, but might not be supported by the browser. A list of supported image formats can be found in: Image file type and format guide.\n• Saving bandwidth and speeding page load times by loading the most appropriate image for the viewer's display. If providing higher-density versions of an image for high-DPI (Retina) display, use on the element instead. This lets browsers opt for lower-density versions in data-saving modes, and you don't have to write explicit conditions.\n\nThe attribute specifies a media condition (similar to a media query) that the user agent will evaluate for each element. If the 's media condition evaluates to , the browser skips it and evaluates the next element inside .\n\nThe srcset attribute is used to offer a list of possible images based on size or the display's pixel density. It is composed of a comma-separated list of image descriptors. Each image descriptor is composed of a URL of the image, and either:\n• a width descriptor, followed by a (such as ); OR\n• a pixel density descriptor, followed by an (such as ) to serve a high-res image for high-DPI screens.\n• width and pixel density descriptors should not be used together The following example illustrates the usage of attribute with the element to specify a high-density and standard-resolution image: The attribute can also be used on the element without needing the element. The following example demonstrates how to use the attribute to specify standard-resolution and high-density images, respectively: The attribute is not mandatory when using srcset, but it is recommended to use it in order to provide additional information to the browser to help it select the best image source. Without sizes, the browser will use the default size of the image as specified by its dimensions in pixels. This may not be the best fit for all devices, especially if the image is displayed on different screen sizes or in different contexts. Please note that sizes will have its effect only if width dimension descriptors are provided with srcset instead of pixel ratio values (200w instead of 2x for example). For more information on using , see the Responsive images documentation."
    },
    {
        "link": "https://w3schools.com/html/html_images.asp",
        "document": "Images can improve the design and the appearance of a web page.\n\nThe HTML tag is used to embed an image in a web page.\n\nImages are not technically inserted into a web page; images are linked to web pages. The tag creates a holding space for the referenced image.\n\nThe tag is empty, it contains attributes only, and does not have a closing tag.\n\nThe tag has two required attributes:\n• src - Specifies the path to the image\n• alt - Specifies an alternate text for the image\n\nThe required attribute specifies the path (URL) to the image.\n\nNote: When a web page loads, it is the browser, at that moment, that gets the image from a web server and inserts it into the page. Therefore, make sure that the image actually stays in the same spot in relation to the web page, otherwise your visitors will get a broken link icon. The broken link icon and the text are shown if the browser cannot find the image.\n\nThe required attribute provides an alternate text for an image, if the user for some reason cannot view it (because of slow connection, an error in the src attribute, or if the user uses a screen reader).\n\nThe value of the attribute should describe the image:\n\nIf a browser cannot find an image, it will display the value of the attribute:\n\nYou can use the attribute to specify the width and height of an image.\n\nAlternatively, you can use the and attributes:\n\nThe and attributes always define the width and height of the image in pixels.\n\nThe , , and attributes are all valid in HTML.\n\nHowever, we suggest using the attribute. It prevents styles sheets from changing the size of images:\n\nIf you have your images in a sub-folder, you must include the folder name in the attribute:\n\nSome web sites point to an image on another server.\n\nTo point to an image on another server, you must specify an absolute (full) URL in the attribute:\n\nNotes on external images: External images might be under copyright. If you do not get permission to use it, you may be in violation of copyright laws. In addition, you cannot control external images; they can suddenly be removed or changed.\n\nTo use an image as a link, put the tag inside the tag:\n\nUse the CSS property to let the image float to the right or to the left of a text:\n\nHere are the most common image file types, which are supported in all browsers (Chrome, Edge, Firefox, Safari, Opera):\n• Use the HTML element to define an image\n• Use the HTML attribute to define the URL of the image\n• Use the HTML attribute to define an alternate text for an image, if it cannot be displayed\n• Use the HTML and attributes or the CSS and properties to define the size of the image\n• Use the CSS property to let the image float to the left or to the right"
    },
    {
        "link": "https://w3.org/TR/html401/struct/objects.html",
        "document": "HTML's multimedia features allow authors to include images, applets (programs that are automatically downloaded and run on the user's machine), video clips, and other HTML documents in their pages.\n\nPrevious versions of HTML allowed authors to include images (via ) and applets (via ). These elements have several limitations:\n• They fail to solve the more general problem of how to include new and future media types.\n• The element only works with Java-based applets. This element is deprecated in favor of .\n\nTo address these issues, HTML 4 introduces the element, which offers an all-purpose solution to generic object inclusion. The element allows HTML authors to specify everything required by an object for its presentation by a user agent: source code, initial values, and run-time data. In this specification, the term \"object\" is used to describe the things that people want to place in HTML documents; other commonly used terms for these things are: applets, plug-ins, media handlers, etc.\n\nThe new element thus subsumes some of the tasks carried out by existing elements. Consider the following chart of functionalities:\n\nThe chart indicates that each type of inclusion has a specific and a general solution. The generic element will serve as the solution for implementing future media types.\n\nTo include images, authors may use the element or the element.\n\nTo include applets, authors should use the element as the element is deprecated.\n\nTo include one HTML document in another, authors may use either the new element or the element. In both cases, the embedded document remains independent of the main document. Visual user agents may present the embedded document in a distinct window within the main document. Please consult the notes on embedded documents for a comparison of and for document inclusion.\n\nImages and other included objects may have hyperlinks associated with them, both through the standard linking mechanisms, but also via image maps. An image map specifies active geometric regions of an included object and assigns a link to each region. When activated, these links may cause a document to be retrieved, may run a program on the server, etc.\n\nIn the following sections, we discuss the various mechanisms available to authors for multimedia inclusions and creating image maps for those inclusions.\n\nThe element embeds an image in the current document at the location of the element's definition. The element has no content; it is usually replaced inline by the image designated by the attribute, the exception being for left or right-aligned images that are \"floated\" out of line.\n\nThe attribute specifies alternate text that is rendered when the image cannot be displayed (see below for information on how to specify alternate text ). User agents must render alternate text when they cannot support images, they cannot support a certain image type or when they are configured not to display images.\n\nPlease consult the section on the visual presentation of objects, images, and applets for information about image size, alignment, and borders.\n\nMost user agents have built-in mechanisms for rendering common data types such as text, GIF images, colors, fonts, and a handful of graphic elements. To render data types they don't support natively, user agents generally run external applications. The element allows authors to control whether data should be rendered externally or by some program, specified by the author, that renders the data within the user agent.\n\nIn the most general case, an author may need to specify three types of information:\n• The implementation of the included object. For instance, if the included object is a clock applet, the author must indicate the location of the applet's executable code.\n• The data to be rendered. For instance, if the included object is a program that renders font data, the author must indicate the location of that data.\n• Additional values required by the object at run-time. For example, some applets may require initial values for parameters.\n\nThe element allows authors to specify all three types of data, but authors may not have to specify all three at once. For example, some objects may not require data (e.g., a self-contained applet that performs a small animation). Others may not require run-time initialization. Still others may not require additional implementation information, i.e., the user agent itself may already know how to render that type of data (e.g., GIF images).\n\nAuthors specify an object's implementation and the location of the data to be rendered via the element. To specify run-time values, however, authors use the element, which is discussed in the section on object initialization.\n\nThe element may also appear in the content of the element. Since user agents generally do not render elements in the , authors should ensure that any elements in the do not specify content that may be rendered. Please consult the section on sharing frame data for an example of including the element in the element.\n\nPlease consult the section on form controls for information about elements in forms.\n\nThis document does not specify the behavior of elements that use both the attribute to identify an implementation and the attribute to specify data for that implementation. In order to ensure portability, authors should use the element to tell implementations where to retrieve additional data.\n\nA user agent must interpret an element according to the following precedence rules:\n• The user agent must first try to render the object. It should not render the element's contents, but it must examine them in case the element contains any direct children that are elements (see object initialization) or elements (see client-side image maps).\n• If the user agent is not able to render the object for whatever reason (configured not to, lack of resources, wrong architecture, etc.), it must try to render its contents.\n\nAuthors should not include content in elements that appear in the element.\n\nOne significant consequence of the element's design is that it offers a mechanism for specifying alternate object renderings; each embedded declaration may specify alternate content types. If a user agent cannot render the outermost , it tries to render the contents, which may be another element, etc.\n\nPlease consult the section on the visual presentation of objects, images, and applets for information about object size, alignment, and borders.\n\nelements specify a set of values that may be required by an object at run-time. Any number of elements may appear in the content of an or element, in any order, but must be placed at the start of the content of the enclosing or element.\n\nThe syntax of names and values is assumed to be understood by the object's implementation. This document does not specify how user agents should retrieve name/value pairs nor how they should interpret parameter names that appear twice.\n\nWhen an element is rendered, user agents must search the content for only those elements that are direct children and \"feed\" them to the .\n\nThe location of an object's implementation is given by a URI. As we discussed in the introduction to URIs, the first segment of an absolute URI specifies the naming scheme used to transfer the data designated by the URI. For HTML documents, this scheme is frequently \"http\". Some applets might employ other naming schemes. For instance, when specifying a Java applet, authors may use URIs that begin with \"java\" and for ActiveX applets, authors may use \"clsid\".\n\nBy setting the attribute, a user agent can decide whether to retrieve the Java application based on its ability to do so.\n\nSome rendering schemes require additional information to identify their implementation and must be told where to find that information. Authors may give path information to the object's implementation via the attribute.\n• Data may be retrieved from the network by the user agent one time (during the declaration) and reused for each instantiation.\n• It is possible to instantiate an object from a location other than the object's declaration, for example, from a link.\n• It is possible to specify objects as run-time data for other objects.\n\nTo declare an object so that it is not executed when read by the user agent, set the boolean attribute in the element. At the same time, authors must identify the declaration by setting the attribute in the element to a unique value. Later instantiations of the object will refer to this identifier.\n\nA declared must appear in a document before the first instance of that .\n\nAn object defined with the attribute is instantiated every time an element that refers to that object requires it to be rendered (e.g., a link that refers to it is activated, an object that refers to it is activated, etc.).\n\nUser agents that don't support the attribute must render the contents of the declaration.\n\nSee the Transitional DTD for the formal definition.\n\nThis element, supported by all Java-enabled browsers, allows designers to embed a Java applet in an HTML document. It has been deprecated in favor of the element.\n\nThe content of the acts as alternate information for user agents that don't support this element or are currently configured not to support applets. User agents must ignore the content otherwise.\n\nInitial values may be supplied to the applet via the element.\n\nAn embedded document is entirely independent of the document in which it is embedded. For instance, relative URIs within the embedded document resolve according to the base URI of the embedded document, not that of the main document. An embedded document is only rendered within another document (e.g., in a subwindow); it remains otherwise independent.\n\nThe behavior of a user agent in cases where a file includes itself is not defined.\n\nAn image map is created by associating an object with a specification of sensitive geometric areas on the object.\n\nThere are two types of image maps:\n• When a user activates a region of a client-side image map with a mouse, the pixel coordinates are interpreted by the user agent. The user agent selects a link that was specified for the activated region and follows it.\n• When a user activates a region of a server-side image map with a mouse, the pixel coordinates of the click are sent to the server-side agent specified by the attribute of the element. The server-side agent interprets the coordinates and performs some action.\n\nClient-side image maps are preferred over server-side image maps for at least two reasons: they are accessible to people browsing with non-graphical user agents and they offer immediate feedback as to whether or not the pointer is over an active region.\n\nThe element specifies a client-side image map (or other navigation mechanism) that may be associated with another elements ( , , or ). An image map is associated with an element via the element's attribute. The element may be used without an associated image for general navigation mechanisms.\n\nThe presence of the attribute for an implies that the object being included is an image. Furthermore, when the element has an associated client-side image map, user agents may implement user interaction with the solely in terms of the client-side image map. This allows user agents (such as an audio browser or robot) to interact with the without having to process it; the user agent may even elect not to retrieve (or process) the object. When an has an associated image map, authors should not expect that the object will be retrieved or processed by every user agent.\n\nThe element content model allows authors to combine the following:\n• One or more elements. These elements have no content but specify the geometric regions of the image map and the link associated with each region. Note that user agents do not generally render elements. Therefore, authors must provide alternate text for each with the attribute (see below for information on how to specify alternate text).\n• Block-level content. This content should include elements that specify the geometric regions of the image map and the link associated with each region. Note that the user agent should render block-level content of a element. Authors should use this method to create more accessible documents.\n\nWhen a element contains mixed content (both elements and block-level content), user agents must ignore the elements.\n\nAuthors should specify an image maps's geometry completely with elements, or completely with elements, or completely with both if content is mixed. Authors may wish to mix content so that older user agents will handle map geometries specified by elements and new user agents will take advantage of richer block content.\n\nIf two or more defined regions overlap, the region-defining element that appears earliest in the document takes precedence (i.e., responds to user input).\n\nUser agents and authors should offer textual alternates to graphical image maps for cases when graphics are not available or the user cannot access them. For example, user agents may use text to create textual links in place of a graphical image map. Such links may be activated in a variety of ways (keyboard, voice activation, etc.).\n\nSimilarly, the attribute for the element declares that geometric region has no associated link.\n\nServer-side image maps may be interesting in cases where the image map is too complicated for a client-side image map.\n\nIt is only possible to define a server-side image map for the and elements. In the case of , the must be inside an element and the boolean attribute ([CI]) must be set. In the case of , the must be of type \"image\".\n\nWhen the user activates the link by clicking on the image, the screen coordinates are sent directly to the server where the document resides. Screen coordinates are expressed as screen pixel values relative to the image. For normative information about the definition of a pixel and how to scale it, please consult [CSS1].\n\nThe location clicked is passed to the server as follows. The user agent derives a new URI from the URI specified by the attribute of the element, by appending `?' followed by the x and y coordinates, separated by a comma. The link is then followed using the new URI. For instance, in the given example, if the user clicks at the location x=10, y=27 then the derived URI is \"http://www.acme.com/cgi-bin/competition?10,27\".\n\nUser agents that do not offer the user a means to select specific coordinates (e.g., non-graphical user agents that rely on keyboard input, speech-based user agents, etc.) should send the coordinates \"0,0\" to the server when the link is activated.\n\nWhen specified, the and attributes tell user agents to override the natural image or object size in favor of these values.\n\nWhen the object is an image, it is scaled. User agents should do their best to scale an object or image to match the width and height specified by the author. Note that lengths expressed as percentages are based on the horizontal or vertical space currently available, not on the natural size of the image, object, or applet.\n\nThe and attributes give user agents an idea of the size of an image or object so that they may reserve space for it and continue rendering the document while waiting for the image data.\n\nAn image or object may be surrounded by a border (e.g., when a border is specified by the user or when the image is the content of an element).\n\nThe following values for concern the object's position with respect to surrounding text:\n• means that the bottom of the object should be vertically aligned with the current baseline. This is the default value.\n• means that the center of the object should be vertically aligned with the current baseline.\n• means that the top of the object should be vertically aligned with the top of the current text line.\n\nTwo other values, and , cause the image to float to the current left or right margin. They are discussed in the section on floating objects.\n\n13.8 How to specify alternate text\n\nSeveral non-textual elements ( , , , and ) let authors specify alternate text to serve as content when the element cannot be rendered normally. Specifying alternate text assists users without graphic display terminals, users whose browsers don't support forms, visually impaired users, those who use speech synthesizers, those who have configured their graphical user agents not to display images, etc.\n\nThe attribute must be specified for the and elements. It is optional for the and elements.\n\nWhile alternate text may be very helpful, it must be handled with care. Authors should observe the following guidelines:\n• Do not specify irrelevant alternate text when including images intended to format a page, for instance, would be inappropriate for an image that adds a red ball for decorating a heading or paragraph. In such cases, the alternate text should be the empty string (\"\"). Authors are in any case advised to avoid using images to format pages; style sheets should be used instead.\n• Do not specify meaningless alternate text (e.g., \"dummy text\"). Not only will this frustrate users, it will slow down user agents that must convert text to speech or braille output.\n\nImplementors should consult the section on accessibility for information about how to handle cases of omitted alternate text."
    },
    {
        "link": "https://browserstack.com/guide/handling-images-in-html-and-css",
        "document": "With the internet accessible on all devices, web development has become more complex. Working with images in HTML is crucial for designing responsive and visually engaging websites.\n\nThis article explores the importance of adjusting image size in HTML, different image file types, resizing techniques in HTML and CSS, and testing responsiveness on real devices.\n\nWhy do you need to adjust image size in HTML and CSS?\n\nAdjusting image size in HTML and CSS is essential for creating fast, responsive, and visually appealing web pages. Properly sized images enhance user experience, improve page performance, and ensure compatibility across different devices and screen resolutions. Here are the primary reasons to adjust image sizes in HTML and CSS:\n• Improves Page Load Speed: Large, unoptimized images slow down website performance. Resizing images ensures faster load times and better overall efficiency.\n• Enhances Responsiveness: Different devices have varying screen sizes, requiring flexible images that adapt seamlessly without distortion.\n• Saves Bandwidth and Reduces Data Usage: Optimizing images is a good idea as such images consume less bandwidth, benefiting users on mobile networks and improving website efficiency.\n• Maintains Aspect Ratio and Visual Consistency: Properly scaled images prevent distortion, ensuring a balanced and professional look across different layouts.\n• Better SEO and Search Rankings: Faster-loading pages contribute to better search engine rankings. Well-optimized images with descriptive text improve accessibility and visibility.\n• Prevents Layout Shifting and Broken Designs: Defining appropriate image dimensions helps maintain a stable layout, preventing unexpected shifts that can affect user experience.\n\nChoosing the right image file format balances quality, performance, and compatibility across different devices and browsers. Each format serves a specific purpose, whether for photographs, graphics, or web optimization. Some of the common file formats include:\n• Uses lossy compression to reduce file size while maintaining good quality.\n• Supports transparency, making it ideal for logos and graphics.\n• Uses lossless compression to preserve image quality but creates larger file sizes.\n• Delivers high-quality images at smaller file sizes compared to JPEG and PNG.\n• Works well for web optimization and loads efficiently in modern browsers.\n• Works well for memes, small animations, and lightweight graphics.\n• Works best for icons, logos, and illustrations.\n• Allows easy styling and manipulation with CSS and JavaScript.\n• Compresses images better than WebP while maintaining high quality.\n• Still gaining browser support but offers great potential for future optimization.\n\nA responsive website offers significant advantages over a non-responsive one, ensuring smooth functionality across various devices and screen sizes. It dynamically adjusts its layout to fit different screens without distortion.\n\nA key aspect of responsiveness is adjusting image size to maintain visual balance and performance. By using the right HTML attributes and CSS properties, developers can ensure images load quickly, scale seamlessly, and enhance user experience across all devices.\n\nImages in an HTML file have default width and height values, which may not suit all screen sizes. Adjusting image size ensures a responsive design that adapts to different devices. While resizing images, follow these essential guidelines to maintain quality and responsiveness.\n• Changing an image’s width automatically scales its height to maintain the aspect ratio. This prevents distortion and keeps the image visually consistent.\n\n2. Use Relative Units Instead of Absolute Units\n• Set image dimensions using percentages instead of fixed pixels.\n• Using percentages allows the image to scale dynamically across different screen sizes, ensuring better responsiveness.\n• Fixed pixel values keep the image size constant, which may not work well on smaller screens.\n• If an image does not fit well within a webpage layout, resizing it in HTML helps maintain a balanced design. This can be easily achieved using the height and width attributes in the <img> tag. By default, these attributes use pixel values:\n\nAs we discussed above, changing height and width values in the HTML does not bring many deals to the responsive aspect of the image in a webpage. Therefore, developers widely opt for CSS to achieve responsive web design on images on their webpage.\n\nNow, let’s unlock more power in achieving responsiveness with the help of CSS.\n\nIf you use relative units, it will make your images fluid, irrespective of the screen size it is viewed in and works the same for all the screens size.\n\nMedia queries are only used when you want to give different sizes to your image when it is displayed in different viewports. For example, you want your image width to be 40% when displayed on a desktop and 60% when displayed on mobile phones. Moreover, media queries are one of the most used ways to make your page responsive. Let’s take an example of media queries, where the image will take the width of 100% when it is displayed on devices smaller than 720px.\n\nOne other feature in CSS is to use the max-width property. It prevents the image width from becoming larger than the value of max-width specified by you. However, it is not widely accepted for making images responsive, especially when your image is being viewed on a variety of devices.\n\nFor an instance, if the size of the image is 500px and the device width is 360px, then the complete image is not visible, due to lack of space.\n\nAlthough, if you apply the max-width to 100% the image will shrink itself to fit in the layout of the webpage, still, if the screen size increase more than 500px, the size of the image won’t increase, not following the responsiveness law.\n\nAfter a lot of attempts to make the image responsive, the ultimate attempt to bring all the responsive features under one roof is achieved when the object-fit property is introduced. The object-fit property brings the most amount of control when customizing the CSS for responsiveness.\n• contain: It resizes the image to make it fully visible, keeping the original aspect ratio intact.\n• cover: It resizes the image to cover the entire container, keeping the original aspect ratio constant.\n• fill: The image will be filled in the given area, even if it means breaking the original aspect ratio of the image.\n• none: The image will remain as it is and will fill the given area.\n\nHow to test Image Responsiveness on Real Devices?\n\nTesting Responsiveness of Images on Real Devices is a must to ensure it renders correctly on different devices of varying resolutions and screen sizes. Follow the easy steps below to test image responsiveness on real devices:\n\nStep 1: Open BrowserStack Responsive Dashboard and enter the URL of the webpage containing the responsive image. If you have created a website on your local machine, you must host your website to test its responsiveness on BrowserStack Responsive.\n\nStep 3: The user can check how the site appears on a certain device after choosing it.\n\nAs the number of mobile users is growing exponentially, the need of making responsive websites will only become more obvious. People are now accessing the web through smartphones and other portable devices, which is only increasing the challenge to bring more features to the responsiveness of the website.\n\nIf your website is responsive, it is automatically inviting more mobile traffic, lowers the bounce rate as per Google SEO rule, and gets more conversions, due to an aesthetic user experience. Moreover, why would you not want your website to be viewed across a variety of devices?\n\nTesting on real devices is essential for true responsiveness. BrowserStack Responsive enables developers to test websites across real browsers and devices, ensuring perfect layouts, images, and performance without needing physical device labs."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/HTML_images",
        "document": "How do we put an image on a webpage? In order to put an image on a web page, we use the element. This is a void element (meaning, it cannot have any child content and cannot have an end tag) that requires two attributes to be useful: and . The attribute contains a URL pointing to the image you want to embed in the page. As with the attribute for elements, the attribute can be a relative URL or an absolute URL. Without a attribute, an element has no image to load. The attribute is described below. Note: You should read A quick primer on URLs and paths to refresh your memory on relative and absolute URLs before continuing. So for example, if your image is called , and it sits in the same directory as your HTML page, you could embed the image like so: If the image was in an subdirectory, which was inside the same directory as the HTML page, then you'd embed it like this: Note: Search engines also read image filenames and count them towards SEO. Therefore, you should give your image a descriptive filename; is better than . You could also embed the image using its absolute URL, for example: Linking via absolute URLs is not recommended, however. You should host the images you want to use on your site, which in simple setups means keeping the images for your website on the same server as your HTML. In addition, it is more efficient to use relative URLs than absolute URLs in terms of maintenance (when you move your site to a different domain, you won't need to update all your URLs to include the new domain). In more advanced setups, you might use a CDN (Content Delivery Network) to deliver your images. If you did not create the images, you should make sure you have the permission to use them under the conditions of the license they are published under (see Media assets and licensing below for more information). Warning: Never point the attribute at an image hosted on someone else's website without permission. This is called \"hotlinking\". It is considered unethical, since someone else would be paying the bandwidth costs for delivering the image when someone visits your page. It also leaves you with no control over the image being removed or replaced with something embarrassing. The previous code snippet, either with the absolute or the relative URL, will give us the following result: Note: Elements like and are sometimes referred to as replaced elements. This is because the element's content and size are defined by an external resource (like an image or video file), not by the contents of the element itself. You can read more about them at replaced elements. Note: You can find the finished example from this section running on GitHub (see the source code too.)\n\nThe next attribute we'll look at is . Its value is supposed to be a textual description of the image, for use in situations where the image cannot be seen/displayed or takes a long time to render because of a slow internet connection. For example, our above code could be modified like so: <img src=\"images/dinosaur.jpg\" alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\" /> The easiest way to test your text is to purposely misspell your filename. If for example our image name was spelled , the browser wouldn't display the image, and would display the alt text instead: So, why would you ever see or need alt text? It can come in handy for a number of reasons:\n• The user is visually impaired, and is using a screen reader to read the web out to them. In fact, having alt text available to describe images is useful to most users.\n• As described above, the spelling of the file or path name might be wrong.\n• The browser doesn't support the image type. Some people still use text-only browsers, such as Lynx, which displays the alt text of images.\n• You may want to provide text for search engines to utilize; for example, search engines can match alt text with search queries.\n• Users have turned off images to reduce data transfer volume and distractions. This is especially common on mobile phones, and in countries where bandwidth is limited or expensive. What exactly should you write inside your attribute? It depends on why the image is there in the first place. In other words, what you lose if your image doesn't show up:\n• Decoration. You should use CSS background images for decorative images, but if you must use HTML, add a blank . If the image isn't part of the content, a screen reader shouldn't waste time reading it.\n• Content. If your image provides significant information, provide the same information in a brief text – or even better, in the main text which everybody can see. Don't write redundant text. How annoying would it be for a sighted user if all paragraphs were written twice in the main content? If the image is described adequately by the main text body, you can just use .\n• Link. If you put an image inside tags, to turn an image into a link, you still must provide accessible link text. In such cases you may, either, write it inside the same element, or inside the image's attribute – whichever works best in your case.\n• Text. You should not put your text into images. If your main heading needs a drop shadow, for example, use CSS for that rather than putting the text into an image. However, If you really can't avoid doing this, you should supply the text inside the attribute. Essentially, the key is to deliver a usable experience, even when the images can't be seen. This ensures all users are not missing any of the content. Try turning off images in your browser and see how things look. You'll soon realize how helpful alt text is if the image cannot be seen. Note: See our guide to Text Alternatives and An alt Decision Tree to learn how to use an attribute for images in various situations.\n\nYou can use the and attributes to specify the width and height of your image. They are given as integers without a unit, and represent the image's width and height in pixels. You can find your image's width and height in a number of ways. For example, on the Mac you can use + to get the display information for the image file. Returning to our example, we could do this: <img src=\"images/dinosaur.jpg\" alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\" width=\"400\" height=\"341\" /> There's a very good reason to do this. The HTML for your page and the image are separate resources, fetched by the browser as separate HTTP(S) requests. As soon as the browser has received the HTML, it will start to display it to the user. If the images haven't yet been received (and this will often be the case, as image file sizes are often much larger than HTML files), then the browser will render only the HTML, and will update the page with the image as soon as it is received. For example, suppose we have some text after the image: <h1>Images in HTML</h1> <img src=\"dinosaur.jpg\" alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\" title=\"A T-Rex on display in the Manchester University Museum\" /> <blockquote> <p> But down there it would be dark now, and not the lovely lighted aquarium she imagined it to be during the daylight hours, eddying with schools of tiny, delicate animals floating and dancing slowly to their own serene currents and creating the look of a living painting. That was wrong, in any case. The ocean was different from an aquarium, which was an artificial environment. The ocean was a world. And a world is not art. Dorothy thought about the living things that moved in that world: large, ruthless and hungry. Like us up here. </p> <footer>- Rachel Ingalls, <cite>Mrs. Caliban</cite></footer> </blockquote> As soon as the browser downloads the HTML, the browser will start to display the page. Once the image is loaded, the browser adds the image to the page. Because the image takes up space, the browser has to move the text down the page, to fit the image above it: Moving the text like this is extremely distracting to users, especially if they have already started to read it. If you specify the actual size of the image in your HTML, using the and attributes, then the browser knows, before it has downloaded the image, how much space it has to allow for it. This means that when the image has been downloaded, the browser doesn't have to move the surrounding content. For an excellent article on the history of this feature, see Setting height and width on images is important again. Note: Although, as we have said, it is good practice to specify the actual size of your images using HTML attributes, you should not use them to resize images. If you set the image size too big, you'll end up with images that look grainy, fuzzy, or too small, and wasting bandwidth downloading an image that is not fitting the user's needs. The image may also end up looking distorted, if you don't maintain the correct aspect ratio. You should use an image editor to put your image at the correct size before putting it on your webpage. If you do need to alter an image's size, you should use CSS instead.\n\nIt is now your turn to play! This active learning section will have you up and running with an embedding exercise. You are provided with a basic tag; we'd like you to embed the image located at the following URL: Earlier we said to never hotlink to images on other servers, but this is just for learning purposes, so we'll let you off this one time. We would also like you to:\n• Add some alt text, and check that it works by misspelling the image URL.\n• Set the image's correct and (hint: it is 200px wide and 171px high), then experiment with other values to see what the effect is. If you make a mistake, you can always reset it using the Reset button. If you get really stuck, press the Show solution button to see an answer: <h2>Live output</h2> <div class=\"output\" style=\"min-height: 50px;\"></div> <h2>Editable code</h2> <p class=\"a11y-label\"> Press Esc to move focus away from the code area (Tab inserts a tab character). </p> <textarea id=\"code\" class=\"input\" style=\"min-height: 100px; width: 95%\"> <img> </textarea> <div class=\"playable-buttons\"> <input id=\"reset\" type=\"button\" value=\"Reset\" /> <input id=\"solution\" type=\"button\" value=\"Show solution\" /> </div> const textarea = document.getElementById(\"code\"); const reset = document.getElementById(\"reset\"); const solution = document.getElementById(\"solution\"); const output = document.querySelector(\".output\"); const code = textarea.value; let userEntry = textarea.value; function updateCode() { output.innerHTML = textarea.value; } const htmlSolution = '<img src=\"https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg\"\n\n alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\"\n\n width=\"200\"\n\n height=\"171\"\n\n title=\"A T-Rex on display in the Manchester University Museum\">'; let solutionEntry = htmlSolution; reset.addEventListener(\"click\", () => { textarea.value = code; userEntry = textarea.value; solutionEntry = htmlSolution; solution.value = \"Show solution\"; updateCode(); }); solution.addEventListener(\"click\", () => { if (solution.value === \"Show solution\") { textarea.value = solutionEntry; solution.value = \"Hide solution\"; } else { textarea.value = userEntry; solution.value = \"Show solution\"; } updateCode(); }); textarea.addEventListener(\"input\", updateCode); window.addEventListener(\"load\", updateCode); // stop tab key tabbing out of textarea and // make it write a tab at the caret position instead textarea.onkeydown = (e) => { if (e.code === \"Tab\") { e.preventDefault(); insertAtCaret(\"\\t\"); } if (e.code === \"Escape\") { textarea.blur(); } }; function insertAtCaret(text) { const scrollPos = textarea.scrollTop; let caretPos = textarea.selectionStart; const front = textarea.value.substring(0, caretPos); const back = textarea.value.substring( textarea.selectionEnd, textarea.value.length, ); textarea.value = front + text + back; caretPos += text.length; textarea.selectionStart = caretPos; textarea.selectionEnd = caretPos; textarea.focus(); textarea.scrollTop = scrollPos; } // Update the saved userCode every time the user updates the text area code textarea.onkeyup = function () { // We only want to save the state when the user code is being shown, // not the solution, so that solution is not saved over the user code if (solution.value === \"Show solution\") { userEntry = textarea.value; } else { solutionEntry = textarea.value; } updateCode(); };\n\nLet's look at some common categories of licenses you are likely to find on the web. Creators of original work such as songs, books, or software often release their work under closed copyright protection. This means that, by default, they (or their publisher) have exclusive rights to use (for example, display or distribute) their work. If you want to use copyrighted images with an all rights reserved license, you need to do one of the following:\n• Pay a license fee to use them. This can be a one-time fee for unlimited use (\"royalty-free\"), or it might be \"rights-managed\", in which case you might have to pay specific fees per use by time slot, geographic region, industry or media type, etc.\n• Limit your uses to those that would be considered fair use or fair dealing in your jurisdiction. Authors are not required to include a copyright notice or license terms with their work. Copyright exists automatically in an original work of authorship once it is created in a tangible medium. So if you find an image online and there are no copyright notices or license terms, the safest course is to assume it is protected by copyright with all rights reserved. If the image is released under a permissive license, such as MIT, BSD, or a suitable Creative Commons (CC) license, you do not need to pay a license fee or seek permission to use it. Still, there are various licensing conditions you will have to fulfill, which vary by license. For example, you might have to:\n• Provide a link to the original source of the image and credit its creator.\n• Indicate whether any changes were made to it.\n• Share any derivative works created using the image under the same license as the original.\n• Not share any derivative works at all.\n• Not use the image in any commercial work.\n• Include a copy of the license along with any release that uses the image. You should consult the applicable license for the specific terms you will need to follow. Note: You may come across the term \"copyleft\" in the context of permissive licenses. Copyleft licenses (such as the GNU General Public License (GPL) or \"Share Alike\" Creative Commons licenses) stipulate that derivative works need to be released under the same license as the original. Copyleft licenses are prominent in the software world. The basic idea is that a new project built with the code of a copyleft-licensed project (this is known as a \"fork\" of the original software) will also need to be licensed under the same copyleft license. This ensures that the source code of the new project will also be made available for others to study and modify. Note that, in general, licenses that were drafted for software, such as the GPL, are not considered to be good licenses for non-software works as they were not drafted with non-software works in mind. Explore the links provided earlier in this section to read about the different license types and the kinds of conditions they specify. Work released into the public domain is sometimes referred to as \"no rights reserved\" — no copyright applies to it, and it can be used without permission and without having to fulfill any licensing conditions. Work can end up in the public domain by various means such as expiration of copyright, or specific waiving of rights. One of the most effective ways to place work in the public domain is to license it under CC0, a specific creative commons license that provides a clear and unambiguous legal tool for this purpose. When using public domain images, obtain proof that the image is in the public domain and keep the proof for your records. For example, take a screenshot of the original source with the licensing status clearly displayed, and consider adding a page to your website with a list of the images acquired along with their license requirements.\n\nSpeaking of captions, there are a number of ways that you could add a caption to go with your image. For example, there would be nothing to stop you from doing this: <div class=\"figure\"> <img src=\"images/dinosaur.jpg\" alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\" width=\"400\" height=\"341\" /> <p>A T-Rex on display in the Manchester University Museum.</p> </div> This is OK. It contains the content you need, and is nicely stylable using CSS. But there is a problem here: there is nothing that semantically links the image to its caption, which can cause problems for screen readers. For example, when you have 50 images and captions, which caption goes with which image? A better solution, is to use the HTML and elements. These are created for exactly this purpose: to provide a semantic container for figures, and to clearly link the figure to the caption. Our above example could be rewritten like this: <figure> <img src=\"images/dinosaur.jpg\" alt=\"The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth\" width=\"400\" height=\"341\" /> <figcaption> A T-Rex on display in the Manchester University Museum. </figcaption> </figure> The element tells browsers, and assistive technology that the caption describes the other content of the element. Note: From an accessibility viewpoint, captions and text have distinct roles. Captions benefit even people who can see the image, whereas text provides the same functionality as an absent image. Therefore, captions and text shouldn't just say the same thing, because they both appear when the image is gone. Try turning images off in your browser and see how it looks. A figure doesn't have to be an image. It is an independent unit of content that:\n• Expresses your meaning in a compact, easy-to-grasp way.\n• Could go in several places in the page's linear flow. A figure could be several images, a code snippet, audio, video, equations, a table, or something else."
    },
    {
        "link": "https://tiny-img.com/blog/best-image-size-for-website",
        "document": ""
    },
    {
        "link": "https://freecodecamp.org/news/how-to-work-with-images-in-html",
        "document": "Images are an essential part of web development, adding visual appeal and context to your web pages.\n\nIn HTML, you can easily incorporate images to enhance the user experience. This article will guide you through the basics of working with images in HTML and help you understand images in HTML better.\n\nHow to Insert an Image into a Web Page\n\nTo display an image on your web page, you'll use the element. It's a self-closing tag, which means you don't need a closing tag. Instead, you place the image source and other attributes within the opening tag.\n• The attribute provides alternative text for screen readers and that's displayed if the image fails to load.\n\nHTML supports various image file formats, including JPEG, PNG, GIF, and more. The choice of format depends on your needs.\n\nHere are explanations of some commonly used image formats in HTML:\n• Best For: Photographs, images with gradients, and complex scenes.\n• Considerations: Lossy compression, not suitable for images with transparency.\n• Best For: Images with transparency, icons, logos, and graphics with sharp edges.\n• Advantages: Supports both lossless and lossy compression, excellent image quality, and transparency.\n• Best For: Simple animations, images with a limited color palette, and icons.\n• Considerations: Limited color support (256 colors), not suitable for photographs or complex images.\n• Best For: Vector graphics, logos, icons, and images that need to scale without loss of quality.\n• Advantages: Resolution-independent, small file sizes, and sharp rendering at any size.\n• Best For: Modern web browsers and efficient image delivery.\n• Advantages: Provides both lossy and lossless compression, smaller file sizes, and good image quality.\n• Best For: Rarely used on the web due to large file sizes and lack of compression.\n• Advantages: No loss of quality, suitable for certain specialized applications.\n• Considerations: Large file sizes and not recommended for general web use.\n\nWhen choosing an image format for your web page, consider factors such as the type of content, image complexity, required transparency, and your target audience's browser support.\n\nIt's common to use a combination of formats within a website to optimize image delivery. Using appropriate image compression techniques and tools can also help reduce file sizes while maintaining image quality, which is crucial for web performance.\n\nYou can control the size of your images using the and attributes. These attributes allow you to specify the dimensions of an image on your web page.\n\nIt's important to set appropriate dimensions to maintain aspect ratios and ensure responsive design.\n\nAligning an image within the text using the attribute is an approach that was once used in older versions of HTML. But the attribute is deprecated in modern HTML (HTML5).\n\nInstead, alignment is typically achieved through CSS. Here's an expanded explanation of both approaches:\n\nHow to use the deprecated attribute (not recommended):\n\nIn older versions of HTML, you could use the attribute with the element to control the alignment of an image within text. The attribute had values like \"left,\" \"right,\" \"top,\" \"middle,\" and \"bottom.\" Here's an example:\n\nThis is some text that wraps around the image.\n\nWhile this method worked in the past, it's considered outdated and is not recommended for modern web development. It's better to separate content from presentation by using CSS for alignment.\n\nHow to use CSS for image alignment (recommended):\n\nIn modern web development, CSS (Cascading Style Sheets) is the preferred way to control the alignment of images within text. You can apply CSS rules directly in your HTML file using inline styles or, preferably, use an external CSS file for better maintainability.\n\nHere's an example of how you can use CSS to align an image to the left within a paragraph:\n\nThis is some text that wraps around the image.\n\nIn this example, we define a CSS class called that uses the property to make the image float to the left of the text. The property adds some space between the image and the text to improve readability.\n\nUsing CSS for alignment provides more flexibility and control over the positioning of images within text, and it is the recommended approach for modern web design. It also separates styling from content, making your HTML cleaner and more maintainable.\n\nYou can make images clickable by wrapping them in an (anchor) element. You can further customize the behavior of the hyperlink by using additional HTML attributes, such as to open the linked page in a new browser tab or window.\n\nNow, when a user clicks the image, it will navigate to the specified link.\n\nModern websites need to be responsive, adapting to various screen sizes. To make your images responsive, use the style property:\n\nThis property ensures that images will automatically scale down proportionally to fit the width of their parent containers when the screen size or viewport width decreases.\n\nThis is particularly important for ensuring that images don't overflow or break the layout on smaller screens, such as those on mobile devices.\n\nHow to Load Images from External Sources\n\nYou can also display images hosted on external websites by specifying the full URL in the attribute:\n\nJust make sure you have permission to use external images and that they are publicly accessible.\n\nWeb accessibility is crucial. Always include descriptive text in the attribute to assist users with disabilities. Meaningful alt text helps screen readers provide context for the image.\n\nAlt text, short for \"alternative text,\" is a textual description of an image that can be read aloud by screen readers or displayed in place of the image if it cannot be loaded.\n• Screen Readers: People with visual impairments often use screen readers to navigate websites. When a screen reader encounters an image, it reads the alt text aloud to provide context and convey the image's meaning.\n• Image Loading Issues: Alt text is also displayed when an image fails to load properly in a web browser, allowing users to understand the image's content even if they cannot see it.\n• Alt text should be concise but descriptive, conveying the essential information or purpose of the image.\n• It should be free from unnecessary details or visual design descriptions (for example, \"A blue button\" is not as helpful as \"Submit Form\").\n• Avoid using phrases like \"image of\" or \"picture of\" since screen readers already announce that it's an image.\n• For decorative or purely aesthetic images that don't convey information, use an empty alt attribute (alt=\"\") or indicate that it's decorative (alt=\"Decorative image\").\n\nRemember that the goal of alt text is to provide a meaningful and informative description of the image so that users with disabilities can understand its content and context.\n\nBy following these guidelines and creating appropriate alt text, you contribute to a more accessible and inclusive web experience for all users.\n\nOptimizing images is crucial for web performance. Compress images, use appropriate dimensions, and select the right file format to balance image quality and loading speed.\n\nYou can improve website performance by implementing lazy loading. The \"loading\" attribute set to \"lazy\" is a feature in HTML that tells the browser to load the image lazily. This means it will only load the image when it's in or near the viewport (visible area) of the web page.\n\nLazy loading can help improve page loading performance by reducing the initial load time for images that are not immediately visible to the user.\n\nHere's the code to do that:\n\nIn addition to alt text for accessibility, consider using image captions for better context. You can include a element within a element:\n\nFor high-DPI displays like Retina screens, serve higher-resolution images using the attribute:\n\nIncorporating images into an HTML documents is a fundamental skill for web developers. With the element and its attributes, you can easily control image display, size, and alignment.\n\nBy following best practices for image optimization, accessibility, and responsive design, you'll create visually appealing and user-friendly web content.\n\nAs you continue your web development journey, practice integrating images into your projects and explore these additional tips to enhance the performance and accessibility of your websites."
    },
    {
        "link": "https://developers.google.com/search/docs/appearance/google-images",
        "document": ": For news and resources from Google Search on making your site discoverable, follow us on LinkedIn\n\nSave and categorize content based on your preferences.\n\nGoogle provides several Search features and products that help users visually discover information on the web, such as the text result images, Google Discover, and Google Images. While each feature and product looks different, the general recommendations for getting images to appear in them is the same.\n\nYou can optimize your images to appear in Google's search results by following these best practices:\n• Help us discover and index your images\n\nHelp us discover and index your images\n\nThe technical requirements for getting your content in Google's search results applies to images too. Since images are a substantially different format compared to HTML, it means there are additional requirements for getting images indexed; for example, finding the images on your site is different, and the presentation of the images also influences whether an image is indexed at all, and for the right keywords.\n\nUsing standard HTML image elements helps crawlers find and process images. Google can find images in attribute of element (even when it's a child of other elements, such as the element). Google doesn't index CSS images.\n\nYou can provide the URL of images we might not have otherwise discovered by submitting an image sitemap.\n\nUnlike regular sitemaps, you can include URLs from other domains in the elements of the image sitemaps. This allows you to use CDNs (content delivery networks) to host images. If you're using a CDN, we encourage you to verify ownership of the CDN's domain name in Search Console so that we can inform you of any crawl errors that we may find.\n\nDesigning responsive web pages leads to better user experience, since people can access them across a plethora of device types. Refer to our guide to responsive images to learn about the best practices for handling images on your website.\n\nWeb pages use the element or the attribute of an element to specify responsive images. However, some browsers and crawlers do not understand these attributes. We recommend that you always specify a fallback URL via the attribute.\n\nThe attribute allows specifying different versions of the same image, specifically for different screen sizes. For example:\n\nThe element is a container that is used to group different versions of the same image. It offers a fallback approach so the browser can choose the right image depending on device capabilities, like pixel density and screen size. The element also comes in handy for using new image formats with built-in graceful degradation for clients that may not yet support the new formats.\n\nPer section 4.8.1 of the HTML Standard, make sure that you provide an element as a fallback with a attribute when using the element using the following format:\n\nGoogle Search supports images referenced in the attribute of in the following file formats: BMP, GIF, JPEG, PNG, WebP, SVG, and AVIF. It's also a good idea to have the extension of your filename match with the file type.\n\nYou can also inline images as Data URIs. Data URIs provide a way to include a file, such as an image, inline by setting the attribute of an element as a Base64-encoded string using the following format:\n\nWhile inlining images can reduce HTTP requests, carefully judge when to use them since it can considerably increase the size of the page. For more on this, refer to the section on pros and cons of inlining images on our web.dev page.\n\nHigh-quality photos appeal to users more than blurry, unclear images. Also, sharp images are more appealing to users in the result thumbnail and can increase the likelihood of getting traffic from users. That said, images are often the largest contributor to overall page size, which can make pages slow and expensive to load. Make sure to apply the latest image optimization and responsive image techniques to provide a high quality and fast user experience.\n\nAnalyze your site speed with PageSpeed Insights and visit our Why does speed matter? to learn about best practices and techniques to improve website performance.\n\nWhile not immediately obvious, the content and metadata of the pages where an image is embedded can have a great influence on how and where the image may appear in Google's search results.\n\nGoogle Search automatically generates a title link and snippet to best explain each result and how it relates to the user query. This helps users decide whether or not to click on a result. Here are two examples how the title links and snippet might look like on a Google search results page:\n\nWe use a number of different sources for this information, including information in the and tags for each page.\n\nYou can help us improve the quality of the title link and snippet displayed for your pages by following Google's title and snippet guidelines.\n\nIf you include structured data, Google can display your images in certain rich results, including a prominent badge in Google Images, which give users relevant information about your page and can drive better targeted traffic to your site.\n\nFollow the general structured data guidelines as well as any guidelines specific to your structured data type; otherwise your structured data might be ineligible for rich result display in Google Images. In each of these structured data types, the image attribute is a required field to be eligible for a badge and rich result in Google Images. Here are two examples how rich results might look like on Google Images:\n\nGoogle extracts information about the subject matter of the image from the content of the page, including captions and image titles. Wherever possible, make sure images are placed near relevant text and on pages that are relevant to the image subject matter.\n\nLikewise, the filename can give Google very light clues about the subject matter of the image. When possible, use filenames that are short, but descriptive. For example, is better than . Avoid using generic filenames like , , when possible. If your site has thousands of images, you might want to consider automating the naming of the images. If you localize your images, remember to also translate the filenames, keeping in mind the URL encoding guidelines if you're using non-latin or special characters.\n\nThe most important attribute when it comes to providing more metadata for an image is the alt text (text that describes an image), which also improves accessibility for people who can't see images on web pages, including users who use screen readers or have low-bandwidth connections.\n\nGoogle uses alt text along with computer vision algorithms and the contents of the page to understand the subject matter of the image. Also, alt text in images is useful as anchor text if you decide to use an image as a link.\n\nWhen writing alt text, focus on creating useful, information-rich content that uses keywords appropriately and is in context of the content of the page. Avoid filling attributes with keywords (also known as keyword stuffing) as it results in a negative user experience and may cause your site to be seen as spam.\n\nAlso consider the accessibility of your alt text, per W3 guidelines. For the element, you can add the attribute of the element, while for inline elements, you can use the element. For example:\n\nWe recommend testing your content by auditing for accessibility and using a slow network connection emulator.\n\nIf you choose, you can prevent the full-sized image from appearing in the Google Images search results page by opting out of inline linking in Google Images search results. To opt out of inline linking:\n• When your image is requested, examine the HTTP referrer header in the request.\n• If the request is coming from a Google domain, reply with a HTTP status code, or a HTTP status code and no content.\n\nGoogle will still crawl your page and see the image, but will display a thumbnail image generated at crawl time in search results. This opt-out is possible at any time, and doesn't require re-processing of a website's images. This behavior isn't considered image cloaking and won't result in manual actions.\n\nAlternatively, you can prevent the image from appearing in search results entirely.\n\nSafeSearch is a setting in Google user accounts that specifies whether to show, blur, or block explicit images, videos, and websites in Google Search results. Make sure Google understands the nature of your site so that Google can apply SafeSearch filters to your site if appropriate. Learn more about labeling pages for SafeSearch."
    }
]