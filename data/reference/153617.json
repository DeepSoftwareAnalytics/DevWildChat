[
    {
        "link": "https://en.uniapp.dcloud.io/vue-basics.html",
        "document": "Vue (pronounced /vjuÀê/, similar to view) is a progressive framework for building user interfaces. Vue is designed to be applied layer by layer from the bottom up.\n\nVue.js uses HTML-based template syntax, allowing developers to declaratively bind the DOM to the data of the underlying Vue instance. All Vue.js templates are legal HTML, so they can be parsed by browsers and HTML parsers that follow the specification.\n\nIn the underlying implementation, Vue compiles the template into a virtual DOM rendering function. Combined with the response system, Vue can intelligently calculate how many components need to be re-rendered and minimize the number of DOM operations.\n\nThe core of Vue.js is a system that allows the use of concise template syntax to declaratively render data into the DOM. It only focuses on the view layer and is easy to use. Everything is responsive.\n\nWe provide a free video tutorial, while reading this document, we recommend that you combine Vue Getting Started Video Tutorial (opens new window) for a quicker grasp.\n\nMost of the content of this article comes from vue official website, but some adjustments have been made in conjunction with to make it easier for developers to get started quickly. Heartfelt thanks should be given to the Vue team!\n\nIn traditional development, when the native JavaScript DOM manipulation function is used to frequently manipulate the DOM, the browser must constantly render the new DOM tree, causing the page to look very stuck.\n\nVue is a single-page application, which makes the page partially refresh, without having to request all the data and DOM every time you jump to the page, which greatly speeds up the access speed and improves the user experience.\n‚Ä¢ Runs fast and easy to get started\n‚Ä¢ Easy to integrate with third-party libraries or existing projects\n‚Ä¢ It used to be .html files, development was also html, and running was also html.\n‚Ä¢ Now it is a .vue file, and development is a vue. After compilation, the runtime has become a js file.\n‚Ä¢ Modern front-end development rarely uses HTML directly, but basically develops, compiles, and runs. So 'uni-app' has the concept of compiler, runtime.\n\n# Changes in the code structure within the file\n‚Ä¢ Before a large node, there and nodes;\n‚Ä¢ Now is a node for writing tag components, and is a node in parallel, that is, there are three-level node.\n\n# Changes in the way external files are cited\n‚Ä¢ In the past, external js and css were introduced through script src and link href;\n‚Ä¢ Now it is written in es6, import external js module (note that it is not a file) or css;\n\njs needs to come in and become an object . There is a tool class in the directory of hello uni-app. You can search for this example in hello uni-app. Hello uni-app sample code is available from github (opens new window).\n\nIn this , the prior should method for encapsulating as an object\n\nOf course, there are some advanced usages\n\ncss external file import. Global styles are written in in the root directory, and every page will load the styles in .\n\nIn addition, Vue supports component import, which makes it easier to encapsulate a library that includes interface, js, and styles See.\n\nIt used to be html tags, for example , now it is a small program component, for example .\n\nSo what is the difference between a label and a component, isn't it all surrounded by angle brackets in English?\n‚Ä¢ In fact, tags are an old concept. Tags are built-in browsers.\n‚Ä¢ But the components can be freely expanded. Similarly, you can encapsulate a piece of js into a function or module, and you can also encapsulate a ui control into a component.\n\nprovides a batch of built-in components (opens new window).\n‚Ä¢ In the previous DOM operation, if you want to change the display content of a DOM element, such as the display text of a view: set the id to the view, then get the DOM element through the selector in js, and then perform assignment operations through js to modify the DOM element Attribute or value.\n‚Ä¢ The current practice is the binding mode of vue, bind a js variable to this DOM element, modify the value of the js variable in the script, the DOM will automatically change, and the page will automatically update the rendering.\n‚Ä¢ The front end uses the [MVVM](short for Model-View-ViewModel) mode. Simply put, Model: represents the data model, View: only focuses on view UI processing, and ViewModel: only processes business and data. Its core is the VM in MVVM, which is the ViewModel. ViewModel is responsible for connecting View and Model to ensure the consistency of views and data. This lightweight architecture makes front-end development more efficient and convenient, greatly reducing the number of lines of code, and better differential rendering performance.\n‚Ä¢ solves the problem of interaction between js and DOM interface by using data binding method of vue.\n\nsupports all vue syntax when publishing to the H5 side; When publishing to App, due to platform limitations, all vue syntax cannot be implemented, but is still the cross-end framework with the highest support for vue syntax.\n\nCompared with the Web platform, the differences in the use of Vue.js in are mainly concentrated in two aspects:\n‚Ä¢ Added: In addition to supporting the life cycle of Vue instances, it also supports Application life cycle and Page life cycle.\n‚Ä¢ Restricted: Compared with the web platform, some functions on the App side are more restricted. See details.\n‚Ä¢ More Vue features can be used on the App side, See details .\n\nThe most common form of data binding is text interpolation:\n\nThe content in will be replaced with the value of msg on the corresponding data object. Whenever the msg on the bound data object changes, the content at the interpolation point will be updated.\n\nSo far we‚Äôve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:\n\nThese expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain one single expression, so the following will NOT work:\n\nDirectives are special attributes with the v- prefix.\n‚Ä¢ The value of the directive attribute is expected to be a single JavaScript expression (v-for is an exception).\n‚Ä¢ The function of the instruction is that when the value of the expression changes, the collateral effect produced by it will act on the DOM responsively.\n‚Ä¢ Some commands can receive a \"parameter\", which is indicated by a colon (üòÉ after the command name.\n\nDynamically bind one or more attributes, or a component to the expression.\n‚Ä¢ In binding upon, it must be declared in the sub-assembly.\n‚Ä¢ You can specify different binding types with modifiers.\n\nIf the values are , or , it will not even be included in the rendered elements.\n\nThe v-on instruction, which is used to monitor DOM events. v-on is abbreviated as'@'\n\nOnly render elements and components once. Subsequent re-rendering, the element/component and all its child nodes will be treated as static content and skipped.\n\nUnlike front-end framework in understanding the client in order to achieve a logical multiplexing state flag template node will be added to the guarantee rendering node only once, but not necessarily be able to optimize the rendering performance, but might slow down the client Comparison efficiency when multiplexing nodes.\n‚Ä¢ Note: The content is inserted as normal HTML-it will not be compiled as a Vue template.\n‚Ä¢ If you try to use the v-html composite template, you can reconsider whether to replace it by using components.\n‚Ä¢ App and H5 end support , WeChat applet will be converted , other end does not support .\n\nCross-end rich text processing scheme can be found in: https://ask.dcloud.net.cn/article/35772 (opens new window)\n\ndata must be declared as a function that returns an initial data object (note that the data object returned in the function should not directly reference objects outside the function); otherwise, the data will not be automatically destroyed when the page is closed, and the last data will be displayed when the page is opened again .\n\nTo save performance, we hard-code the expressions of and into through . The supported syntax and conversion effects are as follows:\n\nAn object can be passed to v-bind:class to switch classes dynamically.\n\nYou can also pass in more fields in the object to dynamically switch multiple classes. In addition, the v-bind:class instruction can also coexist with ordinary classes.\n\nWhen or changes, class list will be updated accordingly. For example, if the value , class list becomes .\n\nYou can pass an array to v-bind:class to apply a class list.\n\nNote: Set the px pixel value in the way: style=\"\". The value is the actual pixel and will not be converted by the compiler.\n\nFurther it may also be used to generate a method or a string, inserted into the page, illustrated:\n\nInstructions are used to conditionally render a piece of content. This content will only return instruction in an expression is rendered value of the time. Use instructions represent the v-if \"else block.\"\n\n, As the name suggests, serves as the \"else-if block\" of v-if and can be used continuously:\n\nSimilarly , we must immediately bring or elements after.\n\nBecause a command, so it must be added to an element. But what if you want to switch multiple elements? At this time it can be a element as invisible package elements, and using v-if above. The final rendering results will not contain elements.\n\nIt is an instruction to display element options based on conditions. Usage and roughly the same:\n\nThe difference is that elements with v-show will always be rendered and kept in the DOM. v-show simply switching element attributes .\n\n# The difference between v-if and v-show\n\nIt is a \"real\" conditional rendering, because it will ensure that the event listeners and subcomponents in the conditional block are properly destroyed and rebuilt during the switching process.\n\nIt is also lazy: if the condition is false in the initial rendering, nothing is done, and the conditional block will not be rendered until the condition becomes true for the first time.\n\nIn contrast, it is much simpler, no matter what the initial conditions are, the element will always be rendered, and it is simply switched based on CSS to control the display and hiding of the element.\n‚Ä¢ There is a higher switching overhead. If the conditions rarely change during runtime, it is better to use v-if.\n‚Ä¢ There is a higher initial rendering overhead. If you need to switch very frequently, v-show is better.\n‚Ä¢ Not recommended to use both and .\n‚Ä¢ When and when used together, than a higher priority.\n\nThe v-for instruction can render a list based on an array.\n‚Ä¢ The v-for directive requires a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on.\n‚Ä¢ The first parameter is the alias iterated array elements.\n‚Ä¢ The second parameter, the index of the current item , is optional.\n\nYou can also use v-for to traverse an object .\n‚Ä¢ The first parameter is an alias iterated array elements.\n‚Ä¢ The second parameter is the name (that is, the key name).\n‚Ä¢ The third parameter serves as an index.\n\nLike , you can also use with the cyclically render some content that contain multiple elements. such as:\n\nWhen using Vue being updated when the list elements rendered, it defaults to \"place update\" strategy. If the order of the data items is changed, Vue will not move the DOM elements to match the order of the data items, but instead update each element in place and ensure that they are rendered correctly at each index position.\n\nIf the position of items in the list will dynamically change or new items added to the list, and you want the list of projects to maintain its own identity and status (such as input content, the selected state), you need to specify a list of items The unique identifier.\n\nThe value of is provided in two forms\n‚Ä¢ Use cycles in a a , the value needs to be unique list number or string, and can not be changed dynamically.\n‚Ä¢ Use cycle itself, then the need itself is a unique character string or a number\n\nWhen the data change triggers the rendering layer to re-render, the components with keys will be corrected, and the framework will ensure that they are reordered, not recreated, to ensure that the components maintain their own state and improve the efficiency of the list rendering.\n‚Ä¢ Differences and other platforms when the platforms H5 integer v-for loop, as in, item 1 from the start, other platforms item from zero, the second parameter may be used in index H5 platform consistent.\n‚Ä¢ The third parameter is not supported in the non-cyclic object H5 platform, such as in, index parameter is not supported.\n\nOn the custom component, you can use it like any ordinary element .\n\nWhen using v-for on the component, the key is required.\n\nYou can listen to DOM events with v-on instruction, when triggered and run some code.\n\nHowever, many event processing logic is more complex, so directly to the code is written in the instructions is not feasible. So you can also receive the name of a method needs to be called.\n\nInstead of binding directly to a method name, we can also use methods in an inline JavaScript statement:\n\nSometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special variable:\n\nThe modifier is a special suffix specified by a period. It is used to indicate that an instruction should be bound in a special way. For example, modifier tells instructions for event-triggered call :\n‚Ä¢ : Supported by all platforms, it will prevent the event from bubbling when used, and also prevent the default behavior of the event on the non-H5 side\n‚Ä¢ If you need to scroll down the page prohibiting mask, use , processing can be used to events, but also can be an empty function.\n‚Ä¢ Key modifier: Run on the mobile phone, with no keyboard event. So the key modifier is not supported.\n\nYou can form a v-model command , and create a two-way data binding on the element. It will automatically select the correct method to update the element based on the control type. While some magic, but in essence merely syntactic sugar. It is responsible for monitoring the user's input events to update the data, and perform some special processing on some extreme scenarios.\n\nIt is recommended to use : Form component (opens new window) directly in the development process.\n‚Ä¢ The tag on the H5 side is replaced with the component\n\nEach contains a calculated attribute and a default is to use to read. All and the context is automatically bound instance Vue.\n\nBinding expressions in templates is very convenient, but they are actually only used for simple operations. Putting too much logic in the template makes the template too heavy and difficult to maintain. E.g:\n\nHere are the variables you want to display flip string. When you want to include more inverted strings here in the template, it will be more difficult to handle.\n\nTherefore, for any complex logic, you should use computed property .\n\nYou can bind as ordinary as calculated binding properties in the template.\n\nVue know rely on , so when change occurs, all dependent binding will be updated. And best of all is that we have to declaratively create this dependency: the calculation of property functions are no side effects (side effect), making it easier to test and understand.\n\nCalculated properties can also depend on the data of multiple Vue instances. As long as any of the data changes, the calculated properties will be re-executed and the view will be updated.\n\nWhen you need it can also provide a function, when manually modify the calculated value of the property, it will trigger function, perform some custom actions.\n\nNow run time, will be called and will be updated accordingly.\n\n# The difference between getter and setter\n‚Ä¢ get: The new value of fullName can be obtained by setting the get method.\n‚Ä¢ set: Set a value (newValue) to change the value associated with fullName through the set method, causing the fullName to be recalculated, and the fullName on the corresponding page will also be changed to new content.\n\nWe can achieve the same effect by calling methods in expressions:\n\nYou can define the same function as a method instead of a calculated attribute. The final result of the two methods is indeed exactly the same. However, the difference is that calculated attributes are cached based on their responsive dependencies .\n\nThey will be re-evaluated only when the related reactive dependencies change. This means that as long as no change, many visits to the calculation results before the property will return immediately to calculate, without having to perform functions again.\n\nThis also means that the following calculated properties will no longer be updated, because Date.now() is not a reactive dependency:\n\nIn contrast, whenever a re-render is triggered, the calling method will always execute the function again .\n\nWhy do we need caching? Suppose we have a computational property A with a relatively large performance overhead, and it needs to traverse a huge array and do a lot of calculations. Then we may have other calculated properties that depend on A. If there is no cache, we will inevitably execute A's getter multiple times! If you do not want to have a cache, please use methods instead.\n\nVue provides a more general way to observe and respond to data changes on Vue instances: listening to properties . When you have some data that needs to change with other data changes, you can easily abuse it . Often, however, a better practice is to use the calculation attribute rather than a command-style callback.\n\nThe above code is imperative and repetitive. Compare it with the version of the calculated attribute:\n‚Ä¢ None For an object, the key is the expression to be observed, and the value is the corresponding callback function. The value can also be a method name, or an object containing options. Vue instance will be called upon instantiation , traversing each object ."
    },
    {
        "link": "https://en.uniapp.dcloud.io/vue-components.html",
        "document": "\n‚Ä¢ Components are the basic building blocks of the view layer.\n‚Ä¢ The component is an encapsulation of a single functional module.\n‚Ä¢ A component includes a start tag and an end tag. Attributes can be written on the label and assigned values to the attributes. The content is written in two labels.\n‚Ä¢ Root is , this case can only and must have a root component. This is the vue single file component specification .\n‚Ä¢ The data option of a component must be a function.\n\nThe following is an example of a basic component. Introduce a component again under the root component, and bind a data to the text area of the component.\n\nBasic components are built in the uni-app framework, including dozens of basic components such as view, text, input, button and video. See the list for details: Uni-app basic components (opens new window)\n\nBut basic components alone are not enough. There will be many encapsulated components in actual development.\n\nFor example, if we need a pentagram click rating component, it is available in the DCloud plug-in market: https://ext.dcloud.net.cn/plugin?id=33 (opens new window)\n\nImport this uni-rate component into your uni-app project, refer to it in the required vue page, and you can display this five-pointed star component in the specified place.\n‚Ä¢ The components can be reused any number of times.\n‚Ä¢ The code is more convenient to organize and manage, and it is more extensible, facilitating collaborative development by multiple people.\n\nWhen registering a component, we always need to give it a name. There are two ways to define component names:\n\nWhen using kebab-case (name separated by dashes) to define a component, you must also use kebab-case when referencing this custom element, for example .\n\nWhen defining a component using PascalCase (name with initial capital letters), you can use both nomenclatures when referencing this custom element. Both and are acceptable.\n\nCreate and store custom components in the directory under the root directory of the uni-app project:\n\nsupports the configuration of global components. Global registration is required in , and the component can be used in all pages after registration.\n‚Ä¢ The first parameter of Vue.component must be a static string.\n‚Ä¢ The nvue page does not currently support global components.\n‚Ä¢ Components can be used directly in\n\nBefore partial registration, import the component you want to use on the page that needs to reference the component.\n\nThe way the page introduces components\n\nThe following two ways to import a corner label component libraryhttps://ext.dcloud.net.cn/plugin?id=21 (opens new window), recommended to use to introduce\n‚Ä¢ Traditional vue specifications: On the index.vue page, import the component as ,and define the you want to use in the Components option.\n\nFor the object of each property, its property name is the name of the custom elements, objects whose property value is the option of this component.\n\nPutting a variable name similar to uniBadge in the object is actually uniBadge: short for uniBadge, that is, the variable name is also:\n‚Ä¢ The name of the custom element used in the template\n‚Ä¢ The variable name that contains this component option (Only hump naming is supported)\n‚Ä¢ easycom : introduce the components into one step. As long as the components are installed in the project directory, and in accordance with the directory structure. You can use it directly on the page without quoting or registering.\n‚Ä¢ None Easycom (opens new window) is automatically turned on , you do not need to manually open ,when there is a demand of nodes personalize .\n‚Ä¢ None No matter how many components are installed in the components directory, easycom will automatically remove unused components after packaging, which is particularly friendly to the use of component libraries.\n\nComponent is a very important part of the technology in .Components allow UI-related wheels to be easily manufactured and shared, which in turn makes development efficiency for users significantly higher.\n\nhas built a component plug-in market, in which there are many ready-made components. If you download components that conform to the components/ component name/component name. vue directory structure, you can use them directly. uni-app plug-in market (opens new window)\n\nCan be an array or object, used to receive data from the parent component. It can be a simple array, or use an object as an alternative. The object allows configuration of advanced options such as type detection, custom validation, and setting default values.\n‚Ä¢ You can give like this passed in a static value:\n‚Ä¢ Pass in all of an object\n\nIf you want to pass in all of an object as a prop, you can use without parameters (replace v-bind: prop-name) . For example, for a given object :\n\nAll props form a one -line downward binding between their parent and child props : updates to the parent prop will flow down to the child components, but the reverse is not possible. This will prevent accidental changes to the state of the parent component from the child component, which will make the data flow of your application difficult to understand.\n‚Ä¢ This is used to pass an initial value; the desired sub-assembly to the next as a local used data.\n‚Ä¢ This with a primitive values passed and the need for conversion. In this case, it is preferable to use the value of a calculated attribute to define:\n\nref is used to register a reference to an element or a child component. The reference will be registered under the parent component‚Äôs $refs object.\n\nIf used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\nWhen used on elements/components with v-for, the registered reference will be an Array containing DOM nodes or component instances.\n\n**An important note about the ref registration timing: **\n\nbecause the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don‚Äôt exist yet! $refs is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\nDespite the existence of props and events, sometimes you might still need to directly access a child component in . To achieve this you can assign a reference ID to the child component using the . For example:\n\nNow in the component where you‚Äôve defined this ref, you can use:\n\nThus allowing the parent component to focus the input inside with:\n\nhere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the modifier for :\n‚Ä¢ Note: the performance of app and h5 are inconsistent, and h5 gets the browser native event.\n\nWhen a child component changes the value of a , the change is synchronized with the binding in the parent component. It is extended as a listener that automatically updates the properties of the parent component.\n\nVue implements a content distribution API, using elements as outlets for hosting content distribution.\n\nIt allows you to synthesize components like this:\n\nIn the template may be written as:\n\nWhen the component is rendered, it will be replaced with \"Your Profile\". The slot can contain any template code, including :\n\nIf a does not contain an element, then anything between the start tag and an end tag assembly is discarded.\n\nWhen you want to use data in a slot, for example:\n\nThis slot has access to the same instance (that is, the same \"scope\") as the rest of the template, but not to the scope of .For example, a visit of less than:\n\nSometimes it is useful to set a specific fallback (that is, the default) content for a slot, which will only be rendered when no content is provided. In one example, component:\n\nWe may hope that the vast majority of cases are rendered within the text \"Submit\". In order to \"Submit\" content as a backup, we can put it in the label:\n‚Ä¢ When I use a parent component when slot and does not provide any content:\n‚Ä¢ When I use a parent assembly time and provides a slot content:\n\nWhen multiple slots are required, you can define named slots using a special feature of the element:\n‚Ä¢ When providing content to a named slot, We can use directive on a element, and provide their name as a parameter of v-slot:\n\nNow all the content elements will have to be passed in the appropriate slot. Any not been wrapped with the v-slot in is considered the default slot content in the content .\n\nLike v-on and v-bind, it also has abbreviations, that is, replace everything before the parameter (v-slot:) with the character # . For example, it can be rewritten as :\n\nIn the scope slot, the parent component can get the data of the child component. Subassembly may be bound label on the attribute value.\n\nSometimes it is useful to allow the contents of the slot to access data that is only available in the subcomponent.\n\nWe may want to change the default content and display it by first name instead of last name. as follows:\n\nHowever, the above code does not work properly, because only components can access the user and the content we provide is in the parent rendering.\n\nTo make user available in the parent slot contents, we can bind user as an of the element:\n\nBinding on the element is called slot prop .Now in the parent scope, we can use the valued to define the name of the we provide:\n\nIn this example, we select will contain all the slots object name , but you can use any name you like.\n\nLike assume unspecified content corresponding slot as the default, with no arguments is assumed to correspond to the default slot:\n\nThe abbreviated syntax of the default slot cannot be mixed with the named slot , because it will cause the scope to be ambiguous:\n\nAlways use the full -based syntax for all slots whenever multiple slots are present:\n\nThe internal working principle of scoped slots is to wrap the contents of your slot in a function with a single parameter:\n\nThis means that the value of a can actually be any expression that can be used as a parameter in a function definition. So with the support of the environment ( single file component ), you can also use the ES2015 deconstructed to pass specific slot , as follows:\n\nThis makes the template more compact, especially if the slot provides more than one .It also opens up other possibilities, such as renaming,for example, rename :\n\nYou can even define a backup for the case where in the slot is :\n\nThe following are reserved keywords and can not be used as component names.\n‚Ä¢ In addition to the names in the above list, standard HTML and SVG tag names cannot be used as component names.\n‚Ä¢ Methods cannot use a method name with the same name as a lifecycle."
    },
    {
        "link": "https://vuejs.org/guide/essentials/list",
        "document": "We can use the directive to render a list of items based on an array. The directive requires a special syntax in the form of , where is the source data array and is an alias for the array element being iterated on:\n\nInside the scope, template expressions have access to all parent scope properties. In addition, also supports an optional second alias for the index of the current item:\n\nThe variable scoping of is similar to the following JavaScript:\n\nNotice how the value matches the function signature of the callback. In fact, you can use destructuring on the item alias similar to destructuring function arguments:\n\nFor nested , scoping also works similar to nested functions. Each scope has access to parent scopes:\n\nYou can also use as the delimiter instead of , so that it is closer to JavaScript's syntax for iterators:\n\nYou can also use to iterate through the properties of an object. The iteration order will be based on the result of calling on the object:\n\nYou can also provide a second alias for the property's name (a.k.a. key):\n\nAnd another for the index:\n\ncan also take an integer. In this case it will repeat the template that many times, based on a range of .\n\nNote here starts with an initial value of instead of .\n\nSimilar to template , you can also use a tag with to render a block of multiple elements. For example:\n\nWhen they exist on the same node, has a higher priority than . That means the condition will not have access to variables from the scope of the :\n\nThis can be fixed by moving to a wrapping tag (which is also more explicit):\n\nWhen Vue is updating a list of elements rendered with , by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\n\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique attribute for each item:\n\nWhen using , the should be placed on the container:\n\nIt is recommended to provide a attribute with whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\n\nThe binding expects primitive values - i.e. strings and numbers. Do not use objects as keys. For detailed usage of the attribute, please see the API documentation.\n\nYou can directly use on a component, like any normal element (don't forget to provide a ):\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\nThe reason for not automatically injecting into the component is because that makes the component tightly coupled to how works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. , and , which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one:\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nIn situations where computed properties are not feasible (e.g. inside nested loops), you can use a method:\n\nBe careful with and in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:"
    },
    {
        "link": "https://raindrop.xlog.app/Vue2-uniapp-study",
        "document": "Vue allows the creation of reusable block tags through components. Most of the time, Vue components are written using a special syntax for HTML templates. When more control than what HTML syntax allows is needed, JSX or pure JavaScript functions can be written to define components. A Vue application consists of a root Vue instance created with , along with an optional nested, reusable component tree.\n\nThe template is a top-level node used to write tag components, while script and style are parallel top-level nodes, meaning there are three top-level nodes.\n‚Ä¢ HTML is a markup language used to structure our web content and give meaning to it, such as defining paragraphs, headings, and data tables, or embedding images and videos in the page.\n‚Ä¢ CSS is a style sheet language that applies styles to HTML content, such as setting background colors and fonts, and laying out content in multiple columns.\n‚Ä¢ JavaScript is a scripting language that can be used to create dynamically updating content, control multimedia, create animations, and much more.\n\nThe Document Object Model (DOM) is an API (Application Programming Interface) for HTML and XML documents. The DOM connects web pages to scripts or programming languages by storing the structure of the document (such as the HTML representing the web page) in memory as objects. The DOM represents the document in the form of a logical tree. Each branch of the tree ends with a node, and each node contains an object. DOM methods allow programmatic access to the tree. With these methods, you can change the structure, style, or content of the document.\n\nDirectives are special attributes prefixed with . The value of a directive attribute is expected to be a single JavaScript expression (with being an exception).\n\nComputed properties are cached based on their reactive dependencies. They will only re-evaluate when their related reactive dependencies change. In contrast, calling a method will always execute the function again whenever a re-render is triggered. Therefore, computed properties are more efficient.\n\nArrow functions can be async by adding the async keyword before the expression.\n\nA Promise is the foundation of asynchronous programming in modern JavaScript. It is an object returned by an asynchronous function that indicates the current state of the operation. When a Promise is returned to the caller, the operation is often not yet complete, but the Promise object provides methods to handle the eventual success or failure of the operation.\n\nThe elegance of Promise lies in that itself also returns a Promise, which indicates the completion status of the asynchronous function called in . This allows for chaining promises.\n\nA promise can be in one of three states: pending, fulfilled, or rejected.\n\nAdding at the beginning of a function makes it an asynchronous function.\n\nIn uni-app, the underlying logic and principles of and are the same as in other JavaScript environments.\n\nIn the lifecycle of Vue components, there are some hook functions that are asynchronous, such as created and mounted. These hook functions allow you to perform asynchronous operations after the component is created or mounted to the DOM.\n\nAn function is a special function that always returns a Promise. Even if you do not explicitly return a Promise, the function will return a resolved Promise with a value of .\n\nThe keyword can only be used inside functions. It is used to wait for the result of a Promise. When is used on a Promise, the JavaScript engine will pause the execution of the function until the Promise is resolved or rejected.\n\nThe underlying principles of and are based on Promises. Promises are one of the standard ways to handle asynchronous operations in JavaScript, and they have three states: pending, fulfilled, and rejected. A Promise object represents an asynchronous operation that may eventually complete or fail, along with the value upon completion or failure.\n\nThe keyword is used to wait for the result of a Promise. When you use the keyword inside an function, the JavaScript engine will pause the execution of the function until the Promise is resolved or rejected. If the Promise is resolved, the value of the expression will be the resolved value; if the Promise is rejected, the expression will throw an error, which can be handled using .\n\nThe HTML element is part of the web component technology suite; it is a placeholder inside a web component that you can fill with your own markup to create separate DOM trees and render them together.\n\nIn Vue.js, the use of the $ symbol is primarily based on specific properties and methods of the Vue instance or Vue component instance. These properties and methods typically start with a $, distinguishing them from regular data properties, computed properties, methods, etc. These properties and methods starting with $ are often provided by the Vue framework itself to perform Vue-related operations or access the internal state of the Vue instance.\n\nDetailed analysis of attribute binding in Vue.js: the difference between colon and non-colon _vue attribute colon-CSDN Blog\n\nThe attribute is called a directive. Directives are prefixed with to indicate that they are special attributes provided by Vue.\n\nWhether to add when setting parameters mainly depends on whether you are setting HTML attributes or Vue-specific directives. They apply special reactive behavior on the rendered DOM.\n\nCases where is not needed#\n\nStatic HTML attributes: When you write attributes directly on an element, such as , here is a static HTML attribute whose value is determined at compile time and does not change with data in the Vue instance.\n\nVue directives but not attribute bindings: For certain Vue directives like , , , etc., they are not used to bind HTML attributes but are Vue-specific template directives used for data binding, conditional rendering, list rendering, etc. These directives do not require a prefix because they are not bindings of HTML attributes.\n\nDynamic HTML attribute binding: When you want to dynamically set the attributes of an HTML element based on data in the Vue instance, you need to use the directive. To simplify, Vue allows the use of as a shorthand for . For example, means that the value of the attribute will be bound to the data property in the Vue instance. If the value of changes, the attribute of will also update accordingly.\n\nDynamic binding and static binding have performance differences. Dynamic binding incurs some rendering overhead because Vue.js needs to monitor changes in the expression and perform reactive updates. Static binding does not have such performance overhead because they are static values.\n\nRead the token value from local storage and store it in the Vuex state manager for easy access to this token value where needed.\n‚Ä¢ Security: Tokens are generally more secure than cookies because they contain encrypted signatures and can be designed not to persist. Cookies are stored on the client side and are more vulnerable to attacks.\n‚Ä¢ Scalability: Token mechanisms are better suited for stateless architectures and distributed systems because they do not require the server to maintain session state.\n‚Ä¢ Cross-Domain Issues: Tokens can easily solve cross-domain issues, while traditional session cookies are subject to the same-origin policy.\n\nis a reference pointing to the form element or component with in the template.\n\nWhen using the attribute in the template of a Vue component, Vue creates a corresponding property in the object of that component instance, and the value of that property is the corresponding child component instance or DOM element.\n\nNote: The value of is before the component is rendered. Therefore, you cannot directly access in the hook; you should access it in the hook or later in the lifecycle.\n\nIn a vue file, , , and are at the same level. In vue2, the second-level nodes of can only have one node, typically continuing to write page components under a root . But in vue3, the template can have multiple second-level nodes, eliminating one level.\n\nIn the script area, developers should be cautious when writing code outside of ; there are two considerations here:\n‚Ä¢ It affects application performance. This part of the code executes when the application starts, not when the page loads. If the code here is too complex, it will affect the application's startup speed and consume more memory.\n‚Ä¢ It does not get reclaimed when the component or page closes. Outer static variables will not be reclaimed when the page closes. If necessary, you need to handle it manually, such as in the or lifecycle hooks.\n\nIn ES6 (ECMAScript 6), both and can be used to export variables (including constants), functions, classes, files, modules, etc., which can then be imported in other files or modules using the import variable (including constants)|function|class|filename|module name syntax for use. There can be multiple exports, but there can only be one export default.\n\nIn Vue.js, using and is a common pattern to define and export Vue plugins. This method allows you to create a plugin that can be used in Vue applications.\n‚Ä¢ : The Vue constructor, which can be used to extend Vue's prototype, register global components, directives, etc.\n‚Ä¢ : An optional parameter, usually used to access the context of the Vue instance, but has been deprecated in Vue 3.\n\nWithin the function body, various operations can be performed to configure Vue or register custom behaviors. When you import this module elsewhere (like in ), you can install this plugin using the method.\n\nIn JavaScript, the prototype is a special mechanism used to implement inheritance and share properties and methods between objects. Every JavaScript object has an internal property , which points to another object known as the prototype object. When trying to access a property or method of an object, if that object does not have the property or method, the JavaScript engine will look up the prototype chain until it finds the property or method. Java, as an object-oriented programming language, also has a concept similar to the prototype mechanism in JavaScript, but it uses class inheritance and interface implementation. Java does not have a direct equivalent to JavaScript's , but we can explore some mechanisms in Java that achieve similar functionality to some extent.\n\nis a special property that exists on all function objects. When a function is created, it automatically gets a property. This property is an object that serves as the prototype for newly created objects. When you create an object using a constructor function, the newly created object inherits properties and methods from the object.\n\nIn Vue.js, you can leverage JavaScript's prototype mechanism to extend Vue's prototype so that all Vue instances can share certain properties and methods. This is typically done by adding properties or methods to .\n\nThe above code adds a property named to Vue's prototype and includes custom modules. After this, you can access these methods through in any Vue instance.\n\ncan be an array or an object used to receive data from parent components. Props can be declared and registered on child components, with the values of the declared parameters defined in the parent component. Updates to parent props flow down to child components but not in reverse. can be simple arrays or use objects as alternatives, allowing for advanced options such as type checking, custom validation, and setting default values.\n\nUsed to register reference information for elements or child components, which will be registered on the parent component's object.\n\nVuex is a state management pattern specifically developed for Vue.js applications. It adopts a centralized storage model to manage the state of all components in the application and ensures that state changes occur in a predictable manner according to specific rules.\n\nThe core of every application is the , which contains most of the state ( ) in your application.\n\nState management has five core concepts: , , , , and .\n\nEach Vue instance goes through a series of initialization processes when created‚Äîsuch as setting up data listeners, compiling templates, mounting the instance to the DOM, and updating the DOM when data changes. During this process, some functions called lifecycle hooks are also executed.\n\nCalled after the component's DOM elements are mounted to the document DOM. In the code below, if a token is found, it directly redirects the page.\n\nNote that page visibility is an event that can be triggered repeatedly.\n\nWhen page a is first entered, a's onShow will be triggered.\n\nWhen a navigates to page b, a will trigger onHide, while b will trigger onShow.\n\nHowever, when b is closed, b will trigger onUnload, and at this point, when a is displayed again, it will trigger onShow again.\n\nIn tabbar pages (those configured in pages.json), switching between different tab pages will trigger their respective onShow and onHide.\n\nCalled immediately after the instance is created.\n\nListens for the initial rendering completion of the page and executes the written code; at this point, the component is fully mounted, and the DOM tree is available.\n\nIn the uni-app framework, pages are first created based on the configuration in pages.json. The DOM is created based on the template components in the page. After that, onload is triggered.\n\nSteps for displaying and using the bottom navigation bar tabBar in uni-app _uni-app Judging whether it is a tabbar interface-CSDN Blog\n\nThe list in tabBar is an array that can only configure a minimum of 2 and a maximum of 5 tabs, sorted in the order of the array. The tabBar settings are located in the file. Tabbar pages must be included in the pages array in the document.\n\nBy setting the following parameters in , you can avoid issues with the app being obscured by the phone's top status bar or water drop screen. You can also add a visual block at the top to fill the top status bar area to solve this issue.\n\nis a local storage API provided by uni-app for storing data on the client side. It is similar to the and in the Web Storage API. Vuex is the official state management pattern for , used to centrally manage the state of all components in the application. Local storage is a way to store data on the client side, while state management is a pattern for centrally managing the state of an application.\n‚Ä¢ Storage Location: stores data in the client's local storage; Vuex store stores data in memory.\n‚Ä¢ Persistence: Data in is persistent; data in the Vuex store will be lost after the page refreshes.\n‚Ä¢ Reactivity: Data in the Vuex store is reactive; data in is not reactive.\n‚Ä¢ State Management: The Vuex store provides complex state management functions; is mainly used for simple data storage.\n‚Ä¢ Security: Data in is more vulnerable to attacks; data in the Vuex store is better protected because it is in memory rather than client-side local storage.\n\nIn the JS files under the store folder, you can see the stored global variables.\n\nA Comprehensive Understanding of Uniapp's setStorage, setStorageSync, getStorage, and getStorageSync (with Demo) _uni.getstorage-CSDN Blog\n\nCache data for use on other pages.\n‚Ä¢ : Asynchronously stores data in local storage, providing callback functions for success, failure, and completion.\n‚Ä¢ : Asynchronously retrieves data from local storage, providing callback functions for success, failure, and completion.\n\nChoose to use the uniapp community's select-lay - DCloud Plugin Market plugin. This plugin can achieve custom data index objects, which work well for displaying single selections of complex data structures.\n\nThe custom data structure is written as follows:\n\nThe value must match the variable value that the selection box ultimately passes; otherwise, the result of the selection will not be displayed in the UI after selection.\n\nIn the UI, different components can be displayed on top of others by setting different layers through parameters.\n\nIn uniapp, some components can set the component's layer using the parameter. The z-index property sets the z-axis order of elements during rendering. In the same stacking context, elements with a higher z-index will cover those with a lower z-index. In simple terms, the higher the value set for this parameter, the higher it will be displayed.\n\nThe default value of z-index on the app side is 0, while on the web side, it is auto.\n\ncan be an array or an object used to receive data from parent components. can be simple arrays or use objects as alternatives, allowing for advanced options such as type checking, custom validation, and setting default values.\n\nThe method is a JavaScript array method used to test whether at least one element in the array satisfies the provided testing function. If at least one element causes the testing function to return , then the method will return ; otherwise, it returns .\n\nCheck if corresponding two sets of variables are the same.\n\nWhen using uview to send requests, it can be configured in advance. Below is the configuration provided by the uview official website. By defining and exporting the configuration, global settings for all requests can be achieved. If the datatype in headers is not configured, uview defaults to sending a body request with POST. If you want to send data using a POST request, you need to modify the value of Content-Type in headers.\n\nWhen sending a query request with POST, the value of Content-Type in headers should be , while for sending a body request, it should be . Since the above is a global setting and the project uses POST to send query data less frequently, you can set the value of Content-Type in headers separately when sending query requests.\n‚Ä¢ Use to select an image from files and use to upload the image. After selecting the image, get the file path and upload it to the server using the POST protocol with . At the same time, receive the image address returned by the server.\n\nIdea: Format the data returned from the backend into a format accepted by the component and implement it through the chart component.\n‚Ä¢ indicates whether the component should respond to touch events.\n‚Ä¢ specifies that the chart type is a line chart.\n‚Ä¢ is an object containing the chart configuration, set in local JS, such as axis labels, grid lines, etc.\n‚Ä¢ is an object containing the dataset to be displayed.\n\nThe built-in table in uniapp cannot complete operations like merging cells, and directly using and may cause compatibility issues across different platforms.\n\nDirectly use the , , and tags in HTML. It is important to note that v-for cannot be used in the following tags:\n\nIn practical use, if you want to use a loop to display data of different lengths returned from the backend, you can nest another layer outside."
    },
    {
        "link": "https://vuejs.org/api/built-in-directives.html",
        "document": "\n‚Ä¢ None works by setting the element's textContent property, so it will overwrite any existing content inside the element. If you need to update the part of , you should use mustache interpolations instead.\n‚Ä¢ None Contents of are inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates using , try to rethink the solution by using components instead. Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS attacks. Only use on trusted content and never on user-provided content. In Single-File Components, styles will not apply to content inside , because that HTML is not processed by Vue's template compiler. If you want to target content with scoped CSS, you can instead use CSS modules or an additional, global element with a manual scoping strategy such as BEM.\n\nToggle the element's visibility based on the truthy-ness of the expression value.\n‚Ä¢ None works by setting the CSS property via inline styles, and will try to respect the initial value when the element is visible. It also triggers transitions when its condition changes.\n\nConditionally render an element or a template fragment based on the truthy-ness of the expression value.\n‚Ä¢ None When a element is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all. Can be used on to denote a conditional block containing only text or multiple elements. This directive triggers transitions when its condition changes. When used together, has a higher priority than . We don't recommend using these two directives together on one element ‚Äî see the list rendering guide for details.\n\nDenote the \"else block\" for or a / chain.\n‚Ä¢ None\n‚Ä¢ None Restriction: previous sibling element must have or .\n‚Ä¢ None Can be used on to denote a conditional block containing only text or multiple elements.\n‚Ä¢ None Now you see me\n\nDenote the \"else if block\" for . Can be chained.\n‚Ä¢ None\n‚Ä¢ None Restriction: previous sibling element must have or .\n‚Ä¢ None Can be used on to denote a conditional block containing only text or multiple elements.\n\nRender the element or template block multiple times based on the source data.\n‚Ä¢ None The directive's value must use the special syntax to provide an alias for the current element being iterated on: Alternatively, you can also specify an alias for the index (or the key if used on an Object): The default behavior of will try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with the special attribute: can also work on values that implement the Iterable Protocol, including native and .\n\nAttach an event listener to the element.\n‚Ä¢ None\n‚Ä¢ - only trigger handler if event was dispatched from this element.\n‚Ä¢ - only trigger handler on certain keys.\n‚Ä¢ - trigger handler at most once.\n‚Ä¢ - only trigger handler for right button mouse events.\n‚Ä¢ None The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present. When used on a normal element, it listens to native DOM events only. When used on a custom element component, it listens to custom events emitted on that child component. When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special property: . also supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n‚Ä¢ None <!-- the click event will be triggered at most once --> Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\nDynamically bind one or more attributes, or a component prop to an expression.\n‚Ä¢ None\n‚Ä¢ or (when using modifier)\n‚Ä¢ Omitting value (when attribute and bound value has the same name, requires 3.4+)\n‚Ä¢ None Expects: any (with argument) | Object (without argument)\n‚Ä¢ None\n‚Ä¢ - transform the kebab-case attribute name into camelCase.\n‚Ä¢ - force a binding to be set as a DOM property (3.2+).\n‚Ä¢ - force a binding to be set as a DOM attribute (3.2+).\n‚Ä¢ None When used to bind the or attribute, supports additional value types such as Array or Objects. See linked guide section below for more details. When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an operator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using or modifiers. This is sometimes necessary, especially when working with custom elements. When used for component prop binding, the prop must be properly declared in the child component. When used without an argument, can be used to bind an object containing attribute name-value pairs.\n‚Ä¢ None <!-- prop binding. \"prop\" must be declared in the child component. --> <!-- pass down parent props in common with a child component --> The modifier also has a dedicated shorthand, : The modifier allows camelizing a attribute name when using in-DOM templates, e.g. the SVG attribute: is not needed if you are using string templates, or pre-compiling the template with a build step.\n‚Ä¢ None Expects: varies based on value of form inputs element or output of components\n‚Ä¢ None\n‚Ä¢ - listen to events instead of\n\nDenote named slots or scoped slots that expect to receive props.\n‚Ä¢ None Expects: JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.\n\nSkip compilation for this element and all its children.\n‚Ä¢ None Inside the element with , all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.\n‚Ä¢ None will not be compiled }}</\n\nRender the element and component once only, and skip future updates.\n‚Ä¢ None On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance. >This will never change: {{msg}}</ Since 3.2, you can also memoize part of the template with invalidation conditions using .\n‚Ä¢ None Memoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example: When the component re-renders, if both and remain the same, all updates for this and its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused. It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied. with an empty dependency array ( ) would be functionally equivalent to . is provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering large lists (where ): When the component's state changes, a large amount of VNodes will be created even though most of the items remained exactly the same. The usage here is essentially saying \"only update this item if it went from non-selected to selected, or the other way around\". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to include in the memo dependency array here since Vue automatically infers it from the item's . When using with , make sure they are used on the same element. does not work inside . can also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.\n\nUsed to hide un-compiled template until it is ready.\n‚Ä¢ None This directive is only needed in no-build-step setups. When using in-DOM templates, there can be a \"flash of un-compiled templates\": the user may see raw mustache tags until the mounted component replaces them with rendered content. will remain on the element until the associated component instance is mounted. Combined with CSS rules such as , it can be used to hide the raw templates until the component is ready.\n‚Ä¢ None The will not be visible until the compilation is done."
    },
    {
        "link": "https://vuejs.org/guide/essentials/list",
        "document": "We can use the directive to render a list of items based on an array. The directive requires a special syntax in the form of , where is the source data array and is an alias for the array element being iterated on:\n\nInside the scope, template expressions have access to all parent scope properties. In addition, also supports an optional second alias for the index of the current item:\n\nThe variable scoping of is similar to the following JavaScript:\n\nNotice how the value matches the function signature of the callback. In fact, you can use destructuring on the item alias similar to destructuring function arguments:\n\nFor nested , scoping also works similar to nested functions. Each scope has access to parent scopes:\n\nYou can also use as the delimiter instead of , so that it is closer to JavaScript's syntax for iterators:\n\nYou can also use to iterate through the properties of an object. The iteration order will be based on the result of calling on the object:\n\nYou can also provide a second alias for the property's name (a.k.a. key):\n\nAnd another for the index:\n\ncan also take an integer. In this case it will repeat the template that many times, based on a range of .\n\nNote here starts with an initial value of instead of .\n\nSimilar to template , you can also use a tag with to render a block of multiple elements. For example:\n\nWhen they exist on the same node, has a higher priority than . That means the condition will not have access to variables from the scope of the :\n\nThis can be fixed by moving to a wrapping tag (which is also more explicit):\n\nWhen Vue is updating a list of elements rendered with , by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\n\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique attribute for each item:\n\nWhen using , the should be placed on the container:\n\nIt is recommended to provide a attribute with whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\n\nThe binding expects primitive values - i.e. strings and numbers. Do not use objects as keys. For detailed usage of the attribute, please see the API documentation.\n\nYou can directly use on a component, like any normal element (don't forget to provide a ):\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\nThe reason for not automatically injecting into the component is because that makes the component tightly coupled to how works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. , and , which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one:\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nIn situations where computed properties are not feasible (e.g. inside nested loops), you can use a method:\n\nBe careful with and in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:"
    },
    {
        "link": "https://medium.com/free-code-camp/an-introduction-to-dynamic-list-rendering-in-vue-js-a70eea3e321",
        "document": "List rendering is one of the most commonly used practices in front-end web development. Dynamic list rendering is often used to present a series of similarly grouped information in a concise and friendly format to the user. In almost every web application we use, we can see lists of content in numerous areas of the app.\n\nIn this article we‚Äôll gather an understanding of Vue‚Äôs directive in generating dynamic lists. We‚Äôll also go through some examples of why the attribute should be used when doing so.\n\nSince we‚Äôll be explaining things thoroughly as we start to write code, this article assumes you‚Äôll have no or very little knowledge with Vue (and/or other JavaScript frameworks).\n\nWe‚Äôre going to use Twitter as the case study for this article.\n\nWhen logged in and in the main index route of Twitter, we‚Äôre presented with a view similar to this:\n\nOn the homepage, we‚Äôve become accustomed to seeing a list of trends, a list of tweets, a list of potential followers, and so on. The content displayed in these lists depends on a multitude of factors ‚Äî our Twitter history, whom we follow, our likes, and so on. As a result, we can say all this data is dynamic.\n\nThough this data is dynamically obtained, the way this data is shown remains the same. This is in part due to using reusable web components.\n\nFor example, we can see the list of tweets as a list of single items. We can think of as a shell that takes data of sorts, such as the username, handle, tweet, and avatar, among other pieces, and simply displays those pieces in a consistent markup.\n\nLet‚Äôs say we wanted to render a list of components (like a list of items) based on a large data source obtained from a server. In Vue, the first thing that should come to mind to accomplish this is the directive.\n\nThe directive is used to render a list of items based on a data source. The directive can be used on a template element and requires a specific syntax along the lines of:\n\nLet‚Äôs see an example of this in practice. First, we‚Äôll assume we‚Äôve already obtained a collection of tweet data:\n\nis a collection of objects with each containing details of that particular tweet‚Äîa unique identifier, the name/handle of the account, tweet message, and so on. Let‚Äôs now attempt to use the directive to render a list of tweet components based on this data.\n\nFirst and foremost, we‚Äôll create the Vue instance ‚Äî the heart of the Vue application. We‚Äôll mount/attach our instance to a DOM element of id and assign the collection as part of the instance‚Äôs data object.\n\nWe‚Äôll now go ahead and create a that our directive will use to render a list. We‚Äôll use the global constructor to create a component named :\n\nA few interesting things to note here:\n‚Ä¢ The expects a object prop as seen in the prop validation requirement ( ). If the component is rendered with a prop that is not an object, Vue will emit warnings.\n‚Ä¢ We‚Äôre binding the properties of the tweet object prop on to the component template with the help of the Mustache syntax: .\n‚Ä¢ The component markup adapts Bulma‚Äôs Box element as it represents a good resemblance to a tweet.\n\nIn the HTML template, we‚Äôll need to create the markup where our Vue app will be mounted (i.e. the element with the id of ). Within this markup, we‚Äôll use the directive to render a list of tweets.\n\nSince is the data collection we‚Äôll be iterating over, will be an appropriate alias to use in the directive. In each rendered , we‚Äôll also pass in the iterated object as props for it to be accessed in the component.\n\nRegardless of how many more tweet objects would be introduced to the collection, or how they‚Äôll change over time ‚Äî our set up will always render all the tweets in the collection in the same markup we expect.\n\nWith the help of some custom CSS, our app will look something like this:\n\nThough everything works as expected, we may be prompted with a Vue tip in our browser console:\n\nNote: You may not be able to see the warning in the browser console when running the code through CodePen.\n\nWhy is Vue telling us to specify explicit keys in our list when everything works as expected?\n\nIt‚Äôs common practice to specify a key attribute for every iterated element within a rendered list. This is because Vue uses the attribute to create unique bindings for each node‚Äôs identity.\n\nLet‚Äôs explain this some more ‚Äî if there were any dynamic UI changes to our list (for example, order of list items gets shuffled), Vue will opt towards changing data within each element instead of moving the DOM elements accordingly. This won‚Äôt be an issue in most cases. However, in certain instances where our list depends on DOM state and/or child component state, this can cause some unintended behavior.\n\nLet‚Äôs see an example of this. What if our simple tweet component now contained an input field that will allow the user to directly respond to the tweet message? We‚Äôll ignore how this response could be submitted and simply address the new input field itself:\n\nWe‚Äôll include this new input field on to the template of :\n\nAssume we wanted to introduce another new feature into our app. This feature would involve allowing the user to shuffle a list of tweets randomly.\n\nTo do this, we can first include a ‚ÄúShuffle!‚Äù button in our HTML template:\n\nWe‚Äôve attached a click event listener on the button element to call a method when triggered. In our Vue instance, we‚Äôll create the method responsible for randomly shuffling the collection in the instance. We‚Äôll use lodash‚Äôs _shuffle method to achieve this:\n\nLet‚Äôs try it out! If we click shuffle a few times, we‚Äôll notice our tweet elements get randomly assorted with each click.\n\nHowever, if we type some information in the input of each component and then click shuffle, we‚Äôll notice something peculiar happening:\n\nSince we haven‚Äôt opted to use the attribute, Vue has not created unique bindings to each tweet node. As a result, when we‚Äôre aiming to reorder the tweets, Vue takes the more performant saving approach to simply change (or patch) data in each element. Since the temporary DOM state (that is, the inputted text) remains in place, we experience this unintended mismatch.\n\nHere‚Äôs a diagram that shows us the data that gets patched on to each element and the DOM state that remains in place:\n\nTo avoid this; we‚Äôll have to assign a unique key to every rendered in the list.\n\nWe‚Äôll use the of a to be the unique identifier since we should safely say a tweet‚Äôs shouldn‚Äôt be equal to that of another. Because we‚Äôre using dynamic values, we‚Äôll use the directive to bind our key to the :\n\nNow, Vue recognizes each tweet‚Äôs node identity, so it‚Äôll reorder the components when we intend on shuffling the list.\n\nSince each tweet component is now being moved accordingly, we can take this a step further and use Vue‚Äôs to show how the elements are being reordered.\n\nTo do this, we‚Äôll add the element as a wrapper to the list. We'll specify a transition name of and declare that the transition group should be rendered as a element.\n\nBased on the name of the transition, Vue will automatically recognize if any CSS transitions/animations have been specified. Since we aim to invoke a transition for the movement of items in the list, Vue will look for a specified CSS transition along the lines of (where is the name given to our transition group).\n\nAs a result, we'll manually introduce a class that has a specified type and time of transition:\n\nNote: This is a very brief look into applying list transitions. Be sure to check out the Vue docs for detailed information on all the different types of transitions that can be applied!\n\nOur elements will now transition appropriately between locations when a shuffle is invoked. Give it a try! Type some information in the input fields and click ‚ÄúShuffle!‚Äù a few times.\n\nPretty cool, right? Without the attribute, the transition-group element can‚Äôt be used to create list transitions since the elements are patched in place instead of being reordered.\n\nShould the attribute always be used? It‚Äôs recommended. The Vue docs specify that the key attribute should only be omitted if:\n‚Ä¢ We intentionally want the default manner of patching elements in place for performance reasons.\n‚Ä¢ The DOM content is simple enough.\n\nAnd there we have it! Hopefully this short article portrayed how useful the directive is as well as provided a little more context to why the attribute is often used. Let me know if you may have any questions/thoughts whatsoever!\n\nIf you liked my style of writing and are potentially interested in learning how to build real world apps with Vue, you may like the book Fullstack Vue: The Complete Guide to Vue.js that I helped publish! The book covers numerous facets of Vue including routing, simple state management, form handling, Vuex, server persistence, and testing, among other topics. If you‚Äôre interested and/or would like to try a sample chapter, you can get more information from our website https://fullstack.io/vue!\n\nIf you have any questions/thoughts/opinions, you‚Äôre more than welcome to reach out to me anytime @djirdehh!"
    },
    {
        "link": "https://freecodecamp.org/news/an-introduction-to-dynamic-list-rendering-in-vue-js-a70eea3e321",
        "document": "List rendering is one of the most commonly used practices in front-end web development. Dynamic list rendering is often used to present a series of similarly grouped information in a concise and friendly format to the user. In almost every web application we use, we can see lists of content in numerous areas of the app.\n\nIn this article we‚Äôll gather an understanding of Vue‚Äôs directive in generating dynamic lists. We‚Äôll also go through some examples of why the attribute should be used when doing so.\n\nSince we‚Äôll be explaining things thoroughly as we start to write code, this article assumes you‚Äôll have no or very little knowledge with Vue (and/or other JavaScript frameworks).\n\nWe‚Äôre going to use Twitter as the case study for this article.\n\nWhen logged in and in the main index route of Twitter, we‚Äôre presented with a view similar to this:\n\nOn the homepage, we‚Äôve become accustomed to seeing a list of trends, a list of tweets, a list of potential followers, and so on. The content displayed in these lists depends on a multitude of factors ‚Äî our Twitter history, whom we follow, our likes, and so on. As a result, we can say all this data is dynamic.\n\nThough this data is dynamically obtained, the way this data is shown remains the same. This is in part due to using reusable web components.\n\nFor example, we can see the list of tweets as a list of single items. We can think of as a shell that takes data of sorts, such as the username, handle, tweet, and avatar, among other pieces, and simply displays those pieces in a consistent markup.\n\nLet‚Äôs say we wanted to render a list of components (like a list of items) based on a large data source obtained from a server. In Vue, the first thing that should come to mind to accomplish this is the directive.\n\nThe directive is used to render a list of items based on a data source. The directive can be used on a template element and requires a specific syntax along the lines of:\n\nLet‚Äôs see an example of this in practice. First, we‚Äôll assume we‚Äôve already obtained a collection of tweet data:\n\nis a collection of objects with each containing details of that particular tweet‚Äîa unique identifier, the name/handle of the account, tweet message, and so on. Let‚Äôs now attempt to use the directive to render a list of tweet components based on this data.\n\nFirst and foremost, we‚Äôll create the Vue instance ‚Äî the heart of the Vue application. We‚Äôll mount/attach our instance to a DOM element of id and assign the collection as part of the instance‚Äôs data object.\n\nWe‚Äôll now go ahead and create a that our directive will use to render a list. We‚Äôll use the global constructor to create a component named :\n\nA few interesting things to note here:\n‚Ä¢ The expects a object prop as seen in the prop validation requirement ( ). If the component is rendered with a prop that is not an object, Vue will emit warnings.\n‚Ä¢ We‚Äôre binding the properties of the tweet object prop on to the component template with the help of the Mustache syntax: .\n‚Ä¢ The component markup adapts Bulma‚Äôs Box element as it represents a good resemblance to a tweet.\n\nIn the HTML template, we‚Äôll need to create the markup where our Vue app will be mounted (i.e. the element with the id of ). Within this markup, we‚Äôll use the directive to render a list of tweets.\n\nSince is the data collection we‚Äôll be iterating over, will be an appropriate alias to use in the directive. In each rendered , we‚Äôll also pass in the iterated object as props for it to be accessed in the component.\n\nRegardless of how many more tweet objects would be introduced to the collection, or how they‚Äôll change over time ‚Äî our set up will always render all the tweets in the collection in the same markup we expect.\n\nWith the help of some custom CSS, our app will look something like this:\n\nThough everything works as expected, we may be prompted with a Vue tip in our browser console:\n\nNote: You may not be able to see the warning in the browser console when running the code through CodePen.\n\nWhy is Vue telling us to specify explicit keys in our list when everything works as expected?\n\nIt‚Äôs common practice to specify a key attribute for every iterated element within a rendered list. This is because Vue uses the attribute to create unique bindings for each node‚Äôs identity.\n\nLet‚Äôs explain this some more ‚Äî if there were any dynamic UI changes to our list (for example, order of list items gets shuffled), Vue will opt towards changing data within each element instead of moving the DOM elements accordingly. This won‚Äôt be an issue in most cases. However, in certain instances where our list depends on DOM state and/or child component state, this can cause some unintended behavior.\n\nLet‚Äôs see an example of this. What if our simple tweet component now contained an input field that will allow the user to directly respond to the tweet message? We‚Äôll ignore how this response could be submitted and simply address the new input field itself:\n\nWe‚Äôll include this new input field on to the template of :\n\nAssume we wanted to introduce another new feature into our app. This feature would involve allowing the user to shuffle a list of tweets randomly.\n\nTo do this, we can first include a ‚ÄúShuffle!‚Äù button in our HTML template:\n\nWe‚Äôve attached a click event listener on the button element to call a method when triggered. In our Vue instance, we‚Äôll create the method responsible for randomly shuffling the collection in the instance. We‚Äôll use lodash‚Äôs _shuffle method to achieve this:\n\nLet‚Äôs try it out! If we click shuffle a few times, we‚Äôll notice our tweet elements get randomly assorted with each click.\n\nHowever, if we type some information in the input of each component and then click shuffle, we‚Äôll notice something peculiar happening:\n\nSince we haven‚Äôt opted to use the attribute, Vue has not created unique bindings to each tweet node. As a result, when we‚Äôre aiming to reorder the tweets, Vue takes the more performant saving approach to simply change (or patch) data in each element. Since the temporary DOM state (that is, the inputted text) remains in place, we experience this unintended mismatch.\n\nHere‚Äôs a diagram that shows us the data that gets patched on to each element and the DOM state that remains in place:\n\nTo avoid this; we‚Äôll have to assign a unique key to every rendered in the list.\n\nWe‚Äôll use the of a to be the unique identifier since we should safely say a tweet‚Äôs shouldn‚Äôt be equal to that of another. Because we‚Äôre using dynamic values, we‚Äôll use the directive to bind our key to the :\n\nNow, Vue recognizes each tweet‚Äôs node identity, so it‚Äôll reorder the components when we intend on shuffling the list.\n\nSince each tweet component is now being moved accordingly, we can take this a step further and use Vue‚Äôs to show how the elements are being reordered.\n\nTo do this, we‚Äôll add the element as a wrapper to the list. We'll specify a transition name of and declare that the transition group should be rendered as a element.\n\nBased on the name of the transition, Vue will automatically recognize if any CSS transitions/animations have been specified. Since we aim to invoke a transition for the movement of items in the list, Vue will look for a specified CSS transition along the lines of (where is the name given to our transition group).\n\nAs a result, we'll manually introduce a class that has a specified type and time of transition:\n\nNote: This is a very brief look into applying list transitions. Be sure to check out the Vue docs for detailed information on all the different types of transitions that can be applied!\n\nOur elements will now transition appropriately between locations when a shuffle is invoked. Give it a try! Type some information in the input fields and click ‚ÄúShuffle!‚Äù a few times.\n\nPretty cool, right? Without the attribute, the transition-group element can‚Äôt be used to create list transitions since the elements are patched in place instead of being reordered.\n\nShould the attribute always be used? It‚Äôs recommended. The Vue docs specify that the key attribute should only be omitted if:\n‚Ä¢ We intentionally want the default manner of patching elements in place for performance reasons.\n‚Ä¢ The DOM content is simple enough.\n\nAnd there we have it! Hopefully this short article portrayed how useful the directive is as well as provided a little more context to why the attribute is often used. Let me know if you may have any questions/thoughts whatsoever!\n\nIf you liked my style of writing and are potentially interested in learning how to build real world apps with Vue, you may like the book Fullstack Vue: The Complete Guide to Vue.js that I helped publish! The book covers numerous facets of Vue including routing, simple state management, form handling, Vuex, server persistence, and testing, among other topics. If you‚Äôre interested and/or would like to try a sample chapter, you can get more information from our website https://fullstack.io/vue!\n\nIf you have any questions/thoughts/opinions, you‚Äôre more than welcome to reach out to me anytime @djirdehh!"
    },
    {
        "link": "https://stackoverflow.com/questions/46631134/how-to-render-components-dynamically-in-vue-js",
        "document": "I am making a form generator, which uses components in it for input fields, buttons etc. I want to be able to generate the form depending on what options I pass to it.\n\nBut I can't get it to render the components.\n\nI tried to return pure HTML but that won't render the components.\n\nI call the form generator from my Home.vue template where I want the form with an options object like this:\n\nIn the form generator component I have tried multiple things like:\n\nI include all the components like:\n\nNow the final part is how do I make render?\n\nThis does not work since it outputs the HTML literally:"
    },
    {
        "link": "https://sciredev.com/blog/list-rendering-and-loops-in-vue-js-best-practices-for-performance-optimization",
        "document": "Vue.js, known for its simplicity and flexibility, provides powerful tools for rendering lists and performing loops efficiently. List rendering is a fundamental aspect of web development, especially when dealing with dynamic data. In this article, we'll explore how to effectively render lists and loops in Vue.js while optimizing performance for better user experiences.\n\nVue.js offers several directives to render lists and perform loops effortlessly:\n\nThe directive allows you to iterate over a variety of data structures including arrays, objects, and ranges.\n\nThe attribute is crucial when rendering lists in Vue.js. It helps Vue.js identify each DOM element uniquely, enabling efficient updates and re-renders.\n\nTo optimize list rendering performance and ensure smooth user experiences, consider the following best practices:\n\nEnsure that each item rendered within a loop has a unique attribute. This allows Vue.js to efficiently track and update DOM elements.\n\nWhile it's tempting to use the array index as the attribute, it's not recommended, especially when dealing with dynamic lists where items can be added, removed, or reordered. Instead, use a unique identifier for each item.\n\nWhen dealing with filtered lists, consider using computed properties to avoid re-rendering the entire list on each filter change. Computed properties cache results and only recompute when their dependencies change.\n\nOptimizing list rendering in Vue.js involves improving performance and reducing unnecessary re-renders. Here are some additional optimization techniques:\n\nMemoization involves caching the results of expensive function calls to avoid redundant computations.You can use the directive for Memoization in Vue.js. The directive in Vue.js provides a way to memoize a sub-tree of the template, optimizing performance by skipping updates if the dependency values remain unchanged. This directive is especially useful in performance-critical scenarios, such as rendering large v-for lists, where updates need to be minimized.\n‚Ä¢ Ensure that is used on the same element as v-for. does not work inside v-for.\n‚Ä¢ When using , it's crucial to specify the dependency array correctly to avoid skipping necessary updates.\n\nFor large lists, consider implementing virtual scrolling techniques such as using libraries like vue-virtual-scroller. Virtual scrolling renders only the visible portion of the list, improving performance and reducing memory usage.\n\nMastering list rendering and loops in Vue.js is essential for building efficient and scalable applications. By understanding Vue.js directives, following best practices, and implementing optimization techniques, you can ensure smooth and performant list rendering experiences for your users. Remember to always prioritize performance and usability when working with dynamic data in Vue.js applications."
    }
]