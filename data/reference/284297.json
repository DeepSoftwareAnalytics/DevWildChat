[
    {
        "link": "https://quizlet.com/study-guides/filtering-customers-in-chinook-database-a9838bbf-6985-4731-a0b4-8e128d85eb04",
        "document": ""
    },
    {
        "link": "https://brainly.com/question/50279237",
        "document": ""
    },
    {
        "link": "https://madushanpathriana.medium.com/sql-for-data-analytics-where-clause-and-case-expression-1e75a469cde5",
        "document": "You can use SQL not only to extract tables from a database as it is, but you can also filter data based on business logic. We will continue with the Chinook data set introduced in the first article. In the first article, we introduced how to install DBeaver, connect Chinook database, and how to write basic Select queries. Here is the first article if you missed it.\n\nÂ· WHERE clause\n\n âˆ˜ Arithmetic Operators\n\n âˆ˜ Logical Operators\n\n âˆ˜ NULL values\n\n âˆ˜ IN condition\n\n âˆ˜ BETWEEN condition\n\nAssume you need to retrieve customer details but not all customers, but details of a specific list of customers. Then you need to use WHERE clause to filter data based on a condition. Conditional statements in the select clause restrict the selection of rows in the database. (WHERE clause is used to filter records)\n\nBelow query select customers from Brazil. Query checks all the values in Country column, and select only the rows where it matches with Brazil. Then return the selected rows. This is how WHRER clause works. It selects the rows where it meets the given conditions.\n\nArithmetic operators are required to write conditions in SQL. As an example, customers older than 30 years old write as customer_age >30.\n\nArithmetic Operators used in the where clause\nâ€¢ >= Greater than or equal to\nâ€¢ <= Less than or equal to\n\nLet's use the where clause in a query. Customer table contains customer's country and their names. We will filter customers only in BRAZIL and select customer FIRSTNAME, LASTNAME and COUNTRY in the below query.\n\nnote : Country column data type is NVARCHAR. That means country values are text values. SQL requires to enclose text values by single quotes or double quotes. But numerical values do not need to enclose.\n\nSelect customers FIRSTNAME, LASTNAME and CUSTOMERID where CUSTOMERID is lesser than or equal to 5.\n\nWhat if we need to filter data based on multiple filters or filter rows that do not meet given conditions? Then you need to use Logical Operators.\n\nLogical operators used in the where clause\n\nWhen there are multiple conditions to filter data and all the conditions need to be satisfied then we can use AND operator to combine conditions. As an example, let's filter Invoices where BillingCountry equals â€˜Germanyâ€™ and Total is greater than or equal to 5 from Invoices table.\n\nConsider when you have multiple conditions and you need to filter data that meet at least one of the conditions. Then you have to use OR operator. Let's filter invoices where the billing city is â€˜Berlinâ€™ or â€˜Frankfurtâ€™ from the Invoices table.\n\nSometimes we need to filter data that do not meet our conditions. As an example in the Employee table, there are multiple job titles. We need to fetch employees who are not IT staff.\n\nnote: you can write the same query as below using != (not equal) operator\n\nOk, now we know how to use logical operators and arithmetic operators to filter data. Let's see how we can combine multiple logical operators and arithmetic operators to write slightly complex conditions within the same query.\n\nLet's filter sales staff who are not born after 1965â€“01â€“01 from Employees table.\nâ€¢ To select only sales staff, their title should be either â€˜Sales Managerâ€™ or â€˜Sales Support Agentâ€™. Hence we can combine that two conditions by OR operator. In order to separate this condition from other conditions, it should enclose with brackets.\nâ€¢ To select employees who are born after 1965â€“01â€“01 we can use NOT operator\nâ€¢ Now we need to combine the above two conditions we can use AND operator. That means selected employees must be â€˜Sales Managerâ€™ or â€˜Sales Support Agentâ€™ and not born after 1965â€“01â€“01.\n\nnote: Birthday is a Datetime column. Datatime variables should enclose with single quotes or double quotes.\n\nIf you use OR operator instead of AND operator query will select rows that fulfill at least one of the conditions. It will return all the sales staff and anyone who is not born after â€˜1965â€“01â€“01â€™\n\nSometimes not all rows and columns are filled with value. There are empty rows in a column. Such empty values are known as Null values. Arithmetic operators or logical operators can not recognize null values. Hence IS NULL is used to check if the field contains a null value or not.\n\nIS NOT NULL is used to see if a field is not null\n\nIn the customers table, company column has Null values.\n\nLet's write a query to select customers' First names whose company name is null.\n\nIn contrary, you can use the below query to select the First names of customers whom where company is not null.\n\nWe learned we can use OR condition to select rows that match multiple values in the same column (where column= â€˜aâ€™ OR column =â€™bâ€™ OR â€¦). But if we large number of items to check then it will be a tedious task to write a length query with multiple OR conditions. IN conditions come in handy in such situations. IN condition checks if the values in a column are present in list when selecting.\n\nnote: list of items should be enclosed with parentheses.\n\nWe used OR condition to filter sales staff from the Employees table. Lets use IN condition to filter Sales manager and Sales support agent from the Employees table.\n\nIf you need to filter rows based on a range of values you should use BETWEEN condition.\n\nBetween condition includes both start and end values to the range. As an example, you can select invoices where the total is between 10 and 25. Below query select rows where total is greater than or equal 10 and less than or equal 25.\n\nNow you know how to use WHERE clause to filter data. In the next article, we will discuss further how to use WHERE clause to filter data based on patterns in text fields and how to create new columns based on business logic ðŸ‘‡ ."
    },
    {
        "link": "https://community.dataquest.io/t/chinook-sql-not-returning-correct-count/545891",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/29548151/sql-trigger-for-chinook-database-condition-when-sum-is-null",
        "document": "I am brushing up on my SQL and using the Chinook database for practice.\n\nthe data model can be found here: https://chinookdatabase.codeplex.com/wikipage?title=Chinook_Schema&referringTitle=Documentation\n\nThe goal is to write a trigger so that the Total in the Invoice table is updated when I insert or delete invoicelines.\n\nand this works great when I insert and delete invoiceline records, except for when I delete the very last invoiceline for an invoice. When I do that, i get the error:\n\nCannot insert the value NULL into column 'Total', table 'Chinook.dbo.Invoice'; column does not allow nulls. UPDATE fails.\n\nso basically I need to set it to zero if sum(LineSum) is null\n\nI am struggling to figure out how to structure the conditional, can anyone please help?"
    },
    {
        "link": "https://sqlite.org/lang_select.html",
        "document": "The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.\n\nThe \"select-stmt\" syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following \"factored-select-stmt\" is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.\n\nNote that there are paths through the syntax diagrams that are not allowed in practice. Some examples:\nâ€¢ A VALUES clause can be the first element in a compound SELECT that uses a WITH clause, but a simple SELECT that consists of just a VALUES clause cannot be preceded by a WITH clause.\nâ€¢ The WITH clause must occur on the first SELECT of a compound SELECT. It cannot follow a compound-operator.\n\nThese and other similar syntax restrictions are described in the text.\n\nThe SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.\n\nThe core of a SELECT statement is a \"simple SELECT\" shown by the select-core and simple-select-stmt syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.\n\nGenerating the results of a simple SELECT statement is presented as a four step process in the description below:\nâ€¢ FROM clause processing: The input data for the simple SELECT is determined. The input data is either implicitly a single row with 0 columns (if there is no FROM clause) or is determined by the FROM clause.\nâ€¢ WHERE clause processing: The input data is filtered using the WHERE clause expression.\nâ€¢ GROUP BY, HAVING and result-column expression processing: The set of result rows is computed by aggregating the data according to any GROUP BY clause and calculating the result-set expressions for the rows of the filtered input dataset.\nâ€¢ DISTINCT/ALL keyword processing: If the query is a \"SELECT DISTINCT\" query, duplicate rows are removed from the set of result rows.\n\nThere are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.\n\nThe input data used by a simple SELECT query is a set of N rows each M columns wide.\n\nIf the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e. N=1 and M=0).\n\nIf a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the collation sequence and affinity of the corresponding expression in the subquery statement.\n\nIf there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific join-operator and join-constraint used to connect the tables or subqueries together.\n\nAll joins in SQLite are based on the cartesian product of the left and right-hand datasets. The columns of the cartesian product dataset are, in order, all the columns of the left-hand dataset followed by all the columns of the right-hand dataset. There is a row in the cartesian product dataset formed by combining each unique combination of a row from the left-hand and right-hand datasets. In other words, if the left-hand dataset consists of N rows of M columns, and the right-hand dataset of N rows of M columns, then the cartesian product is a dataset of N Ã—N rows, each containing M +M columns.\n\nIf the join-operator is \"CROSS JOIN\", \"INNER JOIN\", \"JOIN\" or a comma (\",\") and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:\nâ€¢ If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a boolean expression. Only rows for which the expression evaluates to true are included from the dataset.\nâ€¢ If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression \"lhs.X = rhs.X\" is evaluated for each row of the cartesian product as a boolean expression. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence. For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.\nâ€¢ If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.\nâ€¢ If the join-operator is a \"LEFT JOIN\" or \"LEFT OUTER JOIN\", then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that does not match any row in the right-hand dataset. The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.\nâ€¢ If the join-operator is a \"RIGHT JOIN\" or \"RIGHT OUTER JOIN\", then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original right-hand input dataset that does not match any row in the left-hand dataset. The added rows contain NULL values in the columns that would normally contain values copied from the left-hand input dataset.\nâ€¢ A \"FULL JOIN\" or \"FULL OUTER JOIN\" is a combination of a \"LEFT JOIN\" and a \"RIGHT JOIN\". Extra rows of output are added for each row in left dataset that matches no rows in the right, and for each row in the right dataset that matches no rows in the left. Unmatched columns are filled in with NULL.\n\nWhen more than two tables are joined together as part of a FROM clause, the join operations are processed in order from left to right. In other words, the FROM clause (A join-op-1 B join-op-2 C) is computed as ((A join-op-1 B) join-op-2 C).\n\nThere is no difference between the \"INNER JOIN\", \"JOIN\" and \",\" join operators. They are completely interchangeable in SQLite. The \"CROSS JOIN\" join operator produces the same result as the \"INNER JOIN\", \"JOIN\" and \",\" operators, but is handled differently by the query optimizer in that it prevents the query optimizer from reordering the tables in the join. An application programmer can use the CROSS JOIN operator to directly influence the algorithm that is chosen to implement the SELECT statement. Avoid using CROSS JOIN except in specific situations where manual control of the query optimizer is desired. Avoid using CROSS JOIN early in the development of an application as doing so is a premature optimization. The special handling of CROSS JOIN is an SQLite-specific feature and is not a part of standard SQL.\n\nIf a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a boolean expression. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.\n\nFor a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT or RIGHT or FULL OUTER JOIN, the difference is very important. In an outer join, the extra NULL rows for non-matched rows on the other operand are added after ON clause processing but before WHERE clause processing. A constraint of the form \"left.x=right.y\" in an ON clause will therefore allow through for the added all-NULL rows. But if that same constraint is in the WHERE clause, a NULL in one of \"right.y\" or \"left.x\" will prevent the expression \"left.x=right.y\" from being true, and thus exclude that row from the output.\n\nGeneration of the set of result rows\n\nOnce the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.\n\nThe list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression \"*\" then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by \".*\" then all columns from the named table or subquery are substituted for the single expression. It is an error to use a \"*\" or \"alias.*\" expression in any context other than a result expression list. It is also an error to use a \"*\" or \"alias.*\" expression in a simple SELECT query that does not have a FROM clause.\n\nThe number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.\nâ€¢ None If the SELECT statement is a non-aggregate query, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.\nâ€¢ None If the SELECT statement is an aggregate query without a GROUP BY clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values. The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.\nâ€¢ None If the SELECT statement is an aggregate query with a GROUP BY clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset according to the processing rules stated below for ORDER BY expressions. Each row is then assigned to a \"group\" based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for selecting a collation sequence with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do not have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions. If a HAVING clause is specified, it is evaluated once for each group of rows as a boolean expression. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result. Each expression in the result-set is then evaluated once for each group of rows. If the expression is an aggregate expression, it is evaluated across all rows in the group. Otherwise, it is evaluated against a single arbitrarily chosen row from within the group. If there is more than one non-aggregate expression in the result-set, then all such expressions are evaluated for the same row. Each group of input dataset rows contributes a single row to the set of result rows. Subject to filtering associated with the DISTINCT keyword, the number of rows returned by an aggregate query with a GROUP BY clause is the same as the number of groups of rows produced by applying the GROUP BY and HAVING clauses to the filtered input dataset.\n\nThe usual case is that all column names in an aggregate query are either arguments to aggregate functions or else appear in the GROUP BY clause. A result column which contains a column name that is not within an aggregate function and that does not appear in the GROUP BY clause (if one exists) is called a \"bare\" column. Example:\n\nIn the query above, the \"a\" column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for \"a\". The \"c\" column is contained within the sum() aggregate function and so that output column is the sum of all \"c\" values in rows that have the same value for \"a\". But what is the result of the bare column \"b\"? The answer is that the \"b\" result will be the value for \"b\" in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute \"b\", and so in many cases the value for \"b\" is undefined.\n\nSpecial processing occurs when the aggregate function is either min() or max(). Example:\n\nIf there is exactly one min() or max() aggregate in the query, then all bare columns in the result set take values from an input row which also contains the minimum or maximum. So in the query above, the value of the \"b\" column in the output will be the value of the \"b\" column in the input row that has the largest \"c\" value. There are limitations on this special behavior of min() and max():\nâ€¢ If the same minimum or maximum value occurs on two or more rows, then bare values might be selected from any of those rows. The choice is arbitrary. There is no way to predict from which row the bare values will be choosen. The choice might be different for different bare columns within the same query.\nâ€¢ If there are two or more min() or max() aggregates in the query, then bare column values will be taken from one of the rows on which one of the aggregates has their minimum or maximum value. The choice of which min() or max() aggregate determines the selection of bare column values is arbitrary. The choice might be different for different bare columns within the same query.\nâ€¢ This special processing for min() or max() aggregates only works for the built-in implementation of those aggregates. If an application overrides the built-in min() or max() aggregates with application-defined alternatives, then the values selected for bare columns will be taken from an arbitrary row.\n\nMost other SQL database engines disallow bare columns. If you include a bare column in a query, other database engines will usually raise an error. The ability to include bare columns in a query is an SQLite-specific extension. This is considered a feature, not a bug. See the discussion on SQLite Forum thread 7481d2a6df8980ff for additional information.\n\nOne of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The usual rules apply for selecting a collation sequence to compare text values.\n\nTwo or more simple SELECT statements may be connected together to form a compound SELECT using the UNION, UNION ALL, INTERSECT or EXCEPT operator, as shown by the following diagram:\n\nIn a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain ORDER BY or LIMIT clauses. ORDER BY and LIMIT clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a VALUES clause.\n\nA compound SELECT created using the UNION ALL operator returns all the rows from the SELECT to the left of the UNION ALL operator, and all the rows from the SELECT to the right of it. The UNION operator works the same way as UNION ALL, except that duplicate rows are removed from the final result set. The INTERSECT operator returns the intersection of the results of the left and right SELECTs. The EXCEPT operator returns the subset of rows returned by the left SELECT that are not also returned by the right-hand SELECT. Duplicate rows are removed from the results of INTERSECT and EXCEPT operators before the result set is returned.\n\nFor the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.\n\nWhen three or more simple SELECTs are connected into a compound SELECT, they group from left to right. In other words, if \"A\", \"B\" and \"C\" are all simple SELECT statements, (A op B op C) is processed as ((A op B) op C).\n\nIf a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.\n\nIn a compound SELECT statement, only the last or right-most simple SELECT may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a compound SELECT is a VALUES clause, then no ORDER BY clause is allowed on that statement.\n\nRows are first sorted based on the results of evaluating the left-most expression in the ORDER BY list, then ties are broken by evaluating the second left-most expression and so on. The order in which two rows for which all ORDER BY expressions evaluate to equal values are returned is undefined. Each ORDER BY expression may be optionally followed by one of the keywords ASC (smaller values are returned first) or DESC (larger values are returned first). If neither ASC or DESC are specified, rows are sorted in ascending (smaller values first) order by default.\n\nSQLite considers NULL values to be smaller than any other values for sorting purposes. Hence, NULLs naturally appear at the beginning of an ASC order-by and at the end of a DESC order-by. This can be changed using the \"ASC NULLS LAST\" or \"DESC NULLS FIRST\" syntax.\n\nEach ORDER BY expression is processed as follows:\nâ€¢ None If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).\nâ€¢ None If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.\nâ€¢ None Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.\n\nFor the purposes of sorting rows, values are compared in the same way as for comparison expressions. The collation sequence used to compare two text values is determined as follows:\nâ€¢ None If the ORDER BY expression is assigned a collation sequence using the postfix COLLATE operator, then the specified collation sequence is used.\nâ€¢ None Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix COLLATE operator, then the collation sequence assigned to the aliased expression is used.\nâ€¢ None Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.\nâ€¢ None Otherwise, the BINARY collation sequence is used.\n\nIn a compound SELECT statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.\n\nThe LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.\n\nIn a compound SELECT, only the last or right-most simple SELECT may contain a LIMIT clause. In a compound SELECT, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most simple SELECT is a VALUES clause then no LIMIT clause is allowed.\n\nAny scalar expression may be used in the LIMIT clause, so long as it evaluates to an integer or a value that can be losslessly converted to an integer. If the expression evaluates to a NULL value or any other value that cannot be losslessly converted to an integer, an error is returned. If the LIMIT expression evaluates to a negative value, then there is no upper bound on the number of rows returned. Otherwise, the SELECT returns the first N rows of its result set only, where N is the value that the LIMIT expression evaluates to. Or, if the SELECT statement would return less than N rows without a LIMIT clause, then the entire result set is returned.\n\nThe expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.\n\nInstead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the \"OFFSET\" keyword and avoid using a LIMIT clause with a comma-separated offset.\n\nThe phrase \"VALUES(expr-list)\" means the same thing as \"SELECT expr-list\". The phrase \"VALUES(expr-list-1),...,(expr-list-N)\" means the same thing as \"SELECT expr-list-1 UNION ALL ... UNION ALL SELECT expr-list-N\". Both forms are the same, except that the number of SELECT statements in a compound is limited by SQLITE_LIMIT_COMPOUND_SELECT whereas the number of rows in a VALUES clause has no arbitrary limit.\n\nThere are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:\nâ€¢ None A VALUES clause cannot be followed by ORDER BY.\nâ€¢ None A VALUES clause cannot be followed by LIMIT.\n\nSELECT statements may be optionally preceded by a single WITH clause that defines one or more common table expressions for use within the SELECT statement.\n\nTable-valued Functions In The FROM Clause\n\nA virtual table that contains hidden columns can be used like a table-valued function in the FROM clause. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table. Additional information can be found in the virtual table documentation.\n\nThe SELECT syntax of SQLite differs slightly from standard SQL. These differences are due to several reasons:\nâ€¢ None In the mid-2000s, there was a lot of emphasis on keeping the library footprint as small as possible, so as not to use too much space on memory-limited flip-phones and similar.\nâ€¢ None During the early years of SQLite, the lead developer sought to follow Postel's Law and to be forgiving and flexible in what input was accepted.\nâ€¢ None There were bugs in early SQLite parsers that accepts some strange inputs.\nâ€¢ None The lead developer's knowledge of SQL was imperfect.\n\nWhatever the origin of the input quirks, we generally avoid trying to \"fix\" them, as any new restrictions on the input syntax would likely cause at least some of the millions of applications that use SQLite to break. We do not want that. The goal of the SQLite development team is to preserve backwards compability to the fullest extent possible. Hence, if a syntax quirk is harmless, we leave it alone and document it here, rather than try to fix it.\n\nSQLite accepts all of the usual syntax for JOIN operators:\n\nBut it does not stop there. SQLite is actually very flexible in how you specify a join operator. The general syntax is:\n\nWhere there are between 1 and 3 instances of \"blah\", each of which can be any of \"CROSS\", \"FULL\", \"INNER\", \"LEFT\", \"NATURAL\", \"OUTER\", or \"RIGHT\". The SQLite parser treats each of these keywords as an attribute of the join, which can be combined in any order. This creates the possibility of many new and creative join types beyond what is specified by the syntax diagram. Some of these non-standard join types are specifically disallowed. For example, you cannot say \"INNER OUTER JOIN\", because that would be contradictory. But you can say things like \"OUTER LEFT NATURAL JOIN\" which means the same as \"NATURAL LEFT OUTER JOIN\". Or you can say \"LEFT RIGHT JOIN\" which is the same as \"FULL JOIN\".\n\nRemember: you can use these non-standard join types but you ought not. Stick to using standard JOIN syntax for portability with other SQL database engines.\n\nStandard SQL has tighter restrictions on join syntax than does SQLite. In standard SQL, all joins other than comma-joins, CROSS JOINs, and NATURAL joins must have either an ON clause or a USING clause and comma-joins, CROSS JOINs, and NATURAL joins must not have either an ON or USING clause. SQLite is not nearly so fussy about join syntax. SQLite will accept and process an ON or USING clause on a comma-join or CROSS JOIN, and will let you omit the ON or USING clause from any join at all. In SQLite, the only restrictions are:\nâ€¢ None You cannot have an ON or USING clause on a NATURAL join.\nâ€¢ None You cannot have both an ON clause and a USING clause on the same join.\n\nSQLite even allows you to omit the ON or USING clause from an outer join, though doing so means that the outer join is unconstrained (as if the ON clause where \" \") which make the outer join behave like an inner join.\n\nIn standard SQL, joins that use the JOIN keyword take higher precedence than comma-joins. That is to say, JOIN operators happen before comma operators. This is not the case in SQLite, where all joins have the same precedence.\n\nConsider this example:\n\nIn standard SQL, the FULL JOIN between t2 and t3 would occur first, and then the result of the left join would be cross-joined against t1. But SQLite always handles all joins from left to right. Thus, SQLite will do a cross join on t1 and t2 first, then the result of that cross join will feed into the FULL JOIN with t3. Inner joins are inherently associative, so the difference is only evident if your FROM clause contains one or more outer joins.\n\nYou can work around this, and make your SQL statements portable across all systems, by observing the following stylistic rules:\nâ€¢ None Do not mix comma-joins with the JOIN keyword. It is fine to use comma-joins, but if you do, the you should use only comma-joins for the entire FROM clause.\nâ€¢ None When in doubt, use parentheses to specify the exact join order that you intend.\n\nAny one of these suggestions is sufficient to avoid problems, and most programmers instinctively follow all of these suggestions without having to be told, and so the lack of precedence difference between comma-joins and the JOIN keyword in SQLite rarely comes up in practice. But you should be aware of the problem, in case it ever does appear.\n\nThis page last modified on 2024-12-02 23:58:06 UTC"
    },
    {
        "link": "https://sqlitetutorial.net/sqlite-where",
        "document": "Summary: in this tutorial, you will learn how to use SQLite clause to specify the search condition for rows returned by the query.\n\nThe clause is an optional clause of the statement. It appears after the clause as the following statement:\n\nIn this example, you add a clause to the statement to filter rows returned by the query. When evaluating a statement with a clause, SQLite uses the following steps:\nâ€¢ First, check the table in the clause.\nâ€¢ Second, evaluate the conditions in the clause to get the rows that met these conditions.\nâ€¢ Third, make the final result set based on the rows in the previous step with columns in the clause.\n\nThe search condition in the has the following form:\n\nFor example, you can form a search condition as follows:\n\nBesides the statement, you can use the clause in the and statements.\n\nA comparison operator tests if two expressions are the same. The following table illustrates the comparison operators that you can use to construct expressions:\n\nLogical operators allow you to test the truth of some expressions. A logical operator returns 1, 0, or a NULL value.\n\nNotice that SQLite does not provide Boolean data type therefore 1 means TRUE, and 0 means FALSE.\n\nThe following table illustrates the SQLite logical operators:\n\nWe will use the table in the sample database to illustrate how to use the clause.\n\nThe equality operator ( ) is the most commonly used operator. For example, the following query uses the clause the equality operator to find all the tracks in the album id 1:\n\nSQLite compares the values stored in the column with a literal value to test if they are equal. Only the rows that satisfy the condition are returned.\n\nWhen comparing two values, you need to ensure they are the same data type. You should compare numbers with numbers, string with strings, and so on.\n\nIn case you compare values in different data types e.g., a string with a number, SQLite has to perform implicit data type conversions, but in general, you should avoid doing this.\n\nYou use the logical operator to combine expressions. For example, to get tracks of the album 1 that have the length greater than 200,000 milliseconds, you use the following statement:\n\nThe statement used two expressions and . It uses the logical operator to combine these expressions.\n\nUsing WHERE clause with LIKE operator example\n\nSometimes, you may not remember exactly the data you want to search. In this case, you perform an inexact search using the operator.\n\nFor example, to find which tracks were composed by , you use the operator as follows:\n\nYou get tracks composed by R.A. Smith-Diesel, Adrian Smith, etc.\n\nUsing SQLite WHERE clause with the IN operator example\n\nThe operator allows you to check whether a value is in a list of a comma-separated list of values. For example, to find tracks that have media type id is 2 or 3, you use the operator as shown in the following statement:\n\nIn this tutorial, you have learned how to use the SQLite clause to filter rows in the final result set using comparison and logical operators."
    },
    {
        "link": "https://sqlite.org/lang.html",
        "document": "SQLite understands most of the standard SQL language. But it does omit some features while at the same time adding a few features of its own. This document attempts to describe precisely what parts of the SQL language SQLite does and does not support. A list of SQL keywords is also provided. The SQL language syntax is described by syntax diagrams.\n\nThe following syntax documentation topics are available:\n\nThe routines sqlite3_prepare_v2(), sqlite3_prepare(), sqlite3_prepare16(), sqlite3_prepare16_v2(), sqlite3_exec(), and sqlite3_get_table() accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.\n\nEach SQL statement in the statement list is an instance of the following:\n\nThis page last modified on 2024-04-01 12:41:31 UTC"
    },
    {
        "link": "https://stackoverflow.com/questions/46377710/sqlite-select-query-with-where-clause-in-python-return-none",
        "document": "My sqlite select query with where clause in python return none or empty (>>> )\n\nBut when I use simple select query without where clause it returns all data"
    },
    {
        "link": "https://sqlitetutorial.net/sqlite-select",
        "document": "Summary: in this tutorial, you will learn how to use SQLite statement to query data from a single table.\n\nThe statement is one of the most commonly used statements in SQL. The SQLite statement provides all features of the statement in SQL standard.\n\nThe following example show how to use the statement to perform a simple calculation:\n\nYou can use multiple expressions in the statement as follows:\n\nQuerying data from a table using the SELECT statement\n\nWe often use the statement to query data from one or more tables.\n\nHereâ€™s the syntax of the statement:\n\nThe statement is the most complex statement in SQLite. To make it easier to understand each part, we will break the statement into multiple easy-to-understand tutorials.\nâ€¢ Use the ORDER BY clause to sort the result set.\nâ€¢ Use the DISTINCT clause to query unique rows in a table.\nâ€¢ Use the WHERE clause to filter rows in the result set.\nâ€¢ Use the LIMIT OFFSET clause to constrain the number of rows returned.\nâ€¢ Use the INNER JOIN or LEFT JOIN to query data from multiple tables using join.\nâ€¢ Use the GROUP BY clause to group rows into groups and apply aggregate functions to each group.\nâ€¢ Use the HAVING clause to filter groups.\n\nIn this tutorial, weâ€™ll focus on the simplest form of the statement that allows you to query data from a single table:\n\nEven though the clause appears before the clause, SQLite evaluates the clause first and then the clause, therefore:\nâ€¢ First, specify the table from which you want to get data in the clause. Notice that you can have more than one table in the clause. Weâ€™ll discuss it in the subsequent tutorial.\nâ€¢ Second, specify a column or a list of comma-separated columns in the clause.\n\nYou use the semicolon (;) to terminate the statement.\n\nLetâ€™s take a look at the table in the sample database.\n\nThe table contains columns and rows. It looks like a spreadsheet.\n\nTo get data from the tracks table such as trackid, track name, composer, and unit price, you use the following statement:\n\nYou specify a list column names, from which you want to get data, in the clause and the table in the clause. SQLite returns the following result:\n\nTo get data from all columns, you specify the columns of the table in the clause as follows:\n\nFor a table with many columns, the query would be so long that time-consuming to type. To avoid this, you can use the asterisk (*), which is the shorthand for all columns of the table as follows:\n\nThe query is shorter and cleaner now.\n\nYou should use the asterisk (*) for testing purposes only, not in the application development.\n\nWhen you develop an application, you should control what SQLite returns to your application. Suppose, a table has 3 columns, and you use the asterisk (*) to retrieve the data from all three columns.\n\nWhat if someone removes a column, your application would not be working properly, because it assumes that there are three columns returned, and the logic to process those three columns would be broken.\n\nIf someone adds more columns, your application may work but it gets more data than needed, which creates more I/O overhead between the database and application.\n\nSo try to avoid using the asterisk (*) as a good habit when you use the statement.\n\nIn this tutorial, you have learned how to use a simple form of the SQLite statement to query data from a single table."
    }
]