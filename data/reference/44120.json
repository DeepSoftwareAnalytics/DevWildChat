[
    {
        "link": "https://github.com/alejandrofsevilla/boost-tcp-server-client",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/19136659/boostasio-how-to-asynchronously-read-data-from-client-and-periodically-write-d",
        "document": "I'm very beginner with boost::asio, so please help me.\n\nI need write single-threaded TCP server . Server should accept client connections and continuously read from client sockets for input data. Periodically server should send data to clients . So I have some kind of problem - all examples describe case when we always have loop\n\nSo my decision was to use timer for checking for data to be send to socket.\n\nI wrote test server and have very strange behavior - it's work ok if clients connected, do something and disconnected one after another with some time delta . But if all clients disconnected simultaneously I have situation when timer handler try to use member classes of already DESTROYED object (locking critical section).\n\nI can't describe why ! Please help !\n\n[This video show how it's reproduced] (http://www.youtube.com/watch?v=NMWkD7rqf7Y&feature=youtu.be \"1080p\" )"
    },
    {
        "link": "https://codeproject.com/Articles/1264257/Socket-Programming-in-Cplusplus-using-boost-asio-T",
        "document": ""
    },
    {
        "link": "https://boost.org/doc/libs/1_63_0/doc/html/boost_asio.html",
        "document": "Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt )\n\nBoost.Asio is a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.\n\nLog of Boost.Asio changes made in each Boost release.\n\nExamples that illustrate the use of Boost.Asio in more complex applications.\n\nA tutorial that introduces the fundamental concepts required to use Boost.Asio, and shows how to use Boost.Asio to develop simple client and server programs.\n\nHow to use Boost.Asio in your applications. Includes information on library dependencies and supported platforms.\n\nAn overview of the features included in Boost.Asio, plus rationale and design information.\n\nMost programs interact with the outside world in some way, whether it be via a file, a network, a serial cable, or the console. Sometimes, as is the case with networking, individual I/O operations can take a long time to complete. This poses particular challenges to application development. Boost.Asio provides the tools to manage these long running operations, without requiring programs to use concurrency models based on threads and explicit locking. The Boost.Asio library is intended for programmers using C++ for systems programming, where access to operating system functionality such as networking is often required. In particular, Boost.Asio addresses the following goals:\n• The library should support a range of commonly used operating systems, and provide consistent behaviour across these operating systems.\n• The library should facilitate the development of network applications that scale to thousands of concurrent connections. The library implementation for each operating system should use the mechanism that best enables this scalability.\n• The library should support techniques such as scatter-gather I/O, and allow programs to minimise data copying.\n• Model concepts from established APIs, such as BSD sockets. The BSD socket API is widely implemented and understood, and is covered in much literature. Other programming languages often use a similar interface for networking APIs. As far as is reasonable, Boost.Asio should leverage existing practice.\n• The library should provide a lower entry barrier for new users by taking a toolkit, rather than framework, approach. That is, it should try to minimise the up-front investment in time to just learning a few basic rules and guidelines. After that, a library user should only need to understand the specific functions that are being used.\n• The library should permit the development of other libraries that provide higher levels of abstraction. For example, implementations of commonly used protocols such as HTTP. Although Boost.Asio started life focused primarily on networking, its concepts of asynchronous I/O have been extended to include other operating system resources such as serial ports, file descriptors, and so on.\n\nBoost.Asio contains classes and class templates for basic SSL support. These classes allow encrypted communication to be layered on top of an existing stream, such as a TCP socket. Before creating an encrypted stream, an application must construct an SSL context object. This object is used to set SSL options such as verification mode, certificate files, and so on. As an illustration, client-side initialisation may look something like: To use SSL with a TCP socket, one may write: To perform socket-specific operations, such as establishing an outbound connection or accepting an incoming one, the underlying socket must first be obtained using the template's member function: In some use cases the underlying stream object will need to have a longer lifetime than the SSL stream, in which case the template parameter should be a reference to the stream type: SSL handshaking must be performed prior to transmitting or receiving data over an encrypted connection. This is accomplished using the template's handshake() or async_handshake() member functions. Once connected, SSL stream objects are used as synchronous or asynchronous read and write streams. This means the objects can be used with any of the read(), async_read(), write(), async_write(), read_until() or async_read_until() free functions. Boost.Asio provides various methods for configuring the way SSL certificates are verified: To simplify use cases where certificates are verified according to the rules in RFC 2818 (certificate verification for HTTPS), Boost.Asio provides a reusable verification callback as a function object: The following example shows verification of a remote host's certificate according to the rules used by HTTPS: SSL stream objects perform no locking of their own. Therefore, it is essential that all asynchronous SSL operations are performed in an implicit or explicit strand. Note that this means that no synchronisation is required (and so no locking overhead is incurred) in single threaded programs. OpenSSL is required to make use of Boost.Asio's SSL support. When an application needs to use OpenSSL functionality that is not wrapped by Boost.Asio, the underlying OpenSSL types may be obtained by calling or ."
    },
    {
        "link": "https://stackoverflow.com/questions/77880466/boost-asio-async-client",
        "document": "I'm trying to write a async client using Boost asio, I wrote the following code,\n\nThe client can connect successfully and the handler is being called. Using wireshark I can also see that write() function sends \"Hello, World\" message and gets a reply back, but neither of write or read handlers are getting called.\n\nI tried different stuff saw different sample codes but I couldn't figure it out. Also tried to write the same code using coroutine and the code can be found below but, I'm new to async sockets and Boost Asio and I wasn't sure what I'm still doing(But trying hard to get there),\n\nI would appreciate more experienced developers to point out my mistakes and how is best to do what I'm trying to do."
    },
    {
        "link": "https://stackoverflow.com/questions/19136659/boostasio-how-to-asynchronously-read-data-from-client-and-periodically-write-d",
        "document": "I'm very beginner with boost::asio, so please help me.\n\nI need write single-threaded TCP server . Server should accept client connections and continuously read from client sockets for input data. Periodically server should send data to clients . So I have some kind of problem - all examples describe case when we always have loop\n\nSo my decision was to use timer for checking for data to be send to socket.\n\nI wrote test server and have very strange behavior - it's work ok if clients connected, do something and disconnected one after another with some time delta . But if all clients disconnected simultaneously I have situation when timer handler try to use member classes of already DESTROYED object (locking critical section).\n\nI can't describe why ! Please help !\n\n[This video show how it's reproduced] (http://www.youtube.com/watch?v=NMWkD7rqf7Y&feature=youtu.be \"1080p\" )"
    },
    {
        "link": "https://stackoverflow.com/questions/46909397/boost-asio-async-read-until-followed-by-async-read",
        "document": "I used the async tcp server example from boost which is near to what my application is doing. The code example below is a fully working example.\n\nAt first I start an async read operation until the delimiter char. In this case it is the http header complete sequence. The request contains some payload which is \"hello world\" (11 bytes). For a simplified example I use lambda handlers here. The first handler is called wit a length of 148 which is the header including four bytes for the delimiter sequence.\n\nThe size of the buffer gives me 159 which is the whole request including the payload. So far everything works as expected. To receive the payload I call another async read operation but the handler is never called. The first I tried was to read 11 bytes but that didn't work so I tried to read just two bytes to check if it's working buts it isn't.\n\nThe streambuf already contains all the data but why is the async read handler not called. Shouldn't it be called immediately because the data is inside the buffer or is there any misuse of the api?\n\nI ended up checking calculating the bytes to read with the bytes inside the buffer. When there is no need for a \"true\" read operation I use io_server::post to add a wrapper for the handler. This seems as the best option for that purpose."
    },
    {
        "link": "https://boost.org/doc/libs/1_63_0/doc/html/boost_asio.html",
        "document": "Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt )\n\nBoost.Asio is a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.\n\nLog of Boost.Asio changes made in each Boost release.\n\nExamples that illustrate the use of Boost.Asio in more complex applications.\n\nA tutorial that introduces the fundamental concepts required to use Boost.Asio, and shows how to use Boost.Asio to develop simple client and server programs.\n\nHow to use Boost.Asio in your applications. Includes information on library dependencies and supported platforms.\n\nAn overview of the features included in Boost.Asio, plus rationale and design information.\n\nMost programs interact with the outside world in some way, whether it be via a file, a network, a serial cable, or the console. Sometimes, as is the case with networking, individual I/O operations can take a long time to complete. This poses particular challenges to application development. Boost.Asio provides the tools to manage these long running operations, without requiring programs to use concurrency models based on threads and explicit locking. The Boost.Asio library is intended for programmers using C++ for systems programming, where access to operating system functionality such as networking is often required. In particular, Boost.Asio addresses the following goals:\n• The library should support a range of commonly used operating systems, and provide consistent behaviour across these operating systems.\n• The library should facilitate the development of network applications that scale to thousands of concurrent connections. The library implementation for each operating system should use the mechanism that best enables this scalability.\n• The library should support techniques such as scatter-gather I/O, and allow programs to minimise data copying.\n• Model concepts from established APIs, such as BSD sockets. The BSD socket API is widely implemented and understood, and is covered in much literature. Other programming languages often use a similar interface for networking APIs. As far as is reasonable, Boost.Asio should leverage existing practice.\n• The library should provide a lower entry barrier for new users by taking a toolkit, rather than framework, approach. That is, it should try to minimise the up-front investment in time to just learning a few basic rules and guidelines. After that, a library user should only need to understand the specific functions that are being used.\n• The library should permit the development of other libraries that provide higher levels of abstraction. For example, implementations of commonly used protocols such as HTTP. Although Boost.Asio started life focused primarily on networking, its concepts of asynchronous I/O have been extended to include other operating system resources such as serial ports, file descriptors, and so on.\n\nBoost.Asio contains classes and class templates for basic SSL support. These classes allow encrypted communication to be layered on top of an existing stream, such as a TCP socket. Before creating an encrypted stream, an application must construct an SSL context object. This object is used to set SSL options such as verification mode, certificate files, and so on. As an illustration, client-side initialisation may look something like: To use SSL with a TCP socket, one may write: To perform socket-specific operations, such as establishing an outbound connection or accepting an incoming one, the underlying socket must first be obtained using the template's member function: In some use cases the underlying stream object will need to have a longer lifetime than the SSL stream, in which case the template parameter should be a reference to the stream type: SSL handshaking must be performed prior to transmitting or receiving data over an encrypted connection. This is accomplished using the template's handshake() or async_handshake() member functions. Once connected, SSL stream objects are used as synchronous or asynchronous read and write streams. This means the objects can be used with any of the read(), async_read(), write(), async_write(), read_until() or async_read_until() free functions. Boost.Asio provides various methods for configuring the way SSL certificates are verified: To simplify use cases where certificates are verified according to the rules in RFC 2818 (certificate verification for HTTPS), Boost.Asio provides a reusable verification callback as a function object: The following example shows verification of a remote host's certificate according to the rules used by HTTPS: SSL stream objects perform no locking of their own. Therefore, it is essential that all asynchronous SSL operations are performed in an implicit or explicit strand. Note that this means that no synchronisation is required (and so no locking overhead is incurred) in single threaded programs. OpenSSL is required to make use of Boost.Asio's SSL support. When an application needs to use OpenSSL functionality that is not wrapped by Boost.Asio, the underlying OpenSSL types may be obtained by calling or ."
    },
    {
        "link": "https://app.studyraid.com/en/read/12426/401296/basics-of-asio-coroutines",
        "document": "Asio's coroutine implementation builds on C++20's coroutine TS specification while maintaining backward compatibility with earlier standards. Unlike traditional callback-based asynchronous programming, coroutines enable sequential-looking code that preserves the benefits of non-blocking operations. This approach solves the \"callback hell\" problem by allowing developers to write asynchronous code with natural linear flow while maintaining efficient resource utilization.\n\nThe stackless nature enables efficient scaling to millions of concurrent operations while maintaining low memory footprint. This design choice reflects Asio's focus on high-performance networking applications where resource efficiency is critical.\n\nAsio coroutines utilize C++'s coroutine keywords with specific adaptations for network programming. A coroutine function must return and use for asynchronous operations. This structure allows suspension points where execution can yield control to the I/O service while maintaining local variable state.\n• The socket maintains its state across suspension points\n\nThis implementation handles full-duplex communication efficiently while maintaining readability. The coroutine preserves the socket object's state between read/write operations, avoiding complex state management required in callback-based approaches.\n\nCreating a production-ready server requires careful handling of acceptor loops and error conditions. The server structure leverages multiple coroutines working together through Asio's executor system.\n• Spawning new session coroutines for each connection\n\nThe function launches coroutines onto the executor, enabling parallel connection handling. Using in the main thread creates an efficient event loop that services all asynchronous operations without manual thread management.\n\nComplex network protocols often require sophisticated control flow. Asio coroutines support composition of asynchronous operations using logical operators and custom awaitables.\n\nThe operator creates an asynchronous operation that completes when either the read or timer finishes. This pattern is essential for implementing request timeouts without complex state tracking.\n\nProper resource management in coroutines requires understanding object lifetimes. The Asio executor system automatically manages coroutine frames, but developers must ensure referenced objects remain valid across suspension points.\n• Capturing parameters by value in coroutine frames\n• Using shared_ptr for data shared across async operations\n\nThis approach ensures the message buffer remains valid throughout the asynchronous write operation, even if the coroutine suspends execution mid-operation. The shared_ptr ownership model guarantees proper cleanup after the operation completes.\n\nEffective debugging of coroutines requires understanding their suspension points and execution flow. Asio provides hooks for customizing coroutine behavior and tracking execution.\n\nMastering these techniques enables building high-performance network applications while maintaining debuggability and code clarity. The combination of Asio's powerful abstraction and C++ coroutines creates a robust foundation for modern network programming challenges."
    },
    {
        "link": "https://app.studyraid.com/en/read/12426/401283/integrating-asio-with-existing-projects",
        "document": "Integrating Asio into existing C++ projects requires understanding its dual distribution models and header structure. The library offers two primary variants: standalone Asio (C++11 and later) and Boost.Asio. This choice impacts project configuration and dependency management. Developers must consider their project's C++ standard version, existing Boost dependencies, and long-term maintenance strategy when selecting the Asio variant.\n\nThe header-only nature of Asio simplifies initial integration but requires careful handling of platform-specific dependencies. While core functionality works out-of-the-box, features like SSL support necessitate linking with system libraries. This dual nature of header-only components combined with optional system dependencies creates unique integration challenges that must be addressed through proper build system configuration.\n\nThe code demonstrates the first integration step - header inclusion. The namespace alias pattern shown here addresses variant differences through a single configuration point. This approach allows switching between Asio variants by modifying just the alias declaration, maintaining code portability. The pattern is particularly valuable for projects that might need to support both variants during migration periods.\n\nEffective Asio integration requires adapting the project's build system to handle library dependencies and compilation flags. CMake has emerged as the de facto standard for modern C++ projects, offering robust dependency management and cross-platform support. The build system must account for Asio's header-only nature while properly handling its optional dependencies like OpenSSL.\n\nThis CMake configuration demonstrates proper dependency management. The commands locate Asio and OpenSSL installations, while handles include paths and linking. For header-only components like Asio, modern CMake interfaces properly propagate compilation definitions and include directories. The separation of concerns between Asio core and SSL support allows projects to optionally enable cryptographic features based on requirements.\n\nHandling Asio's dependencies requires a layered approach. The base library only needs C++ standard library support, but real-world integrations often require additional components. Projects must decide between bundling dependencies, relying on system packages, or using package managers like vcpkg or Conan. Each approach has trade-offs in terms of reproducibility, maintenance overhead, and deployment complexity.\n\nThe SSL context configuration demonstrates proper use of Asio's cryptographic features. The code requires OpenSSL development headers and libraries to be available during compilation and runtime. The certificate files' paths highlight the importance of asset management in integrated projects. This implementation uses runtime file loading rather than compile-time embedding, providing flexibility but requiring proper file deployment.\n\nIntegrating Asio's asynchronous model with existing threading architectures requires careful synchronization planning. The library's io_context forms the core of its event loop, but projects often need to combine this with existing thread pools or task scheduling systems. Proper strand usage becomes critical when mixing asynchronous operations with concurrent data access.\n\nThis thread-safe service implementation demonstrates proper strand usage for synchronization. The strand ensures sequential, non-concurrent execution of posted handlers, protecting shared resources without explicit mutex locks. The pattern integrates well with existing thread pools by allowing safe operation from any thread while maintaining Asio's asynchronous execution model.\n\nRobust error handling integration requires bridging Asio's error code system with existing exception handling or logging infrastructure. The library provides multiple error reporting mechanisms, requiring consistent conversion and propagation strategies. Projects must decide between exception-based and error code-based approaches while ensuring compatibility with existing error reporting systems.\n\nThe connection handling code demonstrates comprehensive error integration. The asynchronous connect operation uses a lambda handler that forwards to a centralized error handling function. This pattern allows consistent error processing across the application while converting Asio-specific error codes to project-specific exceptions. The approach maintains Asio's asynchronous nature while integrating with existing error management infrastructure.\n\nIntegrating Asio into performance-sensitive systems requires understanding its memory management and execution patterns. The library's buffer management strategies and asynchronous operation tracking must align with existing memory allocation practices. Projects should implement custom memory pools or allocators that integrate with Asio's handler allocation system for optimal performance.\n\nThis custom allocator integration demonstrates performance optimization techniques. The handler wrapper uses project-specific memory allocation while maintaining compatibility with Asio's asynchronous operations. The pattern allows existing memory management systems to work with Asio's handler allocation mechanism, reducing memory fragmentation and improving performance in high-throughput scenarios.\n\nIntegrating Asio into existing C++ projects requires methodical consideration of build systems, dependency management, threading models, and error handling strategies. By following these patterns and understanding the underlying mechanisms, developers can successfully incorporate Asio's powerful networking capabilities while maintaining project consistency and performance characteristics. The techniques shown provide a foundation for building maintainable, efficient network applications that leverage Asio's strengths within established codebases."
    }
]