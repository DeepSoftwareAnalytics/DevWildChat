[
    {
        "link": "https://geeksforgeeks.org/newtons-divided-difference-interpolation-formula",
        "document": "Interpolation is an estimation of a value within two known values in a sequence of values. Newton’s divided difference interpolation formula is an interpolation technique used when the interval difference is not same for all sequence of values. Suppose f(x ), f(x ), f(x )………f(x ) be the (n+1) values of the function y=f(x) corresponding to the arguments x=x , x , x …x , where interval differences are not same Then the first divided difference is given by\n\nThe second divided difference is given by\n\nand so on… Divided differences are symmetric with respect to the arguments i.e independent of the order of arguments. so, f[x , x ]=f[x , x ] f[x , x , x ]=f[x , x , x ]=f[x , x , x ] By using first divided difference, second divided difference as so on .A table is formed which is called the divided difference table. Divided difference table:\n• These are useful for interpolation.\n• Through difference table, we can find out the differences in higher order.\n• Differences at each stage in each of the columns are easily measured by subtracting the previous value from its immediately succeeding value.\n• The differences are found out successively between the two adjacent values of the y variable till the ultimate difference vanishes or become a constant.\n\nBelow is the implementation of Newton’s divided difference interpolation method."
    },
    {
        "link": "https://geeksforgeeks.org/newton-forward-backward-interpolation",
        "document": "Interpolation is the technique of estimating the value of a function for any intermediate value of the independent variable, while the process of computing the value of the function outside the given range is called extrapolation.\n\n\n\nForward Differences: The differences y1 – y0, y2 – y1, y3 – y2, ……, yn – yn–1 when denoted by dy0, dy1, dy2, ……, dyn–1 are respectively, called the first forward differences. Thus, the first forward differences are : \n\n \n\n\n\nNEWTON’S GREGORY FORWARD INTERPOLATION FORMULA : \n\n \n\nThis formula is particularly useful for interpolating the values of f(x) near the beginning of the set of values given. h is called the interval of difference and u = ( x – a ) / h, Here a is the first term.\n\n\n\nBelow is the implementation of the Newton forward interpolation method. \n\n\n\nTime Complexity: O(n^2) since there are two nested loops to fill the forward difference table and an additional loop to calculate the interpolated value.\n\nSpace Complexity: O(n^2), as the forward difference table is stored in a two-dimensional array with n rows and n columns.\n\n\n\nBackward Differences: The differences y1 – y0, y2 – y1, ……, yn – yn–1 when denoted by dy1, dy2, ……, dyn, respectively, are called first backward difference. Thus, the first backward differences are : \n\n\n\nNEWTON’S GREGORY BACKWARD INTERPOLATION FORMULA : \n\n \n\nThis formula is useful when the value of f(x) is required near the end of the table. h is called the interval of difference and u = ( x – an ) / h, Here an is last term.\n\nBelow is the implementation of the Newton backward interpolation method.\n\nTime Complexity : O(N*N) ,N is the number of rows."
    },
    {
        "link": "https://slideshare.net/slideshow/newton-forward-difference-interpolation-method/106778766",
        "document": ""
    },
    {
        "link": "https://psu.pb.unizin.org/polynomialinterpretation/chapter/chapter-two-newtons-divided-difference-interpolation",
        "document": "A quick word regarding Divided Difference. The title might suggest that derivatives are involved, and in a way that would be correct. The good news is that knowledge of derivatives is not necessary for this technique. However, students should be familiar with the concept of slope, slope-intercept form and how slope is calculated since the process utilizes the change in the dependent variable (commonly known as y or f(x)) divided by the change in the independent variable (commonly known as x).\n\nStudents may have already encountered Divided Difference technique in high school algebra when asked to analyze a set of data to determine the non-linear (usually quadratic) equation that produced the dependent variable, as the following example illustrates.\n\nGiven the following set of x values, determine the quadratic (2nd degree polynomial) that correctly produces the corresponding y values. Show in standard form:\n\nThis simplified use of Newton’s Divided Difference works because one of the x values is zero and there is a uniform distance of one between each x value.\n\nSince the 2nd divided differences are all the same this tells us that there is a quadratic solution\n\nBy plugging in the x,y values (0,2) we can easily solve for c as follows:\n\nOr simply [latex]c = 2[/latex]. Now that we know a and c we plug those in using one of the other points such as (1,-2.7) and solve for b as follows: [latex]2.3(1)^2 + b(1) + 2 = -2.7[/latex] which simplifies to [latex]b = -7[/latex]\n\nResulting in the solution equation of [latex]y = 2.3x^2 - 7x+2[/latex] which works for all given points and approximates everything in between.\n\nNewton’s Divided Difference Interpolation generalizes the above process. The given points no longer have to be in any particular order and the x values do not have to be spaced at uniform intervals; offering a welcome flexible technique.\n\nUsing Newton’s Divided Difference approach, let’s develop a polynomial that takes a limited number of data points (think points plotted on the coordinate plane) and fit them to a polynomial that is continuous across the interval.\n\nThis method is an iterative process that allows us to begin with one point. We can then add additional data points at our discretion, especially if we believe they will produce a better, more representative, polynomial.\n\nEach time we add a point the resulting polynomial increases by a degree resulting in a polynomial of degree one less than the number of points included in the interpolation process.\n\nThe following example illustrates the iterative process and demonstrates its validity.\n\nII) The Linear Solution: By adding a second point we move to a straight-line solution\n\nThis is accomplished by preserving the constant solution [latex]f_0(x) = 3[/latex] while adding a linear component that works for all points on the straight line passing through both given points as follows.\n\n[latex]f_1(x) = f_0(x) + a_1(x - (-2))[/latex] This added component will not alter the solution for [latex]f(-2)[/latex] while introducing the appropriate linear structure (degree one polynomial).\n\nSolving for [latex]f(x) = -4[/latex] ensuring f(x) will satisfy both points and everything on the line passing through the two given points.\n\nSimplifying [latex]f_1(x) = -7x – 11[/latex] since this is valid slope intercept form, we have a linear solution\n\nAdding a third point, allows for the development of a quadratic (2nd degree) equation. We repeat the process with the same goal:\n\npreserving the constant solution at the first point and the linear solution for first two points. The newly added third point will be satisfied by the previous linear solution plus the added quadratic component.\n\nthis component (in red) ensures this new solution works for previous points as well as establishing a valid quadratic form.\n\nAs a check we will plug in our three given values of x to verify it produces the corresponding given y values.\n\nWe have engaged in an iterative process. Utilizing generalized notation for the above we conducted three iterations, with an additional point added at each iteration.\n\nEach new iteration builds upon and preserves the previous solutions.\n\nIn general, the solution polynomial can continue to be increased one degree at a time solving for each new variable as long as additional points become available. This results in the following general form:\n\nNormally it is best to select the lowest order polynomial that is reasonable. Higher order polynomials can introduce unwanted error.\n\nThe table approach below offers a convenient methodology for manually calculating the constants. It lends itself to adding additional points as needed without having to start over.\n\nThe following Table Methodology illustrates and simplifies the above process.\n\nStarting at the right-hand column we backtrack diagonally left and up (circled in red). Backtracking left and downward would have produced the same simplified equation (circled in green)\n\nThis produces the following results: [latex]\\large f(x) = \\frac{38}{20}(x - (-2))(x - (-1)) + (-7(x - (-2)) + 3[/latex]\n\nThis satisfies the three given points as well as any interpolated points between the minimum and maximum value of x. Because it is a continuous function, it also produces extrapolated points beyond the range. These extrapolated points may or may not be valid for any particular situation being analyzed. That is part of the “Art” of interpolation which relies on the experience and expertise of the one studying a particular phenomenon.\n\nThe Sin function – An interesting example\n\nOne of the neat things we can use interpolation for is to create a polynomial that provides reasonable estimates of the sin (or cos) of an angle for any given measure. In fact, the numbers we will use are small and simple that even the Elimination (Substitution) approach will easily produce the desired result.\n\nThe Sine function illustrated on the coordinate plane"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated",
        "document": "The character identifies a string literal as an interpolated string. An interpolated string is a string literal that might contain interpolation expressions. When an interpolated string is resolved to a result string, the compiler replaces items with interpolation expressions by the string representations of the expression results.\n\nString interpolation provides a more readable, convenient syntax to format strings. It's easier to read than string composite formatting. The following example uses both features to produce the same output:\n\nYou can use an interpolated string to initialize a constant string. You can do that only if all interpolation expressions within the interpolated string are constant strings as well.\n\nTo identify a string literal as an interpolated string, prepend it with the symbol. You can't have any white space between the and the that starts a string literal.\n\nThe structure of an item with an interpolation expression is as follows:\n\nElements in square brackets are optional. The following table describes each element:\n\nThe following example uses optional formatting components described in the preceding table:\n\nBeginning with C# 11, you can use new-lines within an interpolation expression to make the expression's code more readable. The following example shows how new-lines can improve the readability of an expression involving pattern matching:\n\nBeginning with C# 11, you can use an interpolated raw string literal, as the following example shows:\n\nTo embed and characters in the result string, start an interpolated raw string literal with multiple characters. When you do that, any sequence of or characters shorter than the number of characters is embedded in the result string. To enclose any interpolation expression within that string, you need to use the same number of braces as the number of characters, as the following example shows:\n\nIn the preceding example, an interpolated raw string literal starts with two characters. You need to put every interpolation expression between double braces ( and ). A single brace is embedded into a result string. If you need to embed repeated or characters into a result string, use an appropriately greater number of characters to designate an interpolated raw string literal. If the string literal has more repeated braces than the number of characters, the and characters are grouped from inside to outside. In the preceding example, the literal interprets and as interpolated expressions. The outer and are included verbatim in the output string.\n\nTo include a brace, \"{\" or \"}\", in the text produced by an interpolated string, use two braces, \"{{\" or \"}}\". For more information, see the Escaping braces section of the Composite formatting article.\n\nAs the colon (\":\") has special meaning in an interpolation expression item, to use a conditional operator in an interpolation expression. Enclose that expression in parentheses.\n\nThe following example shows how to include a brace in a result string. It also shows how to use a conditional operator:\n\nAn interpolated verbatim string starts with both the and characters. You can use and in any order: both and are valid interpolated verbatim strings. For more information about verbatim strings, see the string and verbatim identifier articles.\n\nBy default, an interpolated string uses the current culture defined by the CultureInfo.CurrentCulture property for all formatting operations.\n\nTo resolve an interpolated string to a culture-specific result string, use the String.Create(IFormatProvider, DefaultInterpolatedStringHandler) method, which is available beginning with .NET 6. The following example shows how to do that:\n\nIn .NET 5 and earlier versions of .NET, use implicit conversion of an interpolated string to a FormattableString instance. Then, you can use an instance FormattableString.ToString(IFormatProvider) method or a static FormattableString.Invariant method to produce a culture-specific result string. The following example shows how to do that:\n\nFor more information about custom formatting, see the Custom formatting with ICustomFormatter section of the Formatting types in .NET article.\n\nIf you're new to string interpolation, see the String interpolation in C# interactive tutorial. You can also check another String interpolation in C# tutorial. That tutorial demonstrates how to use interpolated strings to produce formatted strings.\n\nThe compiler checks if an interpolated string is assigned to a type that satisfies the interpolated string handler pattern. An interpolated string handler is a type that converts the interpolated string into a result string. When an interpolated string has the type , it's processed by the System.Runtime.CompilerServices.DefaultInterpolatedStringHandler. For the example of a custom interpolated string handler, see the Write a custom string interpolation handler tutorial. Use of an interpolated string handler is an advanced scenario, typically required for performance reasons.\n\nIf an interpolated string has the type , it's typically transformed into a String.Format method call. The compiler can replace String.Format with String.Concat if the analyzed behavior would be equivalent to concatenation.\n\nIf an interpolated string has the type IFormattable or FormattableString, the compiler generates a call to the FormattableStringFactory.Create method.\n\nFor more information, see the Interpolated string expressions section of the C# language specification and the following new feature specifications:\n• String interpolation in C# 10 and .NET 6 (.NET blog)"
    },
    {
        "link": "https://stackoverflow.com/questions/597720/differences-between-a-multidimensional-array-and-an-array-of-arrays",
        "document": "If there is a difference? What is the best use for each one?\n\nWhat are the differences between multidimensional arrays double[,] and array of arrays double[][] in C#?\n\nArray of arrays (jagged arrays) are faster than multi-dimensional arrays and can be used more effectively. Multidimensional arrays have nicer syntax. If you write some simple code using jagged and multidimensional arrays and then inspect the compiled assembly with an IL disassembler you will see that the storage and retrieval from jagged (or single dimensional) arrays are simple IL instructions while the same operations for multidimensional arrays are method invocations which are always slower. Consider the following methods: static void SetElementAt(int[][] array, int i, int j, int value) { array[i][j] = value; } static void SetElementAt(int[,] array, int i, int j, int value) { array[i, j] = value; } Their IL will be the following: .method private hidebysig static void SetElementAt(int32[][] 'array', int32 i, int32 j, int32 'value') cil managed { // Code size 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: ldarg.1 IL_0002: ldelem.ref IL_0003: ldarg.2 IL_0004: ldarg.3 IL_0005: stelem.i4 IL_0006: ret } // end of method Program::SetElementAt .method private hidebysig static void SetElementAt(int32[0...,0...] 'array', int32 i, int32 j, int32 'value') cil managed { // Code size 10 (0xa) .maxstack 8 IL_0000: ldarg.0 IL_0001: ldarg.1 IL_0002: ldarg.2 IL_0003: ldarg.3 IL_0004: call instance void int32[0...,0...]::Set(int32, int32, int32) IL_0009: ret } // end of method Program::SetElementAt When using jagged arrays you can easily perform such operations as row swap and row resize. Maybe in some cases usage of multidimensional arrays will be more safe, but even Microsoft FxCop tells that jagged arrays should be used instead of multidimensional when you use it to analyse your projects.\n\nA multidimensional array creates a nice linear memory layout while a jagged array implies several extra levels of indirection. Looking up the value in a jagged array works like this:\n• Look up the element at index 3 (which is an array).\n• Look up the element at index 6 in that array (which is a value). For each dimension in this case, there's an additional look up (this is an expensive memory access pattern). A multidimensional array is laid out linearly in memory, the actual value is found by multiplying together the indexes. However, given the array , the property of that multidimensional array returns the total number of elements i.e. 10 * 30 = 300. The property of a jagged array is always 1, but a multidimensional array can have any rank. The method of any array can be used to get the length of each dimension. For the multidimensional array in this example returns 30. Indexing the multidimensional array is faster. e.g. given the multidimensional array in this example = 30 * 1 + 7 = 37, get the element at that index 37. This is a better memory access pattern because only one memory location is involved, which is the base address of the array. A multidimensional array therefore allocates a continuous memory block, while a jagged array does not have to be square, e.g. does not have to equal , which would be true for any multidimensional array. Performance wise, multidimensional arrays should be faster. A lot faster, but due to a really bad CLR implementation they are not. The first row are timings of jagged arrays, the second shows multidimensional arrays and the third, well that's how it should be. The program is shown below, FYI this was tested running Mono. (The Windows timings are vastly different, mostly due to the CLR implementation variations). On Windows, the timings of the jagged arrays are greatly superior, about the same as my own interpretation of what multidimensional array look up should be like, see 'Single()'. Sadly the Windows JIT-compiler is really stupid, and this unfortunately makes these performance discussions difficult, there are too many inconsistencies. These are the timings I got on Windows, same deal here, the first row are jagged arrays, second multidimensional and third my own implementation of multidimensional, note how much slower this is on Windows compared to Mono. using System; using System.Diagnostics; static class ArrayPref { const string Format = \"{0,7:0.000} \"; static void Main() { Jagged(); Multi(); Single(); } static void Jagged() { const int dim = 100; for(var passes = 0; passes < 10; passes++) { var timer = new Stopwatch(); timer.Start(); var jagged = new int[dim][][]; for(var i = 0; i < dim; i++) { jagged[i] = new int[dim][]; for(var j = 0; j < dim; j++) { jagged[i][j] = new int[dim]; for(var k = 0; k < dim; k++) { jagged[i][j][k] = i * j * k; } } } timer.Stop(); Console.Write(Format, (double)timer.ElapsedTicks/TimeSpan.TicksPerMillisecond); } Console.WriteLine(); } static void Multi() { const int dim = 100; for(var passes = 0; passes < 10; passes++) { var timer = new Stopwatch(); timer.Start(); var multi = new int[dim,dim,dim]; for(var i = 0; i < dim; i++) { for(var j = 0; j < dim; j++) { for(var k = 0; k < dim; k++) { multi[i,j,k] = i * j * k; } } } timer.Stop(); Console.Write(Format, (double)timer.ElapsedTicks/TimeSpan.TicksPerMillisecond); } Console.WriteLine(); } static void Single() { const int dim = 100; for(var passes = 0; passes < 10; passes++) { var timer = new Stopwatch(); timer.Start(); var single = new int[dim*dim*dim]; for(var i = 0; i < dim; i++) { for(var j = 0; j < dim; j++) { for(var k = 0; k < dim; k++) { single[i*dim*dim+j*dim+k] = i * j * k; } } } timer.Stop(); Console.Write(Format, (double)timer.ElapsedTicks/TimeSpan.TicksPerMillisecond); } Console.WriteLine(); } }\n\nWith the release of .NET 6 I decided it was a good time to revisit this topic. I rewrote the test code for new .NET and ran it with the requirement of each part running at least a second. The benchmark was done on AMD Ryzen 5600x. Results? It's complicated. It seems that Single array is the most performant for smaller and large arrays (< ~25x25x25 & > ~200x200x200) and Jagged arrays being fastest in between. Unfortunately it seems from my testing that multi-dimensional are by far the slowest option. At best performing twice as slow as the fastest option. But! It depends on what you need the arrays for because jagged arrays can take much longer to initialize on 50^3 cube the initialization was roughly 3 times longer than single dimensional. Multi-dimensional was only a little bit slower than single dimensional. The conclusion? If you need fast code, benchmark it yourself on the machine it's going to run on. CPU architecture can complete change the relative performance of each method. Method name Ticks/Iteration Scaled to the best Array size 1x1x1 (10,000,000 iterations): Jagged: 0.15 4.28 Single: 0.035 1 Multi-dimensional: 0.77 22 Array size 10x10x10 (25,000 iterations): Jagged: 15 1.67 Single: 9 1 Multi-dimensional: 56 6.2 Array size 25x25x25 (25,000 iterations): Jagged: 157 1.3 Single: 120 1 Multi-dimensional: 667 5.56 Array size 50x50x50 (10,000 iterations): Jagged: 1,140 1 Single: 2,440 2.14 Multi-dimensional: 5,210 4.57 Array size 100x100x100 (10,000 iterations): Jagged: 9,800 1 Single: 19,800 2 Multi-dimensional: 41,700 4.25 Array size 200x200x200 (1,000 iterations): Jagged: 161,622 1 Single: 175,507 1.086 Multi-dimensional: 351,275 2.17 Array size 500x500x500 (100 iterations): Jagged: 4,057.413 1.5 Single: 2,709,301 1 Multi-dimensional: 5,359,393 1.98 Don't trust me? Run it yourself and verify. Note: the constant size seems to give jagged arrays an edge, but is not significant enough to change the order in my benchmarks. I have measured in some instance ~7% decrease in performance when using size from user input for jagged arrays, no difference for single arrays and very small difference (~1% or less) for multi-dimensional arrays. It is most prominent in the middle where jagged arrays take the lead. using System.Diagnostics; const string Format = \"{0,7:0.000} \"; const int TotalPasses = 25000; const int Size = 50; Stopwatch timer = new(); var functionList = new List<Action> { Jagged, Single, SingleStandard, Multi }; Console.WriteLine(\"{0,5}{1,20}{2,20}{3,20}{4,20}\", \"Run\", \"Ticks\", \"ms\", \"Ticks/Instance\", \"ms/Instance\"); foreach (var item in functionList) { var warmup = Test(item); var run = Test(item); Console.WriteLine($\"{item.Method.Name}:\"); PrintResult(\"warmup\", warmup); PrintResult(\"run\", run); Console.WriteLine(); } static void PrintResult(string name, long ticks) { Console.WriteLine(\"{0,10}{1,20}{2,20}{3,20}{4,20}\", name, ticks, string.Format(Format, (decimal)ticks / TimeSpan.TicksPerMillisecond), (decimal)ticks / TotalPasses, (decimal)ticks / TotalPasses / TimeSpan.TicksPerMillisecond); } long Test(Action func) { timer.Restart(); func(); timer.Stop(); return timer.ElapsedTicks; } static void Jagged() { for (var passes = 0; passes < TotalPasses; passes++) { var jagged = new int[Size][][]; for (var i = 0; i < Size; i++) { jagged[i] = new int[Size][]; for (var j = 0; j < Size; j++) { jagged[i][j] = new int[Size]; for (var k = 0; k < Size; k++) { jagged[i][j][k] = i * j * k; } } } } } static void Multi() { for (var passes = 0; passes < TotalPasses; passes++) { var multi = new int[Size, Size, Size]; for (var i = 0; i < Size; i++) { for (var j = 0; j < Size; j++) { for (var k = 0; k < Size; k++) { multi[i, j, k] = i * j * k; } } } } } static void Single() { for (var passes = 0; passes < TotalPasses; passes++) { var single = new int[Size * Size * Size]; for (var i = 0; i < Size; i++) { int iOffset = i * Size * Size; for (var j = 0; j < Size; j++) { var jOffset = iOffset + j * Size; for (var k = 0; k < Size; k++) { single[jOffset + k] = i * j * k; } } } } } static void SingleStandard() { for (var passes = 0; passes < TotalPasses; passes++) { var single = new int[Size * Size * Size]; for (var i = 0; i < Size; i++) { for (var j = 0; j < Size; j++) { for (var k = 0; k < Size; k++) { single[i * Size * Size + j * Size + k] = i * j * k; } } } } } Lesson learned: Always include CPU in benchmarks, because it makes a difference. Did it this time? I don't know but I suspect it might've. I would like to update on this, because in .NET Core multi-dimensional arrays are faster than jagged arrays. I ran the tests from John Leidegren and these are the results on .NET Core 2.0 preview 2. I increased the dimension value to make any possible influences from background apps less visible. I looked into disassemblies and this is what I found I wasn't able to identify why single-dimensional arrays were still faster than multi-dimensional but my guess is that it has to do with some optimalization made on the CPU\n\nPreface: This comment is intended to address the answer provided by okutane regarding the performance difference between jagged arrays and multidimensional ones. The assertion that one type is slower than the other because of the method calls isn't correct. One is slower than the other because of more complicated bounds-checking algorithms. You can easily verify this by looking, not at the IL, but at the compiled assembly. For example, on my 4.5 install, accessing an element (via pointer in edx) stored in a two-dimensional array pointed to by ecx with indexes stored in eax and edx looks like so: sub eax,[ecx+10] cmp eax,[ecx+08] jae oops //jump to throw out of bounds exception sub edx,[ecx+14] cmp edx,[ecx+0C] jae oops //jump to throw out of bounds exception imul eax,[ecx+0C] add eax,edx lea edx,[ecx+eax*4+18] Here, you can see that there's no overhead from method calls. The bounds checking is just very convoluted thanks to the possibility of non-zero indexes, which is a functionality not on offer with jagged arrays. If we remove the , , and s for the non-zero cases, the code pretty much resolves to . This calculation is about as fast (one multiply could be replaced by a shift, since that's the whole reason we choose bytes to be sized as powers of two bits) as anything else for random access to an element. Another complication is that there are plenty of cases where a modern compiler will optimize away the nested bounds-checking for element access while iterating over a single-dimension array. The result is code that basically just advances an index pointer over the contiguous memory of the array. Naive iteration over multi-dimensional arrays generally involves an extra layer of nested logic, so a compiler is less likely to optimize the operation. So, even though the bounds-checking overhead of accessing a single element amortizes out to constant runtime with respect to array dimensions and sizes, a simple test-case to measure the difference may take many times longer to execute.\n\nJagged arrays are arrays of arrays or arrays in which each row contains an array of its own. These arrays can have lengths different than those in the other rows. Declaration and Allocation an Array of Arrays The only difference in the declaration of the jagged arrays compared to the regular multidimensional array is that we do not have just one pair of brackets. With the jagged arrays, we have a pair of brackets per dimension. We allocate them this way: int[][] exampleJaggedArray; jaggedArray = new int[2][]; jaggedArray[0] = new int[5]; jaggedArray[1] = new int[3]; The Initializing an array of arrays int[][] exampleJaggedArray = { new int[] {5, 7, 2}, new int[] {10, 20, 40}, new int[] {3, 25} }; Jagged arrays are an aggregation of references. A jagged array does not directly contain any arrays, but rather has elements pointing to them. The size is unknown and that is why CLR just keeps references to the internal arrays. After we allocate memory for one array-element of the jagged array, then the reference starts pointing to the newly created block in the dynamic memory. The variable exampleJaggedArray is stored in the execution stack of the program and points to a block in the dynamic memory, which contains a sequence of three references to other three blocks in memory; each of them contains an array of integer numbers – the elements of the jagged array:"
    },
    {
        "link": "https://code-maze.com/charp-multidimensional-jagged-array",
        "document": "There seems to be a fair amount of confusion about the two ways to model a multidimensional array in C#. We will explore differences and similarities and hopefully help you choose the best model for your project.\n\nIf you need to brush up on array basics you can check out the article C# Back to Basics – Arrays.\n\nThe most-mentioned difference between a multi-dimensional array and a jagged array is that all rows have the same size in a multidimensional array. In contrast, each row in a jagged array can have a different size. While this is an interesting feature, it may be a bit misleading.\n\nThese arrays possess a range of features, including row size, that are natural consequences of their different abstractions. While a multi-dimensional array is a first-class type, jagged arrays are a composite type we create by recursive use of a simple one-dimensional array. This does not imply that the jagged array is inferior by any means. As we will see in the examples, they both have their pros and cons.\n\nLet’s start with the simplest use case and see how to initialize a multidimensional array and a jagged array.\n\nThe first thing that we notice is the relatively intuitive declaration of an empty multidimensional array called for this example. It will have 3 rows and 4 columns (by convention we will call the rightmost index a column index for two-dimensional arrays), or the other way around if we accept a different convention. We’ll see more information on this in the next section.\n\nThe second line leaves more room for interpretation.\n\nWhen we read left to right we first notice what we interpret as an array of integers. This is immediately followed by another which suggests that it is an array of whatever precedes it, in this case, an array of integers. We notice a somewhat counterintuitive initialization on the right side of the expression. Initialization of an integer array would look like so we would expect that an array of arrays of integers would be initialized by . In this example, can you guess whether our jagged array is a collection of three arrays of integers or arrays containing three integers each?\n\nLet’s see how we access elements of both of the array types.\n\nLet’s explore the state of these objects after initialization. First the multidimensional array :\n\nThis example shows relatively straightforward row-by-row traversal. If we want to see the length we need to pass in the dimension, which is maybe not particularly obvious but is still consistent with the “array” of dimensions in the initialization expression ). The output it will show will look like this:\n\nNothing surprising here. Three rows, each with four elements. All elements have the default value for an integer.\n\nAs we can see, it is obvious that each row will have an independent length. It is intuitive that we are iterating a collection of rows and that every row has a collection of elements.\n\nWhen we run this example we get the following output:\n\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\n\nThis shouldn’t come as a surprise. Arrays of integers are reference types, so when they are initialized, their elements are set to the default value for reference types, which is . When we try to access the length of the first row we get this exception, since we still have no rows.\n\nLet’s quickly fix that bug and re-run the example:\n\nHere we combine the initializer with the default integer array constructor to allocate rows and exploit the fact that all rows can have a different number of elements. Let’s see the output that it produces:\n\nThe output is unsurprising. We can see that initializer inversion now makes more sense because the first number declares the number of rows, and we index the row and then the column, similarly to the multidimensional array.\n\nNow let’s explore the memory layout of our multidimensional array and jagged array.\n\nThe CLI spec (section 8.9.1) states:\n\n “Array elements shall be laid out within the array object in row-major order (i.e., the elements associated with the rightmost array dimension shall be laid out contiguously from lowest to highest index). The actual storage allocated for each array element can include platform-specific padding.”\n\nThis means that a multidimensional array is a single object in memory, equivalent to a simple array with the same total number of elements:\n\nElements are laid out row by row – first, the elements of the first row, from the lowest to the highest rightmost index, followed by the elements of the second row, and so on.\n\nWe can expect that for smaller multidimensional arrays this feature provides better memory and cache locality. This may, in some situations, provide better performance. However, larger arrays may easily end up in the Large Object Heap (LOH) if their size exceeds 85 Kb. This is not by itself a bad thing, but in some situations, it may be undesirable. For example, if we allocate many transient objects in the LOH, it may lead to multiple issues. Some of them include LOH fragmentation, slower and more frequent garbage collection, higher memory allocation, etc.\n\nUnlike a multidimensional array, a jagged array allocates independent arrays on the heap for each row, with the addition of one array for the collection of rows:\n\nJagged arrays will have slightly larger overhead for a smaller number of elements. However, for a large number of elements it will create multiple smaller arrays in the Small Object Heap (SOH). If we process one row at a time, the memory or cache locality may not be an issue.\n\nThere are many online claims of superior performance for jagged arrays when compared to multidimensional arrays. As we will see from the following examples, this may not always be true.\n\nLet’s start with a simple use case that resembles those used to justify the claim that a jagged array performs better.\n\nWe will process row-by-row, one element at a time looking for a maximum value.\n\nRunning this benchmark gives us the following results:\n\nHere we can see that the jagged array performs around 8% faster than the multidimensional array.\n\nNow let’s explore a different use case – a common one in image processing known as image convolution. The main difference from our simple scenario is that here, every pixel in an image will require additional 8 surrounding pixels in combination with a convolution kernel. We will explore the performance impact if we model that kernel with both a multidimensional array and a jagged array.\n\nTo keep the examples as simple as possible we will refrain from optimizing other aspects of the algorithm and instead concentrate solely on this particular aspect.\n\nLet’s try to implement a simple image convolution method using a multidimensional array as a convolution kernel:\n\nIn the first couple of lines, we initialize the source image, kernel, and destination image. Following that, we have two nested loops that traverse the source image row-by-row. For each of those pixels, we have two more nested loops that traverse the convolution kernel and compute the resulting pixel color. The exact calculation is of minor importance, except for the fact that a single resulting pixel requires 9 values from the source image and another 9 from the convolution kernel.\n\nNow, let’s see what the same algorithm looks like when we use a jagged array for a convolution kernel.\n\nHighlighted lines show the differences in initialization, boundary check, and element indexing. Other than that, the rest of the code is the same.\n\nNow, let’s run these two methods in a BenchmarkDotNet benchmark and see how they compare.\n\nAs we can see, the jagged array kernel performs 35% slower than a multidimensional array kernel. It’s reasonable to assume that since the multidimensional array is a single object that fits in the CPU data cache, it will require fewer memory operations than a jagged array which is essentially 4 smaller objects requiring at least 4 memory operations.\n\nFrom these two scenarios, we can see that both multidimensional array and jagged array have their place to shine. If performance is a key requirement in your scenario, be sure to thoroughly test both options before committing to one of them.\n\nSo let’s quickly recap the differences between jagged arrays and multidimensional arrays:\n\nIn this article, we compared multidimensional arrays to jagged arrays in C#. We have seen that both have their pros and cons and that none is better in all situations. We have also seen that in performance-critical situations, both can be good candidates and that careful testing may be necessary to make the right choice."
    },
    {
        "link": "https://stackoverflow.com/questions/468832/why-are-multi-dimensional-arrays-in-net-slower-than-normal-arrays",
        "document": "Edit: I apologize everybody. I used the term \"jagged array\" when I actually meant to say \"multi-dimensional array\" (as can be seen in my example below). I apologize for using the incorrect name. I actually found jagged arrays to be faster than multi-dimensional ones! I have added my measurements for jagged arrays.\n\nI was trying to use a multi-dimensional array today, when I noticed that it's performance is not as I would have expected. Using a single-dimensional array and manually calculating indices was much faster (almost two times) than using a 2D array. I wrote a test using arrays (initialized to random values), for 1000 iterations, and I got the following results on my machine:\n\nThis is my test code:\n\nFurther investigation showed that the IL for the second method is 23% larger than that of the first method. (Code size 68 vs 52.) This is mostly due to calls to . The compiler also emits calls to for the multi-dimensional array, whereas it simply calls for the simple array.\n\nSo I am wondering, why is access through multi-dimensional arrays slower than normal arrays? I would have assumed the compiler (or JIT) would do something similar to what I did in my first method, but this was not actually the case.\n\nCould you plese help me understand why this is happening the way it is?\n\nUpdate: Following Henk Holterman's suggestion, here is the implementation of :"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/wpw11f/how_often_are_multidimensional_arrays_and_jagged",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://teamtreehouse.com/community/c-multidimensional-arrays-challenge",
        "document": "Thomas Beaudry and Amy Shah ... both of you mentioned that you were having issues with this one over the weekend. My original answer to Daniel Hildreth was a bit vague because he asked \"Can you explain to me what I'm doing wrong, and what I need to do to fix it without giving the answer away?\" So, my answer was specific to helping him get over the hump based on the code he'd already written. Here's a more generic explanation. Hope it helps.\n\nThere are several ways to write this. You could use the fact that you always know the length and width up front to avoid ever having to look at the array itself to see how big it is. Also, since length and width are the same (i.e. it's not a jagged array), you can use the same variable for both. So your loops like like this...\n\nYou can also look back at the array that you just declared (and instantiated with a fixed size). You must use the Array.GetLength() method, passing the index of the dimension (i.e. 0 for rows, 1 for columns in our case). Array.Length is no help because it will return the total size of the array. (i.e. For a 4x4 2-dimensional array, Array.Length will give you 16.) Using Array.GetLength() is more generic than the code above, but gives up a tiny bit of performance to solve a problem that you already know the answer to. After all, you are the one who just created the array! You already know how big it is! However, if you didn't already have knowledge about the size of the array, this would be better...\n\nHere it is when you put it all together the first way (in this case, the better way)...\n\n//Since we know that we need to include zero, assuming maxFactor = 3, our rows and //columns will go from 0 to 3. So, they will both have a length of 4 (0 1 2 3). //So, we always need to add one to maxFactor to account for zero. //Declare a (2-dimensional) multidimensional array with the right amount of rows and columns. //The outer loop will iterate the rows (0 1 2 3). //The inner loop will iterate the columns (0 1 2 3).\n\nAnd, here is some code to put into your Console app to make it print out pretty like they showed in the instructions. Note: My code that writes the output assumes that it has no knowledge of the size of the array..."
    }
]