[
    {
        "link": "https://stackoverflow.com/questions/3362600/how-to-send-email-attachments",
        "document": "I am having problems understanding how to email an attachment using Python. I have successfully emailed simple messages with the smtplib . Could someone please explain how to send an attachment in an email. I know there are other posts online but as a Python beginner I find them hard to understand.\n\nBecause there are many answers here for Python 3, but none which show how to use the overhauled library from Python 3.6, here is a quick copy+paste from the current examples documentation. (I have abridged it somewhat to remove frills like guessing the correct MIME type.) Modern code which targets Python >3.5 should no longer use the API (including the various , , etc classes) or the even older mumbo jumbo. from email.message import EmailMessage import smtplib from pathlib import Path msg = EmailMessage() msg[\"Subject\"] = \"Our family reunion\" msg[\"From\"] = \"me <[email protected]>\" msg[\"To\"] = \"recipient <[email protected]>\" # definitely don't mess with the .preamble msg.set_content(\"Hello, victim! Look at these pictures\") picpath = Path(\"path/to/attachment.png\") with picpath.open(\"rb\") as fp: msg.add_attachment( fp.read(), maintype=\"image\", subtype=\"png\", filename=picpath.name) # Notice how smtplib now includes a send_message() method with smtplib.SMTP(\"localhost\") as s: s.send_message(msg) The modern API is now quite a bit more versatile and logical than the older version of the library. There are still a few kinks around the presentation in the documentation (it's not obvious how to change the of an attachment, for example; and the discussion of the module is probably too obscure for most newcomers) and fundamentally, you still need to have some sort of idea of what the MIME structure should look like (though the library now finally takes care of a lot of the nitty-gritty around that). Perhaps see What are the \"parts\" in a multipart email? for a brief introduction. Using as your SMTP server obviously only works if you actually have an SMTP server running on your local computer. Properly getting email off your system is a fairly complex separate question. For simple requirements, probably use your existing email account and your provider's email server (search for examples of using port 587 with Google, Yahoo, or whatever you have - what exactly works depends somewhat on the provider; some will only support port 465, or legacy port 25 which is however now by and large impossible to use on public-facing servers because of spam filtering).\n\nNone of the currently given answers here will work correctly with non-ASCII symbols in filenames with clients like GMail, Outlook 2016, and others that don't support RFC 2231 (e.g., see here). The Python 3 code below is adapted from some other stackoverflow answers (sorry, didn't save the origin links) and odoo/openerp code for Python 2.7 (see ir_mail_server.py). It works correctly with GMail and others, and also uses SSL. import smtplib, ssl from os.path import basename from email.mime.base import MIMEBase from mimetypes import guess_type from email.encoders import encode_base64 from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.utils import COMMASPACE, formatdate from email.charset import Charset def try_coerce_ascii(string_utf8): \"\"\"Attempts to decode the given utf8-encoded string as ASCII after coercing it to UTF-8, then return the confirmed 7-bit ASCII string. If the process fails (because the string contains non-ASCII characters) returns ``None``. \"\"\" try: string_utf8.encode('ascii') except UnicodeEncodeError: return return string_utf8 def encode_header_param(param_text): \"\"\"Returns an appropriate RFC 2047 encoded representation of the given header parameter value, suitable for direct assignation as the param value (e.g. via Message.set_param() or Message.add_header()) RFC 2822 assumes that headers contain only 7-bit characters, so we ensure it is the case, using RFC 2047 encoding when needed. :param param_text: unicode or utf-8 encoded string with header value :rtype: string :return: if ``param_text`` represents a plain ASCII string, return the same 7-bit string, otherwise returns an ASCII string containing the RFC2047 encoded text. \"\"\" if not param_text: return \"\" param_text_ascii = try_coerce_ascii(param_text) return param_text_ascii if param_text_ascii\\ else Charset('utf8').header_encode(param_text) smtp_server = '<someserver.com>' smtp_port = 465 # Default port for SSL sender_email = '<[email protected]>' sender_password = '<PASSWORD>' receiver_emails = ['<[email protected]>', '<[email protected]>'] subject = 'Test message' message = \"\"\"\\ Hello! This is a test message with attachments. This message is sent from Python.\"\"\" files = ['<path1>/файл1.pdf', '<path2>/файл2.png'] # Create a secure SSL context context = ssl.create_default_context() msg = MIMEMultipart() msg['From'] = sender_email msg['To'] = COMMASPACE.join(receiver_emails) msg['Date'] = formatdate(localtime=True) msg['Subject'] = subject msg.attach(MIMEText(message)) for f in files: mimetype, _ = guess_type(f) mimetype = mimetype.split('/', 1) with open(f, \"rb\") as fil: part = MIMEBase(mimetype[0], mimetype[1]) part.set_payload(fil.read()) encode_base64(part) filename_rfc2047 = encode_header_param(basename(f)) # The default RFC 2231 encoding of Message.add_header() works in Thunderbird but not GMail # so we fix it by using RFC 2047 encoding for the filename instead. part.set_param('name', filename_rfc2047) part.add_header('Content-Disposition', 'attachment', filename=filename_rfc2047) msg.attach(part) with smtplib.SMTP_SSL(smtp_server, smtp_port, context=context) as server: server.login(sender_email, sender_password) server.sendmail(sender_email, receiver_emails, msg.as_string())\n\nHad a bit of a hussle in getting my script to send generic attachments but after a bit of work doing research and skimming through articles on this post, I finally came up with the following # to query: import sys import ast from datetime import datetime import smtplib import mimetypes from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email import encoders from email.message import Message from email.mime.audio import MIMEAudio from email.mime.base import MIMEBase from email.mime.image import MIMEImage from email.mime.text import MIMEText from dotenv import load_dotenv, dotenv_values load_dotenv() # load environment variables from .env ''' sample .env file # .env file SECRET_KEY=\"gnhfpsjxxxxxxxx\" DOMAIN=\"GMAIL\" TOP_LEVEL_DOMAIN=\"COM\" EMAIL=\"CHESERExxxxxx@${DOMAIN}.${TOP_LEVEL_DOMAIN}\" TO_ADDRESS = (\"[email protected]\",\"[email protected]\")#didn't use this in the code but you can load recipients from here ''' import smtplib tls_port = 587 ssl_port = 465 smtp_server_domain_names = {'GMAIL': ('smtp.gmail.com', tls_port, ssl_port), 'OUTLOOK': ('smtp-mail.outlook.com', tls_port, ssl_port), 'YAHOO': ('smtp.mail.yahoo.com', tls_port, ssl_port), 'AT&T': ('smtp.mail.att.net', tls_port, ssl_port), } # todo: Ability to choose mail server provider # auto read in from the dictionary the respective mail server address and the tls and ssl ports class Bimail: def __init__(self, subject, recipients): self.subject = subject self.recipients = recipients self.htmlbody = '' self.mail_username = 'will be loaded from .env file' self.mail_password = 'loaded from .env file as well' self.attachments = [] # Creating an smtp object # todo: if gmail passed in use gmail's dictionary values def setup_mail_client(self, domain_key_to_use=\"GMAIL\", email_servers_domains_dict=smtp_server_domain_names): \"\"\" :param report_pdf: :type to_address: str \"\"\" smtpObj = None encryption_status = True config = dotenv_values(\".env\") # check if the domain_key exists from within the available email-servers-domains dict file passed in # else throw an error # read environment file to get the Domain to be used if f\"{domain_key_to_use}\" in email_servers_domains_dict.keys(): # if the key is found do the following # 1.extract the domain,tls,ssl ports from email_servers dict for use in program try: values_tuple = email_servers_domains_dict.get(f\"{domain_key_to_use}\") ssl_port = values_tuple[2] tls_port = values_tuple[1] smtp_server = values_tuple[0] smtpObj = smtplib.SMTP(smtp_server, tls_port) print(f\"Success connect with tls on {tls_port}\") print('Awaiting for connection encryption via startttls()') encryption_status = False except: print(f\"Failed connection via tls on port {tls_port}\") try: smtpObj = smtplib.SMTP_SSL(smtp_server, ssl_port) print(f\"Success connect with ssl on {ssl_port}\") encryption_status = True except: print(f\"Failed connection via ssl on port {ssl_port}\") finally: print(\"Within Finally block\") if not smtpObj: print(\"Failed!!! no Internet connection\") else: # if connection channel is unencrypted via the use of tls encrypt it if not encryption_status: status = smtpObj.starttls() if status[0] == 220: print(\"Successfully Encrypted tls channel\") print(\"Successfully Connected!!!! Requesting Login\") # Loading .env file values to config variable #load Login Creds from ENV File self.mail_username = f'{config.get(\"EMAIL\")}' self.mail_password = f'{cofig.get(\"SECRET_KEY\")}' status = smtpObj.login(self.mail_usernam,self.mail_password) if status[0] == 235: print(\"Successfully Authenticated User to xxx account\") success = self.send(smtpObj, f'{config.get(\"EMAIL\")}') if not bool(success): print(f\"Success in Sending Mail to {success}\") print(\"Disconnecting from Server INstance\") quit_result = smtpObj.quit() else: print(f\"Failed to Post {success}!!!\") print(f\"Quiting anyway !!!\") quit_result = smtpObj.quit() else: print(\"Application Specific Password is Required\") else: print(\"World\") def send(self,smtpObj,from_address): msg = MIMEMultipart('alternative') msg['From'] = from_address msg['Subject'] = self.subject msg['To'] = \", \".join(self.recipients) # to must be array of the form ['[email protected]'] msg.preamble = \"preamble goes here\" # check if there are attachments if yes, add them if self.attachments: self.attach(msg) # add html body after attachments msg.attach(MIMEText(self.htmlbody, 'html')) # send print(f\"Attempting Email send to the following addresses {self.recipients}\") result = smtpObj.sendmail(from_address, self.recipients,msg.as_string()) return result def htmladd(self, html): self.htmlbody = self.htmlbody + '<p></p>' + html def attach(self, msg): for f in self.attachments: ctype, encoding = mimetypes.guess_type(f) if ctype is None or encoding is not None: ctype = \"application/octet-stream\" maintype, subtype = ctype.split(\"/\", 1) if maintype == \"text\": fp = open(f) # Note: we should handle calculating the charset attachment = MIMEText(fp.read(), _subtype=subtype) fp.close() elif maintype == \"image\": fp = open(f, \"rb\") attachment = MIMEImage(fp.read(), _subtype=subtype) fp.close() elif maintype == \"ppt\": fp = open(f, \"rb\") attachment = MIMEApplication(fp.read(), _subtype=subtype) fp.close() elif maintype == \"audio\": fp = open(f, \"rb\") attachment = MIMEAudio(fp.read(), _subtype=subtype) fp.close() else: fp = open(f, \"rb\") attachment = MIMEBase(maintype, subtype) attachment.set_payload(fp.read()) fp.close() encoders.encode_base64(attachment) attachment.add_header(\"Content-Disposition\", \"attachment\", filename=f) attachment.add_header('Content-ID', '<{}>'.format(f)) msg.attach(attachment) def addattach(self, files): self.attachments = self.attachments + files # example below if __name__ == '__main__': # subject and recipients mymail = Bimail('Sales email ' + datetime.now().strftime('%Y/%m/%d'), ['[email protected]', '[email protected]']) # start html body. Here we add a greeting. mymail.htmladd('Good morning, find the daily summary below.') # Further things added to body are separated by a paragraph, so you do not need to worry about newlines for new sentences # here we add a line of text and an html table previously stored in the variable mymail.htmladd('Daily sales') mymail.addattach(['htmlsalestable.xlsx']) # another table name + table mymail.htmladd('Daily bestsellers') mymail.addattach(['htmlbestsellertable.xlsx']) # add image chart title mymail.htmladd('Weekly sales chart') # attach image chart mymail.addattach(['saleschartweekly.png']) # refer to image chart in html mymail.htmladd('<img src=\"cid:saleschartweekly.png\"/>') # attach another file mymail.addattach(['MailSend.py']) # send! mymail.setup_mail_client( domain_key_to_use=\"GMAIL\",email_servers_domains_dict=smtp_server_domain_names)"
    },
    {
        "link": "https://medium.com/@abdullahzulfiqar653/sending-emails-with-attachments-using-python-32b908909d73",
        "document": "Sending emails is a common practice in nearly every software application. That’s why sending files as attachments is prevalent; it allows us to easily share data and documents via email. Many of you may be seeking guidance on how to send a file attachment via email, which is why you’re reading my article. In this article, I will explain how to send an email with a attachment.\n\nCSV, XLSX, or TXT are common file extensions that we frequently use in our daily work routines. They’re handy for sharing data such as reports or lists. When you attach a file to an email, you can easily send this data to someone else.\n\nSending emails with attachments is a common task, which is why Python provides built-in email libraries. We will utilize these libraries along with smtplib to send emails.\n\nBefore we start, ensure you have the following requirements ready:\n\n1 — Python should be installed on your system.\n\n2 — You should have valid email account with SMTP server details.\n\nI am using Gmail SMTP for this example, which is quite generic. You can use your email as the username for Gmail SMTP, and for the password, you’ll need to create an app-specific password from your Gmail account. To create an app password, follow this link. Then, in the “How you sign in to Google” section, navigate to 2-Step Verification, where you can create your app password.\n\nWriting code and sending emails using the code below:\n\n\n\n# All imports below are part of python built packages no need to install any exras\n\n\n\n# smtplib provides functionality to send emails using SMTP.\n\nimport smtplib\n\n# MIMEMultipart send emails with both text content and attachments.\n\nfrom email.mime.multipart import MIMEMultipart\n\n# MIMEText for creating body of the email message.\n\nfrom email.mime.text import MIMEText\n\n# MIMEApplication attaching application-specific data (like CSV files) to email messages.\n\nfrom email.mime.application import MIMEApplication\n\n\n\nsubject = \"Email Subject\"\n\nbody = \"This is the body of the text message\"\n\nsender_email = \"your_mail@gmail.com\"\n\nrecipient_email = \"reciever_mail@gmail.com\"\n\nsender_password = \"Valid password here\"\n\nsmtp_server = 'smtp.gmail.com'\n\nsmtp_port = 465\n\npath_to_file = 'example.csv'\n\n\n\n# MIMEMultipart() creates a container for an email message that can hold\n\n# different parts, like text and attachments and in next line we are\n\n# attaching different parts to email container like subject and others.\n\nmessage = MIMEMultipart()\n\nmessage['Subject'] = subject\n\nmessage['From'] = sender_email\n\nmessage['To'] = recipient_email\n\nbody_part = MIMEText(body)\n\nmessage.attach(body_part)\n\n\n\n# section 1 to attach file\n\nwith open(path_to_file,'rb') as file:\n\n # Attach the file with filename to the email\n\n message.attach(MIMEApplication(file.read(), Name=\"example.csv\"))\n\n\n\n# secction 2 for sending email\n\nwith smtplib.SMTP_SSL(smtp_server, smtp_port) as server:\n\n server.login(sender_email, sender_password)\n\n server.sendmail(sender_email, recipient_email, message.as_string())\n\nIn the above example, remember to modify the SMTP server if you’re using a different one. Also, in the ‘file’ variable, I’ve set it as ‘example.csv’ assuming the file is in the same directory as the Python script. However, if your file is located elsewhere, be sure to specify the complete path to the file you want to send as an attachment.\n• = sender’s email means if its you then your email\n• = set server which you are using\n• = SMTP port, set it to 465 if using gmail smtp\n\nBecause these variables contain sensitive data, I highly recommend supplying them from environment variables.\n\nexplanation about import statement and lines after is already explained using comments in the code but last 2 sections of code where we using with expression are not explained so check the explanation below:\n• This code snippet opens a file located at a specified path in “read binary” mode (‘rb’). Then, it reads the contents of the file and attaches it to an email message. The attached file is given the name “example.csv”.\n• This code connects to an email server securely (using SSL), logs in with the sender’s email and password, and then sends an email from the sender to the recipient.\n\nsending emails with attachments using Python is a straightforward process. By following the steps outlined in this guide, you can easily share data and documents with others via email. Remember to handle sensitive information, such as SMTP credentials, with care. With Python’s built-in libraries and a few lines of code, you can automate the process of sending emails with attachments, making it efficient and convenient for various tasks."
    },
    {
        "link": "https://docs.python.org/3/library/smtplib.html",
        "document": "The module defines an SMTP client session object that can be used to send mail to any internet machine with an SMTP or ESMTP listener daemon. For details of SMTP and ESMTP operation, consult RFC 821 (Simple Mail Transfer Protocol) and RFC 1869 (SMTP Service Extensions).\n\nAn instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP method is called with those parameters during initialization. If specified, local_hostname is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using . If the call returns anything other than a success code, an is raised. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, is raised. The optional source_address parameter allows binding to some specific source address in a machine with multiple network interfaces, and/or to some specific source TCP port. It takes a 2-tuple , for the socket to bind to as its source address before connecting. If omitted (or if host or port are and/or respectively) the OS default behavior will be used. For normal use, you should only require the initialization/connect, , and methods. An example is included below. The class supports the statement. When used like this, the SMTP command is issued automatically when the statement exits. E.g.: All commands will raise an auditing event with arguments and , where is the bytes about to be sent to the remote host. Changed in version 3.3: Support for the statement was added. Added in version 3.5: The SMTPUTF8 extension (RFC 6531) is now supported. Changed in version 3.9: If the timeout parameter is set to be zero, it will raise a to prevent the creation of a non-blocking socket.\n\nA nice selection of exceptions is defined as well:\n\nAn instance has the following methods: Set the debug output level. A value of 1 or for level results in debug messages for connection and for all messages sent to and received from the server. A value of 2 for level results in these messages being timestamped. Send a command cmd to the server. The optional argument args is simply concatenated to the command, separated by a space. This returns a 2-tuple composed of a numeric response code and the actual response line (multiline responses are joined into one long line.) In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions. If the connection to the server is lost while waiting for the reply, will be raised. Connect to a host on a given port. The defaults are to connect to the local host at the standard SMTP port (25). If the hostname ends with a colon ( ) followed by a number, that suffix will be stripped off and the number interpreted as the port number to use. This method is automatically invoked by the constructor if a host is specified during instantiation. Returns a 2-tuple of the response code and message sent by the server in its connection response. Identify yourself to the SMTP server using . The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the attribute of the object. In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the when necessary. Identify yourself to an ESMTP server using . The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by . Also sets several informational attributes: the message returned by the server is stored as the attribute, is set to or depending on whether the server supports ESMTP, and will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any). Unless you wish to use before sending mail, it should not be necessary to call this method explicitly. It will be implicitly called by when necessary. This method calls and/or if there has been no previous or command this session. It tries ESMTP first. The server didn’t reply properly to the greeting. Return if name is in the set of SMTP service extensions returned by the server, otherwise. Case is ignored. Check the validity of an address on this server using SMTP . Returns a tuple consisting of code 250 and a full RFC 822 address (including human name) if the user address is valid. Otherwise returns an SMTP error code of 400 or greater and an error string. Many sites disable SMTP in order to foil spammers. Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous or command this session, this method tries ESMTP first. This method will return normally if the authentication was successful, or may raise the following exceptions: The server didn’t reply properly to the greeting. The command is not supported by the server. Each of the authentication methods supported by are tried in turn if they are advertised as supported by the server. See for a list of supported authentication methods. initial_response_ok is passed through to . Optional keyword argument initial_response_ok specifies whether, for authentication methods that support it, an “initial response” as specified in RFC 4954 can be sent along with the command, rather than requiring a challenge/response. Changed in version 3.5: may be raised, and the initial_response_ok parameter was added. Issue an command for the specified authentication mechanism, and handle the challenge response via authobject. mechanism specifies which authentication mechanism is to be used as argument to the command; the valid values are those listed in the element of . authobject must be a callable object taking an optional single argument: If optional keyword argument initial_response_ok is true, will be called first with no argument. It can return the RFC 4954 “initial response” ASCII which will be encoded and sent with the command as below. If the does not support an initial response (e.g. because it requires a challenge), it should return when called with . If initial_response_ok is false, then will not be called first with . If the initial response check returns , or if initial_response_ok is false, will be called to process the server’s challenge response; the challenge argument it is passed will be a . It should return ASCII data that will be base64 encoded and sent to the server. The class provides for the , , and mechanisms; they are named , , and respectively. They all require that the and properties of the instance are set to appropriate values. User code does not normally need to call directly, but can instead call the method, which will try each of the above mechanisms in turn, in the order listed. is exposed to facilitate the implementation of authentication methods not (or not yet) supported directly by . Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call again. If keyfile and certfile are provided, they are used to create an . Optional context parameter is an object; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be . If there has been no previous or command this session, this method tries ESMTP first. Changed in version 3.12: The deprecated keyfile and certfile parameters have been removed. The server didn’t reply properly to the greeting. The server does not support the STARTTLS extension. SSL/TLS support is not available to your Python interpreter. Changed in version 3.4: The method now supports hostname check with and Server Name Indicator (see ). Changed in version 3.5: The error raised for lack of STARTTLS support is now the subclass instead of the base . Send mail. The required arguments are an RFC 822 from-address string, a list of RFC 822 to-address strings (a bare string will be treated as a list with 1 address), and a message string. The caller may pass a list of ESMTP options (such as ) to be used in commands as mail_options. ESMTP options (such as commands) that should be used with all commands can be passed as rcpt_options. (If you need to use different ESMTP options to different recipients you have to use the low-level methods such as , and to send the message.) The from_addr and to_addrs parameters are used to construct the message envelope used by the transport agents. does not modify the message headers in any way. msg may be a string containing characters in the ASCII range, or a byte string. A string is encoded to bytes using the ascii codec, and lone and characters are converted to characters. A byte string is not modified. If there has been no previous or command this session, this method tries ESMTP first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If fails, will be tried and ESMTP options suppressed. This method will return normally if the mail is accepted for at least one recipient. Otherwise it will raise an exception. That is, if this method does not raise an exception, then someone should get your mail. If this method does not raise an exception, it returns a dictionary, with one entry for each recipient that was refused. Each entry contains a tuple of the SMTP error code and the accompanying error message sent by the server. If is included in mail_options, and the server supports it, from_addr and to_addrs may contain non-ASCII characters. This method may raise the following exceptions: All recipients were refused. Nobody got the mail. The attribute of the exception object is a dictionary with information about the refused recipients (like the one returned when at least one recipient was accepted). The server didn’t reply properly to the greeting. The server replied with an unexpected error code (other than a refusal of a recipient). was given in the mail_options but is not supported by the server. Unless otherwise noted, the connection will be open even after an exception is raised. Changed in version 3.2: msg may be a byte string. Changed in version 3.5: support added, and may be raised if is specified but the server does not support it. This is a convenience method for calling with the message represented by an object. The arguments have the same meaning as for , except that msg is a object. If from_addr is or to_addrs is , fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322: from_addr is set to the Sender field if it is present, and otherwise to the From field. to_addrs combines the values (if any) of the To, Cc, and Bcc fields from msg. If exactly one set of Resent-* headers appear in the message, the regular headers are ignored and the Resent-* headers are used instead. If the message contains more than one set of Resent-* headers, a is raised, since there is no way to unambiguously detect the most recent set of Resent- headers. serializes msg using with as the linesep, and calls to transmit the resulting message. Regardless of the values of from_addr and to_addrs, does not transmit any Bcc or Resent-Bcc headers that may appear in msg. If any of the addresses in from_addr and to_addrs contain non-ASCII characters and the server does not advertise support, an is raised. Otherwise the is serialized with a clone of its with the attribute set to , and and are added to mail_options. Terminate the SMTP session and close the connection. Return the result of the SMTP command. Low-level methods corresponding to the standard SMTP/ESMTP commands , , , , , and are also supported. Normally these do not need to be called directly, so they are not documented here. For details, consult the module code.\n\nThis example prompts the user for addresses needed in the message envelope (‘To’ and ‘From’ addresses), and the message to be delivered. Note that the headers to be included with the message must be included in the message as entered; this example doesn’t do any processing of the RFC 822 headers. In particular, the ‘To’ and ‘From’ addresses must be included in the message headers explicitly: # Add the From: and To: headers at the start! In general, you will want to use the package’s features to construct an email message, which you can then send via ; see email: Examples."
    },
    {
        "link": "https://realpython.com/python-send-email",
        "document": "You probably found this tutorial because you want to send emails using Python. Perhaps you want to receive email reminders from your code, send a confirmation email to users when they create an account, or send emails to members of your organization to remind them to pay their dues. Sending emails manually is a time-consuming and error-prone task, but it’s easy to automate with Python.\n\nIn this tutorial you’ll learn how to:\n• Set up a secure connection using and\n• Send emails with HTML content and attachments using the package\n• Use the Yagmail package to send email through your Gmail account using only a few lines of code\n\nYou’ll find a few transactional email services at the end of this tutorial, which will come in useful when you want to send a large number of emails.\n\nPython comes with the built-in module for sending emails using the Simple Mail Transfer Protocol (SMTP). uses the RFC 821 protocol for SMTP. The examples in this tutorial will use the Gmail SMTP server to send emails, but the same principles apply to other email services. Although the majority of email providers use the same connection ports as the ones in this tutorial, you can run a quick Google search to confirm yours. To get started with this tutorial, set up a Gmail account for development, or set up an SMTP debugging server that discards emails you send and prints them to the command prompt instead. Both options are laid out for you below. A local SMTP debugging server can be useful for fixing any issues with email functionality and ensuring your email functions are bug-free before sending out any emails. If you decide to use a Gmail account to send your emails, I highly recommend setting up a throwaway account for the development of your code. This is because you’ll have to adjust your Gmail account’s security settings to allow access from your Python code, and because there’s a chance you might accidentally expose your login details. Also, I found that the inbox of my testing account rapidly filled up with test emails, which is reason enough to set up a new Gmail account for development. A nice feature of Gmail is that you can use the sign to add any modifiers to your email address, right before the sign. For example, mail sent to and will both arrive at . When testing email functionality, you can use this to emulate multiple addresses that all point to the same inbox. To set up a Gmail address for testing your code, do the following:\n• Turn Allow less secure apps to ON. Be aware that this makes it easier for others to gain access to your account. If you don’t want to lower the security settings of your Gmail account, check out Google’s documentation on how to gain access credentials for your Python script, using the OAuth2 authorization framework. You can test email functionality by running a local SMTP debugging server, using the module that comes pre-installed with Python. Rather than sending emails to the specified address, it discards them and prints their content to the console. Running a local debugging server means it’s not necessary to deal with encryption of messages or use credentials to log in to an email server. You can start a local SMTP debugging server by typing the following in Command Prompt: On Linux, use the same command preceded by . Any emails sent through this server will be discarded and shown in the terminal window as a object for each line: b'Hello there, here is a test email' For the rest of the tutorial, I’ll assume you’re using a Gmail account, but if you’re using a local debugging server, just make sure to use as your SMTP server and use port 1025 rather than port 465 or 587. Besides this, you won’t need to use or encrypt the communication using SSL/TLS.\n\nBefore we dive into sending emails with HTML content and attachments, you’ll learn to send plain-text emails using Python. These are emails that you could write up in a simple text editor. There’s no fancy stuff like text formatting or hyperlinks. You’ll learn that a bit later. When you send emails through Python, you should make sure that your SMTP connection is encrypted, so that your message and login credentials are not easily accessed by others. SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are two protocols that can be used to encrypt an SMTP connection. It’s not necessary to use either of these when using a local debugging server. There are two ways to start a secure connection with your email server:\n• Start an SMTP connection that is secured from the beginning using .\n• Start an unsecured SMTP connection that can then be encrypted using . In both instances, Gmail will encrypt emails using TLS, as this is the more secure successor of SSL. As per Python’s Security considerations, it is highly recommended that you use from the module. This will load the system’s trusted CA certificates, enable host name checking and certificate validation, and try to choose reasonably secure protocol and cipher settings. If you want to check the encryption for an email in your Gmail inbox, go to More → Show original to see the encryption type listed under the Received header. is Python’s built-in module for sending emails to any Internet machine with an SMTP or ESMTP listener daemon. I’ll show you how to use first, as it instantiates a connection that is secure from the outset and is slightly more concise than the alternative. Keep in mind that Gmail requires that you connect to port 465 if using , and to port 587 when using . The code example below creates a secure connection with Gmail’s SMTP server, using the of to initiate a TLS-encrypted connection. The default context of validates the host name and its certificates and optimizes the security of the connection. Make sure to fill in your own email address instead of : Using makes sure that the connection is automatically closed at the end of the indented code block. If is zero, or not specified, will use the standard port for SMTP over SSL (port 465). It’s not safe practice to store your email password in your code, especially if you intend to share it with others. Instead, use to let the user type in their password when running the script, as in the example above. If you don’t want your password to show on your screen when you type it, you can import the module and use instead for blind input of your password. Instead of using to create a connection that is secure from the outset, we can create an unsecured SMTP connection and encrypt it using . To do this, create an instance of , which encapsulates an SMTP connection and allows you access to its methods. I recommend defining your SMTP server and port at the beginning of your script to configure them easily. The code snippet below uses the construction , rather than the format which we used in the previous example. To make sure that your code doesn’t crash when something goes wrong, put your main code in a block, and let an block print any error messages to : # Try to log in to server and send email To identify yourself to the server, (SMTP) or (ESMTP) should be called after creating an object, and again after . This function is implicitly called by and if needed, so unless you want to check the SMTP service extensions of the server, it is not necessary to use or explicitly. After you initiated a secure SMTP connection using either of the above methods, you can send your email using , which pretty much does what it says on the tin: I recommend defining the email addresses and message content at the top of your script, after the imports, so you can change them easily: This message is sent from Python.\"\"\" The string starts with followed by two newlines ( ). This ensures shows up as the subject of the email, and the text following the newlines will be treated as the message body. The code example below sends a plain-text email using : This message is sent from Python.\"\"\" For comparison, here is a code example that sends a plain-text email over an SMTP connection secured with . The lines may be omitted, as they are called implicitly by and , if required: This message is sent from Python.\"\"\"\n\nPython’s built-in package allows you to structure more fancy emails, which can then be transferred with as you have done already. Below, you’ll learn how use the package to send emails with HTML content and attachments. If you want to format the text in your email (bold, italics, and so on), or if you want to add any images, hyperlinks, or responsive content, then HTML comes in very handy. Today’s most common type of email is the MIME (Multipurpose Internet Mail Extensions) Multipart email, combining HTML and plain-text. MIME messages are handled by Python’s module. For a detailed description, check the documentation. As not all email clients display HTML content by default, and some people choose only to receive plain-text emails for security reasons, it is important to include a plain-text alternative for HTML messages. As the email client will render the last multipart attachment first, make sure to add the HTML message after the plain-text version. In the example below, our objects will contain the HTML and plain-text versions of our message, and the instance combines these into a single message with two alternative rendering options: # Create the plain-text and HTML version of your message # The email client will try to render the last part first In this example, you first define the plain-text and HTML message as string literals, and then store them as / objects. These can then be added in this order to the message and sent through your secure connection with the email server. Remember to add the HTML message after the plain-text alternative, as email clients will try to render the last subpart first. In order to send binary files to an email server that is designed to work with textual data, they need to be encoded before transport. This is most commonly done using , which encodes binary data into printable ASCII characters. The code example below shows how to send an email with a PDF file as an attachment: \"An email with attachment from Python\" \"This is an email with attachment sent from Python\" # In same directory as script # Email client can usually download this automatically as attachment # Encode file in ASCII characters to send by email # Add attachment to message and convert message to string # Log in to server using secure context and send email The message accepts parameters in the form of RFC5233-style key/value pairs, which are stored in a dictionary and passed to the method of the base class. Check out the documentation for Python’s module to learn more about using MIME classes.\n\nImagine you want to send emails to members of your organization, to remind them to pay their contribution fees. Or maybe you want to send students in your class personalized emails with the grades for their recent assignment. These tasks are a breeze in Python. An easy starting point for sending multiple personalized emails is to create a CSV (comma-separated values) file that contains all the required personal information. (Make sure not to share other people’s private information without their consent.) A CSV file can be thought of as a simple table, where the first line often contains the column headers. Below are the contents of the file , which I saved in the same folder as my Python code. It contains the names, addresses, and grades for a set of fictional people. I used constructions to make sure all emails end up in my own inbox, which in this example is my@gmail.com: When creating a CSV file, make sure to separate your values by a comma, without any surrounding whitespaces. The code example below shows you how to open a CSV file and loop over its lines of content (skipping the header row). To make sure that the code works correctly before you send emails to all your contacts, I’ve printed for each contact, which we can later replace with functionality that actually sends out emails: In the example above, using makes sure that your file closes at the end of the code block. makes it easy to read a CSV file line by line and extract its values. The line skips the header row, so that the following line for name, email, grade in reader: splits subsequent rows at each comma, and stores the resulting values in the strings , and for the current contact. If the values in your CSV file contain whitespaces on either or both sides, you can remove them using the method. You can put personalized content in a message by using to fill in curly-bracket placeholders. For example, \"hi {name}, you {result} your assignment\".format(name=\"John\", result=\"passed\") will give you \"hi John, you passed your assignment\" . As of Python 3.6, string formatting can be done more elegantly using f-strings, but these require the placeholders to be defined before the f-string itself. In order to define the email message at the beginning of the script, and fill in placeholders for each contact when looping over the CSV file, the older method is used. With this in mind, you can set up a general message body, with placeholders that can be tailored to individuals. The following code example lets you send personalized emails to multiple contacts. It loops over a CSV file with for each contact, as in the example above. The general message is defined in the beginning of the script, and for each contact in the CSV file its and placeholders are filled in, and a personalized email is sent out through a secure connection with the Gmail server, as you saw before:\n\nThere are multiple libraries designed to make sending emails easier, such as Envelopes, Flanker and Yagmail. Yagmail is designed to work specifically with Gmail, and it greatly simplifies the process of sending emails through a friendly API, as you can see in the code example below: \"Hello there from Yagmail\" This code example sends an email with a PDF attachment in a fraction of the lines needed for our example using and . When setting up Yagmail, you can add your Gmail validations to the keyring of your OS, as described in the documentation. If you don’t do this, Yagmail will prompt you to enter your password when required and store it in the keyring automatically.\n\nIf you plan to send a large volume of emails, want to see email statistics, and want to ensure reliable delivery, it may be worth looking into transactional email services. Although all of the following services have paid plans for sending large volumes of emails, they also come with a free plan so you can try them out. Some of these free plans are valid indefinitely and may be sufficient for your email needs. Below is an overview of the free plans for some of the major transactional email services. Clicking on the provider name will take you to the pricing section of their website. 40,000 emails for your first 30 days, then 100/day You can run a Google search to see which provider best fits your needs, or just try out a few of the free plans to see which API you like working with most."
    },
    {
        "link": "https://pythonroadmap.com/blog/send-email-attachments-with-python",
        "document": "Before we get started, you'll need to have the following prerequisites in place:\n• A working Python environment, such as Anaconda or Python.org\n• A valid email address and password for an email service provider, such as Gmail or Yahoo\n• Basic understanding of how to send emails with Python\n\nTo send email attachments we need two built-in python libraries : and .\n• library is used to create and format email messages and attachments to them\n• library is used to send email messages via SMTP(Simple Mail Transfer Protocol). SMTP is the protocol used to send emails, regardless of the language you are using.\n\nLet's start by opening a new Python file and writing the following code:\n\nNext, we'll specify our email credentials, such as your email address, password, and the SMTP server settings for your email service provider (e.g. Gmail, Yahoo, Outlook etc). Here's an example of how to set up a Gmail account:\n\nThese credentials will be latest passed on to the specified SMTP server and port. Note, if you're using a different email provider, you'll need to use the appropriate SMTP server settings. Here are the SMTP settings for some popular email providers :\n\nTo create an email message with attachments, we'll need to import the class we imported earlier from library. Let's create a simple email with a a short subject, body, and one attachment:\n\nIn this example, we created an email message with the subject 'Re: Hello, World!', with body \"Hello, this is a test email with an attachment.\". We have also added one attachment named \"attachment.txt\" using the method, this method reads the file data and sets the attachment's content type to \"text/plain.\"\n\nOnce we are done with the above steps, let's now send out email with attachment using library.\n\nHere we first created a SMTP server object using class. This object then makes a secure connection to the SMTP server, logs in with the credentials we specified earlier. We then send the email message using .\n\nLet's discuss some widely used cases that will be helpful while working with email attachments :\n\nTo add multiple attachments to your email message, simply call multiple times with different filenames and file data.\n\nThe and arguments for determine the content type of the attachment. Here are some common content types:\n\nIf you're working with large attachments, you may run into memory issues when reading the file data into memory with . To avoid this, you can use the method to iterate over the attachment data in chunks.\n\nUsing HTML in Your Email Message\n\nMost of the times we want to send fancy HTML templates as emails instead of boring-looking plaintext emails. To achieve this, simply set the message content to an HTML string using .\n\nHow do I handle errors when sending email attachments with Python?\n\n Using Python's exception handling you can catch and handle these errors. Based on the severity, you can log and retry on your exceptions as well.\n\nDepending on the error you can use exception handling to catch and handle these errors. You can add logging, retries as well to help diagnose and retry for failures.\n\nWhat file types can I send as email attachments with Python?\n\n You can send any file type including binaries as email attachments with Python. Remember, some mail servers may block the attachments if the file size, type is a potential security concern.\n\nCan I use Python to receive email attachments?\n\n Yes, to receive email with attachments in Python you can use library. You can then list or get emails, download attachments etc.\n\nHow can I ensure the security of email attachments sent with Python?\n\n Security for email and its attachments are dependent on the email service provider. Make sure you use a secure email service provider, keep strong passwords etc.\n\nHow do I test my email attachments to make sure they work?\n\n You can test by sending test emails with attachments to yourself or other mock email services like mailosaur or mailtrap. You can also test email attachments with varying attachment size etc.\n\nThat's all! In this blog post we saw how we can send email attachments with python easily using the and libraries. Feel free to reach out or comment below for your doubts. Happy emailing!"
    },
    {
        "link": "https://stackoverflow.com/questions/33857698/sending-email-from-python-using-starttls",
        "document": "long story short: starttls can be stripped from smtplib <=py3.5.1rc1 <=py2.7.10 if you do not check response codes for\n• None explicitly calling on smtp servers supporting it with a malicious MitM stripping your command and forging a non response will NOT negotiate ssl, nor raise an exception and therefore leave your communication unencrypted - ergo it is vulnerable to striptls unless you manually verify that the response to or the internal got ssl wrapped. Here's a python 2.7.9 smtplib communication with an example similar to yours that failed to negotiate starttls by having the server or a MitM reply instead of the . No explicit check for the 200 response code in the client script, no exception due to a failed starttls attempt therefore mail transport not encrypted: 220 xx ESMTP 250-xx 250-SIZE 20480000 250-AUTH LOGIN 250-STARTTLS 250 HELP STARTTLS 999 NOSTARTTLS mail FROM:<[email protected]> size=686 250 OK rcpt TO:<[email protected]> 250 OK data\n• None explicitly calling on smtp servers not supporting STARTTLS - or a MitM stripping this capability from the servers response - will raise . see code below.\n• None general note: encryption also depends on the configured cipherspec i.e. your SSLContext which in your case is created by . Note that it is totally valid to configure your SSLContext to allow cipherspecs that authenticate but do not encrypt (if offered/allowed by both server and client). E.g. .\n• None According to this answer python pre 2.7.9/3.4.3 does NOT attempt to enforce certificate validation for the default ssl context and therefore is vulnerable to ssl interception. Starting with Python 2.7.9/3.4.3 certificate validation is enforced for the default context. This also means, that you'll have to manually enable certificate validation for pre 2.7.9/3.4.3 (by creating a custom sslcontext) otherwise any untrusted certificate might be accepted.\n\nShould I use the ehlo() method of the SMTP object? In some examples it is called explicitly before and after calling starttls(). On the other side in the documentation of smptlib it is written, that sendmail() will call it, if it is necessary.\n• , and will implicitly call therefore there is no need to explicitly call it again. This is also"
    },
    {
        "link": "https://docs.python.org/3/library/smtplib.html",
        "document": "The module defines an SMTP client session object that can be used to send mail to any internet machine with an SMTP or ESMTP listener daemon. For details of SMTP and ESMTP operation, consult RFC 821 (Simple Mail Transfer Protocol) and RFC 1869 (SMTP Service Extensions).\n\nAn instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP method is called with those parameters during initialization. If specified, local_hostname is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using . If the call returns anything other than a success code, an is raised. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, is raised. The optional source_address parameter allows binding to some specific source address in a machine with multiple network interfaces, and/or to some specific source TCP port. It takes a 2-tuple , for the socket to bind to as its source address before connecting. If omitted (or if host or port are and/or respectively) the OS default behavior will be used. For normal use, you should only require the initialization/connect, , and methods. An example is included below. The class supports the statement. When used like this, the SMTP command is issued automatically when the statement exits. E.g.: All commands will raise an auditing event with arguments and , where is the bytes about to be sent to the remote host. Changed in version 3.3: Support for the statement was added. Added in version 3.5: The SMTPUTF8 extension (RFC 6531) is now supported. Changed in version 3.9: If the timeout parameter is set to be zero, it will raise a to prevent the creation of a non-blocking socket.\n\nA nice selection of exceptions is defined as well:\n\nAn instance has the following methods: Set the debug output level. A value of 1 or for level results in debug messages for connection and for all messages sent to and received from the server. A value of 2 for level results in these messages being timestamped. Send a command cmd to the server. The optional argument args is simply concatenated to the command, separated by a space. This returns a 2-tuple composed of a numeric response code and the actual response line (multiline responses are joined into one long line.) In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions. If the connection to the server is lost while waiting for the reply, will be raised. Connect to a host on a given port. The defaults are to connect to the local host at the standard SMTP port (25). If the hostname ends with a colon ( ) followed by a number, that suffix will be stripped off and the number interpreted as the port number to use. This method is automatically invoked by the constructor if a host is specified during instantiation. Returns a 2-tuple of the response code and message sent by the server in its connection response. Identify yourself to the SMTP server using . The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the attribute of the object. In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the when necessary. Identify yourself to an ESMTP server using . The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by . Also sets several informational attributes: the message returned by the server is stored as the attribute, is set to or depending on whether the server supports ESMTP, and will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any). Unless you wish to use before sending mail, it should not be necessary to call this method explicitly. It will be implicitly called by when necessary. This method calls and/or if there has been no previous or command this session. It tries ESMTP first. The server didn’t reply properly to the greeting. Return if name is in the set of SMTP service extensions returned by the server, otherwise. Case is ignored. Check the validity of an address on this server using SMTP . Returns a tuple consisting of code 250 and a full RFC 822 address (including human name) if the user address is valid. Otherwise returns an SMTP error code of 400 or greater and an error string. Many sites disable SMTP in order to foil spammers. Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous or command this session, this method tries ESMTP first. This method will return normally if the authentication was successful, or may raise the following exceptions: The server didn’t reply properly to the greeting. The command is not supported by the server. Each of the authentication methods supported by are tried in turn if they are advertised as supported by the server. See for a list of supported authentication methods. initial_response_ok is passed through to . Optional keyword argument initial_response_ok specifies whether, for authentication methods that support it, an “initial response” as specified in RFC 4954 can be sent along with the command, rather than requiring a challenge/response. Changed in version 3.5: may be raised, and the initial_response_ok parameter was added. Issue an command for the specified authentication mechanism, and handle the challenge response via authobject. mechanism specifies which authentication mechanism is to be used as argument to the command; the valid values are those listed in the element of . authobject must be a callable object taking an optional single argument: If optional keyword argument initial_response_ok is true, will be called first with no argument. It can return the RFC 4954 “initial response” ASCII which will be encoded and sent with the command as below. If the does not support an initial response (e.g. because it requires a challenge), it should return when called with . If initial_response_ok is false, then will not be called first with . If the initial response check returns , or if initial_response_ok is false, will be called to process the server’s challenge response; the challenge argument it is passed will be a . It should return ASCII data that will be base64 encoded and sent to the server. The class provides for the , , and mechanisms; they are named , , and respectively. They all require that the and properties of the instance are set to appropriate values. User code does not normally need to call directly, but can instead call the method, which will try each of the above mechanisms in turn, in the order listed. is exposed to facilitate the implementation of authentication methods not (or not yet) supported directly by . Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call again. If keyfile and certfile are provided, they are used to create an . Optional context parameter is an object; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be . If there has been no previous or command this session, this method tries ESMTP first. Changed in version 3.12: The deprecated keyfile and certfile parameters have been removed. The server didn’t reply properly to the greeting. The server does not support the STARTTLS extension. SSL/TLS support is not available to your Python interpreter. Changed in version 3.4: The method now supports hostname check with and Server Name Indicator (see ). Changed in version 3.5: The error raised for lack of STARTTLS support is now the subclass instead of the base . Send mail. The required arguments are an RFC 822 from-address string, a list of RFC 822 to-address strings (a bare string will be treated as a list with 1 address), and a message string. The caller may pass a list of ESMTP options (such as ) to be used in commands as mail_options. ESMTP options (such as commands) that should be used with all commands can be passed as rcpt_options. (If you need to use different ESMTP options to different recipients you have to use the low-level methods such as , and to send the message.) The from_addr and to_addrs parameters are used to construct the message envelope used by the transport agents. does not modify the message headers in any way. msg may be a string containing characters in the ASCII range, or a byte string. A string is encoded to bytes using the ascii codec, and lone and characters are converted to characters. A byte string is not modified. If there has been no previous or command this session, this method tries ESMTP first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If fails, will be tried and ESMTP options suppressed. This method will return normally if the mail is accepted for at least one recipient. Otherwise it will raise an exception. That is, if this method does not raise an exception, then someone should get your mail. If this method does not raise an exception, it returns a dictionary, with one entry for each recipient that was refused. Each entry contains a tuple of the SMTP error code and the accompanying error message sent by the server. If is included in mail_options, and the server supports it, from_addr and to_addrs may contain non-ASCII characters. This method may raise the following exceptions: All recipients were refused. Nobody got the mail. The attribute of the exception object is a dictionary with information about the refused recipients (like the one returned when at least one recipient was accepted). The server didn’t reply properly to the greeting. The server replied with an unexpected error code (other than a refusal of a recipient). was given in the mail_options but is not supported by the server. Unless otherwise noted, the connection will be open even after an exception is raised. Changed in version 3.2: msg may be a byte string. Changed in version 3.5: support added, and may be raised if is specified but the server does not support it. This is a convenience method for calling with the message represented by an object. The arguments have the same meaning as for , except that msg is a object. If from_addr is or to_addrs is , fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322: from_addr is set to the Sender field if it is present, and otherwise to the From field. to_addrs combines the values (if any) of the To, Cc, and Bcc fields from msg. If exactly one set of Resent-* headers appear in the message, the regular headers are ignored and the Resent-* headers are used instead. If the message contains more than one set of Resent-* headers, a is raised, since there is no way to unambiguously detect the most recent set of Resent- headers. serializes msg using with as the linesep, and calls to transmit the resulting message. Regardless of the values of from_addr and to_addrs, does not transmit any Bcc or Resent-Bcc headers that may appear in msg. If any of the addresses in from_addr and to_addrs contain non-ASCII characters and the server does not advertise support, an is raised. Otherwise the is serialized with a clone of its with the attribute set to , and and are added to mail_options. Terminate the SMTP session and close the connection. Return the result of the SMTP command. Low-level methods corresponding to the standard SMTP/ESMTP commands , , , , , and are also supported. Normally these do not need to be called directly, so they are not documented here. For details, consult the module code.\n\nThis example prompts the user for addresses needed in the message envelope (‘To’ and ‘From’ addresses), and the message to be delivered. Note that the headers to be included with the message must be included in the message as entered; this example doesn’t do any processing of the RFC 822 headers. In particular, the ‘To’ and ‘From’ addresses must be included in the message headers explicitly: # Add the From: and To: headers at the start! In general, you will want to use the package’s features to construct an email message, which you can then send via ; see email: Examples."
    },
    {
        "link": "https://stackoverflow.com/questions/64505/sending-mail-from-python-using-smtp",
        "document": "The script I use is quite similar; I post it here as an example of how to use the email.* modules to generate MIME messages; so this script can be easily modified to attach pictures, etc.\n\nI rely on my ISP to add the date time header.\n\nMy ISP requires me to use a secure smtp connection to send mail, I rely on the smtplib module (downloadable at http://www1.cs.columbia.edu/~db2501/ssmtplib.py)\n\nAs in your script, the username and password, (given dummy values below), used to authenticate on the SMTP server, are in plain text in the source. This is a security weakness; but the best alternative depends on how careful you need (want?) to be about protecting these."
    },
    {
        "link": "https://mailtrap.io/blog/smtplib",
        "document": "In this tutorial, I will explain how to send emails using smtplib, a popular Python package that allows you to easily interact with and leverage an SMTP server.\n\nTo finish it off, I’ll show you how to debug the smtplib module and test your emails before you send them to ensure your code is working as intended.\n\nFirst things first, if you haven’t already, make sure to download Python 3.7 or above. Here’s the link to the official download page.\n\nThen, we’ll need to:\n\nSince smtplib is a built-in Python module, we don’t need to install it separately, however, we need to import it alongside , which formats the email correctly.\n\nThen, you’ll need to define the SMTP server details, like so:\n\nAs you can see, I use Mailtrap SMTP, however, you can use any SMTP provider you prefer (e.g., Gmail, Outlook, Office 365, etc.). Personally, I prefer Mailtrap’s SMTP since it’s a reliable mail server with robust sending capabilities that ensures my emails reach recipients’ inboxes. Besides the high sending throughput, it comes with in-depth analytics, dedicated IPs, and other features that make it easy to optimize my email infrastructure.\n\nMailtrap also offers a free plan for you to try out all of its features, so be sure to check it out!\n\nNext, we need to specify the details of our email message, such as the sender, recipient, subject, body, etc. Here’s a code snippet you can tweak according to your liking:\n• If you want to get the full description of smtplib classes and arguments and ensure you’ve imported it properly, run the following command:\n• For the rest of the SMTP objects like SMTP.ehlo, please refer to the official smtplib documentation.\n\n4. Connecting to the SMTP server and sending the email\n\nFinally, to establish a connection to the SMTP server and send the email, add the following code snippet to your main project file (e.g., send-email.py):\n\nYou can also create an email manually without MIME headers with , , and , like so:\n\nAnd for your convenience, here’s the full code snippet you can copy/paste and edit according to your liking:\n\nTo run the script, execute one of the following commands:\n\nIf you’re getting python’ is not recognized as internal or external command error, try running .\n\nFacing any errors? For more debugging info, click here.\n\nTo send an HTML email, specify your HTML message in and replace with in . Check it out:\n\nIf you want to forward your HTML email to multiple recipients, you can simply pass a list of email addresses in and format the field correctly for display:\n\nNote: With the code above, you will send one email to all recipients at once. However, if you want to send separate emails to each recipient and avoid exposing recipients to each other, you can place the following loop inside the block:\n\nKeep in mind that although sending your emails in a loop allows you to track deliveries separately per each recipient, it also slows down bulk sending as the SMTP gets multiple requests. But, more on bulk email sending a bit later in the article.\n\nThe most efficient (and easiest) way to send attachments with smtplib is to use , which allows us to create a, you’ve guessed it, multi-part email.\n\nThen, we’ll attach the file with .\n\nLastly, we’ll encode and attach the file by specifying the path, and that’s it! Here’s the full script:\n\nExtra: If your file is dynamic or user-provided and you think you need to validate its path before sending, you can use the os module. Simply add after and insert before to check if the file exists before opening it:\n\nFor sending emails with embedded images, we will use:\n• for handling different parts of the email (HTML + image).\n• for referencing the image inside the HTML body.\n• As you can notice for yourself from the code, I’ve added the os module again since images are often dynamically named. With os, the code will extract the filename from the full path before attaching it to the email.\n• I’ve also added to ensure the image is displayed inline across different email clients.\n\nSince smtplib doesn’t natively support asynchronous sending, we’ll have to import Python’s asyncio library. Additionally, we’ll install aiosmtplib:\n\nOnce installed, copy/paste the following script into your send-email.py and adjust it accordingly:\n\nAs sending bulk emails comes with a few challenges, we’ll need to implement:\n• Batching to group emails into smaller sets (batches) and avoid being flagged as spam.\n• Throttling to add delays between batches and prevent SMTP overload.\n• Parallel threading to send multiple batches at once and speed up delivery.\n• Async (aiosmtplib) to process emails more efficiently and avoid blocking.\n\nAnd here’s the full code snippet you can use:\n\nImportant: If you plan on sending large amounts of email, I recommend using the dedicated Mailtrap Bulk Stream, which is designed to handle high volumes of email sending while keeping your deliverability high.\n\nYou can also use the bulk-aware email API, with which you can send customized HTML emails to 1,000,000 recipients with a single API call. Moreover, the API will compile the information into emails itself.\n\nHere’s how you can identify SMTP errors (authentication, connection, formatting issues) or other non-SMTP-related issues and troubleshoot any email-sending failures:\n\nFirst things first, to see the full ‘conversation’ between your client and the SMTP server, or communication logs, you can use the built-in debug mode .\n\nYou can also use if your preferred SMTP server requires it to properly identify the client or if you’re encountering connection issues:\n\nNote: Like the rest of the code snippets in this chapter, you can simply copy them into your main Python email-sending file (e.g., send-email.py)\n\nTo log errors for debugging, add the following error handling logic at the end of your email-sending script:\n\nThis logic will also prevent the script from crashing in case authentication, connection, or the sending itself fails.\n\nTo catch the most common SMTP errors and get messages that can help you diagnose problems, simply wrap your code in blocks:\n\nBesides SMTP errors, you can face other issues that are related to network connectivity, server response handling, or even simple syntax typos.\n\nFor or errors, is probably missing for port 587. To fix it, simply call:\n\nIf the problem still persists, disable verification and try again (this is only recommended for testing environments):\n\nLastly, if you want to test your smtplib configuration without a real SMTP server, that is, on localhost, you can use the aiosmtpd module, which has a DebuggingServer feature that discards outgoing messages and prints them to stdout.\n\nTo use the module, install it with the following command:\n\nIn some versions the path to the Debugging controller can be different. If the above command doesn’t work for you, try this one:\n\nHowever, if you want to run it on port 25 for testing, you’ll need root permissions:\n\nAlthough this will tell you whether your code is working correctly or not, aiosmtpd module won’t tell you whether your HTML emails are rendered correctly or whether you’re passing spam filters. However, I’ll show you how to handle this in a minute.\n\nOkay, now that we’ve nailed down smtplib debugging, it’s time to test our email-sending functionality. This is an industry-standard practice that ensures:\n• Your test emails won’t land in your customers’ inboxes.\n• Your domain won’t get blacklisted for spam.\n• Your emails will look the way you intend them to.\n\nPersonally, I use Mailtrap Email Testing, another essential part of Mailtrap Email Delivery Platform, which allows me to do all of the above.\n\nNamely, with Email Testing, I can inspect the HTML/CSS of my emails and easily remove/fix any faulty lines of code, preview how my messages look on different devices or email clients, and more.\n\nOnce I fine tune my HTML, I usually use the Spam Analysis feature, which provides me with a spam score for my emails. If it’s under 5, then I’m in the clear. If it’s above 5, I use the detailed list of spam points to fix my emails accordingly.\n\nThis way, I proactively solve a significant number of potential email deliverability issues, since my won’t hit spam filters when my app moves to production\n\nAbove all, testing emails with Mailtrap is super straightforward, check it out! ⬇️\n\nTo start testing, all you have to do is:\n• Navigate to Email Testing and choose your inbox\n• Go to the Integration tab and select Python: smtplib\n\nThen, you can either copy/paste the credentials into your existing email-sending configuration or use the provided code snippet, whatever you prefer more. Here’s what your send-email.py would look like with testing credentials:\n\nYou can also automate your testing process with Mailtrap’s very own Email Testing API. For more info about this automation, check out the official docs or our GitHub repository.\n\nAnd if you feel like learning more about different testing methods in Python, watch the awesome video our YouTube has prepared for you! 👀\n\nUp for more reads? Learn how to:\n• Use Gmail SMTP or API to send emails in Python"
    },
    {
        "link": "https://realpython.com/python-send-email",
        "document": "You probably found this tutorial because you want to send emails using Python. Perhaps you want to receive email reminders from your code, send a confirmation email to users when they create an account, or send emails to members of your organization to remind them to pay their dues. Sending emails manually is a time-consuming and error-prone task, but it’s easy to automate with Python.\n\nIn this tutorial you’ll learn how to:\n• Set up a secure connection using and\n• Send emails with HTML content and attachments using the package\n• Use the Yagmail package to send email through your Gmail account using only a few lines of code\n\nYou’ll find a few transactional email services at the end of this tutorial, which will come in useful when you want to send a large number of emails.\n\nPython comes with the built-in module for sending emails using the Simple Mail Transfer Protocol (SMTP). uses the RFC 821 protocol for SMTP. The examples in this tutorial will use the Gmail SMTP server to send emails, but the same principles apply to other email services. Although the majority of email providers use the same connection ports as the ones in this tutorial, you can run a quick Google search to confirm yours. To get started with this tutorial, set up a Gmail account for development, or set up an SMTP debugging server that discards emails you send and prints them to the command prompt instead. Both options are laid out for you below. A local SMTP debugging server can be useful for fixing any issues with email functionality and ensuring your email functions are bug-free before sending out any emails. If you decide to use a Gmail account to send your emails, I highly recommend setting up a throwaway account for the development of your code. This is because you’ll have to adjust your Gmail account’s security settings to allow access from your Python code, and because there’s a chance you might accidentally expose your login details. Also, I found that the inbox of my testing account rapidly filled up with test emails, which is reason enough to set up a new Gmail account for development. A nice feature of Gmail is that you can use the sign to add any modifiers to your email address, right before the sign. For example, mail sent to and will both arrive at . When testing email functionality, you can use this to emulate multiple addresses that all point to the same inbox. To set up a Gmail address for testing your code, do the following:\n• Turn Allow less secure apps to ON. Be aware that this makes it easier for others to gain access to your account. If you don’t want to lower the security settings of your Gmail account, check out Google’s documentation on how to gain access credentials for your Python script, using the OAuth2 authorization framework. You can test email functionality by running a local SMTP debugging server, using the module that comes pre-installed with Python. Rather than sending emails to the specified address, it discards them and prints their content to the console. Running a local debugging server means it’s not necessary to deal with encryption of messages or use credentials to log in to an email server. You can start a local SMTP debugging server by typing the following in Command Prompt: On Linux, use the same command preceded by . Any emails sent through this server will be discarded and shown in the terminal window as a object for each line: b'Hello there, here is a test email' For the rest of the tutorial, I’ll assume you’re using a Gmail account, but if you’re using a local debugging server, just make sure to use as your SMTP server and use port 1025 rather than port 465 or 587. Besides this, you won’t need to use or encrypt the communication using SSL/TLS.\n\nBefore we dive into sending emails with HTML content and attachments, you’ll learn to send plain-text emails using Python. These are emails that you could write up in a simple text editor. There’s no fancy stuff like text formatting or hyperlinks. You’ll learn that a bit later. When you send emails through Python, you should make sure that your SMTP connection is encrypted, so that your message and login credentials are not easily accessed by others. SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are two protocols that can be used to encrypt an SMTP connection. It’s not necessary to use either of these when using a local debugging server. There are two ways to start a secure connection with your email server:\n• Start an SMTP connection that is secured from the beginning using .\n• Start an unsecured SMTP connection that can then be encrypted using . In both instances, Gmail will encrypt emails using TLS, as this is the more secure successor of SSL. As per Python’s Security considerations, it is highly recommended that you use from the module. This will load the system’s trusted CA certificates, enable host name checking and certificate validation, and try to choose reasonably secure protocol and cipher settings. If you want to check the encryption for an email in your Gmail inbox, go to More → Show original to see the encryption type listed under the Received header. is Python’s built-in module for sending emails to any Internet machine with an SMTP or ESMTP listener daemon. I’ll show you how to use first, as it instantiates a connection that is secure from the outset and is slightly more concise than the alternative. Keep in mind that Gmail requires that you connect to port 465 if using , and to port 587 when using . The code example below creates a secure connection with Gmail’s SMTP server, using the of to initiate a TLS-encrypted connection. The default context of validates the host name and its certificates and optimizes the security of the connection. Make sure to fill in your own email address instead of : Using makes sure that the connection is automatically closed at the end of the indented code block. If is zero, or not specified, will use the standard port for SMTP over SSL (port 465). It’s not safe practice to store your email password in your code, especially if you intend to share it with others. Instead, use to let the user type in their password when running the script, as in the example above. If you don’t want your password to show on your screen when you type it, you can import the module and use instead for blind input of your password. Instead of using to create a connection that is secure from the outset, we can create an unsecured SMTP connection and encrypt it using . To do this, create an instance of , which encapsulates an SMTP connection and allows you access to its methods. I recommend defining your SMTP server and port at the beginning of your script to configure them easily. The code snippet below uses the construction , rather than the format which we used in the previous example. To make sure that your code doesn’t crash when something goes wrong, put your main code in a block, and let an block print any error messages to : # Try to log in to server and send email To identify yourself to the server, (SMTP) or (ESMTP) should be called after creating an object, and again after . This function is implicitly called by and if needed, so unless you want to check the SMTP service extensions of the server, it is not necessary to use or explicitly. After you initiated a secure SMTP connection using either of the above methods, you can send your email using , which pretty much does what it says on the tin: I recommend defining the email addresses and message content at the top of your script, after the imports, so you can change them easily: This message is sent from Python.\"\"\" The string starts with followed by two newlines ( ). This ensures shows up as the subject of the email, and the text following the newlines will be treated as the message body. The code example below sends a plain-text email using : This message is sent from Python.\"\"\" For comparison, here is a code example that sends a plain-text email over an SMTP connection secured with . The lines may be omitted, as they are called implicitly by and , if required: This message is sent from Python.\"\"\"\n\nPython’s built-in package allows you to structure more fancy emails, which can then be transferred with as you have done already. Below, you’ll learn how use the package to send emails with HTML content and attachments. If you want to format the text in your email (bold, italics, and so on), or if you want to add any images, hyperlinks, or responsive content, then HTML comes in very handy. Today’s most common type of email is the MIME (Multipurpose Internet Mail Extensions) Multipart email, combining HTML and plain-text. MIME messages are handled by Python’s module. For a detailed description, check the documentation. As not all email clients display HTML content by default, and some people choose only to receive plain-text emails for security reasons, it is important to include a plain-text alternative for HTML messages. As the email client will render the last multipart attachment first, make sure to add the HTML message after the plain-text version. In the example below, our objects will contain the HTML and plain-text versions of our message, and the instance combines these into a single message with two alternative rendering options: # Create the plain-text and HTML version of your message # The email client will try to render the last part first In this example, you first define the plain-text and HTML message as string literals, and then store them as / objects. These can then be added in this order to the message and sent through your secure connection with the email server. Remember to add the HTML message after the plain-text alternative, as email clients will try to render the last subpart first. In order to send binary files to an email server that is designed to work with textual data, they need to be encoded before transport. This is most commonly done using , which encodes binary data into printable ASCII characters. The code example below shows how to send an email with a PDF file as an attachment: \"An email with attachment from Python\" \"This is an email with attachment sent from Python\" # In same directory as script # Email client can usually download this automatically as attachment # Encode file in ASCII characters to send by email # Add attachment to message and convert message to string # Log in to server using secure context and send email The message accepts parameters in the form of RFC5233-style key/value pairs, which are stored in a dictionary and passed to the method of the base class. Check out the documentation for Python’s module to learn more about using MIME classes.\n\nImagine you want to send emails to members of your organization, to remind them to pay their contribution fees. Or maybe you want to send students in your class personalized emails with the grades for their recent assignment. These tasks are a breeze in Python. An easy starting point for sending multiple personalized emails is to create a CSV (comma-separated values) file that contains all the required personal information. (Make sure not to share other people’s private information without their consent.) A CSV file can be thought of as a simple table, where the first line often contains the column headers. Below are the contents of the file , which I saved in the same folder as my Python code. It contains the names, addresses, and grades for a set of fictional people. I used constructions to make sure all emails end up in my own inbox, which in this example is my@gmail.com: When creating a CSV file, make sure to separate your values by a comma, without any surrounding whitespaces. The code example below shows you how to open a CSV file and loop over its lines of content (skipping the header row). To make sure that the code works correctly before you send emails to all your contacts, I’ve printed for each contact, which we can later replace with functionality that actually sends out emails: In the example above, using makes sure that your file closes at the end of the code block. makes it easy to read a CSV file line by line and extract its values. The line skips the header row, so that the following line for name, email, grade in reader: splits subsequent rows at each comma, and stores the resulting values in the strings , and for the current contact. If the values in your CSV file contain whitespaces on either or both sides, you can remove them using the method. You can put personalized content in a message by using to fill in curly-bracket placeholders. For example, \"hi {name}, you {result} your assignment\".format(name=\"John\", result=\"passed\") will give you \"hi John, you passed your assignment\" . As of Python 3.6, string formatting can be done more elegantly using f-strings, but these require the placeholders to be defined before the f-string itself. In order to define the email message at the beginning of the script, and fill in placeholders for each contact when looping over the CSV file, the older method is used. With this in mind, you can set up a general message body, with placeholders that can be tailored to individuals. The following code example lets you send personalized emails to multiple contacts. It loops over a CSV file with for each contact, as in the example above. The general message is defined in the beginning of the script, and for each contact in the CSV file its and placeholders are filled in, and a personalized email is sent out through a secure connection with the Gmail server, as you saw before:\n\nThere are multiple libraries designed to make sending emails easier, such as Envelopes, Flanker and Yagmail. Yagmail is designed to work specifically with Gmail, and it greatly simplifies the process of sending emails through a friendly API, as you can see in the code example below: \"Hello there from Yagmail\" This code example sends an email with a PDF attachment in a fraction of the lines needed for our example using and . When setting up Yagmail, you can add your Gmail validations to the keyring of your OS, as described in the documentation. If you don’t do this, Yagmail will prompt you to enter your password when required and store it in the keyring automatically.\n\nIf you plan to send a large volume of emails, want to see email statistics, and want to ensure reliable delivery, it may be worth looking into transactional email services. Although all of the following services have paid plans for sending large volumes of emails, they also come with a free plan so you can try them out. Some of these free plans are valid indefinitely and may be sufficient for your email needs. Below is an overview of the free plans for some of the major transactional email services. Clicking on the provider name will take you to the pricing section of their website. 40,000 emails for your first 30 days, then 100/day You can run a Google search to see which provider best fits your needs, or just try out a few of the free plans to see which API you like working with most."
    }
]