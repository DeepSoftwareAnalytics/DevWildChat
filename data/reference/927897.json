[
    {
        "link": "https://crypto.stackexchange.com/questions/48054/creating-your-own-encryption-and-decryption-algorithm",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/8442444/character-for-character-encryption",
        "document": "You want to use a stream cipher, or (if your use case justifies it) a one-time pad. One-time pads are a pain to use - you need to get the key to the receiving party somehow out-of-band, the key must be at least as long as the plaintext, and there are significant difficulties dealing with all the issues that occur if there is a transmission error - so stream ciphers are probably the way to go.\n\nRC4 could be a suitable algorithm for you.\n\nIs there a particular reason why you must have character-for-character encryption? Symmetric algorithms like AES tend to use small block sizes, typically 64 bits, so it's unlikely to add much space overhead. If you can use a symmetric block cipher then that may make things easier for you.\n\nI'm not sure what you mean by a \"key\" based solution. All modern encryption algorithms are keyed, but the nature of the key changes depending on the algorithm. Symmetric ciphers typically have a shared secret key, asymmetric algorithms are the ones that use public/private keys. There are different stream ciphers that use either type of key, according to the Handbook of Applied Cryptography.\n\nI'm also a little unsure what you mean by \"the security threat of losing our key is not significant, and is an acceptable risk.\" If you lose your key then you have no encryption any more (at least, until you rotate your keys). If not having encryption is acceptable then why are you bothering with encryption in the first place? If it's enough to just obfuscate the data then that's a whole different problem."
    },
    {
        "link": "https://security.stackexchange.com/questions/9605/techniques-for-writing-encryption-algorithms-exclusively-for-personal-use",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://auth0.com/blog/encoding-encryption-hashing",
        "document": "Sometimes people use the terms encryption and encoding interchangeably. Also, often hashing is called into play as an encryption mechanism. Confusing these concepts may lead to misunderstandings in the way security is implemented.\n\nLet's take a high-level overview of these concepts and clarify the differences.\n\nIf you prefer watching videos, here is a video version of this article:\n\nLet's start with encoding. You can define it as a technique to transform data from one format to another so that it can be understood and consumed by different systems.\n\nBasically, encoding has to do with information representation. When you have some information, say the name of the mineral that weakens Superman, you can represent it through letters, as in kryptonite. This is a handy representation for humans but not so easy for being manipulated by computers. What usually happens, in this case, is the transformation of this sequence of characters into a sequence of bits like this:\n\nYou have two representations for the same information. The letter-based representation is usually understood by human systems; the bit-based representation is more suitable for computer systems. Commonly, you say that the sequence of letters has been encoded into a sequence of bits.\n\nSo, encoding is just a transformation from one data representation to another, keeping the same information. Usually, it involves a conversion table, such as an ASCII table in our example, that maps a representation item in one system to the corresponding representation item in the other system.\n\nYou can find several encoding mechanisms out there. To mention just a few in the character encoding space, apart from the dear old ASCII, you have:\nâ€¢ Unicode, which allows you to represent more complex items than letters, such as emoji and other symbols.\nâ€¢ Base64, which lets you represent binary data, such as an image, through text.\nâ€¢ URL encoding, useful to represent arbitrary data in an URL, where some characters are reserved or cannot be used (think of spaces or colons, for example).\n\nConsider JSON Web Tokens (JWT), for example. The three parts that compose a token are encoded using Base64-URL, a variant of Base64 encoding combined with URL encoding. The following is an example of encoded JWT:\n\nYou can see the decoded version of this JWT using the jwt.io debugger.\n\nThis encoding mechanism allows the token to be easily passed in HTML and HTTP environments without fear of clashes with reserved or unrepresentable characters. If you want to learn more about JWTs, you can download the JWT Handbook.\n\nEncoding ensures interoperability between systems. It allows systems that use different data representations to share information.\n\nEncoding has no security purpose. Anyone who knows the conversion algorithm can encode and decode data. The conversion algorithm is not kept secret. On the contrary, it is public in order to facilitate interoperability between systems.\n\nFinally, encoding is a reversible process. You can transform a piece of data from one representation to another and then go back to the original representation without information loss.\n\nEncryption is a technique that makes your data unreadable and hard to decode for an unauthorized user.\n\nSo, basically, encryption is a mechanism that transforms data into a different representation so that prying eyes cannot understand it. Wait! Isn't this transformation the same as encoding after all? ðŸ¤”\n\nHow can a human being understand that the following sequence of bits represents the word kryptonite?\n\nIn fact, the question is not far-fetched. In a way, encryption is a form of encoding. It transforms data from one representation to another. For this reason, sometimes, people use the terms encryption and encoding interchangeably. However, the purpose of encryption is different from the encoding's one.\n\nLook at the definition above. The encryption technique aims at making data unreadable and hard to decode. If you think about it for a moment, it is the opposite reason of pure encoding: encoding aims at making data as much understandable as possible across systems while encryption tries to make it undecipherable, unless you are authorized.\n\nThe main goal of encryption is to ensure data confidentiality, i.e., protecting data from being accessed by unauthorized parties.\n\nSo, while encoding makes its conversion algorithms as public as possible, encryption should keep such algorithms private. Actually, it's not really like that. Relying on secret algorithms is not the best choice to protect data in the long run. Better solutions rely on well-known algorithms whose data transformation is based on sequences of numbers or letters called keys.\n\nThe best mechanisms to encrypt data are based on mathematical algorithms that can be solved only with the possession of a key or with advanced computational power. Two families of key-based encryption algorithms exist:\nâ€¢ Symmetric-key algorithms: these algorithms use the same key to encrypt and decrypt data. The Advanced Encryption Standard (AES) algorithm is an example of this family's algorithms.\nâ€¢ Asymmetric-key algorithms: these algorithms use different keys to encrypt and decrypt data. The two keys are bound by a complex mathematical relationship. RSA is an example of an algorithm in this family. Check out this blog post for a gentle introduction to asymmetric-key algorithms.\n\nLike pure encoding, encryption is a reversible process as well, although just for authorized people. Authorized people are the ones in possession of a decryption key.\n\nThe challenge of authorized versus unauthorized people is to make data decryption without the key as hard as possible. This leads to applying a mix of cautions such as complex mathematical relationships between the keys, keeping them secret, changing them frequently, and so on.\n\nLet's take a look at hashing now. Basically, it's a technique to generate a unique fixed-length string (hash) strictly depending on the specific input data.\n\nSince the generated hash depends on the specific input data, any small change to the input data generates a different hash. So, having the hash of a given piece of data, you can verify if that data has been altered by calculating its hash and comparing it with the one you already have. In other words, hashing ensures data integrity.\n\nSuppose you like Lex Luthor's sarcastic line, That's Kryptonite, Superman. Little souvenir from the old home town. You like it so much that you want it to always be quoted in exactly this way. No character changed.\n\nYou calculate its hash string as follows:\n\nAssume someone writes that quote slightly different, such as, That's kryptonite, Superman. Little souvenir from the old home town. The following is the hash of this second version:\n\nYou can see that the two hashes are different just by looking at the first characters. This tells you that the two sentences are not written the same way. Did you notice the difference between the two sentences? The second version has a lower-case k instead of the capital K in kryptonite.\n\nYou may say: why do you compare the two hash strings when you could compare the two sentences? Good point! Imagine that you have a document of thousands of words or a high-quality picture instead of a sentence. In that case, comparing the hash strings is more effective than comparing the whole media.\n\nSo, how can you get a hash? A hashing algorithm must have the following features:\nâ€¢ The same input always produces the same output.\nâ€¢ Multiple different inputs should not produce the same output.\nâ€¢ It must not be possible to obtain the input from the output data.\nâ€¢ Any change to the input data implies a different resulting hash.\n\nAs you can see, point 4 implies that hashing is not a reversible process, unlike encoding and encryption. Also, point 3 seems to say that, while you should get different hashes for distinct input data, it can't be guaranteed. Actually, this point makes the difference between hashing algorithms. For example, MD5 has been a very common hashing algorithm in the past, but in 2008 it was deprecated due to collision detection. The same happened to some early algorithms of the Secure Hashing Algorithms (SHA) family.\n\nThe Right Tool for the Right Goal\n\nAs you've seen, encoding, hashing, and encryption have their specific purposes and features. Confusing their capabilities and roles in your system may lead to disastrous consequences.\n\nFor example, you may think that encrypting passwords is the best security option. Actually, it's a very bad idea. That's what the Adobe engineers learned in a data breach in 2013. The attackers who got access to their user database could break the encryption algorithm. Remember that encryption is a reversible process. Even if they don't have the decryption key, they may have enough time to guess it. Adobe reset users' passwords as a countermeasure, but you know users use the same password for multiple services. So, even if access to Adobe services may be safe, access to other websites was potentially compromised.\n\nThey should have used hashing instead of encryption to store users passwords securely. You know that hashing is not a reversible process. Attackers can't determine the password from which the hash was generated. But also, simply relying on hashing is not the best option, as the LinkedIn breach teaches us.\n\nIf you want, you can learn more about storing passwords using hashing and how to use salt to store them properly. Also, for a more technical comparison of encoding, encryption, and hashing, read this article.\n\nNow you know the difference between encoding, encryption, and hashing. To briefly recap what you learned throughout this article, take a look at the following cheat sheet:"
    },
    {
        "link": "https://geeksforgeeks.org/substitution-cipher",
        "document": "Hiding some data is known as encryption. When plain text is encrypted it becomes unreadable and is known as ciphertext. In a Substitution cipher, any character of plain text from the given fixed set of characters is substituted by some other character from the same set depending on a key. For example with a shift of 1, A would be replaced by B, B would become C, and so on.\n\nNote: A special case of Substitution cipher is known as Caesar cipher where the key is taken as 3.\n\nThe encryption can be represented using modular arithmetic by first transforming the letters into numbers, according to the scheme, A = 0, B = 1,â€¦, Z = 25. Encryption of a letter by a shift n can be described mathematically as.\nâ€¢ None A String of both lower and upper case letters, called PlainText.\nâ€¢ None Create a list of all the characters.\nâ€¢ None Create a dictionary to store the substitution for all characters.\nâ€¢ None For each character, transform the given character as per the rule, depending on whether weâ€™re encrypting or decrypting the text.\n\nBelow is the implementation.\n\n// Create a dictionary to store the substitution for the // given alphabet in the plain text based on the key // Create a map to store the substitution for the given // alphabet in the cipher text based on the key // create a dictionary to store the substitution for the given alphabet in the plain text based on the key // create a map to store the substitution for the given alphabet in the cipher text based on the key for the given alphabet in the plain text for the given alphabet in the cipher // create a dictionary to store the substitution for the given alphabet in the plain text based on the key // create a dictionary to store the substitution for the given alphabet in the cipher text based on the key Create a map to store the substitution for the given alphabet in the plain text based on the key Create a map to store the substitution for the given alphabet in the cipher text based on the key"
    },
    {
        "link": "https://crypto.stackexchange.com/questions/48054/creating-your-own-encryption-and-decryption-algorithm",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://liquidweb.com/blog/encryption-key-management-best-practices",
        "document": "Storing and accessing information about your business, employees, and consumers is essential for streamlined day-to-day operations and frictionless customer experiences.\n\nThat said, access to data comes with the responsibility to secure and protect it from outside consumption or tampering. As a cornerstone of cybersecurity, encryption helps prevent data breaches and make your data unreadable to attackers who gain access to your network.\n\nAnd Liquid Webâ€™s Private Cloud powered by VMware can further protect your data.\n\nIf you want to get the most out of cryptographic processes, you need to have the right practices and policies in place to maintain the balance of ensuring that encrypted data remains accessible to those who need it and securing it from anyone else.\nâ€¢ The role of encryption in protecting sensitive data\nâ€¢ Encryption keys and the importance of key management in effective encryption\n\nThe role of encryption in protecting sensitive data\n\nEncryption is an essential tool for protecting sensitive data â€” or any data, for that matter â€” as it ensures that data remains unreadable to unauthorized users and prevents tampering. You can use encryption to secure data thatâ€™s stored on premises or in the cloud. Equally crucial is the use of encryption to maintain the integrity of your data by preventing tampering during transit or processing.\n\nEncryption keys and the importance of key management in effective encryption\n\nCryptographic keys are used to encrypt and decrypt your data, which helps ensure that only the people authorized to view and edit information have that access. Encryption keys also secure data transfers between entities and verify digital signatures.\n\nThe two main types of cryptographic algorithms are:\nâ€¢ Symmetric encryption (or private key encryption) uses the same key to encrypt and decrypt information. This is frequently used for data transmission.\nâ€¢ Asymmetric encryption (or public key infrastructure) uses two related keys, one public and the other private. Typically, the public key encrypts the data, and the private key is used by the individual decrypting it. Asymmetric cryptography is often used to protect and share the keys used in symmetric encryption.\n\nBecause keys enable data protection, authorized information access, secure transfers, and authentication, managing them properly is crucial to the encryption process. When surveyed, 59% of IT and IT security professionals said that managing encryption keys significantly impacts their businesses. To understand the importance of key management, itâ€™s helpful to look at what happens when it goes wrong.\n\nPoor key management can make it difficult to decrypt information, interrupting operations and leading to expensive data recovery processes. If youâ€™re not properly managing encryption keys, you can end up with fines and fees for not complying with encryption guidelines that may apply to your company, like the General Data Protection Regulation (GDPR) or the Health Insurance Portability and Accountability Act (HIPAA).\n\nMismanagement of keys can also compromise the security of your encrypted data by giving unauthorized people access to protected information.\n\nWhen a key becomes compromised, an outside entity can:\nâ€¢ Impersonate someone in your organization.\nâ€¢ Access, extract, or manipulate the data you store on your server.\nâ€¢ Sign electronic documents on behalf of someone in your organization.\n\nIf your company experiences a data breach, you can incur financial losses and reputational damage that can negatively impact your ability to win and keep customers. As such, itâ€™s essential for IT and IT security teams to implement effective key management as part of their regular processes.\n\nThat said, 89% of cybersecurity personnel list cryptography as an area that requires skill improvement. For those looking to improve overall security, here are eight on-premise and cloud encryption key management best practices to implement for optimal encryption performance.\n\nCreating a centralized key management policy can help ensure the proper handling of keys. Your policy should clearly outline who is responsible for each key lifecycle management stage, from creation and activation to expiration and destruction. It should also define key access controls, which dictate who can use and manage each key at different stages.\n\nIn addition to roles and responsibilities, your key management policy should dictate how your team uses and manages keys. For example, you can specify when certain keys can and canâ€™t be used. You can incorporate the rest of these best practices into your companyâ€™s policy as guidelines for properly handling keys.\n\nOnce youâ€™ve created the policy, you should enforce it, which starts with training your team on the instructions and then monitoring to ensure everyone is complying with the guidelines.\n\nData encryption keys are used for encryption, decryption, authentication, digital signatures, and protecting other keys (also known as key wrapping). That said, you should limit each key to a single purpose rather than using one key to achieve multiple goals.\n\nWhen each key has one purpose, it simplifies management, as itâ€™s easier to adhere to the best practices around key length and rotation period based on its intended use. This also increases security because reusing one key for different purposes can expose you to more vulnerabilities. Single-use keys are more isolated and provide better data protection.\n\nEmbedding keys into the source code of your programs or configuration files adds unnecessary risk and complexity to your key management process. First and foremost, if hackers can access your source code, this gives them access to the key. It can also make it more difficult for you to detect breaches.\n\nBeyond that, hard coding means youâ€™ll have to edit your source code every time you rotate keys. This makes key management more labor-intensive, as you must redeploy your application more frequently. At the bare minimum, keys should be stored in separate files or as environment variables to separate them from your source code and reduce the risk of exposure.\n\nInstead of using software to store keys, consider opting for hardware security modules (HSMs), which are physical tools designed for securing key materials. Because keys are stored and used within the HSM and not exported, this reduces your overall exposure risk.\n\nBecause HSMs are explicitly built for cryptographic operations, most offer benefits like tamper-resistant features, adherence to the latest recommendations for key generation, and compliance with regulatory standards. Theyâ€™re also designed to enable faster encryption, decryption, and authentication, helping optimize the performance of systems that rely on encryption.\n\nKey management systems (KMSs) are network services that facilitate the management and use of encryption keys in a secure environment. These systems are essential cybersecurity tools for most organizations, and 52% of professionals report using at least five key management solutions to effectively manage data encryption keys across various environments.\n\nHSMs back many KMS solutions, and using them together is an excellent way to enable secure and efficient key management. You can streamline your key management by using a KMS to automate tasks in the key lifespan, including generation, backup, rotation, and destruction. Automating these key activities reduces the risk of manual error and keeps the lifespan running smoothly for all keys across your organization.\n\nAuditing your key management processes annually helps you enforce your companyâ€™s policies and procedures. As a result, you can limit exposure and reduce the risk of any keys becoming compromised and leading to a data breach.\n\nConducting audits also allows you to ensure that your policies and procedures remain effective and up to date. You can get feedback from your team about any unclear, outdated, or inefficient guidelines and take steps to improve them.\n\nDisaster response and data recovery should be outlined as a part of your key management procedures. Start by identifying the types of threats you may face and understanding the potential impact of each one.\n\nFrom there, define your key backup strategy. Focus on where to store backups and how often to back up each key automatically. Your recovery strategy should also include instructions on how to restore and verify keys from your backups before using them.\n\nIf you want to test the effectiveness of your plan, you can perform disaster drills and see if there are areas of the strategy that need improvement.\n\nA comprehensive inventory of your keys is especially useful when conducting audits and responding to disasters.\n\nBecause of this, itâ€™s important to maintain and update your database of key information and metadata, including:\nâ€¢ Users who are authorized to access the key.\nâ€¢ Person or department who owns the key.\n\nYou can also group keys by their priority level in a recovery situation so your team knows where to focus their time if thereâ€™s a disaster event. In addition to the inventory, you want to keep up-to-date access and usage logs to inform audits. These logs can detail who used the key, when they used it, and what information they accessed.\n\nBecause keys play such a vital role in encryption, understanding how to manage them effectively in your organization is a must for protecting sensitive data. Successful management starts with a well-defined central strategy with clear policies around each stage of the key lifecycle.\n\nFrom there, you want to monitor key usage, audit for threats, and keep up with the latest cryptography recommendations. You can protect your data further with Liquid Webâ€™s private cloud hosting, which gives you total control over your data and lets you customize your security measures."
    },
    {
        "link": "https://quora.com/How-would-you-go-about-designing-your-own-cipher",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://csfieldguide.org.nz/en/chapters/coding-encryption/substitution-ciphers",
        "document": "You can find more information about the Computer Science Field Guide on the about page. View about page\n\nThe Computer Science Field Guide has many chapters to inform you of the various areas of Computer Science. View chapters\n\nWe provide guides for using the Computer Science Field Guide in different curricula. View curriculum guides\n\nWe have many interactives throughout the website that teach many different computer science concepts. View interactives\n\nIf you are an educator, we recommend reading the teacher version for extra information on how to use this guide for teaching. Switch to teacher mode\n\nThis project is completely open source and available on GitHub. View on GitHub"
    },
    {
        "link": "https://egress.com/blog/email-encryption/encryption-101-substitution-ciphers",
        "document": "The basic idea of a substitution cipher is a simple one: take one letter in your message, letâ€™s say â€˜Aâ€™, and replace it with a different letter, such as â€˜Eâ€™.\n\nBoth the Atbash and Caesar ciphers used this basic principle, however they both have one weakness: predictability. Figure out how a handful of letters had been encrypted and you can pretty much break the entire message. (Learn more about how these ciphers work in my previous post: Encryption 101: Back to basics.)\n\nThe substitution cipher, however, takes this idea to the next level and provides a â€˜randomâ€™ alphabet to encrypt the message. In other words, each letter is encrypted with its own key.\n\nThe table below displays an alphabet that I chose at random, simply placing letters in different locations until it was complete.\n\nThis new alphabet makes figuring out the relationship between the plaintext and the ciphertext a lot harder, as the confusion that the cipher provides has been increased. The diffusion, however, is still fairly low â€“ changing one letter in the plaintext will still only change one letter in the ciptertext â€“ but this wonâ€™t really increase in complexity until we start looking at more modern examples.\n\nHowever, while the Atbash cipher had just one key and the Caesar cipher had 25, the substitution cipher has 26 (factorial) unique keys. This works out to about 403,291,461,126,605,635,584,000,000 different ways to write the alphabet!\n\nAs you can see, the number of keys increases rapidly the more the ciphers advance.\n\nWhile one might think that having a vast number of keys to choose from is a good security metric â€“ after all, what attacker is going to sit there and write out every possible permutation of the alphabet, run your ciphertext through it and see whether they can break the encryption â€“ substitution ciphers still suffer the same inherit weakness as the transposition ciphers before them: letter frequency analysis.(I discussed this topic in further detail when looking at weaknesses in the Caesar cipher.)"
    }
]