[
    {
        "link": "https://nexpcb.com/blog/what-is-ipc2581-why-is-it-important-for-electronics-engineers",
        "document": "IPC-2581, also known as IPC-DPMX, or Digital Product Model Exchange, is one of the \"Application Characteristic Data\" standards in the IPC 25XX Series of Data Exchange Standards of the IPC standards in the electronics industry. It is a new layered neutral data format with superior manufacturability, quality, reliability, and consistency for data information transmission between a PCB designer, a manufacturing and assembly facility. It is developed by a group of standards developers, tool developers, CAD users, and CAM users.\n\nThe standard is now being promoted by the IPC-2581 Consortium, with an independent website www.ipc2581.com. An updated version, the IPC-2581C, has been released in December 2020. The new version introduced even more groundbreaking new features.\n\nHowever, before we discuss the features and benefits of this standard and why we need it, we need to understand the shortcomings of the existing data format, i.e. the inherent limitations of the RS-274X Gerber format:\n\n\n\n● A separate physical file is required for each layer of PCB information, such as manufacturing records and assembly layers, etc.\n\n● Drill information (usually in the format of the N.C.drill file) needs to be sent separately.\n\n● Layer stackup definition needs to be presented in the form of diagrams, text, or filenames and agreed upon with the manufacturer.\n\n● The netlist used for testing (which contains the electrical connections between components) also needs to be sent separately.\n\n● The pick-and-place file with component placement information and the BOM procurement file are also made separately, which often tends to cause errors.\n\n\n\nCompared with other standards, the IPC-2581 standard uses a single XML-based file that consolidates a richer set of board manufacturing data. Including:\n\n\n\n● PCB Copper Foil Etching Information\n\n● Layer stackup information including both rigid and flexible layer\n\n● The netlist for PCB testing\n\n● BOM for procurement and assembly\n\n● Manufacturing and assembly precautions and parameters\n\n\n\nWe can open an XML file and see the following content:\n\n\n\n<IPC-2581> : Title of the standard\n\n<Content : The content filed\n\n<FunctionMode /> Function mode\n\n<StepRef /> Name of the stack \n\n<LayerRef /> Name of the layer\n\n<BomRef /> Name of the BOM \n\n...\n\n</Content> End of the content field\n\n<HistoryRecord Historical information\n\n<Bom The Bill of Material field\n\n<Ecad The ECAD field\n\nThe ECAD field is usually the main part of the file, which includes more field information, such as\n\n<CadData CAD data\n\n<Package Package\n\n< LogicalNet Net name\n\n, etc.\n\n\n\nIt can be seen that documents based on an XML format have additional advantages:\n\n\n\n● Integrity: All data can be exported from EDA tools using one format.\n\n● Security: No intermediate data conversion, and support selective output, such as sending only manufacturing data to the PCB manufacturer.\n\n● Smarter: The XML-based format provides intelligent calculation and recognition, eliminates human errors while providing an information base for intelligent data in industrial automation.\n\n● More open: The Consortium membership gives the benefit to be free from patent restrictions, with continued updates and expansion of manufacturer software and EDA software support. \n\n\n\n\n\nIn fact, IPC-2581 was created with the combination of GenCAM and ODB++. Although Gerber has introduced Gerber X2 to make up for some of the deficiencies found in the older version, it can't be done overnight due to downward compatibility with older data and devices.\n\n\n\nIPC-2581, as one of the underlying standards of the entire IPC Standards Tree, has a more rigorous hierarchical structure and can align perfectly with other IPC standards, providing a natural tool and means for PCB manufacturing and assembly companies to comply with the IPC standards.\n\n\n\nIPC-2518C also supports automation supporting Industry 4.0, and bidirectional DFX intelligence capability, which addresses the collaboration issue of DFM. It also reduces the communication barriers and information omissions between various players such as clients, designers, PCB manufacturers, and PCB assembly factories, greatly improving work efficiency and reducing costs.\n\nNexPCB is actively investigating the support and application of IPC-2581 and will launch IPC-2581 support services when the time is ripe. We believe every reputable electronics manufacturer should do the same\n\nIf you would like to know the latest developments in the IPC2581 and\n\nhow to work with this new model, sign up for our blog now.\n\nWith every change comes a backlash, but in the case of IPC2581, the general consensus tends to be optimistic, given the past difficulty in communication with the older standards. Do you think the new IPC standards will help us move towards a more hands-free manufacturing workflow, or is it adding unneeded complexity to the older model? Let us know in the comments!"
    },
    {
        "link": "https://community.cadence.com/cadence_blogs_8/b/pcb/posts/ipc-2581-pcb",
        "document": "The PCB manufacturing industry has been using the Gerber data format for decades for transferring PCB design files to manufacturers. Though the Gerber format has improved over the years, it still lacks the intelligence to accurately convey the design intent. As an alternative to Gerber, the IPC-2581 data format was developed in 2004. IPC-2581 ensures efficient PCB design data transfer and brings advanced capabilities to extract all the required data for manufacturing and assembly. This includes netlist, test pad information, artwork, drill data, bill of materials, test files, and design variants. While exporting data, you can choose to suppress any information which is not needed for fabrication, assembly, testing, or procurement. You can share the design data with the manufacturing team for quick Design for Manufacturing (DFM) checks and incorporate their feedback in real-time to save you time and effort.\n\nIPC-2581 is a generic standard for PCB and assembly manufacturing data and transfer methodology. This standard synthesizes all aspects of a design into one XML file. The format of this file is defined and maintained by a consortium of PCB manufacturers and suppliers. Cadence is a founding member of the IPC-2581 consortium. For more information, visit the Cadence IPC-2581 link.\n\nIn this blog post, we will explore how to export and import IPC-2581 files using Allegro® PCB Editor. The advantage of using Allegro PCB Editor is that it provides a user interface with multiple pre-configured fields that help you customize your data for exporting. Depending on the recipient, you can configure these fields so that only relevant information is conveyed. That way, you can transfer the data necessary for the external partners and protect the design IP. The output is generated as a single XML file containing all the specific details. You can send this file to manufacture or assembly counterparts for evaluation during any time of the design cycle. Since it follows an XML schema, the file is readable and easy to comprehend by designers and manufacturing experts. It can be uploaded directly into the manufacture’s CAM tools and interpreted accordingly without needing any conversion program. The manufacturing experts can relay their feedback through the same XML file, which you can import into the design. Before implementing the feedback, you can compare the original IPC-2581 file with the one you received. The differences in the design are displayed in the UI. The entire process is completely automated and does not require any manual intervention at all.\n\nLet’s go through the process of exporting and importing IPC-2581 data in detail.\n\nExtracting manufacturing data from a design in Allegro PCB Editor in the IPC-2581 format is a simple procedure. Let’s say your layout design is almost ready. At this stage, you can send the design data to manufacturers so that they can run quick DFM checks and provide some feedback before you finalize routing and placement. To generate that data in the IPC-2581 format, first launch the IPC2581 Export form and configure the options or use the default settings.\n• Specify a name for the output file. By default, it takes the name of the current design.\n• Choose a version that is supported both at your end as well as by your manufacturing facility.\n\nYou can choose from the four available options: 1, A, B, or C. IPC2581-B is the most widely used version, while IPC2581-1 and IPC2581-A are obsolete. IPC2581-C is the latest and the highest version and includes additional features, such as support for rigid-flex, embedded components, cavities, edge plating, and countersink/counterbore backdrill.\n• The Output units field shows the current units for the active design.\n\nYou can choose to save information in a different unit in the output XML file.\n\nWhen you select a functional mode, the default options available for the relevant attributes or functions are automatically selected in the File Segmentations and Function Apportionment section. You can also choose more options to include additional information in the XML file.\n\nThe functional mode represents data extraction types defined in the IPC-2581 standard. For versions earlier or lower than IPC2581-C, you should select both Functional Mode and Function Level to specify the data type to be extracted. Using functional modes, you can also export BOM, electrical data, layer information, and so on.\n• To create or edit the artwork details, click Film Creation.\n\nClick the Domain Selection button to open the Film Domain Setting form. Verify that the IPC2581 column is enabled for the artwork films you want to export and close the form.\n\nWhen exporting data with the IPC2581-C version, you can modify a layer name in the exported file by adding filename affixes to the non-conductor artwork film names. To add global film filename affixes in the General Parameters tab, you need to set the ipc2581_enable_artwork_filename_affixes environment variable in the User Preferences Editor.\n• To map film records to specific layer types expected in the IPC-2581 file , click the Layer Mapping Edit button in the IPC2581 Export form.\n\nIPC2581 Layer Mapping Editor is displayed. The layers are already enabled based on the layer naming settings in Artwork Control Form. You can customize this information for Inner Copper, Outer Copper, Documentation, Solder Mask, Solder Paste, Silkscreen, or Fab Layers in this form.\n• To include component or net properties in the IPC-2581 file, open the Export Property tab to add properties.\n\nYou can send the generated IPC-2581 file to the manufacturing facility to run DFM checks on the design data.\n\nHere is a sample IPC-2581 file created for sharing fabrication data.\n\nThe same XML file can be used by the manufacturer to share feedback. When imported back into the design, this file creates new Manufacturing subclasses by adding the IPC prefix to the film record name. By comparing film records you can view the updates suggested by the manufacturer.\n\nYou can import the file using a simple GUI that provides an option to visually compare the design changes. To launch this GUI:\n• Browse to the IPC2581 ( ) file received from the manufacturer.\n• Enable the Layer stackup option to import stackup details in your design.\n\nAfter the import process is completed, the Compare and Purge Import options are enabled.\n• Click Compare to view the layer-wise differences between the original and the imported film records.\n\nThe IPC2581 Compare form is displayed. You can toggle the visibility of IPC2581 layers and artwork film names and compare the artwork data.\n• To compare an IPC layer with a different layer of Film, modify the mapping by clicking the ellipses for the layer. For example, the IPC_Bottom can be compared with any layer selected from the drop-down menu in the Select film to map dialog.\n• The Purge Import option, as its name suggests, removes imported data from the design.\n\nView the IPC-2581 video for a quick view of the steps explained in this post.\n\nLeveraging the capabilities of the IPC-2581 data exchange standard accelerates manufacturing and assembly and improves the turn-around time of complex designs. Allegro PCB Editor is equipped with all the features that help you exchange the intended manufacturing details with your manufacturing partners. The responsive and agile GUI-based environment aligned with IPC releases ensures the delivery of high-quality products in reduced time.\n\nDo SUBSCRIBE to be updated about upcoming blogs. If you have any topic you want us to cover or any feedback for us, you can write to us at pcbbloggers@cadence.com."
    },
    {
        "link": "https://altium.com/documentation/altium-designer/ipc-2581-support?version=21&srsltid=AfmBOorJ12oxeolDy_3RbX5GipU-RgCaitlUOjRVxudEvHyu5YnPluy5",
        "document": "As part of Altium Designer’s ability to export a wide range of PCB design fabrication and assembly file formats, the IPC-2581 Standard format is available for both individual and output job file generation.\n\nRelated to the existing ODB++ format, IPC-2581 is an open-source standard developed by the Institute for Printed Circuits IPC-2581 Consortium some years ago (2004), but since refined to the most recent Revision A and B releases (IPC-2581A/B).\n\nThe standard has progressively gained wider acceptance as an alternative to the traditional fabrication output data composed of, typically, a collection of Gerber, Drill, BOM, and text files, etc. The previous need for a complex mix of fabrication files is due to the inherent limitations of the traditional RS-274x Gerber format, which lacks definitions for the layer stack, drill information, netlist data (electrical connectivity), and BOM information.\n\nThe IPC-2581 standard is officially titled ‘Generic Requirements for Printed Board Assembly Products Manufacturing Description Data and Transfer Methodology’ and offers an XML-based single file format that incorporates a rich range of board fabrication data - from layer stackup details though to full pad/routing/component information, and the Bill Of Materials (BOM).\n\nThe potential advantage of adopting the IPC-2581 format for transferring board design data to fabrication and assembly houses is centered on the highly-defined, detailed single file format that is fully understood at both ends of the chain. With a working system of CAD-CAM data exchange established, the risks associated with data misinterpretation, file errors, and variable Gerber interpretation, are largely eliminated. In short, both the IPC-2581 and Gerber X2 formats represent a new generation of board design to manufacture data transfer.\n• See the related Blog entry by Ben Jordan.\n• See the IPC-2581 Consortium website for more detailed information.\n• Need a Viewer? Download one from IPC-2581 free Viewers.\n\nFunctionality is provided courtesy of the IPC2581 extension (a Software Extension).\n\nPurchased tab of the Extensions & Updates page (click on the control at the top-right of the workspace then choose Extensions and Updates from the menu). If reinstalling, remember to restart Altium Designer once the extension has been successfully downloaded and installed. The IPC-2581 functionality can only be accessed provided the IPC2581 extension is installed as part of your Altium Designer installation. This extension is installed by default when installing the software, but in case of inadvertent uninstall can be found on thetab of thepage (click on thecontrol at the top-right of the workspace then choosefrom the menu). If reinstalling, remember to restart Altium Designer once the extension has been successfully downloaded and installed.\n\nWith a project PCB file loaded as the active document, an IPC-2581 file can be generated by selecting File » Fabrication Outputs » IPC-2581 from the main menu. This opens an initial IPC-2581 Configuration dialog in which you can specify the revision of the IPC-2581 standard to be used ( or ), as well as the measurement units and floating point number precision applied during the export process.\n\nThe precision setting determines the positional and sizing accuracy of the data within the generated IPC-2581 compliant file as illustrated in the image below.\n\nThe XML-based IPC-2581 file will be exported to the location defined in the Output Path field on the Options tab of the Project Options dialog. It will be named using the format .\n\nTo include IPC-2581 file output in a project's Output Job Configuration file, click on [Add New Fabrication Output] under the Fabrication Outputs section then select IPC-2581 from the menu, and the desired data source from the associated sub-menu.\n\nAs with other Fabrication outputs, when the OutJob is run - either manually or part of the project release system - the IPC-2581 file will be generated in accordance with settings defined for the applicable Output Container."
    },
    {
        "link": "https://protoexpress.com/kb/how-to-export-and-get-started-with-ipc-2581",
        "document": "The IPC-2581, also known as IPC-DPMX (digital product model exchange), provides a unified design data format, enabling seamless data exchange between designers and fab houses.\n\nHere, you will learn how to export the IPC-DPMX file using Cadence Allegro, Altium Designer, and KiCAD.\n\nWatch our webinar on IPC-2581: Expedite NPI with Smart Design Data Hand-off to learn Hemant Shah and Patrick’s insights.\n\nTo get started with IPC-2581, follow the procedure below.\n\nStep 1: Choose File -> Export -> IPC2581 to launch the IPC2581 Export form in Allegro PCB Editor.\n\nStep 2: Enter the output file name and destination.\n\nStep 3: Select the version (1, A, B, or C) and units (millimeter, micron, inch) that best suit your requirements.\n\nStep 4: Under File Segmentations and Function Apportionment, choose a functional mode for data extraction. The default option is ASSEMBLY.\n\nStep 5: If you want to generate film for specific or all layers, click Film Creation to open the Artwork Control Form.\n\nCheck the specific layers for which you want to generate films. Click Select All to generate film for all layers.\n\nStep 6: To customize layer mapping for inner copper, outer copper, documentation, etc., hit Layer Mapping Editor.\n\nStep-by-step procedure to export the IPC-2581 file from Altium Designer\n\nStep 1: Choose File -> Fabrication Outputs-> IPC2581 to launch the IPC-2581 configuration dialogue box from Altium Designer.\n\nStep 2: Select the IPC-2581 version (A or B), the measurement system, and the floating point precision you wish to apply during the export process.\n\nStep 1: File -> Fabrication Outputs -> IPC2581 File (.xml) to open the Export IPC-2581 dialogue box in KiCAD.\n\nStep 2: Choose the destination folder and enter the output file name.\n\nStep 4: Click Export to get started with the IPC-2581 file generation.\n\nThe unified file is then shared with the fabricators. They import the smart design data file using CAM systems to produce PCBs based on the design data provided by designers.\n\nStep 1: Run the Stackup Designer to generate your layer stack. Click on Report to view your build-up.\n\nStep 2: Hit Export to IPC 2581. to download the stack-up data with a .XML extension.\n\nInclude the following data before submitting the file to your CM:\n• None Instructions for printed board component placement , soldering, and any special assembly processes\n\nYou can also mention the following depending on your design requirements:\n• None Changes or revisions made to the design\n\nRevision B offers improved drilling and drill types features, allowing a more detailed dataset for drill and drilling processes. The improvements include:\n• Layer Stack section of the design data file. It defines critical parameters such as:\n• None Location (specified through coordinates or referencing other features)\n• None Additional features, such as geometry object fill types, line types, user-defined primitives, pin orientation, and design intent notes, are included\n\nThe Rev C is a big upgrade over its previous versions. It introduces notable improvements such as:\n• None Specifications for flex stack-ups, defining critical parameters such as:\n\nThe new and unique features of IPC-DPMX rev C significantly enhance its capabilities. Hemant Shah, the chairman of the IPC-2581 consortium, said:\n\nWatch our interview with Hemant Shah, the benefits of IPC-2581 revision C.\n• None Enables the precise definition of impedance requirements at the net, layer, or stack-up.\n• None Integrates a standardized library of material dielectric constants and loss tangents, enhancing accuracy and consistency in impedance calculations.\n• None Streamlines the impedance specification process by eliminating the need for a separate impedance table upload.\n\nThis smart design data format facilitates the electronic exchange of DFM data, including questions, exceptions, and design edits.\n• None It allows for real-time exchange of DFM feedback between designers and manufacturers with comments, approvals, and rejections.\n• None The format marks the PCB design for manufacturing errors graphically and links them directly to design data within the DPMX file, streamlining the identification and resolution process.\n• It enables tracking which errors the designers/customer fixes for each design and identifies the ones that are waived, offering transparency throughout the manufacturing process.\n• None Approved DFM can be electronically stored within the file instead of an engineer’s disk drive or cloud storage.\n• None IPC-DPMX records the metrics easily over time for a specific customer and project.\n\nLearn how to design a cost-efficient PCB without board respins. Download the Design for Manufacturing Handbook.\n\nIn the current method of stack-up exchange, CAM engineers manually create Gerber and ODB++ files for individual layers, solder masks, and silkscreen. The stack-up details are exported in separate fab drawings. These details are then exported as separate text files, requiring manufacturers to import and decode the information from ASCII code.\n\nOn the other hand, IPC-2581 streamlines the communication between designers and manufacturers by providing a standardized format for stack-up information exchange.\n• Stack-up status is indicated with enumerations such as:\n\nGerber files require over 30 files to define different manufacturing aspects. The data, commonly encoded in ASCII, conveys critical information required for printed circuit board fabrication. However, these files can also use different formats, like EBCDIC, EIA, or ISO codes, for compatibility with various systems.\n\nOn the other hand, the ODB++, exported in .tgz, .tar, .gz, .zip, or .tar extensions, is a complex and large file with multiple data layers.\n\nIPC-2581, in contrast, adopts a neutral XML-based format that consolidates all design and manufacturing information into a single file.\n\nIts unified approach simplifies data exchange and improves overall design and manufacturing workflow efficiency.\n• Top and bottom assembly layers with precise component attributes, positioning, and footprint markings\n\nThe re-engineering process for Gerber and ODB++ files presents challenges due to their primary focus on manufacturing data, which excludes crucial details such as netlist and BOM.\n\nVariations in file format across different software tools often result in compatibility issues, which require manual interpretation and data conversion. The iterative documentation and electronic communication channels further contribute to the complexity of the re-engineering task.\n\nWhen we talk about the open standard IPC-2581, it ensures consistent interpretation across diverse software tools.\n• Includes valuable component details like values, datasheets, and BOM references, eliminating the need for external searches and manual data gathering.\n• None Allows you to upload external references (photos, URLs, and videos) to express the right design intent.\n• None Supports version control, allowing you to track changes and revert to previous versions.\n• None Replaces error-prone e-paper-based communication with efficient electronic bi-directional communication, reducing time and improving collaboration and efficiency.\n\nFor FAQs on IPC-DPMX, see IPC-2581 questions answered by consortium members.\n\nAdopting the smart design data format as part of your workflow can lead to smoother collaboration, quicker turnaround times, and improved communication with manufacturers."
    },
    {
        "link": "https://flowcad.com/en/white-paper-ipc2581.htm",
        "document": "One of the first photoplotters was introduced in 1960 by Gerber Scientific Inc. A photoplotter is a special electronic, optical and mechanical device that can be used to create an exposure stencil on a monochromatic film with high contrast. Light is exposed onto the film through selected aperture openings, similar to analog photography. There was a small set of commands for different functions such as light on or off, selection of one of the 8 or 16 apertures, and movement in X and Y direction. Commands were a subset of RS-274-D command set for controlling numerical (NC) machine tools.\n\nThis instruction set, specially adapted to describe wires, copper areas, solder stop areas and legends, has been exported in Gerber format, also known as standard Gerber or Gerber RS-274-D. At that time, data was still transferred by punch card and amount of data had to be small. Since this format did not contain any information about apertures, there was another file with aperture information for each plotter. Due to the progress of technology in printed circuit boards as well as in photoplotters, Gerber format was no longer sufficient, became obsolete and was expanded in 1998.\n\nGerber Scientific Inc. was acquired by Barco ETS in 1998, which expanded the format to Extended Gerber in September 1998 and published RS-274X Format User Guide.\n\nExtended Gerber or RS-274X is a human readable instruction set in ASCII format. It contains a set of commands from graphical objects with positive or negative properties. In Extended Gerber aperture information is included in the file. From these objects the image is then created in resolution of the plotter and currently exposed with laser beams. Ucamco (formerly Barco ETS) owns the rights to Gerber format.\n\nIn September 2014, Karel Tavernier, Managing Director of Ucamco, wrote that Standard Gerber is technically obsolete and should no longer be used. Although one could derive it from its name, Standard Gerber is not a defined standard for PCB data transfer: Units and aperture definitions are not determined by any recognizable standard, but are contained in an informal document whose interpretation is necessarily subjective. For this reason, Standard Gerber files cannot be read by machines in a standardized, reliable way. Standard Gerber requires aperture marking and copper plating, both are manual tasks in CAM, resulting in increased costs, delays and risks in PCB manufacturing. Extended Gerber can be read by machines and consequently replaced Standard Gerber.\n\nIn PCB manufacturing not only films for layers are created, there was always a lot of descriptive information about production or assembly besides (extended) Gerber files. Valor Computerized Systems Ltd. developed ODB++ format, which allowed more different information to be stored in a zipped data container from various files. Files include e.g. netlist, component information as parts list or texts. Valor was taken over by Mentor Graphics in 2010, Mentor has since been \"swallowed\" by Siemens. Goal of ODB++ is to output and transfer all design data for manufacturing, assembly and testing together in a single file. ODB++ contains a complete layer table that describes original layer designations, layer type and order of layers. Unlike Gerber data, ODB++ usually makes it clear what a pad and what a trace is. An attribute system can be used to define register marks and test points.\n\nTechnological leaps in printed circuit board technology clearly showed the problem when so-called standards for data transmission belong to individual companies and are defined by these companies. Extended Gerber belongs to a photoplotter manufacturer and ODB++ to a PCB layout provider. Especially when innovative technologies are developed, new parameters have to be transferred from development tool to CAM software, exposure units or automatic placement machines.\n\nThe two administrators of the standard did not meet industry's wishes to extend the standard to new technologies that they themselves did not support in their products. Therefore, many companies joined forces and agreed to establish a neutral, open and global standard for PCB development that would meet diverse requirements. The IPC - Association Connecting Electronics Industries was chosen as parent organization. IPC is a worldwide trade and standardization organization based in Illinois, USA, which deals with concerns of electronics manufacturing. Its activities include publication of industry standards and criteria for evaluating various goods in electrical and electronics industry.\n\nIPC-2581 is not only being developed by two individual companies as before, but IPC-2581 consortium comprises more than 100 members. Participating companies come from EDA-CAD, CAM, assembly (EMS), PCB manufacturing and testing, as well as users from all over the world. They all have a common goal: a modern data exchange standard for all, from all industries such as automotive, aerospace, medical, telecom, industrial and consumer.\n\nIPC-2581 is free of licenses as well as usage agreements and is supported by all major market participants. Various companies in the USA and Asia have already fully converted to IPC-2581 standard and transmit their data exclusively in this format.\n\nThe reason is not only that all data can be transferred in one data container. Interesting applications have already been established.\n\nMain differences between ODB++ and IPC-2581 are that IPC format is not defined and maintained by one company, but by a consortium of over a hundred companies. This ensures that it is an open and manufacturer-independent standard and that requirements easily can be adapted to new technologies. There are no commercial advantages or licensing rights with this standard.\n\nEvery software manufacturer can program and maintain his IPC interface license-free himself and is not dependent on the help of others. This provides security for CAD flows.\n\nAll data is contained in a readable XML file, so there can be no confusion. File can be filled differently depending on the user, so that only information that the recipient is allowed to see is exchanged.\n\nIf circuit boards needs to be technically demanding, particularly reliable or inexpensive, a precise specification of layer structure is required. For this purpose, developers request a layer structure from PCB manufacturers and are then get layer structure for requested specification. Materials, layer thicknesses and other parameters are defined here.\n\nFor impedance controlled printed circuit boards, PCB manufacturer adapts materials, e.g. by system-specific undercuts so that they can guarantee an impedance of 50 ohms between two layers with specified conductor track widths. Many PCB manufacturers use software from Polar and can output layer stack-up as IPC-2581.\n\nLayer stack-up is already defined when the designer reads the IPC-2581 file into OrCAD or Allegro. Routing on individual layers can now be optimally simulated and verified with 50 Ohm layer structure for signal integrity. Quick change of a layer stack also shows whether different suppliers with different materials have the same electrical properties and thus represent a second source.\n\nProduction data output is a double-edged sword. On one hand, you want to transmit all information necessary for production. On the other hand, you want to retain know-how and only pass on most necessary information to external companies. Especially if PCBs are produced by different companies local and abroad, the amount of data should be controlled to protect the IP.\n\nIPC-2581 format is a XML-based data format that defines all possible values. When exporting to OrCAD or Allegro, output profiles can be defined, for example fabrication, assembly, test and internal. For each output profile it can be defined which data is required for this production step. Thus, PCB manufacturer does not receive any component information and assembly house does not receive any layered materials.\n\nWhen exporting, four standardized files for different uses can be read out and stored in PLM system. Then purchasing department can send corresponding production data to suppliers with one file each, and each supplier has all the information it needs in one file. Confusion of individual Gerber films or time-consuming technical queries from the supplier to the designer are thus minimized. IPC-2581 format can also be compressed during output.\n\nAfter 6 decades it is the right time to gain a market advantage through the advantages of IPC-2581. IPC-2581 embodies what electronics industry has always demanded. It is a manufacturer-independent standard that is not restricted by restrictions of individuals and can be used by the entire electronics industry."
    },
    {
        "link": "https://w3schools.com/xml/schema_example.asp",
        "document": "This chapter will demonstrate how to write an XML Schema. You will also learn that a schema can be written in different ways.\n\nLet's have a look at this XML document called \"shiporder.xml\":\n\nThe XML document above consists of a root element, \"shiporder\", that contains a required attribute called \"orderid\". The \"shiporder\" element contains three different child elements: \"orderperson\", \"shipto\" and \"item\". The \"item\" element appears twice, and it contains a \"title\", an optional \"note\" element, a \"quantity\", and a \"price\" element.\n\nThe line above: xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" tells the XML parser that this document should be validated against a schema. The line: xsi:noNamespaceSchemaLocation=\"shiporder.xsd\" specifies WHERE the schema resides (here it is in the same folder as \"shiporder.xml\").\n\nNow we want to create a schema for the XML document above.\n\nWe start by opening a new file that we will call \"shiporder.xsd\". To create the schema we could simply follow the structure in the XML document and define each element as we find it. We will start with the standard XML declaration followed by the xs:schema element that defines a schema:\n\nIn the schema above we use the standard namespace (xs), and the URI associated with this namespace is the Schema language definition, which has the standard value of http://www.w3.org/2001/XMLSchema.\n\nNext, we have to define the \"shiporder\" element. This element has an attribute and it contains other elements, therefore we consider it as a complex type. The child elements of the \"shiporder\" element is surrounded by a xs:sequence element that defines an ordered sequence of sub elements:\n\nThen we have to define the \"orderperson\" element as a simple type (because it does not contain any attributes or other elements). The type (xs:string) is prefixed with the namespace prefix associated with XML Schema that indicates a predefined schema data type:\n\nNext, we have to define two elements that are of the complex type: \"shipto\" and \"item\". We start by defining the \"shipto\" element:\n\nWith schemas we can define the number of possible occurrences for an element with the maxOccurs and minOccurs attributes. maxOccurs specifies the maximum number of occurrences for an element and minOccurs specifies the minimum number of occurrences for an element. The default value for both maxOccurs and minOccurs is 1!\n\nNow we can define the \"item\" element. This element can appear multiple times inside a \"shiporder\" element. This is specified by setting the maxOccurs attribute of the \"item\" element to \"unbounded\" which means that there can be as many occurrences of the \"item\" element as the author wishes. Notice that the \"note\" element is optional. We have specified this by setting the minOccurs attribute to zero:\n\nWe can now declare the attribute of the \"shiporder\" element. Since this is a required attribute we specify use=\"required\".\n\nNote: The attribute declarations must always come last:\n\nHere is the complete listing of the schema file called \"shiporder.xsd\":\n\nThe previous design method is very simple, but can be difficult to read and maintain when documents are complex.\n\nThe next design method is based on defining all elements and attributes first, and then referring to them using the ref attribute.\n\nHere is the new design of the schema file (\"shiporder.xsd\"):\n\nThe third design method defines classes or types, that enables us to reuse element definitions. This is done by naming the simpleTypes and complexTypes elements, and then point to them through the type attribute of the element.\n\nHere is the third design of the schema file (\"shiporder.xsd\"):\n\nThe restriction element indicates that the datatype is derived from a W3C XML Schema namespace datatype. So, the following fragment means that the value of the element or attribute must be a string value:\n\nThe restriction element is more often used to apply restrictions to elements. Look at the following lines from the schema above:\n\nThis indicates that the value of the element or attribute must be a string, it must be exactly six characters in a row, and those characters must be a number from 0 to 9."
    },
    {
        "link": "https://w3.org/TR/xmlschema11-1",
        "document": ""
    },
    {
        "link": "https://w3schools.com/xml/schema_elements_ref.asp",
        "document": "Enables the author to extend the XML document with attributes not specified by the schema"
    },
    {
        "link": "https://w3.org/TR/xmlschema-1",
        "document": "Please refer to the errata for this document, which may include some normative corrections.\n\nXML Schema: Structures specifies the XML Schema definition language, which offers facilities for describing the structure and constraining the contents of XML 1.0 documents, including those which exploit the XML Namespace facility. The schema language, which is itself represented in XML 1.0 and uses namespaces, substantially reconstructs and considerably extends the capabilities found in XML 1.0 document type definitions (DTDs). This specification depends on XML Schema Part 2: Datatypes.\n\nNoah Mendelsohn's affiliation has changed since the publication of the first edition. He is now at IBM, and can be contacted at noah_mendelsohn@us.ibm.com\n\nMurray Maloney is no longer affiliated with Commerce One; his contact details are unchanged.\n\nDavid Beech has retired since the publication of the first edition, and can be reached at davidbeech@earthlink.net\n\nThe errata list for this second edition is available at http://www.w3.org/2004/03/xmlschema-errata .\n\nThis second edition is not a new version, it merely incorporates the changes dictated by the corrections to errors found in the first edition as agreed by the XML Schema Working Group, as a convenience to readers. A separate list of all such corrections is available at http://www.w3.org/2001/05/xmlschema-errata .\n\nThe English version of this specification is the only normative version. Information about translations of this document is available at http://www.w3.org/2001/05/xmlschema-translations .\n\nThis document has been produced by the W3C XML Schema Working Group as part of the W3C XML Activity . The goals of the XML Schema language are discussed in the XML Schema Requirements document. The authors of this document are the members of the XML Schema Working Group. Different parts of this specification have different editors.\n\nThis is a W3C Recommendation , which forms part of the Second Edition of XML Schema. This document has been reviewed by W3C Members and other interested parties and has been endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited as a normative reference from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.\n\nThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/."
    },
    {
        "link": "https://xmlschema.readthedocs.io/en/latest/usage.html",
        "document": "Import the library and then create an instance of a schema using the path of the file containing the schema as argument: The argument can be also a file-like object or a string containing the schema definition: Strings and file-like objects might not work when the schema includes other local subschemas, because the package cannot knows anything about the schema’s source location: In these cases you can provide an appropriate base_url optional argument to define the reference directory path for other includes and imports: Other options for schema instance creation are available using non-standard methods. Most cases require to use the build option to delay the schema build after the loading of all schema resources. For example: Another option, available since release v1.6.1, is to provide a list of schema sources, particularly useful when sources have no locations associated: or similarly to the previous example one can use the method : Anyway, the advice is to build intermediate XSD schemas instead for loading all the schemas needed in a standard way, because XSD mechanisms of imports, includes, redefines, and overrides are usually supported when you submit your schemas to other XSD validators. Sometimes, it is advantageous to validate XML files using an XSD schema located at a remote location while also having the option to store the same schema locally for offline use. The first option is to build a schema and then export the XSD sources to a local directory: With these commands, a folder is created and contains the XSD files that can be used without access to the internet. The resulting XSD files are identical to their remote source files, with the only difference being that xmlschema transforms the remote URLs into local URLs. The command bundles a set of a target XSD file and all its dependencies by changing the attributes into statements as follows: The alternative option is to download the XSD resources directly: For default the original XSD schemas are not changed and a location map is returned. This map is also written to a LOCATION_MAP dictionary in the target directory as the module , so can be used after as uri_mapper argument for building the schema instance. Since release v2.5.0 the attributes are rewritten with local paths that don’t start with the target directory path, in order to be reusable from any working directory. Furthermore for default the residual redundant imports from different location hints, are cleaned stripping attributes from them.\n\nA schema instance has methods to validate an XML document against the schema. The first method is , that returns if the XML argument is validated by the schema loaded in the instance, and returns if the document is invalid. An alternative mode for validating an XML document is implemented by the method , that raises an error when the XML doesn’t conform to the schema: A validation method is also available at module level, useful when you need to validate a document only once or if you extract information about the schema, typically the schema location and the namespace, directly from the XML document:\n\nA schema instance can be also used for decoding an XML document to a nested dictionary: The decoded values match the datatypes declared in the XSD schema: Decoded data can be encoded back to XML: All the decoding and encoding methods are based on two generator methods of the class, namely iter_decode() and iter_encode(), that yield both data and validation errors. See Schema level API section for more information. If you need to decode only a part of the XML document you can pass also an XPath expression using the path argument. An XPath expression for the schema considers the schema as the root element with global elements as its children. Validation and decode API works also with XML data loaded in ElementTree structures: The standard ElementTree library lacks of namespace information in trees, so you have to provide a map to convert URIs to prefixes: You can also convert XML data using the lxml library, that works better because namespace information is associated within each node of the trees: Starting from the version 0.9.9 the package includes converter objects, in order to control the decoding process and produce different data structures. These objects intervene at element level to compose the decoded data (attributes and content) into a data structure. The default converter produces a data structure similar to the format produced by previous versions of the package. You can customize the conversion process providing a converter instance or subclass when you create a schema instance or when you want to decode an XML document. For instance you can use the Badgerfish converter for a schema instance: You can also change the data decoding process providing the keyword argument converter to the method call: {'vh:bikes': {'vh:bike': [None, None]}, 'vh:cars': {'vh:car': [None, None]}} See the Converters for XML data section for more information about converters. XSD datatypes are decoded to Python basic datatypes. Python strings are used for all string-based XSD types and others, like xs:hexBinary or xs:QName. Python integers are used for xs:integer and derived types, for xs:boolean values and for xs:decimal values. Currently there are three options for variate the decoding of XSD atomic datatypes: decoding type for xs:decimal (is for default) if set to decodes datetime and duration types to their respective XSD atomic types instead of keeping the XML string value if set to decodes xs:hexBinary and xs:base64Binary types to their respective XSD atomic types instead of keeping the XML string value Incompatible values are decoded with when the validation mode is . For these situations there are two options for changing the behavior of the decoder: a callback function to fill undecodable data with a typed value. The callback function must accept one positional argument, that can be an XSD Element or an attribute declaration. If not provided undecodable data is replaced by . if set to True the decoder fills also missing attributes. The filling value is None or a typed value if the filler callback is provided. These options concern the decoding of XSD elements: a function that will be called with any decoded atomic value and the XSD type used for decoding. The return value will be used instead of the original value. if set to empty elements that are valid are decoded with an empty string value instead of . an function that is called with decoded element data before calling the converter decode method. Takes an instance plus optionally the XSD element and the XSD type, and returns a new instance. These two options are specific for the content processed with an XSD wildcard: if set to unknown tags are kept and are decoded with xs:anyType. For default unknown tags not decoded by a wildcard are discarded. maximum level of decoding, for default there is no limit. With lazy resources is automatically set to source.lazy_depth for managing lazy decoding. Available also for validation methods. a callback function for replacing data over the max_depth level. The callback function must accept one positional argument, that can be an XSD Element. For default deeper data is replaced with values when max_depth is provided. an optional function for performing non-standard validations on XML data. The provided function is called for each traversed element, with the XML element as 1st argument and the corresponding XSD element as 2nd argument. It can be also a generator function and has to raise/yield exceptions. an optional function for stopping or changing validation/decoding at element level. The provided function must accept two arguments, the XML element and the matching XSD element. If the value returned by this function is evaluated to false then the validation/decoding process continues without changes, otherwise it’s stopped or changed. If the value returned is a validation mode the validation/decoding process continues changing the current validation mode to the returned value, otherwise the element and its content are not processed. For validation only this function can also stop validation suddenly raising a exception.\n\nThe data structured created by the decoder can be easily serialized to JSON. But if you data include values (for decimal XSD built-in type) you cannot convert the data to JSON: File , line , in File , line , in File , line , in File , line , in File , line , in File , line , in File , line , in File , line , in File , line , in File , line , in : This problem is resolved providing an alternative JSON-compatible type for values, using the keyword argument decimal_type: From version 1.0 there are two module level API for simplify the JSON serialization and deserialization task. See the and in the Document level API section."
    }
]